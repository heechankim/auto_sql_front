/*!
 * vuerd
 * @version 1.3.7 | Sun Nov 29 2020
 * @author dineug <dineug2@gmail.com>
 * @license MIT
 */
var vuerd = (function (exports) {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * True if the custom elements polyfill is in use.
     */
    const isCEPolyfill = typeof window !== 'undefined' &&
        window.customElements != null &&
        window.customElements.polyfillWrapFlushCallback !==
        undefined;
    /**
     * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),
     * into another container (could be the same container), before `before`. If
     * `before` is null, it appends the nodes to the container.
     */
    const reparentNodes = (container, start, end = null, before = null) => {
        while (start !== end) {
            const n = start.nextSibling;
            container.insertBefore(start, before);
            start = n;
        }
    };
    /**
     * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
     * `container`.
     */
    const removeNodes = (container, start, end = null) => {
        while (start !== end) {
            const n = start.nextSibling;
            container.removeChild(start);
            start = n;
        }
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * An expression marker with embedded unique key to avoid collision with
     * possible text in templates.
     */
    const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
    /**
     * An expression marker used text-positions, multi-binding attributes, and
     * attributes with markup-like text values.
     */
    const nodeMarker = `<!--${marker}-->`;
    const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
    /**
     * Suffix appended to all bound attribute names.
     */
    const boundAttributeSuffix = '$lit$';
    /**
     * An updatable Template that tracks the location of dynamic parts.
     */
    class Template {
        constructor(result, element) {
            this.parts = [];
            this.element = element;
            const nodesToRemove = [];
            const stack = [];
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            // Keeps track of the last index associated with a part. We try to delete
            // unnecessary nodes, but we never want to associate two different parts
            // to the same index. They must have a constant node between.
            let lastPartIndex = 0;
            let index = -1;
            let partIndex = 0;
            const { strings, values: { length } } = result;
            while (partIndex < length) {
                const node = walker.nextNode();
                if (node === null) {
                    // We've exhausted the content inside a nested template element.
                    // Because we still have parts (the outer for-loop), we know:
                    // - There is a template in the stack
                    // - The walker will find a nextNode outside the template
                    walker.currentNode = stack.pop();
                    continue;
                }
                index++;
                if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                    if (node.hasAttributes()) {
                        const attributes = node.attributes;
                        const { length } = attributes;
                        // Per
                        // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                        // attributes are not guaranteed to be returned in document order.
                        // In particular, Edge/IE can return them out of order, so we cannot
                        // assume a correspondence between part index and attribute index.
                        let count = 0;
                        for (let i = 0; i < length; i++) {
                            if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                                count++;
                            }
                        }
                        while (count-- > 0) {
                            // Get the template literal section leading up to the first
                            // expression in this attribute
                            const stringForPart = strings[partIndex];
                            // Find the attribute name
                            const name = lastAttributeNameRegex.exec(stringForPart)[2];
                            // Find the corresponding attribute
                            // All bound attributes have had a suffix added in
                            // TemplateResult#getHTML to opt out of special attribute
                            // handling. To look up the attribute value we also need to add
                            // the suffix.
                            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
                            const attributeValue = node.getAttribute(attributeLookupName);
                            node.removeAttribute(attributeLookupName);
                            const statics = attributeValue.split(markerRegex);
                            this.parts.push({ type: 'attribute', index, name, strings: statics });
                            partIndex += statics.length - 1;
                        }
                    }
                    if (node.tagName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                }
                else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                    const data = node.data;
                    if (data.indexOf(marker) >= 0) {
                        const parent = node.parentNode;
                        const strings = data.split(markerRegex);
                        const lastIndex = strings.length - 1;
                        // Generate a new text node for each literal section
                        // These nodes are also used as the markers for node parts
                        for (let i = 0; i < lastIndex; i++) {
                            let insert;
                            let s = strings[i];
                            if (s === '') {
                                insert = createMarker();
                            }
                            else {
                                const match = lastAttributeNameRegex.exec(s);
                                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                                    s = s.slice(0, match.index) + match[1] +
                                        match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                                }
                                insert = document.createTextNode(s);
                            }
                            parent.insertBefore(insert, node);
                            this.parts.push({ type: 'node', index: ++index });
                        }
                        // If there's no text, we must insert a comment to mark our place.
                        // Else, we can trust it will stick around after cloning.
                        if (strings[lastIndex] === '') {
                            parent.insertBefore(createMarker(), node);
                            nodesToRemove.push(node);
                        }
                        else {
                            node.data = strings[lastIndex];
                        }
                        // We have a part for each match found
                        partIndex += lastIndex;
                    }
                }
                else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {
                    if (node.data === marker) {
                        const parent = node.parentNode;
                        // Add a new marker node to be the startNode of the Part if any of
                        // the following are true:
                        //  * We don't have a previousSibling
                        //  * The previousSibling is already the start of a previous part
                        if (node.previousSibling === null || index === lastPartIndex) {
                            index++;
                            parent.insertBefore(createMarker(), node);
                        }
                        lastPartIndex = index;
                        this.parts.push({ type: 'node', index });
                        // If we don't have a nextSibling, keep this node so we have an end.
                        // Else, we can remove it to save future costs.
                        if (node.nextSibling === null) {
                            node.data = '';
                        }
                        else {
                            nodesToRemove.push(node);
                            index--;
                        }
                        partIndex++;
                    }
                    else {
                        let i = -1;
                        while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                            // Comment node has a binding marker inside, make an inactive part
                            // The binding won't work, but subsequent bindings will
                            // TODO (justinfagnani): consider whether it's even worth it to
                            // make bindings in comments work
                            this.parts.push({ type: 'node', index: -1 });
                            partIndex++;
                        }
                    }
                }
            }
            // Remove text binding nodes after the walk to not disturb the TreeWalker
            for (const n of nodesToRemove) {
                n.parentNode.removeChild(n);
            }
        }
    }
    const endsWith = (str, suffix) => {
        const index = str.length - suffix.length;
        return index >= 0 && str.slice(index) === suffix;
    };
    const isTemplatePartActive = (part) => part.index !== -1;
    // Allows `document.createComment('')` to be renamed for a
    // small manual size-savings.
    const createMarker = () => document.createComment('');
    /**
     * This regex extracts the attribute name preceding an attribute-position
     * expression. It does this by matching the syntax allowed for attributes
     * against the string literal directly preceding the expression, assuming that
     * the expression is in an attribute-value position.
     *
     * See attributes in the HTML spec:
     * https://www.w3.org/TR/html5/syntax.html#elements-attributes
     *
     * " \x09\x0a\x0c\x0d" are HTML space characters:
     * https://www.w3.org/TR/html5/infrastructure.html#space-characters
     *
     * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
     * space character except " ".
     *
     * So an attribute is:
     *  * The name: any character except a control character, space character, ('),
     *    ("), ">", "=", or "/"
     *  * Followed by zero or more space characters
     *  * Followed by "="
     *  * Followed by zero or more space characters
     *  * Followed by:
     *    * Any character except space, ('), ("), "<", ">", "=", (`), or
     *    * (") then any non-("), or
     *    * (') then any non-(')
     */
    const lastAttributeNameRegex =
        // eslint-disable-next-line no-control-regex
        /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;
    /**
     * Removes the list of nodes from a Template safely. In addition to removing
     * nodes from the Template, the Template part indices are updated to match
     * the mutated Template DOM.
     *
     * As the template is walked the removal state is tracked and
     * part indices are adjusted as needed.
     *
     * div
     *   div#1 (remove) <-- start removing (removing node is div#1)
     *     div
     *       div#2 (remove)  <-- continue removing (removing node is still div#1)
     *         div
     * div <-- stop removing since previous sibling is the removing node (div#1,
     * removed 4 nodes)
     */
    function removeNodesFromTemplate(template, nodesToRemove) {
        const { element: { content }, parts } = template;
        const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
        let partIndex = nextActiveIndexInTemplateParts(parts);
        let part = parts[partIndex];
        let nodeIndex = -1;
        let removeCount = 0;
        const nodesToRemoveInTemplate = [];
        let currentRemovingNode = null;
        while (walker.nextNode()) {
            nodeIndex++;
            const node = walker.currentNode;
            // End removal if stepped past the removing node
            if (node.previousSibling === currentRemovingNode) {
                currentRemovingNode = null;
            }
            // A node to remove was found in the template
            if (nodesToRemove.has(node)) {
                nodesToRemoveInTemplate.push(node);
                // Track node we're removing
                if (currentRemovingNode === null) {
                    currentRemovingNode = node;
                }
            }
            // When removing, increment count by which to adjust subsequent part indices
            if (currentRemovingNode !== null) {
                removeCount++;
            }
            while (part !== undefined && part.index === nodeIndex) {
                // If part is in a removed node deactivate it by setting index to -1 or
                // adjust the index as needed.
                part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
                // go to the next active part.
                partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                part = parts[partIndex];
            }
        }
        nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));
    }
    const countNodes = (node) => {
        let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;
        const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
        while (walker.nextNode()) {
            count++;
        }
        return count;
    };
    const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
        for (let i = startIndex + 1; i < parts.length; i++) {
            const part = parts[i];
            if (isTemplatePartActive(part)) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Inserts the given node into the Template, optionally before the given
     * refNode. In addition to inserting the node into the Template, the Template
     * part indices are updated to match the mutated Template DOM.
     */
    function insertNodeIntoTemplate(template, node, refNode = null) {
        const { element: { content }, parts } = template;
        // If there's no refNode, then put node at end of template.
        // No part indices need to be shifted in this case.
        if (refNode === null || refNode === undefined) {
            content.appendChild(node);
            return;
        }
        const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
        let partIndex = nextActiveIndexInTemplateParts(parts);
        let insertCount = 0;
        let walkerIndex = -1;
        while (walker.nextNode()) {
            walkerIndex++;
            const walkerNode = walker.currentNode;
            if (walkerNode === refNode) {
                insertCount = countNodes(node);
                refNode.parentNode.insertBefore(node, refNode);
            }
            while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
                // If we've inserted the node, simply adjust all subsequent parts
                if (insertCount > 0) {
                    while (partIndex !== -1) {
                        parts[partIndex].index += insertCount;
                        partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                    }
                    return;
                }
                partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
            }
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const directives = new WeakMap();
    /**
     * Brands a function as a directive factory function so that lit-html will call
     * the function during template rendering, rather than passing as a value.
     *
     * A _directive_ is a function that takes a Part as an argument. It has the
     * signature: `(part: Part) => void`.
     *
     * A directive _factory_ is a function that takes arguments for data and
     * configuration and returns a directive. Users of directive usually refer to
     * the directive factory as the directive. For example, "The repeat directive".
     *
     * Usually a template author will invoke a directive factory in their template
     * with relevant arguments, which will then return a directive function.
     *
     * Here's an example of using the `repeat()` directive factory that takes an
     * array and a function to render an item:
     *
     * ```js
     * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`
     * ```
     *
     * When `repeat` is invoked, it returns a directive function that closes over
     * `items` and the template function. When the outer template is rendered, the
     * return directive function is called with the Part for the expression.
     * `repeat` then performs it's custom logic to render multiple items.
     *
     * @param f The directive factory function. Must be a function that returns a
     * function of the signature `(part: Part) => void`. The returned function will
     * be called with the part object.
     *
     * @example
     *
     * import {directive, html} from 'lit-html';
     *
     * const immutable = directive((v) => (part) => {
     *   if (part.value !== v) {
     *     part.setValue(v)
     *   }
     * });
     */
    const directive = (f) => ((...args) => {
        const d = f(...args);
        directives.set(d, true);
        return d;
    });
    const isDirective = (o) => {
        return typeof o === 'function' && directives.has(o);
    };

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * A sentinel value that signals that a value was handled by a directive and
     * should not be written to the DOM.
     */
    const noChange = {};
    /**
     * A sentinel value that signals a NodePart to fully clear its content.
     */
    const nothing = {};

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * An instance of a `Template` that can be attached to the DOM and updated
     * with new values.
     */
    class TemplateInstance {
        constructor(template, processor, options) {
            this.__parts = [];
            this.template = template;
            this.processor = processor;
            this.options = options;
        }
        update(values) {
            let i = 0;
            for (const part of this.__parts) {
                if (part !== undefined) {
                    part.setValue(values[i]);
                }
                i++;
            }
            for (const part of this.__parts) {
                if (part !== undefined) {
                    part.commit();
                }
            }
        }
        _clone() {
            // There are a number of steps in the lifecycle of a template instance's
            // DOM fragment:
            //  1. Clone - create the instance fragment
            //  2. Adopt - adopt into the main document
            //  3. Process - find part markers and create parts
            //  4. Upgrade - upgrade custom elements
            //  5. Update - set node, attribute, property, etc., values
            //  6. Connect - connect to the document. Optional and outside of this
            //     method.
            //
            // We have a few constraints on the ordering of these steps:
            //  * We need to upgrade before updating, so that property values will pass
            //    through any property setters.
            //  * We would like to process before upgrading so that we're sure that the
            //    cloned fragment is inert and not disturbed by self-modifying DOM.
            //  * We want custom elements to upgrade even in disconnected fragments.
            //
            // Given these constraints, with full custom elements support we would
            // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
            //
            // But Safari does not implement CustomElementRegistry#upgrade, so we
            // can not implement that order and still have upgrade-before-update and
            // upgrade disconnected fragments. So we instead sacrifice the
            // process-before-upgrade constraint, since in Custom Elements v1 elements
            // must not modify their light DOM in the constructor. We still have issues
            // when co-existing with CEv0 elements like Polymer 1, and with polyfills
            // that don't strictly adhere to the no-modification rule because shadow
            // DOM, which may be created in the constructor, is emulated by being placed
            // in the light DOM.
            //
            // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
            // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
            // in one step.
            //
            // The Custom Elements v1 polyfill supports upgrade(), so the order when
            // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
            // Connect.
            const fragment = isCEPolyfill ?
                this.template.element.content.cloneNode(true) :
                document.importNode(this.template.element.content, true);
            const stack = [];
            const parts = this.template.parts;
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            let partIndex = 0;
            let nodeIndex = 0;
            let part;
            let node = walker.nextNode();
            // Loop through all the nodes and parts of a template
            while (partIndex < parts.length) {
                part = parts[partIndex];
                if (!isTemplatePartActive(part)) {
                    this.__parts.push(undefined);
                    partIndex++;
                    continue;
                }
                // Progress the tree walker until we find our next part's node.
                // Note that multiple parts may share the same node (attribute parts
                // on a single element), so this loop may not run at all.
                while (nodeIndex < part.index) {
                    nodeIndex++;
                    if (node.nodeName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                    if ((node = walker.nextNode()) === null) {
                        // We've exhausted the content inside a nested template element.
                        // Because we still have parts (the outer for-loop), we know:
                        // - There is a template in the stack
                        // - The walker will find a nextNode outside the template
                        walker.currentNode = stack.pop();
                        node = walker.nextNode();
                    }
                }
                // We've arrived at our part's node.
                if (part.type === 'node') {
                    const part = this.processor.handleTextExpression(this.options);
                    part.insertAfterNode(node.previousSibling);
                    this.__parts.push(part);
                }
                else {
                    this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
                }
                partIndex++;
            }
            if (isCEPolyfill) {
                document.adoptNode(fragment);
                customElements.upgrade(fragment);
            }
            return fragment;
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Our TrustedTypePolicy for HTML which is declared using the html template
     * tag function.
     *
     * That HTML is a developer-authored constant, and is parsed with innerHTML
     * before any untrusted expressions have been mixed in. Therefor it is
     * considered safe by construction.
     */
    const policy = window.trustedTypes &&
        trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });
    const commentMarker = ` ${marker} `;
    /**
     * The return type of `html`, which holds a Template and the values from
     * interpolated expressions.
     */
    class TemplateResult {
        constructor(strings, values, type, processor) {
            this.strings = strings;
            this.values = values;
            this.type = type;
            this.processor = processor;
        }
        /**
         * Returns a string of HTML used to create a `<template>` element.
         */
        getHTML() {
            const l = this.strings.length - 1;
            let html = '';
            let isCommentBinding = false;
            for (let i = 0; i < l; i++) {
                const s = this.strings[i];
                // For each binding we want to determine the kind of marker to insert
                // into the template source before it's parsed by the browser's HTML
                // parser. The marker type is based on whether the expression is in an
                // attribute, text, or comment position.
                //   * For node-position bindings we insert a comment with the marker
                //     sentinel as its text content, like <!--{{lit-guid}}-->.
                //   * For attribute bindings we insert just the marker sentinel for the
                //     first binding, so that we support unquoted attribute bindings.
                //     Subsequent bindings can use a comment marker because multi-binding
                //     attributes must be quoted.
                //   * For comment bindings we insert just the marker sentinel so we don't
                //     close the comment.
                //
                // The following code scans the template source, but is *not* an HTML
                // parser. We don't need to track the tree structure of the HTML, only
                // whether a binding is inside a comment, and if not, if it appears to be
                // the first binding in an attribute.
                const commentOpen = s.lastIndexOf('<!--');
                // We're in comment position if we have a comment open with no following
                // comment close. Because <-- can appear in an attribute value there can
                // be false positives.
                isCommentBinding = (commentOpen > -1 || isCommentBinding) &&
                    s.indexOf('-->', commentOpen + 1) === -1;
                // Check to see if we have an attribute-like sequence preceding the
                // expression. This can match "name=value" like structures in text,
                // comments, and attribute values, so there can be false-positives.
                const attributeMatch = lastAttributeNameRegex.exec(s);
                if (attributeMatch === null) {
                    // We're only in this branch if we don't have a attribute-like
                    // preceding sequence. For comments, this guards against unusual
                    // attribute values like <div foo="<!--${'bar'}">. Cases like
                    // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
                    // below.
                    html += s + (isCommentBinding ? commentMarker : nodeMarker);
                }
                else {
                    // For attributes we use just a marker sentinel, and also append a
                    // $lit$ suffix to the name to opt-out of attribute-specific parsing
                    // that IE and Edge do for style and certain SVG attributes.
                    html += s.substr(0, attributeMatch.index) + attributeMatch[1] +
                        attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +
                        marker;
                }
            }
            html += this.strings[l];
            return html;
        }
        getTemplateElement() {
            const template = document.createElement('template');
            let value = this.getHTML();
            if (policy !== undefined) {
                // this is secure because `this.strings` is a TemplateStringsArray.
                // TODO: validate this when
                // https://github.com/tc39/proposal-array-is-template-object is
                // implemented.
                value = policy.createHTML(value);
            }
            template.innerHTML = value;
            return template;
        }
    }
    /**
     * A TemplateResult for SVG fragments.
     *
     * This class wraps HTML in an `<svg>` tag in order to parse its contents in the
     * SVG namespace, then modifies the template to remove the `<svg>` tag so that
     * clones only container the original fragment.
     */
    class SVGTemplateResult extends TemplateResult {
        getHTML() {
            return `<svg>${super.getHTML()}</svg>`;
        }
        getTemplateElement() {
            const template = super.getTemplateElement();
            const content = template.content;
            const svgElement = content.firstChild;
            content.removeChild(svgElement);
            reparentNodes(content, svgElement.firstChild);
            return template;
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const isPrimitive = (value) => {
        return (value === null ||
            !(typeof value === 'object' || typeof value === 'function'));
    };
    const isIterable = (value) => {
        return Array.isArray(value) ||
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            !!(value && value[Symbol.iterator]);
    };
    /**
     * Writes attribute values to the DOM for a group of AttributeParts bound to a
     * single attribute. The value is only set once even if there are multiple parts
     * for an attribute.
     */
    class AttributeCommitter {
        constructor(element, name, strings) {
            this.dirty = true;
            this.element = element;
            this.name = name;
            this.strings = strings;
            this.parts = [];
            for (let i = 0; i < strings.length - 1; i++) {
                this.parts[i] = this._createPart();
            }
        }
        /**
         * Creates a single part. Override this to create a differnt type of part.
         */
        _createPart() {
            return new AttributePart(this);
        }
        _getValue() {
            const strings = this.strings;
            const l = strings.length - 1;
            const parts = this.parts;
            // If we're assigning an attribute via syntax like:
            //    attr="${foo}"  or  attr=${foo}
            // but not
            //    attr="${foo} ${bar}" or attr="${foo} baz"
            // then we don't want to coerce the attribute value into one long
            // string. Instead we want to just return the value itself directly,
            // so that sanitizeDOMValue can get the actual value rather than
            // String(value)
            // The exception is if v is an array, in which case we do want to smash
            // it together into a string without calling String() on the array.
            //
            // This also allows trusted values (when using TrustedTypes) being
            // assigned to DOM sinks without being stringified in the process.
            if (l === 1 && strings[0] === '' && strings[1] === '') {
                const v = parts[0].value;
                if (typeof v === 'symbol') {
                    return String(v);
                }
                if (typeof v === 'string' || !isIterable(v)) {
                    return v;
                }
            }
            let text = '';
            for (let i = 0; i < l; i++) {
                text += strings[i];
                const part = parts[i];
                if (part !== undefined) {
                    const v = part.value;
                    if (isPrimitive(v) || !isIterable(v)) {
                        text += typeof v === 'string' ? v : String(v);
                    }
                    else {
                        for (const t of v) {
                            text += typeof t === 'string' ? t : String(t);
                        }
                    }
                }
            }
            text += strings[l];
            return text;
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                this.element.setAttribute(this.name, this._getValue());
            }
        }
    }
    /**
     * A Part that controls all or part of an attribute value.
     */
    class AttributePart {
        constructor(committer) {
            this.value = undefined;
            this.committer = committer;
        }
        setValue(value) {
            if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
                this.value = value;
                // If the value is a not a directive, dirty the committer so that it'll
                // call setAttribute. If the value is a directive, it'll dirty the
                // committer if it calls setValue().
                if (!isDirective(value)) {
                    this.committer.dirty = true;
                }
            }
        }
        commit() {
            while (isDirective(this.value)) {
                const directive = this.value;
                this.value = noChange;
                directive(this);
            }
            if (this.value === noChange) {
                return;
            }
            this.committer.commit();
        }
    }
    /**
     * A Part that controls a location within a Node tree. Like a Range, NodePart
     * has start and end locations and can set and update the Nodes between those
     * locations.
     *
     * NodeParts support several value types: primitives, Nodes, TemplateResults,
     * as well as arrays and iterables of those types.
     */
    class NodePart {
        constructor(options) {
            this.value = undefined;
            this.__pendingValue = undefined;
            this.options = options;
        }
        /**
         * Appends this part into a container.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        appendInto(container) {
            this.startNode = container.appendChild(createMarker());
            this.endNode = container.appendChild(createMarker());
        }
        /**
         * Inserts this part after the `ref` node (between `ref` and `ref`'s next
         * sibling). Both `ref` and its next sibling must be static, unchanging nodes
         * such as those that appear in a literal section of a template.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        insertAfterNode(ref) {
            this.startNode = ref;
            this.endNode = ref.nextSibling;
        }
        /**
         * Appends this part into a parent part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        appendIntoPart(part) {
            part.__insert(this.startNode = createMarker());
            part.__insert(this.endNode = createMarker());
        }
        /**
         * Inserts this part after the `ref` part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        insertAfterPart(ref) {
            ref.__insert(this.startNode = createMarker());
            this.endNode = ref.endNode;
            ref.endNode = this.startNode;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            if (this.startNode.parentNode === null) {
                return;
            }
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            const value = this.__pendingValue;
            if (value === noChange) {
                return;
            }
            if (isPrimitive(value)) {
                if (value !== this.value) {
                    this.__commitText(value);
                }
            }
            else if (value instanceof TemplateResult) {
                this.__commitTemplateResult(value);
            }
            else if (value instanceof Node) {
                this.__commitNode(value);
            }
            else if (isIterable(value)) {
                this.__commitIterable(value);
            }
            else if (value === nothing) {
                this.value = nothing;
                this.clear();
            }
            else {
                // Fallback, will render the string representation
                this.__commitText(value);
            }
        }
        __insert(node) {
            this.endNode.parentNode.insertBefore(node, this.endNode);
        }
        __commitNode(value) {
            if (this.value === value) {
                return;
            }
            this.clear();
            this.__insert(value);
            this.value = value;
        }
        __commitText(value) {
            const node = this.startNode.nextSibling;
            value = value == null ? '' : value;
            // If `value` isn't already a string, we explicitly convert it here in case
            // it can't be implicitly converted - i.e. it's a symbol.
            const valueAsString = typeof value === 'string' ? value : String(value);
            if (node === this.endNode.previousSibling &&
                node.nodeType === 3 /* Node.TEXT_NODE */) {
                // If we only have a single text node between the markers, we can just
                // set its value, rather than replacing it.
                // TODO(justinfagnani): Can we just check if this.value is primitive?
                node.data = valueAsString;
            }
            else {
                this.__commitNode(document.createTextNode(valueAsString));
            }
            this.value = value;
        }
        __commitTemplateResult(value) {
            const template = this.options.templateFactory(value);
            if (this.value instanceof TemplateInstance &&
                this.value.template === template) {
                this.value.update(value.values);
            }
            else {
                // Make sure we propagate the template processor from the TemplateResult
                // so that we use its syntax extension, etc. The template factory comes
                // from the render function options so that it can control template
                // caching and preprocessing.
                const instance = new TemplateInstance(template, value.processor, this.options);
                const fragment = instance._clone();
                instance.update(value.values);
                this.__commitNode(fragment);
                this.value = instance;
            }
        }
        __commitIterable(value) {
            // For an Iterable, we create a new InstancePart per item, then set its
            // value to the item. This is a little bit of overhead for every item in
            // an Iterable, but it lets us recurse easily and efficiently update Arrays
            // of TemplateResults that will be commonly returned from expressions like:
            // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
            // If _value is an array, then the previous render was of an
            // iterable and _value will contain the NodeParts from the previous
            // render. If _value is not an array, clear this part and make a new
            // array for NodeParts.
            if (!Array.isArray(this.value)) {
                this.value = [];
                this.clear();
            }
            // Lets us keep track of how many items we stamped so we can clear leftover
            // items from a previous render
            const itemParts = this.value;
            let partIndex = 0;
            let itemPart;
            for (const item of value) {
                // Try to reuse an existing part
                itemPart = itemParts[partIndex];
                // If no existing part, create a new one
                if (itemPart === undefined) {
                    itemPart = new NodePart(this.options);
                    itemParts.push(itemPart);
                    if (partIndex === 0) {
                        itemPart.appendIntoPart(this);
                    }
                    else {
                        itemPart.insertAfterPart(itemParts[partIndex - 1]);
                    }
                }
                itemPart.setValue(item);
                itemPart.commit();
                partIndex++;
            }
            if (partIndex < itemParts.length) {
                // Truncate the parts array so _value reflects the current state
                itemParts.length = partIndex;
                this.clear(itemPart && itemPart.endNode);
            }
        }
        clear(startNode = this.startNode) {
            removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
        }
    }
    /**
     * Implements a boolean attribute, roughly as defined in the HTML
     * specification.
     *
     * If the value is truthy, then the attribute is present with a value of
     * ''. If the value is falsey, the attribute is removed.
     */
    class BooleanAttributePart {
        constructor(element, name, strings) {
            this.value = undefined;
            this.__pendingValue = undefined;
            if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
                throw new Error('Boolean attributes can only contain a single expression');
            }
            this.element = element;
            this.name = name;
            this.strings = strings;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const value = !!this.__pendingValue;
            if (this.value !== value) {
                if (value) {
                    this.element.setAttribute(this.name, '');
                }
                else {
                    this.element.removeAttribute(this.name);
                }
                this.value = value;
            }
            this.__pendingValue = noChange;
        }
    }
    /**
     * Sets attribute values for PropertyParts, so that the value is only set once
     * even if there are multiple parts for a property.
     *
     * If an expression controls the whole property value, then the value is simply
     * assigned to the property under control. If there are string literals or
     * multiple expressions, then the strings are expressions are interpolated into
     * a string first.
     */
    class PropertyCommitter extends AttributeCommitter {
        constructor(element, name, strings) {
            super(element, name, strings);
            this.single =
                (strings.length === 2 && strings[0] === '' && strings[1] === '');
        }
        _createPart() {
            return new PropertyPart(this);
        }
        _getValue() {
            if (this.single) {
                return this.parts[0].value;
            }
            return super._getValue();
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this.element[this.name] = this._getValue();
            }
        }
    }
    class PropertyPart extends AttributePart {
    }
    // Detect event listener options support. If the `capture` property is read
    // from the options object, then options are supported. If not, then the third
    // argument to add/removeEventListener is interpreted as the boolean capture
    // value so we should only pass the `capture` property.
    let eventOptionsSupported = false;
    // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
    // blocks right into the body of a module
    (() => {
        try {
            const options = {
                get capture() {
                    eventOptionsSupported = true;
                    return false;
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.addEventListener('test', options, options);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.removeEventListener('test', options, options);
        }
        catch (_e) {
            // event options not supported
        }
    })();
    class EventPart {
        constructor(element, eventName, eventContext) {
            this.value = undefined;
            this.__pendingValue = undefined;
            this.element = element;
            this.eventName = eventName;
            this.eventContext = eventContext;
            this.__boundHandleEvent = (e) => this.handleEvent(e);
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const newListener = this.__pendingValue;
            const oldListener = this.value;
            const shouldRemoveListener = newListener == null ||
                oldListener != null &&
                (newListener.capture !== oldListener.capture ||
                    newListener.once !== oldListener.once ||
                    newListener.passive !== oldListener.passive);
            const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
            if (shouldRemoveListener) {
                this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            if (shouldAddListener) {
                this.__options = getOptions(newListener);
                this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            this.value = newListener;
            this.__pendingValue = noChange;
        }
        handleEvent(event) {
            if (typeof this.value === 'function') {
                this.value.call(this.eventContext || this.element, event);
            }
            else {
                this.value.handleEvent(event);
            }
        }
    }
    // We copy options because of the inconsistent behavior of browsers when reading
    // the third argument of add/removeEventListener. IE11 doesn't support options
    // at all. Chrome 41 only reads `capture` if the argument is an object.
    const getOptions = (o) => o &&
        (eventOptionsSupported ?
            { capture: o.capture, passive: o.passive, once: o.once } :
            o.capture);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * The default TemplateFactory which caches Templates keyed on
     * result.type and result.strings.
     */
    function templateFactory(result) {
        let templateCache = templateCaches.get(result.type);
        if (templateCache === undefined) {
            templateCache = {
                stringsArray: new WeakMap(),
                keyString: new Map()
            };
            templateCaches.set(result.type, templateCache);
        }
        let template = templateCache.stringsArray.get(result.strings);
        if (template !== undefined) {
            return template;
        }
        // If the TemplateStringsArray is new, generate a key from the strings
        // This key is shared between all templates with identical content
        const key = result.strings.join(marker);
        // Check if we already have a Template for this key
        template = templateCache.keyString.get(key);
        if (template === undefined) {
            // If we have not seen this key before, create a new Template
            template = new Template(result, result.getTemplateElement());
            // Cache the Template for this key
            templateCache.keyString.set(key, template);
        }
        // Cache all future queries for this TemplateStringsArray
        templateCache.stringsArray.set(result.strings, template);
        return template;
    }
    const templateCaches = new Map();

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const parts = new WeakMap();
    /**
     * Renders a template result or other value to a container.
     *
     * To update a container with new values, reevaluate the template literal and
     * call `render` with the new result.
     *
     * @param result Any value renderable by NodePart - typically a TemplateResult
     *     created by evaluating a template tag like `html` or `svg`.
     * @param container A DOM parent to render to. The entire contents are either
     *     replaced, or efficiently updated if the same result type was previous
     *     rendered there.
     * @param options RenderOptions for the entire render tree rendered to this
     *     container. Render options must *not* change between renders to the same
     *     container, as those changes will not effect previously rendered DOM.
     */
    const render = (result, container, options) => {
        let part = parts.get(container);
        if (part === undefined) {
            removeNodes(container, container.firstChild);
            parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
            part.appendInto(container);
        }
        part.setValue(result);
        part.commit();
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Creates Parts when a template is instantiated.
     */
    class DefaultTemplateProcessor {
        /**
         * Create parts for an attribute-position binding, given the event, attribute
         * name, and string literals.
         *
         * @param element The element containing the binding
         * @param name  The attribute name
         * @param strings The string literals. There are always at least two strings,
         *   event for fully-controlled bindings with a single expression.
         */
        handleAttributeExpressions(element, name, strings, options) {
            const prefix = name[0];
            if (prefix === '.') {
                const committer = new PropertyCommitter(element, name.slice(1), strings);
                return committer.parts;
            }
            if (prefix === '@') {
                return [new EventPart(element, name.slice(1), options.eventContext)];
            }
            if (prefix === '?') {
                return [new BooleanAttributePart(element, name.slice(1), strings)];
            }
            const committer = new AttributeCommitter(element, name, strings);
            return committer.parts;
        }
        /**
         * Create parts for a text-position binding.
         * @param templateFactory
         */
        handleTextExpression(options) {
            return new NodePart(options);
        }
    }
    const defaultTemplateProcessor = new DefaultTemplateProcessor();

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // IMPORTANT: do not change the property name or the assignment expression.
    // This line will be used in regexes to search for lit-html usage.
    // TODO(justinfagnani): inject version number at build time
    if (typeof window !== 'undefined') {
        (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.3.0');
    }
    /**
     * Interprets a template literal as an HTML template that can efficiently
     * render to and update a container.
     */
    const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
    /**
     * Interprets a template literal as an SVG template that can efficiently
     * render to and update a container.
     */
    const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
        // Get a key to lookup in `templateCaches`.
    const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
    let compatibleShadyCSSVersion = true;
    if (typeof window.ShadyCSS === 'undefined') {
        compatibleShadyCSSVersion = false;
    }
    else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
        console.warn(`Incompatible ShadyCSS version detected. ` +
            `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +
            `@webcomponents/shadycss@1.3.1.`);
        compatibleShadyCSSVersion = false;
    }
    /**
     * Template factory which scopes template DOM using ShadyCSS.
     * @param scopeName {string}
     */
    const shadyTemplateFactory = (scopeName) => (result) => {
        const cacheKey = getTemplateCacheKey(result.type, scopeName);
        let templateCache = templateCaches.get(cacheKey);
        if (templateCache === undefined) {
            templateCache = {
                stringsArray: new WeakMap(),
                keyString: new Map()
            };
            templateCaches.set(cacheKey, templateCache);
        }
        let template = templateCache.stringsArray.get(result.strings);
        if (template !== undefined) {
            return template;
        }
        const key = result.strings.join(marker);
        template = templateCache.keyString.get(key);
        if (template === undefined) {
            const element = result.getTemplateElement();
            if (compatibleShadyCSSVersion) {
                window.ShadyCSS.prepareTemplateDom(element, scopeName);
            }
            template = new Template(result, element);
            templateCache.keyString.set(key, template);
        }
        templateCache.stringsArray.set(result.strings, template);
        return template;
    };
    const TEMPLATE_TYPES = ['html', 'svg'];
    /**
     * Removes all style elements from Templates for the given scopeName.
     */
    const removeStylesFromLitTemplates = (scopeName) => {
        TEMPLATE_TYPES.forEach((type) => {
            const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
            if (templates !== undefined) {
                templates.keyString.forEach((template) => {
                    const { element: { content } } = template;
                    // IE 11 doesn't support the iterable param Set constructor
                    const styles = new Set();
                    Array.from(content.querySelectorAll('style')).forEach((s) => {
                        styles.add(s);
                    });
                    removeNodesFromTemplate(template, styles);
                });
            }
        });
    };
    const shadyRenderSet = new Set();
    /**
     * For the given scope name, ensures that ShadyCSS style scoping is performed.
     * This is done just once per scope name so the fragment and template cannot
     * be modified.
     * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
     * to be scoped and appended to the document
     * (2) removes style elements from all lit-html Templates for this scope name.
     *
     * Note, <style> elements can only be placed into templates for the
     * initial rendering of the scope. If <style> elements are included in templates
     * dynamically rendered to the scope (after the first scope render), they will
     * not be scoped and the <style> will be left in the template and rendered
     * output.
     */
    const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
        shadyRenderSet.add(scopeName);
        // If `renderedDOM` is stamped from a Template, then we need to edit that
        // Template's underlying template element. Otherwise, we create one here
        // to give to ShadyCSS, which still requires one while scoping.
        const templateElement = !!template ? template.element : document.createElement('template');
        // Move styles out of rendered DOM and store.
        const styles = renderedDOM.querySelectorAll('style');
        const { length } = styles;
        // If there are no styles, skip unnecessary work
        if (length === 0) {
            // Ensure prepareTemplateStyles is called to support adding
            // styles via `prepareAdoptedCssText` since that requires that
            // `prepareTemplateStyles` is called.
            //
            // ShadyCSS will only update styles containing @apply in the template
            // given to `prepareTemplateStyles`. If no lit Template was given,
            // ShadyCSS will not be able to update uses of @apply in any relevant
            // template. However, this is not a problem because we only create the
            // template for the purpose of supporting `prepareAdoptedCssText`,
            // which doesn't support @apply at all.
            window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
            return;
        }
        const condensedStyle = document.createElement('style');
        // Collect styles into a single style. This helps us make sure ShadyCSS
        // manipulations will not prevent us from being able to fix up template
        // part indices.
        // NOTE: collecting styles is inefficient for browsers but ShadyCSS
        // currently does this anyway. When it does not, this should be changed.
        for (let i = 0; i < length; i++) {
            const style = styles[i];
            style.parentNode.removeChild(style);
            condensedStyle.textContent += style.textContent;
        }
        // Remove styles from nested templates in this scope.
        removeStylesFromLitTemplates(scopeName);
        // And then put the condensed style into the "root" template passed in as
        // `template`.
        const content = templateElement.content;
        if (!!template) {
            insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
        }
        else {
            content.insertBefore(condensedStyle, content.firstChild);
        }
        // Note, it's important that ShadyCSS gets the template that `lit-html`
        // will actually render so that it can update the style inside when
        // needed (e.g. @apply native Shadow DOM case).
        window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
        const style = content.querySelector('style');
        if (window.ShadyCSS.nativeShadow && style !== null) {
            // When in native Shadow DOM, ensure the style created by ShadyCSS is
            // included in initially rendered output (`renderedDOM`).
            renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
        }
        else if (!!template) {
            // When no style is left in the template, parts will be broken as a
            // result. To fix this, we put back the style node ShadyCSS removed
            // and then tell lit to remove that node from the template.
            // There can be no style in the template in 2 cases (1) when Shady DOM
            // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM
            // is in use ShadyCSS removes the style if it contains no content.
            // NOTE, ShadyCSS creates its own style so we can safely add/remove
            // `condensedStyle` here.
            content.insertBefore(condensedStyle, content.firstChild);
            const removes = new Set();
            removes.add(condensedStyle);
            removeNodesFromTemplate(template, removes);
        }
    };
    /**
     * Extension to the standard `render` method which supports rendering
     * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
     * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
     * or when the webcomponentsjs
     * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
     *
     * Adds a `scopeName` option which is used to scope element DOM and stylesheets
     * when native ShadowDOM is unavailable. The `scopeName` will be added to
     * the class attribute of all rendered DOM. In addition, any style elements will
     * be automatically re-written with this `scopeName` selector and moved out
     * of the rendered DOM and into the document `<head>`.
     *
     * It is common to use this render method in conjunction with a custom element
     * which renders a shadowRoot. When this is done, typically the element's
     * `localName` should be used as the `scopeName`.
     *
     * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
     * custom properties (needed only on older browsers like IE11) and a shim for
     * a deprecated feature called `@apply` that supports applying a set of css
     * custom properties to a given location.
     *
     * Usage considerations:
     *
     * * Part values in `<style>` elements are only applied the first time a given
     * `scopeName` renders. Subsequent changes to parts in style elements will have
     * no effect. Because of this, parts in style elements should only be used for
     * values that will never change, for example parts that set scope-wide theme
     * values or parts which render shared style elements.
     *
     * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
     * custom element's `constructor` is not supported. Instead rendering should
     * either done asynchronously, for example at microtask timing (for example
     * `Promise.resolve()`), or be deferred until the first time the element's
     * `connectedCallback` runs.
     *
     * Usage considerations when using shimmed custom properties or `@apply`:
     *
     * * Whenever any dynamic changes are made which affect
     * css custom properties, `ShadyCSS.styleElement(element)` must be called
     * to update the element. There are two cases when this is needed:
     * (1) the element is connected to a new parent, (2) a class is added to the
     * element that causes it to match different custom properties.
     * To address the first case when rendering a custom element, `styleElement`
     * should be called in the element's `connectedCallback`.
     *
     * * Shimmed custom properties may only be defined either for an entire
     * shadowRoot (for example, in a `:host` rule) or via a rule that directly
     * matches an element with a shadowRoot. In other words, instead of flowing from
     * parent to child as do native css custom properties, shimmed custom properties
     * flow only from shadowRoots to nested shadowRoots.
     *
     * * When using `@apply` mixing css shorthand property names with
     * non-shorthand names (for example `border` and `border-width`) is not
     * supported.
     */
    const render$1 = (result, container, options) => {
        if (!options || typeof options !== 'object' || !options.scopeName) {
            throw new Error('The `scopeName` option is required.');
        }
        const scopeName = options.scopeName;
        const hasRendered = parts.has(container);
        const needsScoping = compatibleShadyCSSVersion &&
            container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&
            !!container.host;
        // Handle first render to a scope specially...
        const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
        // On first scope render, render into a fragment; this cannot be a single
        // fragment that is reused since nested renders can occur synchronously.
        const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
        render(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));
        // When performing first scope render,
        // (1) We've rendered into a fragment so that there's a chance to
        // `prepareTemplateStyles` before sub-elements hit the DOM
        // (which might cause them to render based on a common pattern of
        // rendering in a custom element's `connectedCallback`);
        // (2) Scope the template with ShadyCSS one time only for this scope.
        // (3) Render the fragment into the container and make sure the
        // container knows its `part` is the one we just rendered. This ensures
        // DOM will be re-used on subsequent renders.
        if (firstScopeRender) {
            const part = parts.get(renderContainer);
            parts.delete(renderContainer);
            // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)
            // that should apply to `renderContainer` even if the rendered value is
            // not a TemplateInstance. However, it will only insert scoped styles
            // into the document if `prepareTemplateStyles` has already been called
            // for the given scope name.
            const template = part.value instanceof TemplateInstance ?
                part.value.template :
                undefined;
            prepareTemplateStyles(scopeName, renderContainer, template);
            removeNodes(container, container.firstChild);
            container.appendChild(renderContainer);
            parts.set(container, part);
        }
        // After elements have hit the DOM, update styling if this is the
        // initial render to this container.
        // This is needed whenever dynamic changes are made so it would be
        // safest to do every render; however, this would regress performance
        // so we leave it up to the user to call `ShadyCSS.styleElement`
        // for dynamic changes.
        if (!hasRendered && needsScoping) {
            window.ShadyCSS.styleElement(container.host);
        }
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    var _a;
    /**
     * Use this module if you want to create your own base class extending
     * [[UpdatingElement]].
     * @packageDocumentation
     */
    /*
     * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
     * replaced at compile time by the munged name for object[property]. We cannot
     * alias this function, so we have to use a small shim that has the same
     * behavior when not compiling.
     */
    window.JSCompiler_renameProperty =
        (prop, _obj) => prop;
    const defaultConverter = {
        toAttribute(value, type) {
            switch (type) {
                case Boolean:
                    return value ? '' : null;
                case Object:
                case Array:
                    // if the value is `null` or `undefined` pass this through
                    // to allow removing/no change behavior.
                    return value == null ? value : JSON.stringify(value);
            }
            return value;
        },
        fromAttribute(value, type) {
            switch (type) {
                case Boolean:
                    return value !== null;
                case Number:
                    return value === null ? null : Number(value);
                case Object:
                case Array:
                    return JSON.parse(value);
            }
            return value;
        }
    };
    /**
     * Change function that returns true if `value` is different from `oldValue`.
     * This method is used as the default for a property's `hasChanged` function.
     */
    const notEqual = (value, old) => {
        // This ensures (old==NaN, value==NaN) always returns false
        return old !== value && (old === old || value === value);
    };
    const defaultPropertyDeclaration = {
        attribute: true,
        type: String,
        converter: defaultConverter,
        reflect: false,
        hasChanged: notEqual
    };
    const STATE_HAS_UPDATED = 1;
    const STATE_UPDATE_REQUESTED = 1 << 2;
    const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
    const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
    /**
     * The Closure JS Compiler doesn't currently have good support for static
     * property semantics where "this" is dynamic (e.g.
     * https://github.com/google/closure-compiler/issues/3177 and others) so we use
     * this hack to bypass any rewriting by the compiler.
     */
    const finalized = 'finalized';
    /**
     * Base element class which manages element properties and attributes. When
     * properties change, the `update` method is asynchronously called. This method
     * should be supplied by subclassers to render updates as desired.
     * @noInheritDoc
     */
    class UpdatingElement extends HTMLElement {
        constructor() {
            super();
            this.initialize();
        }
        /**
         * Returns a list of attributes corresponding to the registered properties.
         * @nocollapse
         */
        static get observedAttributes() {
            // note: piggy backing on this to ensure we're finalized.
            this.finalize();
            const attributes = [];
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            this._classProperties.forEach((v, p) => {
                const attr = this._attributeNameForProperty(p, v);
                if (attr !== undefined) {
                    this._attributeToPropertyMap.set(attr, p);
                    attributes.push(attr);
                }
            });
            return attributes;
        }
        /**
         * Ensures the private `_classProperties` property metadata is created.
         * In addition to `finalize` this is also called in `createProperty` to
         * ensure the `@property` decorator can add property metadata.
         */
        /** @nocollapse */
        static _ensureClassProperties() {
            // ensure private storage for property declarations.
            if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
                this._classProperties = new Map();
                // NOTE: Workaround IE11 not supporting Map constructor argument.
                const superProperties = Object.getPrototypeOf(this)._classProperties;
                if (superProperties !== undefined) {
                    superProperties.forEach((v, k) => this._classProperties.set(k, v));
                }
            }
        }
        /**
         * Creates a property accessor on the element prototype if one does not exist
         * and stores a PropertyDeclaration for the property with the given options.
         * The property setter calls the property's `hasChanged` property option
         * or uses a strict identity check to determine whether or not to request
         * an update.
         *
         * This method may be overridden to customize properties; however,
         * when doing so, it's important to call `super.createProperty` to ensure
         * the property is setup correctly. This method calls
         * `getPropertyDescriptor` internally to get a descriptor to install.
         * To customize what properties do when they are get or set, override
         * `getPropertyDescriptor`. To customize the options for a property,
         * implement `createProperty` like this:
         *
         * static createProperty(name, options) {
         *   options = Object.assign(options, {myOption: true});
         *   super.createProperty(name, options);
         * }
         *
         * @nocollapse
         */
        static createProperty(name, options = defaultPropertyDeclaration) {
            // Note, since this can be called by the `@property` decorator which
            // is called before `finalize`, we ensure storage exists for property
            // metadata.
            this._ensureClassProperties();
            this._classProperties.set(name, options);
            // Do not generate an accessor if the prototype already has one, since
            // it would be lost otherwise and that would never be the user's intention;
            // Instead, we expect users to call `requestUpdate` themselves from
            // user-defined accessors. Note that if the super has an accessor we will
            // still overwrite it
            if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
                return;
            }
            const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
            const descriptor = this.getPropertyDescriptor(name, key, options);
            if (descriptor !== undefined) {
                Object.defineProperty(this.prototype, name, descriptor);
            }
        }
        /**
         * Returns a property descriptor to be defined on the given named property.
         * If no descriptor is returned, the property will not become an accessor.
         * For example,
         *
         *   class MyElement extends LitElement {
         *     static getPropertyDescriptor(name, key, options) {
         *       const defaultDescriptor =
         *           super.getPropertyDescriptor(name, key, options);
         *       const setter = defaultDescriptor.set;
         *       return {
         *         get: defaultDescriptor.get,
         *         set(value) {
         *           setter.call(this, value);
         *           // custom action.
         *         },
         *         configurable: true,
         *         enumerable: true
         *       }
         *     }
         *   }
         *
         * @nocollapse
         */
        static getPropertyDescriptor(name, key, options) {
            return {
                // tslint:disable-next-line:no-any no symbol in index
                get() {
                    return this[key];
                },
                set(value) {
                    const oldValue = this[name];
                    this[key] = value;
                    this
                        .requestUpdateInternal(name, oldValue, options);
                },
                configurable: true,
                enumerable: true
            };
        }
        /**
         * Returns the property options associated with the given property.
         * These options are defined with a PropertyDeclaration via the `properties`
         * object or the `@property` decorator and are registered in
         * `createProperty(...)`.
         *
         * Note, this method should be considered "final" and not overridden. To
         * customize the options for a given property, override `createProperty`.
         *
         * @nocollapse
         * @final
         */
        static getPropertyOptions(name) {
            return this._classProperties && this._classProperties.get(name) ||
                defaultPropertyDeclaration;
        }
        /**
         * Creates property accessors for registered properties and ensures
         * any superclasses are also finalized.
         * @nocollapse
         */
        static finalize() {
            // finalize any superclasses
            const superCtor = Object.getPrototypeOf(this);
            if (!superCtor.hasOwnProperty(finalized)) {
                superCtor.finalize();
            }
            this[finalized] = true;
            this._ensureClassProperties();
            // initialize Map populated in observedAttributes
            this._attributeToPropertyMap = new Map();
            // make any properties
            // Note, only process "own" properties since this element will inherit
            // any properties defined on the superClass, and finalization ensures
            // the entire prototype chain is finalized.
            if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
                const props = this.properties;
                // support symbols in properties (IE11 does not support this)
                const propKeys = [
                    ...Object.getOwnPropertyNames(props),
                    ...(typeof Object.getOwnPropertySymbols === 'function') ?
                        Object.getOwnPropertySymbols(props) :
                        []
                ];
                // This for/of is ok because propKeys is an array
                for (const p of propKeys) {
                    // note, use of `any` is due to TypeSript lack of support for symbol in
                    // index types
                    // tslint:disable-next-line:no-any no symbol in index
                    this.createProperty(p, props[p]);
                }
            }
        }
        /**
         * Returns the property name for the given attribute `name`.
         * @nocollapse
         */
        static _attributeNameForProperty(name, options) {
            const attribute = options.attribute;
            return attribute === false ?
                undefined :
                (typeof attribute === 'string' ?
                    attribute :
                    (typeof name === 'string' ? name.toLowerCase() : undefined));
        }
        /**
         * Returns true if a property should request an update.
         * Called when a property value is set and uses the `hasChanged`
         * option for the property if present or a strict identity check.
         * @nocollapse
         */
        static _valueHasChanged(value, old, hasChanged = notEqual) {
            return hasChanged(value, old);
        }
        /**
         * Returns the property value for the given attribute value.
         * Called via the `attributeChangedCallback` and uses the property's
         * `converter` or `converter.fromAttribute` property option.
         * @nocollapse
         */
        static _propertyValueFromAttribute(value, options) {
            const type = options.type;
            const converter = options.converter || defaultConverter;
            const fromAttribute = (typeof converter === 'function' ? converter : converter.fromAttribute);
            return fromAttribute ? fromAttribute(value, type) : value;
        }
        /**
         * Returns the attribute value for the given property value. If this
         * returns undefined, the property will *not* be reflected to an attribute.
         * If this returns null, the attribute will be removed, otherwise the
         * attribute will be set to the value.
         * This uses the property's `reflect` and `type.toAttribute` property options.
         * @nocollapse
         */
        static _propertyValueToAttribute(value, options) {
            if (options.reflect === undefined) {
                return;
            }
            const type = options.type;
            const converter = options.converter;
            const toAttribute = converter && converter.toAttribute ||
                defaultConverter.toAttribute;
            return toAttribute(value, type);
        }
        /**
         * Performs element initialization. By default captures any pre-set values for
         * registered properties.
         */
        initialize() {
            this._updateState = 0;
            this._updatePromise =
                new Promise((res) => this._enableUpdatingResolver = res);
            this._changedProperties = new Map();
            this._saveInstanceProperties();
            // ensures first update will be caught by an early access of
            // `updateComplete`
            this.requestUpdateInternal();
        }
        /**
         * Fixes any properties set on the instance before upgrade time.
         * Otherwise these would shadow the accessor and break these properties.
         * The properties are stored in a Map which is played back after the
         * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
         * (<=41), properties created for native platform properties like (`id` or
         * `name`) may not have default values set in the element constructor. On
         * these browsers native properties appear on instances and therefore their
         * default value will overwrite any element default (e.g. if the element sets
         * this.id = 'id' in the constructor, the 'id' will become '' since this is
         * the native platform default).
         */
        _saveInstanceProperties() {
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            this.constructor
                ._classProperties.forEach((_v, p) => {
                if (this.hasOwnProperty(p)) {
                    const value = this[p];
                    delete this[p];
                    if (!this._instanceProperties) {
                        this._instanceProperties = new Map();
                    }
                    this._instanceProperties.set(p, value);
                }
            });
        }
        /**
         * Applies previously saved instance properties.
         */
        _applyInstanceProperties() {
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            // tslint:disable-next-line:no-any
            this._instanceProperties.forEach((v, p) => this[p] = v);
            this._instanceProperties = undefined;
        }
        connectedCallback() {
            // Ensure first connection completes an update. Updates cannot complete
            // before connection.
            this.enableUpdating();
        }
        enableUpdating() {
            if (this._enableUpdatingResolver !== undefined) {
                this._enableUpdatingResolver();
                this._enableUpdatingResolver = undefined;
            }
        }
        /**
         * Allows for `super.disconnectedCallback()` in extensions while
         * reserving the possibility of making non-breaking feature additions
         * when disconnecting at some point in the future.
         */
        disconnectedCallback() {
        }
        /**
         * Synchronizes property values when attributes change.
         */
        attributeChangedCallback(name, old, value) {
            if (old !== value) {
                this._attributeToProperty(name, value);
            }
        }
        _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
            const ctor = this.constructor;
            const attr = ctor._attributeNameForProperty(name, options);
            if (attr !== undefined) {
                const attrValue = ctor._propertyValueToAttribute(value, options);
                // an undefined value does not change the attribute.
                if (attrValue === undefined) {
                    return;
                }
                // Track if the property is being reflected to avoid
                // setting the property again via `attributeChangedCallback`. Note:
                // 1. this takes advantage of the fact that the callback is synchronous.
                // 2. will behave incorrectly if multiple attributes are in the reaction
                // stack at time of calling. However, since we process attributes
                // in `update` this should not be possible (or an extreme corner case
                // that we'd like to discover).
                // mark state reflecting
                this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
                if (attrValue == null) {
                    this.removeAttribute(attr);
                }
                else {
                    this.setAttribute(attr, attrValue);
                }
                // mark state not reflecting
                this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
            }
        }
        _attributeToProperty(name, value) {
            // Use tracking info to avoid deserializing attribute value if it was
            // just set from a property setter.
            if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
                return;
            }
            const ctor = this.constructor;
            // Note, hint this as an `AttributeMap` so closure clearly understands
            // the type; it has issues with tracking types through statics
            // tslint:disable-next-line:no-unnecessary-type-assertion
            const propName = ctor._attributeToPropertyMap.get(name);
            if (propName !== undefined) {
                const options = ctor.getPropertyOptions(propName);
                // mark state reflecting
                this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
                this[propName] =
                    // tslint:disable-next-line:no-any
                    ctor._propertyValueFromAttribute(value, options);
                // mark state not reflecting
                this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
            }
        }
        /**
         * This protected version of `requestUpdate` does not access or return the
         * `updateComplete` promise. This promise can be overridden and is therefore
         * not free to access.
         */
        requestUpdateInternal(name, oldValue, options) {
            let shouldRequestUpdate = true;
            // If we have a property key, perform property update steps.
            if (name !== undefined) {
                const ctor = this.constructor;
                options = options || ctor.getPropertyOptions(name);
                if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
                    if (!this._changedProperties.has(name)) {
                        this._changedProperties.set(name, oldValue);
                    }
                    // Add to reflecting properties set.
                    // Note, it's important that every change has a chance to add the
                    // property to `_reflectingProperties`. This ensures setting
                    // attribute + property reflects correctly.
                    if (options.reflect === true &&
                        !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
                        if (this._reflectingProperties === undefined) {
                            this._reflectingProperties = new Map();
                        }
                        this._reflectingProperties.set(name, options);
                    }
                }
                else {
                    // Abort the request if the property should not be considered changed.
                    shouldRequestUpdate = false;
                }
            }
            if (!this._hasRequestedUpdate && shouldRequestUpdate) {
                this._updatePromise = this._enqueueUpdate();
            }
        }
        /**
         * Requests an update which is processed asynchronously. This should
         * be called when an element should update based on some state not triggered
         * by setting a property. In this case, pass no arguments. It should also be
         * called when manually implementing a property setter. In this case, pass the
         * property `name` and `oldValue` to ensure that any configured property
         * options are honored. Returns the `updateComplete` Promise which is resolved
         * when the update completes.
         *
         * @param name {PropertyKey} (optional) name of requesting property
         * @param oldValue {any} (optional) old value of requesting property
         * @returns {Promise} A Promise that is resolved when the update completes.
         */
        requestUpdate(name, oldValue) {
            this.requestUpdateInternal(name, oldValue);
            return this.updateComplete;
        }
        /**
         * Sets up the element to asynchronously update.
         */
        async _enqueueUpdate() {
            this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
            try {
                // Ensure any previous update has resolved before updating.
                // This `await` also ensures that property changes are batched.
                await this._updatePromise;
            }
            catch (e) {
                // Ignore any previous errors. We only care that the previous cycle is
                // done. Any error should have been handled in the previous update.
            }
            const result = this.performUpdate();
            // If `performUpdate` returns a Promise, we await it. This is done to
            // enable coordinating updates with a scheduler. Note, the result is
            // checked to avoid delaying an additional microtask unless we need to.
            if (result != null) {
                await result;
            }
            return !this._hasRequestedUpdate;
        }
        get _hasRequestedUpdate() {
            return (this._updateState & STATE_UPDATE_REQUESTED);
        }
        get hasUpdated() {
            return (this._updateState & STATE_HAS_UPDATED);
        }
        /**
         * Performs an element update. Note, if an exception is thrown during the
         * update, `firstUpdated` and `updated` will not be called.
         *
         * You can override this method to change the timing of updates. If this
         * method is overridden, `super.performUpdate()` must be called.
         *
         * For instance, to schedule updates to occur just before the next frame:
         *
         * ```
         * protected async performUpdate(): Promise<unknown> {
         *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
         *   super.performUpdate();
         * }
         * ```
         */
        performUpdate() {
            // Abort any update if one is not pending when this is called.
            // This can happen if `performUpdate` is called early to "flush"
            // the update.
            if (!this._hasRequestedUpdate) {
                return;
            }
            // Mixin instance properties once, if they exist.
            if (this._instanceProperties) {
                this._applyInstanceProperties();
            }
            let shouldUpdate = false;
            const changedProperties = this._changedProperties;
            try {
                shouldUpdate = this.shouldUpdate(changedProperties);
                if (shouldUpdate) {
                    this.update(changedProperties);
                }
                else {
                    this._markUpdated();
                }
            }
            catch (e) {
                // Prevent `firstUpdated` and `updated` from running when there's an
                // update exception.
                shouldUpdate = false;
                // Ensure element can accept additional updates after an exception.
                this._markUpdated();
                throw e;
            }
            if (shouldUpdate) {
                if (!(this._updateState & STATE_HAS_UPDATED)) {
                    this._updateState = this._updateState | STATE_HAS_UPDATED;
                    this.firstUpdated(changedProperties);
                }
                this.updated(changedProperties);
            }
        }
        _markUpdated() {
            this._changedProperties = new Map();
            this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
        }
        /**
         * Returns a Promise that resolves when the element has completed updating.
         * The Promise value is a boolean that is `true` if the element completed the
         * update without triggering another update. The Promise result is `false` if
         * a property was set inside `updated()`. If the Promise is rejected, an
         * exception was thrown during the update.
         *
         * To await additional asynchronous work, override the `_getUpdateComplete`
         * method. For example, it is sometimes useful to await a rendered element
         * before fulfilling this Promise. To do this, first await
         * `super._getUpdateComplete()`, then any subsequent state.
         *
         * @returns {Promise} The Promise returns a boolean that indicates if the
         * update resolved without triggering another update.
         */
        get updateComplete() {
            return this._getUpdateComplete();
        }
        /**
         * Override point for the `updateComplete` promise.
         *
         * It is not safe to override the `updateComplete` getter directly due to a
         * limitation in TypeScript which means it is not possible to call a
         * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
         * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
         * This method should be overridden instead. For example:
         *
         *   class MyElement extends LitElement {
         *     async _getUpdateComplete() {
         *       await super._getUpdateComplete();
         *       await this._myChild.updateComplete;
         *     }
         *   }
         */
        _getUpdateComplete() {
            return this._updatePromise;
        }
        /**
         * Controls whether or not `update` should be called when the element requests
         * an update. By default, this method always returns `true`, but this can be
         * customized to control when to update.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        shouldUpdate(_changedProperties) {
            return true;
        }
        /**
         * Updates the element. This method reflects property values to attributes.
         * It can be overridden to render and keep updated element DOM.
         * Setting properties inside this method will *not* trigger
         * another update.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        update(_changedProperties) {
            if (this._reflectingProperties !== undefined &&
                this._reflectingProperties.size > 0) {
                // Use forEach so this works even if for/of loops are compiled to for
                // loops expecting arrays
                this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));
                this._reflectingProperties = undefined;
            }
            this._markUpdated();
        }
        /**
         * Invoked whenever the element is updated. Implement to perform
         * post-updating tasks via DOM APIs, for example, focusing an element.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        updated(_changedProperties) {
        }
        /**
         * Invoked when the element is first updated. Implement to perform one time
         * work on the element after update.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        firstUpdated(_changedProperties) {
        }
    }
    _a = finalized;
    /**
     * Marks class as having finished creating properties.
     */
    UpdatingElement[_a] = true;

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const legacyCustomElement = (tagName, clazz) => {
        window.customElements.define(tagName, clazz);
        // Cast as any because TS doesn't recognize the return type as being a
        // subtype of the decorated class when clazz is typed as
        // `Constructor<HTMLElement>` for some reason.
        // `Constructor<HTMLElement>` is helpful to make sure the decorator is
        // applied to elements however.
        // tslint:disable-next-line:no-any
        return clazz;
    };
    const standardCustomElement = (tagName, descriptor) => {
        const { kind, elements } = descriptor;
        return {
            kind,
            elements,
            // This callback is called once the class is otherwise fully defined
            finisher(clazz) {
                window.customElements.define(tagName, clazz);
            }
        };
    };
    /**
     * Class decorator factory that defines the decorated class as a custom element.
     *
     * ```
     * @customElement('my-element')
     * class MyElement {
     *   render() {
     *     return html``;
     *   }
     * }
     * ```
     * @category Decorator
     * @param tagName The name of the custom element to define.
     */
    const customElement = (tagName) => (classOrDescriptor) => (typeof classOrDescriptor === 'function') ?
        legacyCustomElement(tagName, classOrDescriptor) :
        standardCustomElement(tagName, classOrDescriptor);
    const standardProperty = (options, element) => {
        // When decorating an accessor, pass it through and add property metadata.
        // Note, the `hasOwnProperty` check in `createProperty` ensures we don't
        // stomp over the user's accessor.
        if (element.kind === 'method' && element.descriptor &&
            !('value' in element.descriptor)) {
            return Object.assign(Object.assign({}, element), { finisher(clazz) {
                    clazz.createProperty(element.key, options);
                } });
        }
        else {
            // createProperty() takes care of defining the property, but we still
            // must return some kind of descriptor, so return a descriptor for an
            // unused prototype field. The finisher calls createProperty().
            return {
                kind: 'field',
                key: Symbol(),
                placement: 'own',
                descriptor: {},
                // When @babel/plugin-proposal-decorators implements initializers,
                // do this instead of the initializer below. See:
                // https://github.com/babel/babel/issues/9260 extras: [
                //   {
                //     kind: 'initializer',
                //     placement: 'own',
                //     initializer: descriptor.initializer,
                //   }
                // ],
                initializer() {
                    if (typeof element.initializer === 'function') {
                        this[element.key] = element.initializer.call(this);
                    }
                },
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                }
            };
        }
    };
    const legacyProperty = (options, proto, name) => {
        proto.constructor
            .createProperty(name, options);
    };
    /**
     * A property decorator which creates a LitElement property which reflects a
     * corresponding attribute value. A [[`PropertyDeclaration`]] may optionally be
     * supplied to configure property features.
     *
     * This decorator should only be used for public fields. Private or protected
     * fields should use the [[`internalProperty`]] decorator.
     *
     * @example
     * ```ts
     * class MyElement {
     *   @property({ type: Boolean })
     *   clicked = false;
     * }
     * ```
     * @category Decorator
     * @ExportDecoratedItems
     */
    function property(options) {
        // tslint:disable-next-line:no-any decorator
        return (protoOrDescriptor, name) => (name !== undefined) ?
            legacyProperty(options, protoOrDescriptor, name) :
            standardProperty(options, protoOrDescriptor);
    }

    /**
     @license
     Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
     This code may only be used under the BSD style license found at
     http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
     http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
     found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
     part of the polymer project is also subject to an additional IP rights grant
     found at http://polymer.github.io/PATENTS.txt
     */
    /**
     * Whether the current browser supports `adoptedStyleSheets`.
     */
    const supportsAdoptingStyleSheets = (window.ShadowRoot) &&
        (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) &&
        ('adoptedStyleSheets' in Document.prototype) &&
        ('replace' in CSSStyleSheet.prototype);
    const constructionToken = Symbol();
    class CSSResult {
        constructor(cssText, safeToken) {
            if (safeToken !== constructionToken) {
                throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
            }
            this.cssText = cssText;
        }
        // Note, this is a getter so that it's lazy. In practice, this means
        // stylesheets are not created until the first element instance is made.
        get styleSheet() {
            if (this._styleSheet === undefined) {
                // Note, if `supportsAdoptingStyleSheets` is true then we assume
                // CSSStyleSheet is constructable.
                if (supportsAdoptingStyleSheets) {
                    this._styleSheet = new CSSStyleSheet();
                    this._styleSheet.replaceSync(this.cssText);
                }
                else {
                    this._styleSheet = null;
                }
            }
            return this._styleSheet;
        }
        toString() {
            return this.cssText;
        }
    }
    /**
     * Wrap a value for interpolation in a [[`css`]] tagged template literal.
     *
     * This is unsafe because untrusted CSS text can be used to phone home
     * or exfiltrate data to an attacker controlled site. Take care to only use
     * this with trusted input.
     */
    const unsafeCSS = (value) => {
        return new CSSResult(String(value), constructionToken);
    };
    const textFromCSSResult = (value) => {
        if (value instanceof CSSResult) {
            return value.cssText;
        }
        else if (typeof value === 'number') {
            return value;
        }
        else {
            throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
        }
    };
    /**
     * Template tag which which can be used with LitElement's [[LitElement.styles |
     * `styles`]] property to set element styles. For security reasons, only literal
     * string values may be used. To incorporate non-literal values [[`unsafeCSS`]]
     * may be used inside a template string part.
     */
    const css = (strings, ...values) => {
        const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
        return new CSSResult(cssText, constructionToken);
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // IMPORTANT: do not change the property name or the assignment expression.
    // This line will be used in regexes to search for LitElement usage.
    // TODO(justinfagnani): inject version number at build time
    (window['litElementVersions'] || (window['litElementVersions'] = []))
        .push('2.4.0');
    /**
     * Sentinal value used to avoid calling lit-html's render function when
     * subclasses do not implement `render`
     */
    const renderNotImplemented = {};
    /**
     * Base element class that manages element properties and attributes, and
     * renders a lit-html template.
     *
     * To define a component, subclass `LitElement` and implement a
     * `render` method to provide the component's template. Define properties
     * using the [[`properties`]] property or the [[`property`]] decorator.
     */
    class LitElement extends UpdatingElement {
        /**
         * Return the array of styles to apply to the element.
         * Override this method to integrate into a style management system.
         *
         * @nocollapse
         */
        static getStyles() {
            return this.styles;
        }
        /** @nocollapse */
        static _getUniqueStyles() {
            // Only gather styles once per class
            if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {
                return;
            }
            // Take care not to call `this.getStyles()` multiple times since this
            // generates new CSSResults each time.
            // TODO(sorvell): Since we do not cache CSSResults by input, any
            // shared styles will generate new stylesheet objects, which is wasteful.
            // This should be addressed when a browser ships constructable
            // stylesheets.
            const userStyles = this.getStyles();
            if (Array.isArray(userStyles)) {
                // De-duplicate styles preserving the _last_ instance in the set.
                // This is a performance optimization to avoid duplicated styles that can
                // occur especially when composing via subclassing.
                // The last item is kept to try to preserve the cascade order with the
                // assumption that it's most important that last added styles override
                // previous styles.
                const addStyles = (styles, set) => styles.reduceRight((set, s) =>
                    // Note: On IE set.add() does not return the set
                    Array.isArray(s) ? addStyles(s, set) : (set.add(s), set), set);
                // Array.from does not work on Set in IE, otherwise return
                // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()
                const set = addStyles(userStyles, new Set());
                const styles = [];
                set.forEach((v) => styles.unshift(v));
                this._styles = styles;
            }
            else {
                this._styles = userStyles === undefined ? [] : [userStyles];
            }
            // Ensure that there are no invalid CSSStyleSheet instances here. They are
            // invalid in two conditions.
            // (1) the sheet is non-constructible (`sheet` of a HTMLStyleElement), but
            //     this is impossible to check except via .replaceSync or use
            // (2) the ShadyCSS polyfill is enabled (:. supportsAdoptingStyleSheets is
            //     false)
            this._styles = this._styles.map((s) => {
                if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
                    // Flatten the cssText from the passed constructible stylesheet (or
                    // undetectable non-constructible stylesheet). The user might have
                    // expected to update their stylesheets over time, but the alternative
                    // is a crash.
                    const cssText = Array.prototype.slice.call(s.cssRules)
                        .reduce((css, rule) => css + rule.cssText, '');
                    return unsafeCSS(cssText);
                }
                return s;
            });
        }
        /**
         * Performs element initialization. By default this calls
         * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and
         * captures any pre-set values for registered properties.
         */
        initialize() {
            super.initialize();
            this.constructor._getUniqueStyles();
            this.renderRoot = this.createRenderRoot();
            // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
            // element's getRootNode(). While this could be done, we're choosing not to
            // support this now since it would require different logic around de-duping.
            if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
                this.adoptStyles();
            }
        }
        /**
         * Returns the node into which the element should render and by default
         * creates and returns an open shadowRoot. Implement to customize where the
         * element's DOM is rendered. For example, to render into the element's
         * childNodes, return `this`.
         * @returns {Element|DocumentFragment} Returns a node into which to render.
         */
        createRenderRoot() {
            return this.attachShadow({ mode: 'open' });
        }
        /**
         * Applies styling to the element shadowRoot using the [[`styles`]]
         * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
         * available and will fallback otherwise. When Shadow DOM is polyfilled,
         * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
         * is available but `adoptedStyleSheets` is not, styles are appended to the
         * end of the `shadowRoot` to [mimic spec
         * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
         */
        adoptStyles() {
            const styles = this.constructor._styles;
            if (styles.length === 0) {
                return;
            }
            // There are three separate cases here based on Shadow DOM support.
            // (1) shadowRoot polyfilled: use ShadyCSS
            // (2) shadowRoot.adoptedStyleSheets available: use it
            // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
            // rendering
            if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
                window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);
            }
            else if (supportsAdoptingStyleSheets) {
                this.renderRoot.adoptedStyleSheets =
                    styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
            }
            else {
                // This must be done after rendering so the actual style insertion is done
                // in `update`.
                this._needsShimAdoptedStyleSheets = true;
            }
        }
        connectedCallback() {
            super.connectedCallback();
            // Note, first update/render handles styleElement so we only call this if
            // connected after first update.
            if (this.hasUpdated && window.ShadyCSS !== undefined) {
                window.ShadyCSS.styleElement(this);
            }
        }
        /**
         * Updates the element. This method reflects property values to attributes
         * and calls `render` to render DOM via lit-html. Setting properties inside
         * this method will *not* trigger another update.
         * @param _changedProperties Map of changed properties with old values
         */
        update(changedProperties) {
            // Setting properties in `render` should not trigger an update. Since
            // updates are allowed after super.update, it's important to call `render`
            // before that.
            const templateResult = this.render();
            super.update(changedProperties);
            // If render is not implemented by the component, don't call lit-html render
            if (templateResult !== renderNotImplemented) {
                this.constructor
                    .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
            }
            // When native Shadow DOM is used but adoptedStyles are not supported,
            // insert styling after rendering to ensure adoptedStyles have highest
            // priority.
            if (this._needsShimAdoptedStyleSheets) {
                this._needsShimAdoptedStyleSheets = false;
                this.constructor._styles.forEach((s) => {
                    const style = document.createElement('style');
                    style.textContent = s.cssText;
                    this.renderRoot.appendChild(style);
                });
            }
        }
        /**
         * Invoked on each update to perform rendering tasks. This method may return
         * any value renderable by lit-html's `NodePart` - typically a
         * `TemplateResult`. Setting properties inside this method will *not* trigger
         * the element to update.
         */
        render() {
            return renderNotImplemented;
        }
    }
    /**
     * Ensure this class is marked as `finalized` as an optimization ensuring
     * it will not needlessly try to `finalize`.
     *
     * Note this property name is a string to prevent breaking Closure JS Compiler
     * optimizations. See updating-element.ts for more information.
     */
    LitElement['finalized'] = true;
    /**
     * Reference to the underlying library method used to render the element's
     * DOM. By default, points to the `render` method from lit-html's shady-render
     * module.
     *
     * **Most users will never need to touch this property.**
     *
     * This  property should not be confused with the `render` instance method,
     * which should be overridden to define a template for the element.
     *
     * Advanced users creating a new base class based on LitElement can override
     * this property to point to a custom render method with a signature that
     * matches [shady-render's `render`
     * method](https://lit-html.polymer-project.org/api/modules/shady_render.html#render).
     *
     * @nocollapse
     */
    LitElement.render = render$1;

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Stores the StyleInfo object applied to a given AttributePart.
     * Used to unset existing values when a new StyleInfo object is applied.
     */
    const previousStylePropertyCache = new WeakMap();
    /**
     * A directive that applies CSS properties to an element.
     *
     * `styleMap` can only be used in the `style` attribute and must be the only
     * expression in the attribute. It takes the property names in the `styleInfo`
     * object and adds the property values as CSS properties. Property names with
     * dashes (`-`) are assumed to be valid CSS property names and set on the
     * element's style object using `setProperty()`. Names without dashes are
     * assumed to be camelCased JavaScript property names and set on the element's
     * style object using property assignment, allowing the style object to
     * translate JavaScript-style names to CSS property names.
     *
     * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':
     * '0'})` sets the `background-color`, `border-top` and `--size` properties.
     *
     * @param styleInfo {StyleInfo}
     */
    const styleMap = directive((styleInfo) => (part) => {
        if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||
            part.committer.name !== 'style' || part.committer.parts.length > 1) {
            throw new Error('The `styleMap` directive must be used in the style attribute ' +
                'and must be the only part in the attribute.');
        }
        const { committer } = part;
        const { style } = committer.element;
        let previousStyleProperties = previousStylePropertyCache.get(part);
        if (previousStyleProperties === undefined) {
            // Write static styles once
            style.cssText = committer.strings.join(' ');
            previousStylePropertyCache.set(part, previousStyleProperties = new Set());
        }
        // Remove old properties that no longer exist in styleInfo
        // We use forEach() instead of for-of so that re don't require down-level
        // iteration.
        previousStyleProperties.forEach((name) => {
            if (!(name in styleInfo)) {
                previousStyleProperties.delete(name);
                if (name.indexOf('-') === -1) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    style[name] = null;
                }
                else {
                    style.removeProperty(name);
                }
            }
        });
        // Add or update properties
        for (const name in styleInfo) {
            previousStyleProperties.add(name);
            if (name.indexOf('-') === -1) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                style[name] = styleInfo[name];
            }
            else {
                style.setProperty(name, styleInfo[name]);
            }
        }
    });

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const templateCaches$1 = new WeakMap();
    /**
     * Enables fast switching between multiple templates by caching the DOM nodes
     * and TemplateInstances produced by the templates.
     *
     * Example:
     *
     * ```
     * let checked = false;
     *
     * html`
     *   ${cache(checked ? html`input is checked` : html`input is not checked`)}
     * `
     * ```
     */
    const cache = directive((value) => (part) => {
        if (!(part instanceof NodePart)) {
            throw new Error('cache can only be used in text bindings');
        }
        let templateCache = templateCaches$1.get(part);
        if (templateCache === undefined) {
            templateCache = new WeakMap();
            templateCaches$1.set(part, templateCache);
        }
        const previousValue = part.value;
        // First, can we update the current TemplateInstance, or do we need to move
        // the current nodes into the cache?
        if (previousValue instanceof TemplateInstance) {
            if (value instanceof TemplateResult &&
                previousValue.template === part.options.templateFactory(value)) {
                // Same Template, just trigger an update of the TemplateInstance
                part.setValue(value);
                return;
            }
            else {
                // Not the same Template, move the nodes from the DOM into the cache.
                let cachedTemplate = templateCache.get(previousValue.template);
                if (cachedTemplate === undefined) {
                    cachedTemplate = {
                        instance: previousValue,
                        nodes: document.createDocumentFragment(),
                    };
                    templateCache.set(previousValue.template, cachedTemplate);
                }
                reparentNodes(cachedTemplate.nodes, part.startNode.nextSibling, part.endNode);
            }
        }
        // Next, can we reuse nodes from the cache?
        if (value instanceof TemplateResult) {
            const template = part.options.templateFactory(value);
            const cachedTemplate = templateCache.get(template);
            if (cachedTemplate !== undefined) {
                // Move nodes out of cache
                part.setValue(cachedTemplate.nodes);
                part.commit();
                // Set the Part value to the TemplateInstance so it'll update it.
                part.value = cachedTemplate.instance;
            }
        }
        part.setValue(value);
    });

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isFunction(x) {
        return typeof x === 'function';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var _enable_super_gross_mode_that_will_cause_bad_things = false;
    var config = {
        Promise: undefined,
        set useDeprecatedSynchronousErrorHandling(value) {
            if (value) {
                var error = /*@__PURE__*/ new Error();
                /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
            }
            _enable_super_gross_mode_that_will_cause_bad_things = value;
        },
        get useDeprecatedSynchronousErrorHandling() {
            return _enable_super_gross_mode_that_will_cause_bad_things;
        },
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function hostReportError(err) {
        setTimeout(function () { throw err; }, 0);
    }

    /** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
    var empty = {
        closed: true,
        next: function (value) { },
        error: function (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        },
        complete: function () { }
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isObject(x) {
        return x !== null && typeof x === 'object';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
        function UnsubscriptionErrorImpl(errors) {
            Error.call(this);
            this.message = errors ?
                errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
            return this;
        }
        UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
        return UnsubscriptionErrorImpl;
    })();
    var UnsubscriptionError = UnsubscriptionErrorImpl;

    /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
    var Subscription = /*@__PURE__*/ (function () {
        function Subscription(unsubscribe) {
            this.closed = false;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (unsubscribe) {
                this._ctorUnsubscribe = true;
                this._unsubscribe = unsubscribe;
            }
        }
        Subscription.prototype.unsubscribe = function () {
            var errors;
            if (this.closed) {
                return;
            }
            var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
            this.closed = true;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (_parentOrParents instanceof Subscription) {
                _parentOrParents.remove(this);
            }
            else if (_parentOrParents !== null) {
                for (var index = 0; index < _parentOrParents.length; ++index) {
                    var parent_1 = _parentOrParents[index];
                    parent_1.remove(this);
                }
            }
            if (isFunction(_unsubscribe)) {
                if (_ctorUnsubscribe) {
                    this._unsubscribe = undefined;
                }
                try {
                    _unsubscribe.call(this);
                }
                catch (e) {
                    errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
                }
            }
            if (isArray(_subscriptions)) {
                var index = -1;
                var len = _subscriptions.length;
                while (++index < len) {
                    var sub = _subscriptions[index];
                    if (isObject(sub)) {
                        try {
                            sub.unsubscribe();
                        }
                        catch (e) {
                            errors = errors || [];
                            if (e instanceof UnsubscriptionError) {
                                errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                            }
                            else {
                                errors.push(e);
                            }
                        }
                    }
                }
            }
            if (errors) {
                throw new UnsubscriptionError(errors);
            }
        };
        Subscription.prototype.add = function (teardown) {
            var subscription = teardown;
            if (!teardown) {
                return Subscription.EMPTY;
            }
            switch (typeof teardown) {
                case 'function':
                    subscription = new Subscription(teardown);
                case 'object':
                    if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                        return subscription;
                    }
                    else if (this.closed) {
                        subscription.unsubscribe();
                        return subscription;
                    }
                    else if (!(subscription instanceof Subscription)) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                    break;
                default: {
                    throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
                }
            }
            var _parentOrParents = subscription._parentOrParents;
            if (_parentOrParents === null) {
                subscription._parentOrParents = this;
            }
            else if (_parentOrParents instanceof Subscription) {
                if (_parentOrParents === this) {
                    return subscription;
                }
                subscription._parentOrParents = [_parentOrParents, this];
            }
            else if (_parentOrParents.indexOf(this) === -1) {
                _parentOrParents.push(this);
            }
            else {
                return subscription;
            }
            var subscriptions = this._subscriptions;
            if (subscriptions === null) {
                this._subscriptions = [subscription];
            }
            else {
                subscriptions.push(subscription);
            }
            return subscription;
        };
        Subscription.prototype.remove = function (subscription) {
            var subscriptions = this._subscriptions;
            if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);
                if (subscriptionIndex !== -1) {
                    subscriptions.splice(subscriptionIndex, 1);
                }
            }
        };
        Subscription.EMPTY = (function (empty) {
            empty.closed = true;
            return empty;
        }(new Subscription()));
        return Subscription;
    }());
    function flattenUnsubscriptionErrors(errors) {
        return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var rxSubscriber = /*@__PURE__*/ (function () {
        return typeof Symbol === 'function'
            ? /*@__PURE__*/ Symbol('rxSubscriber')
            : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
    })();

    /** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
    var Subscriber = /*@__PURE__*/ (function (_super) {
        __extends(Subscriber, _super);
        function Subscriber(destinationOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this.syncErrorValue = null;
            _this.syncErrorThrown = false;
            _this.syncErrorThrowable = false;
            _this.isStopped = false;
            switch (arguments.length) {
                case 0:
                    _this.destination = empty;
                    break;
                case 1:
                    if (!destinationOrNext) {
                        _this.destination = empty;
                        break;
                    }
                    if (typeof destinationOrNext === 'object') {
                        if (destinationOrNext instanceof Subscriber) {
                            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                            _this.destination = destinationOrNext;
                            destinationOrNext.add(_this);
                        }
                        else {
                            _this.syncErrorThrowable = true;
                            _this.destination = new SafeSubscriber(_this, destinationOrNext);
                        }
                        break;
                    }
                default:
                    _this.syncErrorThrowable = true;
                    _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                    break;
            }
            return _this;
        }
        Subscriber.prototype[rxSubscriber] = function () { return this; };
        Subscriber.create = function (next, error, complete) {
            var subscriber = new Subscriber(next, error, complete);
            subscriber.syncErrorThrowable = false;
            return subscriber;
        };
        Subscriber.prototype.next = function (value) {
            if (!this.isStopped) {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            this.destination.error(err);
            this.unsubscribe();
        };
        Subscriber.prototype._complete = function () {
            this.destination.complete();
            this.unsubscribe();
        };
        Subscriber.prototype._unsubscribeAndRecycle = function () {
            var _parentOrParents = this._parentOrParents;
            this._parentOrParents = null;
            this.unsubscribe();
            this.closed = false;
            this.isStopped = false;
            this._parentOrParents = _parentOrParents;
            return this;
        };
        return Subscriber;
    }(Subscription));
    var SafeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this._parentSubscriber = _parentSubscriber;
            var next;
            var context = _this;
            if (isFunction(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;
                if (observerOrNext !== empty) {
                    context = Object.create(observerOrNext);
                    if (isFunction(context.unsubscribe)) {
                        _this.add(context.unsubscribe.bind(context));
                    }
                    context.unsubscribe = _this.unsubscribe.bind(_this);
                }
            }
            _this._context = context;
            _this._next = next;
            _this._error = error;
            _this._complete = complete;
            return _this;
        }
        SafeSubscriber.prototype.next = function (value) {
            if (!this.isStopped && this._next) {
                var _parentSubscriber = this._parentSubscriber;
                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._next, value);
                }
                else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
                if (this._error) {
                    if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(this._error, err);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, this._error, err);
                        this.unsubscribe();
                    }
                }
                else if (!_parentSubscriber.syncErrorThrowable) {
                    this.unsubscribe();
                    if (useDeprecatedSynchronousErrorHandling) {
                        throw err;
                    }
                    hostReportError(err);
                }
                else {
                    if (useDeprecatedSynchronousErrorHandling) {
                        _parentSubscriber.syncErrorValue = err;
                        _parentSubscriber.syncErrorThrown = true;
                    }
                    else {
                        hostReportError(err);
                    }
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.complete = function () {
            var _this = this;
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                if (this._complete) {
                    var wrappedComplete = function () { return _this._complete.call(_this._context); };
                    if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(wrappedComplete);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                        this.unsubscribe();
                    }
                }
                else {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                this.unsubscribe();
                if (config.useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                else {
                    hostReportError(err);
                }
            }
        };
        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
            if (!config.useDeprecatedSynchronousErrorHandling) {
                throw new Error('bad call');
            }
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                if (config.useDeprecatedSynchronousErrorHandling) {
                    parent.syncErrorValue = err;
                    parent.syncErrorThrown = true;
                    return true;
                }
                else {
                    hostReportError(err);
                    return true;
                }
            }
            return false;
        };
        SafeSubscriber.prototype._unsubscribe = function () {
            var _parentSubscriber = this._parentSubscriber;
            this._context = null;
            this._parentSubscriber = null;
            _parentSubscriber.unsubscribe();
        };
        return SafeSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
    function canReportError(observer) {
        while (observer) {
            var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
            if (closed_1 || isStopped) {
                return false;
            }
            else if (destination && destination instanceof Subscriber) {
                observer = destination;
            }
            else {
                observer = null;
            }
        }
        return true;
    }

    /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
    function toSubscriber(nextOrObserver, error, complete) {
        if (nextOrObserver) {
            if (nextOrObserver instanceof Subscriber) {
                return nextOrObserver;
            }
            if (nextOrObserver[rxSubscriber]) {
                return nextOrObserver[rxSubscriber]();
            }
        }
        if (!nextOrObserver && !error && !complete) {
            return new Subscriber(empty);
        }
        return new Subscriber(nextOrObserver, error, complete);
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function identity(x) {
        return x;
    }

    /** PURE_IMPORTS_START _identity PURE_IMPORTS_END */
    function pipeFromArray(fns) {
        if (fns.length === 0) {
            return identity;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
    var Observable = /*@__PURE__*/ (function () {
        function Observable(subscribe) {
            this._isScalar = false;
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var operator = this.operator;
            var sink = toSubscriber(observerOrNext, error, complete);
            if (operator) {
                sink.add(operator.call(sink, this.source));
            }
            else {
                sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                    this._subscribe(sink) :
                    this._trySubscribe(sink));
            }
            if (config.useDeprecatedSynchronousErrorHandling) {
                if (sink.syncErrorThrowable) {
                    sink.syncErrorThrowable = false;
                    if (sink.syncErrorThrown) {
                        throw sink.syncErrorValue;
                    }
                }
            }
            return sink;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                if (config.useDeprecatedSynchronousErrorHandling) {
                    sink.syncErrorThrown = true;
                    sink.syncErrorValue = err;
                }
                if (canReportError(sink)) {
                    sink.error(err);
                }
                else {
                    console.warn(err);
                }
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscription;
                subscription = _this.subscribe(function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        if (subscription) {
                            subscription.unsubscribe();
                        }
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var source = this.source;
            return source && source.subscribe(subscriber);
        };
        Observable.prototype[observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            if (operations.length === 0) {
                return this;
            }
            return pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    function getPromiseCtor(promiseCtor) {
        if (!promiseCtor) {
            promiseCtor =  Promise;
        }
        if (!promiseCtor) {
            throw new Error('no Promise impl found');
        }
        return promiseCtor;
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
        function ObjectUnsubscribedErrorImpl() {
            Error.call(this);
            this.message = 'object unsubscribed';
            this.name = 'ObjectUnsubscribedError';
            return this;
        }
        ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
        return ObjectUnsubscribedErrorImpl;
    })();
    var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

    /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
    var SubjectSubscription = /*@__PURE__*/ (function (_super) {
        __extends(SubjectSubscription, _super);
        function SubjectSubscription(subject, subscriber) {
            var _this = _super.call(this) || this;
            _this.subject = subject;
            _this.subscriber = subscriber;
            _this.closed = false;
            return _this;
        }
        SubjectSubscription.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.closed = true;
            var subject = this.subject;
            var observers = subject.observers;
            this.subject = null;
            if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
                return;
            }
            var subscriberIndex = observers.indexOf(this.subscriber);
            if (subscriberIndex !== -1) {
                observers.splice(subscriberIndex, 1);
            }
        };
        return SubjectSubscription;
    }(Subscription));

    /** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
    var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SubjectSubscriber, _super);
        function SubjectSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            return _this;
        }
        return SubjectSubscriber;
    }(Subscriber));
    var Subject = /*@__PURE__*/ (function (_super) {
        __extends(Subject, _super);
        function Subject() {
            var _this = _super.call(this) || this;
            _this.observers = [];
            _this.closed = false;
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
        }
        Subject.prototype[rxSubscriber] = function () {
            return new SubjectSubscriber(this);
        };
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype.next = function (value) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            if (!this.isStopped) {
                var observers = this.observers;
                var len = observers.length;
                var copy = observers.slice();
                for (var i = 0; i < len; i++) {
                    copy[i].next(value);
                }
            }
        };
        Subject.prototype.error = function (err) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            this.hasError = true;
            this.thrownError = err;
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].error(err);
            }
            this.observers.length = 0;
        };
        Subject.prototype.complete = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].complete();
            }
            this.observers.length = 0;
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = true;
            this.closed = true;
            this.observers = null;
        };
        Subject.prototype._trySubscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            else {
                return _super.prototype._trySubscribe.call(this, subscriber);
            }
        };
        Subject.prototype._subscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            else if (this.hasError) {
                subscriber.error(this.thrownError);
                return Subscription.EMPTY;
            }
            else if (this.isStopped) {
                subscriber.complete();
                return Subscription.EMPTY;
            }
            else {
                this.observers.push(subscriber);
                return new SubjectSubscription(this, subscriber);
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable));
    var AnonymousSubject = /*@__PURE__*/ (function (_super) {
        __extends(AnonymousSubject, _super);
        function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
        }
        AnonymousSubject.prototype.next = function (value) {
            var destination = this.destination;
            if (destination && destination.next) {
                destination.next(value);
            }
        };
        AnonymousSubject.prototype.error = function (err) {
            var destination = this.destination;
            if (destination && destination.error) {
                this.destination.error(err);
            }
        };
        AnonymousSubject.prototype.complete = function () {
            var destination = this.destination;
            if (destination && destination.complete) {
                this.destination.complete();
            }
        };
        AnonymousSubject.prototype._subscribe = function (subscriber) {
            var source = this.source;
            if (source) {
                return this.source.subscribe(subscriber);
            }
            else {
                return Subscription.EMPTY;
            }
        };
        return AnonymousSubject;
    }(Subject));

    /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
    function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
        return function (source) {
            return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
        };
    }
    var GroupByOperator = /*@__PURE__*/ (function () {
        function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
            this.keySelector = keySelector;
            this.elementSelector = elementSelector;
            this.durationSelector = durationSelector;
            this.subjectSelector = subjectSelector;
        }
        GroupByOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
        };
        return GroupByOperator;
    }());
    var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
        __extends(GroupBySubscriber, _super);
        function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
            var _this = _super.call(this, destination) || this;
            _this.keySelector = keySelector;
            _this.elementSelector = elementSelector;
            _this.durationSelector = durationSelector;
            _this.subjectSelector = subjectSelector;
            _this.groups = null;
            _this.attemptedToUnsubscribe = false;
            _this.count = 0;
            return _this;
        }
        GroupBySubscriber.prototype._next = function (value) {
            var key;
            try {
                key = this.keySelector(value);
            }
            catch (err) {
                this.error(err);
                return;
            }
            this._group(value, key);
        };
        GroupBySubscriber.prototype._group = function (value, key) {
            var groups = this.groups;
            if (!groups) {
                groups = this.groups = new Map();
            }
            var group = groups.get(key);
            var element;
            if (this.elementSelector) {
                try {
                    element = this.elementSelector(value);
                }
                catch (err) {
                    this.error(err);
                }
            }
            else {
                element = value;
            }
            if (!group) {
                group = (this.subjectSelector ? this.subjectSelector() : new Subject());
                groups.set(key, group);
                var groupedObservable = new GroupedObservable(key, group, this);
                this.destination.next(groupedObservable);
                if (this.durationSelector) {
                    var duration = void 0;
                    try {
                        duration = this.durationSelector(new GroupedObservable(key, group));
                    }
                    catch (err) {
                        this.error(err);
                        return;
                    }
                    this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
                }
            }
            if (!group.closed) {
                group.next(element);
            }
        };
        GroupBySubscriber.prototype._error = function (err) {
            var groups = this.groups;
            if (groups) {
                groups.forEach(function (group, key) {
                    group.error(err);
                });
                groups.clear();
            }
            this.destination.error(err);
        };
        GroupBySubscriber.prototype._complete = function () {
            var groups = this.groups;
            if (groups) {
                groups.forEach(function (group, key) {
                    group.complete();
                });
                groups.clear();
            }
            this.destination.complete();
        };
        GroupBySubscriber.prototype.removeGroup = function (key) {
            this.groups.delete(key);
        };
        GroupBySubscriber.prototype.unsubscribe = function () {
            if (!this.closed) {
                this.attemptedToUnsubscribe = true;
                if (this.count === 0) {
                    _super.prototype.unsubscribe.call(this);
                }
            }
        };
        return GroupBySubscriber;
    }(Subscriber));
    var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(GroupDurationSubscriber, _super);
        function GroupDurationSubscriber(key, group, parent) {
            var _this = _super.call(this, group) || this;
            _this.key = key;
            _this.group = group;
            _this.parent = parent;
            return _this;
        }
        GroupDurationSubscriber.prototype._next = function (value) {
            this.complete();
        };
        GroupDurationSubscriber.prototype._unsubscribe = function () {
            var _a = this, parent = _a.parent, key = _a.key;
            this.key = this.parent = null;
            if (parent) {
                parent.removeGroup(key);
            }
        };
        return GroupDurationSubscriber;
    }(Subscriber));
    var GroupedObservable = /*@__PURE__*/ (function (_super) {
        __extends(GroupedObservable, _super);
        function GroupedObservable(key, groupSubject, refCountSubscription) {
            var _this = _super.call(this) || this;
            _this.key = key;
            _this.groupSubject = groupSubject;
            _this.refCountSubscription = refCountSubscription;
            return _this;
        }
        GroupedObservable.prototype._subscribe = function (subscriber) {
            var subscription = new Subscription();
            var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
            if (refCountSubscription && !refCountSubscription.closed) {
                subscription.add(new InnerRefCountSubscription(refCountSubscription));
            }
            subscription.add(groupSubject.subscribe(subscriber));
            return subscription;
        };
        return GroupedObservable;
    }(Observable));
    var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
        __extends(InnerRefCountSubscription, _super);
        function InnerRefCountSubscription(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            parent.count++;
            return _this;
        }
        InnerRefCountSubscription.prototype.unsubscribe = function () {
            var parent = this.parent;
            if (!parent.closed && !this.closed) {
                _super.prototype.unsubscribe.call(this);
                parent.count -= 1;
                if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                    parent.unsubscribe();
                }
            }
        };
        return InnerRefCountSubscription;
    }(Subscription));

    /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
    var Action = /*@__PURE__*/ (function (_super) {
        __extends(Action, _super);
        function Action(scheduler, work) {
            return _super.call(this) || this;
        }
        Action.prototype.schedule = function (state, delay) {
            return this;
        };
        return Action;
    }(Subscription));

    /** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
    var AsyncAction = /*@__PURE__*/ (function (_super) {
        __extends(AsyncAction, _super);
        function AsyncAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.pending = false;
            return _this;
        }
        AsyncAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (this.closed) {
                return this;
            }
            this.state = state;
            var id = this.id;
            var scheduler = this.scheduler;
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            this.pending = true;
            this.delay = delay;
            this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
            return this;
        };
        AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            return setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (delay !== null && this.delay === delay && this.pending === false) {
                return id;
            }
            clearInterval(id);
            return undefined;
        };
        AsyncAction.prototype.execute = function (state, delay) {
            if (this.closed) {
                return new Error('executing a cancelled action');
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
                return error;
            }
            else if (this.pending === false && this.id != null) {
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
        };
        AsyncAction.prototype._execute = function (state, delay) {
            var errored = false;
            var errorValue = undefined;
            try {
                this.work(state);
            }
            catch (e) {
                errored = true;
                errorValue = !!e && e || new Error(e);
            }
            if (errored) {
                this.unsubscribe();
                return errorValue;
            }
        };
        AsyncAction.prototype._unsubscribe = function () {
            var id = this.id;
            var scheduler = this.scheduler;
            var actions = scheduler.actions;
            var index = actions.indexOf(this);
            this.work = null;
            this.state = null;
            this.pending = false;
            this.scheduler = null;
            if (index !== -1) {
                actions.splice(index, 1);
            }
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
        };
        return AsyncAction;
    }(Action));

    var Scheduler = /*@__PURE__*/ (function () {
        function Scheduler(SchedulerAction, now) {
            if (now === void 0) {
                now = Scheduler.now;
            }
            this.SchedulerAction = SchedulerAction;
            this.now = now;
        }
        Scheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) {
                delay = 0;
            }
            return new this.SchedulerAction(this, work).schedule(state, delay);
        };
        Scheduler.now = function () { return Date.now(); };
        return Scheduler;
    }());

    /** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
    var AsyncScheduler = /*@__PURE__*/ (function (_super) {
        __extends(AsyncScheduler, _super);
        function AsyncScheduler(SchedulerAction, now) {
            if (now === void 0) {
                now = Scheduler.now;
            }
            var _this = _super.call(this, SchedulerAction, function () {
                if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                    return AsyncScheduler.delegate.now();
                }
                else {
                    return now();
                }
            }) || this;
            _this.actions = [];
            _this.active = false;
            _this.scheduled = undefined;
            return _this;
        }
        AsyncScheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) {
                delay = 0;
            }
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
                return AsyncScheduler.delegate.schedule(work, delay, state);
            }
            else {
                return _super.prototype.schedule.call(this, work, delay, state);
            }
        };
        AsyncScheduler.prototype.flush = function (action) {
            var actions = this.actions;
            if (this.active) {
                actions.push(action);
                return;
            }
            var error;
            this.active = true;
            do {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            } while (action = actions.shift());
            this.active = false;
            if (error) {
                while (action = actions.shift()) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsyncScheduler;
    }(Scheduler));

    /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
    var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
    function empty$1(scheduler) {
        return scheduler ? emptyScheduled(scheduler) : EMPTY;
    }
    function emptyScheduled(scheduler) {
        return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isScheduler(value) {
        return value && typeof value.schedule === 'function';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var subscribeToArray = function (array) {
        return function (subscriber) {
            for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        };
    };

    /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
    function scheduleArray(input, scheduler) {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var i = 0;
            sub.add(scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                    return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    sub.add(this.schedule());
                }
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
    function fromArray(input, scheduler) {
        if (!scheduler) {
            return new Observable(subscribeToArray(input));
        }
        else {
            return scheduleArray(input, scheduler);
        }
    }

    /** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
    function of() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = args[args.length - 1];
        if (isScheduler(scheduler)) {
            args.pop();
            return scheduleArray(args, scheduler);
        }
        else {
            return fromArray(args);
        }
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var nextHandle = 1;
    var RESOLVED = /*@__PURE__*/ (function () { return /*@__PURE__*/ Promise.resolve(); })();
    var activeHandles = {};
    function findAndClearHandle(handle) {
        if (handle in activeHandles) {
            delete activeHandles[handle];
            return true;
        }
        return false;
    }
    var Immediate = {
        setImmediate: function (cb) {
            var handle = nextHandle++;
            activeHandles[handle] = true;
            RESOLVED.then(function () { return findAndClearHandle(handle) && cb(); });
            return handle;
        },
        clearImmediate: function (handle) {
            findAndClearHandle(handle);
        },
    };

    /** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
    var AsapAction = /*@__PURE__*/ (function (_super) {
        __extends(AsapAction, _super);
        function AsapAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
        };
        AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            if (scheduler.actions.length === 0) {
                Immediate.clearImmediate(id);
                scheduler.scheduled = undefined;
            }
            return undefined;
        };
        return AsapAction;
    }(AsyncAction));

    /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
    var AsapScheduler = /*@__PURE__*/ (function (_super) {
        __extends(AsapScheduler, _super);
        function AsapScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AsapScheduler.prototype.flush = function (action) {
            this.active = true;
            this.scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            var count = actions.length;
            action = action || actions.shift();
            do {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            } while (++index < count && (action = actions.shift()));
            this.active = false;
            if (error) {
                while (++index < count && (action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsapScheduler;
    }(AsyncScheduler));

    /** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
    var asapScheduler = /*@__PURE__*/ new AsapScheduler(AsapAction);

    /** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
    var asyncScheduler = /*@__PURE__*/ new AsyncScheduler(AsyncAction);
    var async = asyncScheduler;

    /** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
    var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
        __extends(AnimationFrameAction, _super);
        function AnimationFrameAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
        };
        AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            if (scheduler.actions.length === 0) {
                cancelAnimationFrame(id);
                scheduler.scheduled = undefined;
            }
            return undefined;
        };
        return AnimationFrameAction;
    }(AsyncAction));

    /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
    var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
        __extends(AnimationFrameScheduler, _super);
        function AnimationFrameScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationFrameScheduler.prototype.flush = function (action) {
            this.active = true;
            this.scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            var count = actions.length;
            action = action || actions.shift();
            do {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            } while (++index < count && (action = actions.shift()));
            this.active = false;
            if (error) {
                while (++index < count && (action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AnimationFrameScheduler;
    }(AsyncScheduler));

    /** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
    var animationFrameScheduler = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    function map(project, thisArg) {
        return function mapOperation(source) {
            if (typeof project !== 'function') {
                throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
            }
            return source.lift(new MapOperator(project, thisArg));
        };
    }
    var MapOperator = /*@__PURE__*/ (function () {
        function MapOperator(project, thisArg) {
            this.project = project;
            this.thisArg = thisArg;
        }
        MapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
        };
        return MapOperator;
    }());
    var MapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MapSubscriber, _super);
        function MapSubscriber(destination, project, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.count = 0;
            _this.thisArg = thisArg || _this;
            return _this;
        }
        MapSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.project.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return MapSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
    var subscribeToPromise = function (promise) {
        return function (subscriber) {
            promise.then(function (value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function (err) { return subscriber.error(err); })
                .then(null, hostReportError);
            return subscriber;
        };
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function getSymbolIterator() {
        if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
        }
        return Symbol.iterator;
    }
    var iterator = /*@__PURE__*/ getSymbolIterator();

    /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
    var subscribeToIterable = function (iterable) {
        return function (subscriber) {
            var iterator$1 = iterable[iterator]();
            do {
                var item = void 0;
                try {
                    item = iterator$1.next();
                }
                catch (err) {
                    subscriber.error(err);
                    return subscriber;
                }
                if (item.done) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(item.value);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
            if (typeof iterator$1.return === 'function') {
                subscriber.add(function () {
                    if (iterator$1.return) {
                        iterator$1.return();
                    }
                });
            }
            return subscriber;
        };
    };

    /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
    var subscribeToObservable = function (obj) {
        return function (subscriber) {
            var obs = obj[observable]();
            if (typeof obs.subscribe !== 'function') {
                throw new TypeError('Provided object does not correctly implement Symbol.observable');
            }
            else {
                return obs.subscribe(subscriber);
            }
        };
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isPromise(value) {
        return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
    }

    /** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
    var subscribeTo = function (result) {
        if (!!result && typeof result[observable] === 'function') {
            return subscribeToObservable(result);
        }
        else if (isArrayLike(result)) {
            return subscribeToArray(result);
        }
        else if (isPromise(result)) {
            return subscribeToPromise(result);
        }
        else if (!!result && typeof result[iterator] === 'function') {
            return subscribeToIterable(result);
        }
        else {
            var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
            var msg = "You provided " + value + " where a stream was expected."
                + ' You can provide an Observable, Promise, Array, or Iterable.';
            throw new TypeError(msg);
        }
    };

    /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
    function scheduleObservable(input, scheduler) {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                var observable$1 = input[observable]();
                sub.add(observable$1.subscribe({
                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                }));
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
    function schedulePromise(input, scheduler) {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                return input.then(function (value) {
                    sub.add(scheduler.schedule(function () {
                        subscriber.next(value);
                        sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                    }));
                }, function (err) {
                    sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
                });
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
    function scheduleIterable(input, scheduler) {
        if (!input) {
            throw new Error('Iterable cannot be null');
        }
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var iterator$1;
            sub.add(function () {
                if (iterator$1 && typeof iterator$1.return === 'function') {
                    iterator$1.return();
                }
            });
            sub.add(scheduler.schedule(function () {
                iterator$1 = input[iterator]();
                sub.add(scheduler.schedule(function () {
                    if (subscriber.closed) {
                        return;
                    }
                    var value;
                    var done;
                    try {
                        var result = iterator$1.next();
                        value = result.value;
                        done = result.done;
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                        this.schedule();
                    }
                }));
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
    function isInteropObservable(input) {
        return input && typeof input[observable] === 'function';
    }

    /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
    function isIterable$1(input) {
        return input && typeof input[iterator] === 'function';
    }

    /** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */
    function scheduled(input, scheduler) {
        if (input != null) {
            if (isInteropObservable(input)) {
                return scheduleObservable(input, scheduler);
            }
            else if (isPromise(input)) {
                return schedulePromise(input, scheduler);
            }
            else if (isArrayLike(input)) {
                return scheduleArray(input, scheduler);
            }
            else if (isIterable$1(input) || typeof input === 'string') {
                return scheduleIterable(input, scheduler);
            }
        }
        throw new TypeError((input !== null && typeof input || input) + ' is not observable');
    }

    /** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
    function from(input, scheduler) {
        if (!scheduler) {
            if (input instanceof Observable) {
                return input;
            }
            return new Observable(subscribeTo(input));
        }
        else {
            return scheduled(input, scheduler);
        }
    }

    /** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */
    var SimpleInnerSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SimpleInnerSubscriber, _super);
        function SimpleInnerSubscriber(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            return _this;
        }
        SimpleInnerSubscriber.prototype._next = function (value) {
            this.parent.notifyNext(value);
        };
        SimpleInnerSubscriber.prototype._error = function (error) {
            this.parent.notifyError(error);
            this.unsubscribe();
        };
        SimpleInnerSubscriber.prototype._complete = function () {
            this.parent.notifyComplete();
            this.unsubscribe();
        };
        return SimpleInnerSubscriber;
    }(Subscriber));
    var SimpleOuterSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SimpleOuterSubscriber, _super);
        function SimpleOuterSubscriber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
            this.destination.next(innerValue);
        };
        SimpleOuterSubscriber.prototype.notifyError = function (err) {
            this.destination.error(err);
        };
        SimpleOuterSubscriber.prototype.notifyComplete = function () {
            this.destination.complete();
        };
        return SimpleOuterSubscriber;
    }(Subscriber));
    function innerSubscribe(result, innerSubscriber) {
        if (innerSubscriber.closed) {
            return undefined;
        }
        if (result instanceof Observable) {
            return result.subscribe(innerSubscriber);
        }
        return subscribeTo(result)(innerSubscriber);
    }

    /** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */
    function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        if (typeof resultSelector === 'function') {
            return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
        }
        else if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
    }
    var MergeMapOperator = /*@__PURE__*/ (function () {
        function MergeMapOperator(project, concurrent) {
            if (concurrent === void 0) {
                concurrent = Number.POSITIVE_INFINITY;
            }
            this.project = project;
            this.concurrent = concurrent;
        }
        MergeMapOperator.prototype.call = function (observer, source) {
            return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
        };
        return MergeMapOperator;
    }());
    var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MergeMapSubscriber, _super);
        function MergeMapSubscriber(destination, project, concurrent) {
            if (concurrent === void 0) {
                concurrent = Number.POSITIVE_INFINITY;
            }
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.concurrent = concurrent;
            _this.hasCompleted = false;
            _this.buffer = [];
            _this.active = 0;
            _this.index = 0;
            return _this;
        }
        MergeMapSubscriber.prototype._next = function (value) {
            if (this.active < this.concurrent) {
                this._tryNext(value);
            }
            else {
                this.buffer.push(value);
            }
        };
        MergeMapSubscriber.prototype._tryNext = function (value) {
            var result;
            var index = this.index++;
            try {
                result = this.project(value, index);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.active++;
            this._innerSub(result);
        };
        MergeMapSubscriber.prototype._innerSub = function (ish) {
            var innerSubscriber = new SimpleInnerSubscriber(this);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = innerSubscribe(ish, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
            }
        };
        MergeMapSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
                this.destination.complete();
            }
            this.unsubscribe();
        };
        MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
            this.destination.next(innerValue);
        };
        MergeMapSubscriber.prototype.notifyComplete = function () {
            var buffer = this.buffer;
            this.active--;
            if (buffer.length > 0) {
                this._next(buffer.shift());
            }
            else if (this.active === 0 && this.hasCompleted) {
                this.destination.complete();
            }
        };
        return MergeMapSubscriber;
    }(SimpleOuterSubscriber));

    /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
    function mergeAll(concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        return mergeMap(identity, concurrent);
    }

    /** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
    function fromEvent(target, eventName, options, resultSelector) {
        if (isFunction(options)) {
            resultSelector = options;
            options = undefined;
        }
        if (resultSelector) {
            return fromEvent(target, eventName, options).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
        }
        return new Observable(function (subscriber) {
            function handler(e) {
                if (arguments.length > 1) {
                    subscriber.next(Array.prototype.slice.call(arguments));
                }
                else {
                    subscriber.next(e);
                }
            }
            setupSubscription(target, eventName, handler, subscriber, options);
        });
    }
    function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
        }
        else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () { return source_2.off(eventName, handler); };
        }
        else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
        }
        else if (sourceObj && sourceObj.length) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        }
        else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(unsubscribe);
    }
    function isNodeStyleEventEmitter(sourceObj) {
        return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
    }
    function isJQueryStyleEventEmitter(sourceObj) {
        return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
    }
    function isEventTarget(sourceObj) {
        return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
    }

    /** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
    function isNumeric(val) {
        return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
    }

    /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
    function merge() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
        }
        var concurrent = Number.POSITIVE_INFINITY;
        var scheduler = null;
        var last = observables[observables.length - 1];
        if (isScheduler(last)) {
            scheduler = observables.pop();
            if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
                concurrent = observables.pop();
            }
        }
        else if (typeof last === 'number') {
            concurrent = observables.pop();
        }
        if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
            return observables[0];
        }
        return mergeAll(concurrent)(fromArray(observables, scheduler));
    }

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    function filter(predicate, thisArg) {
        return function filterOperatorFunction(source) {
            return source.lift(new FilterOperator(predicate, thisArg));
        };
    }
    var FilterOperator = /*@__PURE__*/ (function () {
        function FilterOperator(predicate, thisArg) {
            this.predicate = predicate;
            this.thisArg = thisArg;
        }
        FilterOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
        };
        return FilterOperator;
    }());
    var FilterSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(FilterSubscriber, _super);
        function FilterSubscriber(destination, predicate, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.thisArg = thisArg;
            _this.count = 0;
            return _this;
        }
        FilterSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.predicate.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (result) {
                this.destination.next(value);
            }
        };
        return FilterSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
    function timer(dueTime, periodOrScheduler, scheduler) {
        if (dueTime === void 0) {
            dueTime = 0;
        }
        var period = -1;
        if (isNumeric(periodOrScheduler)) {
            period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
        }
        else if (isScheduler(periodOrScheduler)) {
            scheduler = periodOrScheduler;
        }
        if (!isScheduler(scheduler)) {
            scheduler = async;
        }
        return new Observable(function (subscriber) {
            var due = isNumeric(dueTime)
                ? dueTime
                : (+dueTime - scheduler.now());
            return scheduler.schedule(dispatch, due, {
                index: 0, period: period, subscriber: subscriber
            });
        });
    }
    function dispatch(state) {
        var index = state.index, period = state.period, subscriber = state.subscriber;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        this.schedule(state, period);
    }

    /** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
    function buffer(closingNotifier) {
        return function bufferOperatorFunction(source) {
            return source.lift(new BufferOperator(closingNotifier));
        };
    }
    var BufferOperator = /*@__PURE__*/ (function () {
        function BufferOperator(closingNotifier) {
            this.closingNotifier = closingNotifier;
        }
        BufferOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
        };
        return BufferOperator;
    }());
    var BufferSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(BufferSubscriber, _super);
        function BufferSubscriber(destination, closingNotifier) {
            var _this = _super.call(this, destination) || this;
            _this.buffer = [];
            _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
            return _this;
        }
        BufferSubscriber.prototype._next = function (value) {
            this.buffer.push(value);
        };
        BufferSubscriber.prototype.notifyNext = function () {
            var buffer = this.buffer;
            this.buffer = [];
            this.destination.next(buffer);
        };
        return BufferSubscriber;
    }(SimpleOuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
    function debounceTime(dueTime, scheduler) {
        if (scheduler === void 0) {
            scheduler = async;
        }
        return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
    }
    var DebounceTimeOperator = /*@__PURE__*/ (function () {
        function DebounceTimeOperator(dueTime, scheduler) {
            this.dueTime = dueTime;
            this.scheduler = scheduler;
        }
        DebounceTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
        };
        return DebounceTimeOperator;
    }());
    var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(DebounceTimeSubscriber, _super);
        function DebounceTimeSubscriber(destination, dueTime, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.dueTime = dueTime;
            _this.scheduler = scheduler;
            _this.debouncedSubscription = null;
            _this.lastValue = null;
            _this.hasValue = false;
            return _this;
        }
        DebounceTimeSubscriber.prototype._next = function (value) {
            this.clearDebounce();
            this.lastValue = value;
            this.hasValue = true;
            this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
        };
        DebounceTimeSubscriber.prototype._complete = function () {
            this.debouncedNext();
            this.destination.complete();
        };
        DebounceTimeSubscriber.prototype.debouncedNext = function () {
            this.clearDebounce();
            if (this.hasValue) {
                var lastValue = this.lastValue;
                this.lastValue = null;
                this.hasValue = false;
                this.destination.next(lastValue);
            }
        };
        DebounceTimeSubscriber.prototype.clearDebounce = function () {
            var debouncedSubscription = this.debouncedSubscription;
            if (debouncedSubscription !== null) {
                this.remove(debouncedSubscription);
                debouncedSubscription.unsubscribe();
                this.debouncedSubscription = null;
            }
        };
        return DebounceTimeSubscriber;
    }(Subscriber));
    function dispatchNext(subscriber) {
        subscriber.debouncedNext();
    }

    /** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */
    function repeat(count) {
        if (count === void 0) {
            count = -1;
        }
        return function (source) {
            if (count === 0) {
                return empty$1();
            }
            else if (count < 0) {
                return source.lift(new RepeatOperator(-1, source));
            }
            else {
                return source.lift(new RepeatOperator(count - 1, source));
            }
        };
    }
    var RepeatOperator = /*@__PURE__*/ (function () {
        function RepeatOperator(count, source) {
            this.count = count;
            this.source = source;
        }
        RepeatOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
        };
        return RepeatOperator;
    }());
    var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(RepeatSubscriber, _super);
        function RepeatSubscriber(destination, count, source) {
            var _this = _super.call(this, destination) || this;
            _this.count = count;
            _this.source = source;
            return _this;
        }
        RepeatSubscriber.prototype.complete = function () {
            if (!this.isStopped) {
                var _a = this, source = _a.source, count = _a.count;
                if (count === 0) {
                    return _super.prototype.complete.call(this);
                }
                else if (count > -1) {
                    this.count = count - 1;
                }
                source.subscribe(this._unsubscribeAndRecycle());
            }
        };
        return RepeatSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
    function takeUntil(notifier) {
        return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
    }
    var TakeUntilOperator = /*@__PURE__*/ (function () {
        function TakeUntilOperator(notifier) {
            this.notifier = notifier;
        }
        TakeUntilOperator.prototype.call = function (subscriber, source) {
            var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
            var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
            if (notifierSubscription && !takeUntilSubscriber.seenValue) {
                takeUntilSubscriber.add(notifierSubscription);
                return source.subscribe(takeUntilSubscriber);
            }
            return takeUntilSubscriber;
        };
        return TakeUntilOperator;
    }());
    var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(TakeUntilSubscriber, _super);
        function TakeUntilSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.seenValue = false;
            return _this;
        }
        TakeUntilSubscriber.prototype.notifyNext = function () {
            this.seenValue = true;
            this.complete();
        };
        TakeUntilSubscriber.prototype.notifyComplete = function () {
        };
        return TakeUntilSubscriber;
    }(SimpleOuterSubscriber));

    /** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
    var defaultThrottleConfig = {
        leading: true,
        trailing: false
    };

    /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
    function throttleTime(duration, scheduler, config) {
        if (scheduler === void 0) {
            scheduler = async;
        }
        if (config === void 0) {
            config = defaultThrottleConfig;
        }
        return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
    }
    var ThrottleTimeOperator = /*@__PURE__*/ (function () {
        function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
            this.duration = duration;
            this.scheduler = scheduler;
            this.leading = leading;
            this.trailing = trailing;
        }
        ThrottleTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
        };
        return ThrottleTimeOperator;
    }());
    var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ThrottleTimeSubscriber, _super);
        function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
            var _this = _super.call(this, destination) || this;
            _this.duration = duration;
            _this.scheduler = scheduler;
            _this.leading = leading;
            _this.trailing = trailing;
            _this._hasTrailingValue = false;
            _this._trailingValue = null;
            return _this;
        }
        ThrottleTimeSubscriber.prototype._next = function (value) {
            if (this.throttled) {
                if (this.trailing) {
                    this._trailingValue = value;
                    this._hasTrailingValue = true;
                }
            }
            else {
                this.add(this.throttled = this.scheduler.schedule(dispatchNext$1, this.duration, { subscriber: this }));
                if (this.leading) {
                    this.destination.next(value);
                }
                else if (this.trailing) {
                    this._trailingValue = value;
                    this._hasTrailingValue = true;
                }
            }
        };
        ThrottleTimeSubscriber.prototype._complete = function () {
            if (this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this.destination.complete();
            }
            else {
                this.destination.complete();
            }
        };
        ThrottleTimeSubscriber.prototype.clearThrottle = function () {
            var throttled = this.throttled;
            if (throttled) {
                if (this.trailing && this._hasTrailingValue) {
                    this.destination.next(this._trailingValue);
                    this._trailingValue = null;
                    this._hasTrailingValue = false;
                }
                throttled.unsubscribe();
                this.remove(throttled);
                this.throttled = null;
            }
        };
        return ThrottleTimeSubscriber;
    }(Subscriber));
    function dispatchNext$1(arg) {
        var subscriber = arg.subscriber;
        subscriber.clearThrottle();
    }

    class Logger {
        static debug(...args) {
            console.dir(...args);
        }
        static log(...args) {
            console.log(...args);
        }
        static warn(...args) {
            console.warn(...args);
        }
        static error(...args) {
            console.error(...args);
        }
    }

    const TEXT_PADDING = 2;
    class Helper {
        constructor() {
            this.keydown$ = new Subject();
            this.span = null;
            this.input = null;
            this.subscriptionList = [];
        }
        onInputClear() {
            if (this.input) {
                this.input.value = "";
            }
        }
        setSpan(span) {
            this.span = span;
        }
        getTextWidth(value) {
            if (this.span === null) {
                return value.length * 10 + TEXT_PADDING;
            }
            this.span.innerText = value;
            return this.span.offsetWidth + TEXT_PADDING;
        }
        setInput(input) {
            this.input = input;
            this.subscriptionList.push(fromEvent(input, "input").subscribe(() => this.onInputClear));
        }
        focus() {
            if (this.input !== null) {
                this.input.focus();
            }
        }
        blur() {
            if (this.input !== null) {
                this.input.blur();
            }
        }
        destroy() {
            this.subscriptionList.forEach((subscription) => subscription.unsubscribe());
            this.subscriptionList = [];
        }
    }
    function getData(list, id) {
        for (const v of list) {
            if (v.id === id) {
                return v;
            }
        }
        return null;
    }
    function getIndex(list, id) {
        let index = null;
        const size = list.length;
        for (let i = 0; i < size; i++) {
            if (id === list[i].id) {
                index = i;
                break;
            }
        }
        return index;
    }
    function s4() {
        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    }
    function uuid() {
        return [
            s4(),
            s4(),
            "-",
            s4(),
            "-",
            s4(),
            "-",
            s4(),
            "-",
            s4(),
            s4(),
            s4(),
        ].join("");
    }
    function range(a, b) {
        const indexList = [];
        let start = a;
        let end = b;
        if (a > b) {
            start = b;
            end = a;
        }
        for (let i = start; i <= end; i++) {
            indexList.push(i);
        }
        return indexList;
    }
    function isObject$1(obj) {
        return typeof obj === "object" && obj !== null;
    }
    function isFunction$1(fn) {
        return typeof fn === "function";
    }
    function isEmpty(obj) {
        return obj === null || obj === undefined;
    }
    function cloneDeep(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    function markToHTML(className, target, key) {
        const keyArray = key.split("");
        const strArray = target.split("");
        for (let i = 0; i < keyArray.length - 1; i++) {
            if (keyEquals(keyArray, i + 1)) {
                keyArray.splice(i, 1);
                i--;
            }
        }
        const buf = [];
        strArray.forEach((value) => {
            const html = keyHTML(keyArray, value, className);
            if (html) {
                buf.push(html);
            }
            else {
                buf.push(value);
            }
        });
        return buf.join("");
    }
    function keyEquals(keyArray, start) {
        let result = false;
        for (let i = start + 1; i < keyArray.length; i++) {
            if (keyArray[start].toLowerCase() === keyArray[i].toLowerCase() ||
                keyArray[start] === " ") {
                result = true;
                break;
            }
        }
        return result;
    }
    function keyHTML(keyArray, target, className) {
        let result = null;
        for (const key of keyArray) {
            if (target.toLowerCase() === key.toLowerCase()) {
                result = `<span class="${className}">${target}</span>`;
                break;
            }
        }
        return result;
    }
    function autoName(list, id, name, num = 1) {
        let result = true;
        for (const value of list) {
            if (name === value.name && value.id !== id && name !== "") {
                result = false;
                break;
            }
        }
        if (result) {
            return name;
        }
        return autoName(list, id, name.replace(/[0-9]/g, "") + num, num + 1);
    }

    const rawToProxy = new WeakMap();
    const rawToRefTriggers = new WeakMap();
    const refToUpdate = new WeakMap();
    const refToTask = new WeakMap();
    const refToRaws = new WeakMap();
    const proxyToRaw = new WeakMap();
    const proxyToObservable = new WeakMap();
    let currentRef = null;
    let currentUpdate = null;
    function observer(raw, p) {
        if (isObject$1(currentRef) && isFunction$1(currentUpdate)) {
            const refTriggers = rawToRefTriggers.get(raw);
            if (refTriggers) {
                if (!refTriggers.some((refTrigger) => refTrigger.ref === currentRef)) {
                    refTriggers.push({
                        ref: currentRef,
                        keys: [p],
                    });
                }
                else {
                    refTriggers.forEach((refTrigger) => {
                        if (refTrigger.ref === currentRef &&
                            !refTrigger.keys.some((key) => key === p)) {
                            refTrigger.keys.push(p);
                        }
                    });
                }
            }
            else {
                rawToRefTriggers.set(raw, [
                    {
                        ref: currentRef,
                        keys: [p],
                    },
                ]);
            }
            refToUpdate.set(currentRef, currentUpdate);
            setRefToRaws(currentRef, raw);
        }
    }
    function setRefToRaws(ref, newRaw) {
        const raws = refToRaws.get(ref);
        if (raws) {
            if (!raws.some((raw) => raw === newRaw)) {
                raws.push(newRaw);
            }
        }
        else {
            refToRaws.set(ref, [newRaw]);
        }
    }
    function effect(target, p) {
        const refTriggers = rawToRefTriggers.get(target);
        if (refTriggers) {
            for (let i = 0; i < refTriggers.length; i++) {
                const refTrigger = refTriggers[i];
                if (refTrigger.keys.some((key) => key === p)) {
                    const update = refToUpdate.get(refTrigger.ref);
                    if (update) {
                        Promise.resolve()
                            .then(() => {
                                refToTask.set(refTrigger.ref, update);
                            })
                            .then(() => {
                                if (refToTask.has(refTrigger.ref)) {
                                    const task = refToTask.get(refTrigger.ref);
                                    refToTask.delete(refTrigger.ref);
                                    if (task) {
                                        task();
                                    }
                                }
                            });
                    }
                    refTriggers.splice(i, 1);
                    i--;
                }
            }
            if (refTriggers.length === 0) {
                rawToRefTriggers.delete(target);
            }
        }
    }
    function createObservable(raw, excludeKeys = []) {
        const proxy = new Proxy(raw, {
            get(target, p) {
                observer(raw, p);
                if (isObject$1(target[p]) &&
                    !proxyToRaw.has(target[p]) &&
                    !excludeKeys.some((key) => key === p)) {
                    if (rawToProxy.has(target[p])) {
                        return rawToProxy.get(target[p]);
                    }
                    return createObservable(target[p], excludeKeys);
                }
                return target[p];
            },
            set(target, p, value) {
                target[p] = value;
                if (Array.isArray(target)) {
                    if (p === "length") {
                        effectLegacy(target, p);
                        effect(target, p);
                    }
                }
                else {
                    effectLegacy(target, p);
                    effect(target, p);
                }
                return true;
            },
        });
        rawToProxy.set(raw, proxy);
        proxyToRaw.set(proxy, raw);
        return proxy;
    }
    function observeLegacy(proxy, observer) {
        let observable$ = proxyToObservable.get(proxy);
        if (!observable$) {
            observable$ = new Subject();
            proxyToObservable.set(proxy, observable$);
        }
        return observable$.subscribe(observer);
    }
    function effectLegacy(raw, name) {
        const proxy = rawToProxy.get(raw);
        if (proxy) {
            const observable$ = proxyToObservable.get(proxy);
            if (observable$) {
                asapScheduler.schedule(() => observable$.next(name));
            }
        }
    }

    class RxElement extends LitElement {
        constructor() {
            super(...arguments);
            this.subscriptionList = [];
        }
        disconnectedCallback() {
            this.subscriptionList.forEach((subscription) => subscription.unsubscribe());
            this.subscriptionList = [];
            super.disconnectedCallback();
        }
    }
    class EditorElement extends RxElement {
        connectedCallback() {
            super.connectedCallback();
            // instance context injection
            const root = this.getRootNode();
            const editor = root.host;
            this.context = editor.context;
            // cache update
            this.requestUpdate();
        }
        createRenderRoot() {
            return this;
        }
    }

    const SIZE_FONT = 13;
    const SIZE_MIN_WIDTH = 60;
    const SIZE_BORDER_BOTTOM = 1.5;
    const SIZE_COLUMN_OPTION_AI = 15;
    const SIZE_COLUMN_OPTION_QU = 22;
    const SIZE_COLUMN_OPTION_NN = 34;
    const SIZE_COLUMN_CLOSE = 9;
    const SIZE_COLUMN_KEY = 12;
    const SIZE_COLUMN_MARGIN_RIGHT = 5;
    const SIZE_INPUT_EDIT_HEIGHT = 19;
    const SIZE_COLUMN_HEIGHT = SIZE_INPUT_EDIT_HEIGHT + SIZE_BORDER_BOTTOM;
    const SIZE_TABLE_BORDER = 1;
    const SIZE_TABLE_PADDING = 10;
    const SIZE_TABLE_HEADER_HEIGHT = 47;
    const SIZE_TABLE_HEADER_BODY_HEIGHT = 30;
    const SIZE_START_X = 200;
    const SIZE_START_Y = 100;
    const SIZE_START_ADD = 50;
    const SIZE_MEMO_WIDTH = 127;
    const SIZE_MEMO_HEIGHT = 100;
    const SIZE_MEMO_PADDING = 10;
    const SIZE_SASH = 5;
    const SIZE_CONTEXTMENU_HEIGHT = 40;
    const SIZE_MINIMAP_WIDTH = 150;
    const SIZE_MINIMAP_MARGIN = 20;
    const SIZE_MENUBAR_HEIGHT = 30;
    const SIZE_CANVAS_MIN = 2000;
    const SIZE_CANVAS_MAX = 20000;

    const help = css `
  /* =============== help ============== */
  .vuerd-help {
    position: absolute;
    top: ${SIZE_MENUBAR_HEIGHT}px;
    height: calc(100% - ${SIZE_MENUBAR_HEIGHT}px);
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    opacity: 0.9;
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
    z-index: 100000050;
    fill: #fff0;
    padding: 20px;
    box-sizing: border-box;
  }
  .vuerd-help:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-help-header {
    height: 30px;
    margin-bottom: 10px;
    overflow: hidden;
  }
  .vuerd-help-header > h3 {
    display: inline-block;
    margin: 0;
  }
  .vuerd-help-header > .vuerd-button {
    float: right;
  }
  .vuerd-help-body {
    height: calc(100% - 40px);
    overflow: auto;
    box-sizing: border-box;
  }
`;

    const importErrorDDL = css `
  /* =============== import error DDL ============== */
  .vuerd-import-error-ddl {
    position: absolute;
    top: ${SIZE_MENUBAR_HEIGHT}px;
    height: calc(100% - ${SIZE_MENUBAR_HEIGHT}px);
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    opacity: 0.9;
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
    z-index: 100000050;
    fill: #fff0;
    padding: 20px;
    box-sizing: border-box;
  }
  .vuerd-import-error-ddl:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-import-error-ddl-header {
    height: 30px;
    margin-bottom: 10px;
    overflow: hidden;
  }
  .vuerd-import-error-ddl-header > h3 {
    display: inline-block;
    margin: 0;
  }
  .vuerd-import-error-ddl-header > .vuerd-button {
    float: right;
  }
  .vuerd-import-error-ddl-body {
    font-family: monospace !important;
    white-space: pre;
    height: calc(100% - 70px);
    overflow: auto;
    box-sizing: border-box;
  }
  .vuerd-import-error-ddl-footer {
    height: 20px;
    margin-top: 10px;
  }
  .vuerd-import-error-ddl-footer > a {
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
`;

    const setting = css `
  /* =============== setting ============== */
  .vuerd-setting {
    position: absolute;
    top: ${SIZE_MENUBAR_HEIGHT}px;
    height: calc(100% - ${SIZE_MENUBAR_HEIGHT}px);
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    opacity: 0.9;
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
    z-index: 100000050;
    fill: #fff0;
    padding: 20px;
    box-sizing: border-box;
  }
  .vuerd-setting:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-setting-header {
    height: 30px;
    margin-bottom: 10px;
    overflow: hidden;
  }
  .vuerd-setting-header > h3 {
    display: inline-block;
    margin: 0;
  }
  .vuerd-setting-header > .vuerd-button {
    float: right;
  }
  .vuerd-setting-body {
    height: calc(100% - 40px);
    overflow: auto;
    box-sizing: border-box;
  }
  .vuerd-setting-body tbody tr td {
    padding-right: 20px;
    padding-bottom: 10px;
  }

  /* =============== switch ============== */
  .vuerd-switch {
    position: relative;
    display: inline-block;
    width: 37.5px;
    height: 22.5px;
    overflow: hidden;
  }
  .vuerd-switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .vuerd-switch > .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(
      --vuerd-theme-font-placeholder,
      var(--vuerd-color-font-placeholder)
    );
    transition: 0.3s;
  }
  .vuerd-switch > .slider:before {
    position: absolute;
    content: "";
    height: 15px;
    width: 15px;
    left: 3.75px;
    bottom: 3.75px;
    background-color: var(
      --vuerd-theme-font-active,
      var(--vuerd-color-font-active)
    );
    transition: 0.3s;
  }
  .vuerd-switch > input:checked + .slider {
    background-color: var(--vuerd-theme-focus, var(--vuerd-color-focus));
  }
  .vuerd-switch > input:focus + .slider {
    box-shadow: 0 0 1px var(--vuerd-theme-focus, var(--vuerd-color-focus));
  }
  .vuerd-switch > input:checked + .slider:before {
    transform: translateX(15px);
  }
  .vuerd-switch > .slider.round {
    border-radius: 34px;
  }
  .vuerd-switch > .slider.round:before {
    border-radius: 50%;
  }

  .vuerd-column-order {
    cursor: move;
    box-sizing: border-box;
    padding: 5px;
    display: inline-block;
  }
  .vuerd-column-order:hover {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }
  .vuerd-column-order.draggable {
    opacity: 0.5;
  }
  .vuerd-column-order.none-hover:hover {
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
  }
  /* animation flip */
  .vuerd-column-order-move {
    transition: transform 0.3s;
  }
`;

    const tableProperties = css `
  /* =============== tableProperties ============== */
  .vuerd-table-properties {
    position: absolute;
    top: ${SIZE_MENUBAR_HEIGHT}px;
    height: calc(100% - ${SIZE_MENUBAR_HEIGHT}px);
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    opacity: 0.9;
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
    z-index: 100000050;
    fill: #fff0;
    padding: 20px;
    box-sizing: border-box;
  }
  .vuerd-table-properties:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-table-properties-header {
    height: 30px;
    margin-bottom: 10px;
    overflow: hidden;
  }
  .vuerd-table-properties-header > h3 {
    display: inline-block;
    margin: 0;
  }
  .vuerd-table-properties-header > .vuerd-button {
    float: right;
  }
  .vuerd-table-properties-body {
    height: calc(100% - 40px);
    overflow: auto;
    box-sizing: border-box;
  }
  .vuerd-table-properties-body tbody tr td {
    padding-right: 20px;
    padding-bottom: 10px;
  }
  .vuerd-table-properties-tab {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    margin-bottom: 10px;
  }
  .vuerd-table-properties-tab > li {
    padding: 10px;
    box-sizing: border-box;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
    white-space: nowrap;
    display: inline-block;
  }
  .vuerd-table-properties-tab > li:hover {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }
  .vuerd-table-properties-tab > li.active {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }

  /* =============== tab indexes ============== */
  .vuerd-tab-indexes input {
    display: inline-flex;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 23.5px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    border-bottom: solid #fff0 1.5px;
  }
  .vuerd-tab-indexes input:focus {
    border-bottom: solid var(--vuerd-theme-edit, var(--vuerd-color-edit)) 1.5px;
  }
  .vuerd-index {
    fill: #fff0;
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
  .vuerd-index:hover,
  .vuerd-index-column:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-index-column {
    fill: #fff0;
    display: inline-block;
  }
  .vuerd-index-column.draggable {
    opacity: 0.5;
  }
  .vuerd-index-unique {
    display: inline-block;
    cursor: pointer;
    color: var(
      --vuerd-theme-font-placeholder,
      var(--vuerd-color-font-placeholder)
    );
  }
  .vuerd-index-unique.checked {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
  .vuerd-index-column-name {
    display: inline-block;
    cursor: move;
    padding: 5px;
  }
  .vuerd-index-column-name:hover {
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }
  .vuerd-index-column-name.none-hover:hover {
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
  }
  .vuerd-index-column-order {
    display: inline-block;
    cursor: pointer;
  }
  .vuerd-index-add-column {
    display: inline-block;
    position: relative;
  }
  .vuerd-index-add-column-list {
    position: absolute;
    top: 27px;
    left: 0;
    z-index: 100;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
    opacity: 0.9;
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .vuerd-index-add-column-list > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }
  .vuerd-index-add-column-list > li:hover,
  .vuerd-index-add-column-hint.active {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }
  .vuerd-index-add-column-list > li:hover .vuerd-mark,
  .vuerd-index-add-column-hint.active .vuerd-mark {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
  /* animation flip */
  .vuerd-index-add-column-hint-move {
    transition: transform 0.2s;
  }
  .vuerd-index-column-move {
    transition: transform 0.3s;
  }

  /* =============== tab SQL, GeneratorCode ============== */
  .vuerd-tab-sql,
  .vuerd-tab-generator-code {
    white-space: pre;
    box-sizing: border-box;
    background-color: #23241f;
    overflow: auto;
    font-family: monospace !important;
    outline: none;
  }
`;

    const contextmenu = css `
  /* =============== contextmenu ============== */
  .vuerd-contextmenu {
    position: fixed;
    z-index: 100002000;
    opacity: 0.9;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .vuerd-contextmenu > li {
    height: ${SIZE_CONTEXTMENU_HEIGHT}px;
    padding: 10px 5px 10px 10px;
    box-sizing: border-box;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
    white-space: nowrap;
  }
  .vuerd-contextmenu > li:hover {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    fill: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }
  .vuerd-contextmenu > li > span {
    display: inline-flex;
    vertical-align: middle;
    align-items: center;
    overflow: hidden;
    text-overflow: ellipsis;
    padding-right: 5px;
  }
  .vuerd-contextmenu > li > span.icon,
  .vuerd-contextmenu > li > span.icon > img {
    width: 16px;
  }
  .vuerd-contextmenu > li > span.name {
    width: 110px;
    height: 17px;
  }
  .vuerd-contextmenu > li > span.keymap {
    width: 85px;
    display: inline-block;
    padding-right: 0;
  }
  .vuerd-contextmenu > li > span.arrow {
    width: 13px;
    padding-right: 0;
  }
`;

    const sash = css `
  /* =============== sash ============== */
  .vuerd-sash {
    position: absolute;
    z-index: 300;
  }
  .vuerd-sash.vertical {
    width: ${SIZE_SASH}px;
    height: 100%;
    cursor: ew-resize;
  }
  .vuerd-sash.horizontal {
    width: 100%;
    height: ${SIZE_SASH}px;
    cursor: ns-resize;
  }
  .vuerd-sash.edge {
    width: ${SIZE_SASH}px;
    height: ${SIZE_SASH}px;
  }
`;

    const table = css `
  /* =============== table ============== */
  .vuerd-table {
    position: absolute;
    opacity: 0.9;
    padding: ${SIZE_TABLE_PADDING}px;
    font-size: ${SIZE_FONT}px;
    fill: #fff0;
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    border: solid #fff0 ${SIZE_TABLE_BORDER}px;
  }
  .vuerd-table:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-table.active {
    border: solid
      var(--vuerd-theme-table-active, var(--vuerd-color-table-active))
      ${SIZE_TABLE_BORDER}px;
    box-shadow: 0 1px 6px
      var(--vuerd-theme-table-active, var(--vuerd-color-table-active));
  }
  .vuerd-table .vuerd-table-header-top {
    overflow: hidden;
    cursor: move;
  }
  .vuerd-table .vuerd-table-header-top .vuerd-button {
    margin-left: 5px;
    float: right;
  }
  .vuerd-table .vuerd-table-header-body {
    height: ${SIZE_TABLE_HEADER_BODY_HEIGHT}px;
  }
`;

    const column = css `
  /* =============== column ============== */
  .vuerd-column {
    height: ${SIZE_COLUMN_HEIGHT}px;
    fill: #fff0;
  }
  .vuerd-column:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-column.select {
    background-color: var(
      --vuerd-theme-column-select,
      var(--vuerd-color-column-select)
    );
  }
  .vuerd-column.active {
    background-color: var(
      --vuerd-theme-column-active,
      var(--vuerd-color-column-active)
    );
  }
  .vuerd-column.draggable {
    opacity: 0.5;
  }
  /* animation flip */
  .vuerd-column-move {
    transition: transform 0.3s;
  }

  vuerd-input-edit,
  vuerd-column-key,
  vuerd-column-not-null,
  vuerd-column-data-type,
  vuerd-column-auto-increment,
  vuerd-column-unique {
    float: left;
  }
  .vuerd-input-edit {
    display: flex;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  input.vuerd-input-edit {
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 17px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
  }
  div.vuerd-input-edit {
    border-bottom: solid #fff0 1.5px;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    cursor: default;
  }
  .vuerd-input-edit.select {
    background-color: var(
      --vuerd-theme-column-select,
      var(--vuerd-color-column-select)
    );
  }
  .vuerd-input-edit.active {
    background-color: var(
      --vuerd-theme-column-active,
      var(--vuerd-color-column-active)
    );
  }
  .vuerd-input-edit.focus {
    border-bottom: solid var(--vuerd-theme-focus, var(--vuerd-color-focus))
      1.5px;
  }
  .vuerd-input-edit.edit {
    border-bottom: solid var(--vuerd-theme-edit, var(--vuerd-color-edit)) 1.5px;
  }
  .vuerd-input-edit.placeholder {
    color: var(
      --vuerd-theme-font-placeholder,
      var(--vuerd-color-font-placeholder)
    );
  }

  .vuerd-column-key {
    display: flex;
    vertical-align: middle;
    align-items: center;
    fill: #fff0;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
  }
  .vuerd-column-key.pk {
    fill: var(--vuerd-theme-key-pk, var(--vuerd-color-key-pk));
  }
  .vuerd-column-key.fk {
    fill: var(--vuerd-theme-key-fk, var(--vuerd-color-key-fk));
  }
  .vuerd-column-key.pfk {
    fill: var(--vuerd-theme-key-pfk, var(--vuerd-color-key-pfk));
  }

  .vuerd-column-not-null {
    display: flex;
    vertical-align: middle;
    align-items: center;
    border-bottom: solid #fff0 1.5px;
    cursor: default;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
  .vuerd-column-not-null.focus {
    border-bottom: solid var(--vuerd-theme-focus, var(--vuerd-color-focus))
      1.5px;
  }

  .vuerd-column-data-type {
    display: flex;
    vertical-align: middle;
    align-items: center;
    position: relative;
  }
  vuerd-column-data-type-hint {
    position: absolute;
  }
  .vuerd-column-data-type-hint {
    position: absolute;
    opacity: 0.9;
    top: 11px;
    left: 0;
    z-index: 100000000;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .vuerd-column-data-type-hint > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }
  .vuerd-column-data-type-hint > li:hover,
  .vuerd-data-type-hint.active {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }
  .vuerd-column-data-type-hint > li:hover .vuerd-mark,
  .vuerd-data-type-hint.active .vuerd-mark {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
  /* animation flip */
  .vuerd-data-type-hint-move {
    transition: transform 0.2s;
  }
  .vuerd-mark {
    color: var(--vuerd-theme-edit, var(--vuerd-color-edit));
  }

  .vuerd-column-auto-increment,
  .vuerd-column-unique {
    display: flex;
    vertical-align: middle;
    align-items: center;
    border-bottom: solid #fff0 1.5px;
    cursor: default;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(
      --vuerd-theme-font-placeholder,
      var(--vuerd-color-font-placeholder)
    );
  }
  .vuerd-column-auto-increment.focus,
  .vuerd-column-unique.focus {
    border-bottom: solid var(--vuerd-theme-focus, var(--vuerd-color-focus))
      1.5px;
  }
  .vuerd-column-auto-increment.checked,
  .vuerd-column-unique.checked {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
`;

    const relationship = css `
  /* =============== relationship ============== */
  .vuerd-relationship {
    stroke: var(--vuerd-theme-key-fk, var(--vuerd-color-key-fk));
  }
  .vuerd-relationship.identification {
    stroke: var(--vuerd-theme-key-pfk, var(--vuerd-color-key-pfk));
  }
  .vuerd-relationship.active {
    stroke: var(--vuerd-theme-edit, var(--vuerd-color-edit));
  }
`;

    const drawRelationship = css `
  /* =============== drawRelationship ============== */
  .vuerd-draw-relationship {
    position: absolute;
    top: 0;
    stroke: var(--vuerd-theme-key-fk, var(--vuerd-color-key-fk));
  }
`;

    const memo = css `
  /* =============== memo ============== */
  .vuerd-memo {
    position: absolute;
    opacity: 0.9;
    fill: #fff0;
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .vuerd-memo:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-memo.active {
    border: solid
      var(--vuerd-theme-table-active, var(--vuerd-color-table-active)) 1px;
    box-shadow: 0 1px 6px
      var(--vuerd-theme-table-active, var(--vuerd-color-table-active));
  }
  .vuerd-memo > .vuerd-memo-header {
    padding: ${SIZE_MEMO_PADDING}px;
    cursor: move;
  }
  .vuerd-memo > .vuerd-memo-header .vuerd-button {
    float: right;
  }
  .vuerd-memo > .vuerd-memo-body .vuerd-memo-textarea {
    padding: ${SIZE_MEMO_PADDING}px;
    opacity: 0.9;
    border: none;
    resize: none;
    outline: none;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
  }
`;

    const minimap = css `
  /* =============== minimap ============== */
  .vuerd-minimap {
    position: absolute;
    z-index: 602;
    overflow: hidden;
    background-color: var(--vuerd-theme-canvas, var(--vuerd-color-canvas));
  }
  .vuerd-minimap-shadow {
    position: absolute;
    z-index: 601;
    box-shadow: 0 1px 6px
      var(--vuerd-theme-minimap-shadow, var(--vuerd-color-minimap-shadow));
  }
  .vuerd-minimap-canvas {
    position: relative;
  }
  .vuerd-minimap-canvas-svg {
    position: absolute;
    z-index: 1;
  }
  .vuerd-minimap-handle {
    position: absolute;
    z-index: 603;
    border: solid var(--vuerd-theme-edit, var(--vuerd-color-edit)) 1px;
    cursor: pointer;
    opacity: 0.7;
  }
  .vuerd-minimap-handle:hover {
    opacity: 1;
  }
`;

    const dragSelect = css `
  /* =============== dragSelect ============== */
  .vuerd-drag-select {
    position: fixed;
    z-index: 100000001;
    stroke: var(--vuerd-theme-focus, var(--vuerd-color-focus));
  }
`;

    const menubar = css `
  /* =============== menubar ============== */
  .vuerd-menubar {
    width: 100%;
    position: absolute;
    overflow: hidden;
    z-index: 600;
    display: flex;
    align-items: center;
    height: ${SIZE_MENUBAR_HEIGHT}px;
    background-color: var(--vuerd-theme-menubar, var(--vuerd-color-menubar));
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .vuerd-menubar > .vuerd-menubar-input {
    margin-left: 20px;
  }
  .vuerd-menubar > .vuerd-menubar-input input {
    outline: none;
    border: none;
    opacity: 0.9;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(--vuerd-theme-menubar, var(--vuerd-color-menubar));
  }
  .vuerd-menubar > .vuerd-menubar-menu {
    cursor: pointer;
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
    margin-left: 10px;
  }
  .vuerd-menubar > .vuerd-menubar-menu.active,
  .vuerd-menubar > .vuerd-menubar-menu:hover {
    fill: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
  .vuerd-menubar > .vuerd-menubar-menu.undo-redo {
    cursor: not-allowed;
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-menubar > .vuerd-menubar-menu.undo-redo.active {
    cursor: pointer;
    fill: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
  .vuerd-menubar > .vuerd-menubar-menu-vertical {
    margin-left: 10px;
  }

  /* =============== Grid filter ============== */
  .vuerd-grid-filter {
    position: absolute;
    z-index: 100000040;
    right: 190px;
    width: 370px;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    background-color: var(--vuerd-theme-menubar, var(--vuerd-color-menubar));
    opacity: 0.9;
    fill: #fff0;
    padding: 10px;
  }
  .vuerd-grid-filter:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-grid-filter-header {
    height: 30px;
  }
  .vuerd-grid-filter-header h3 {
    display: inline-block;
    margin: 0 10px 0 0;
  }
  .vuerd-grid-filter-header .vuerd-grid-filter-radio-editor {
    display: inline-block;
  }
  .vuerd-grid-filter-header .vuerd-button {
    float: right;
    margin-left: 5px;
  }
  .vuerd-grid-filter-state {
    height: ${SIZE_COLUMN_HEIGHT}px;
    fill: #fff0;
  }
  .vuerd-grid-filter-state:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-grid-filter-state.select {
    background-color: var(
      --vuerd-theme-column-select,
      var(--vuerd-color-column-select)
    );
  }
  .vuerd-grid-filter-state.draggable {
    opacity: 0.5;
  }
  /* animation flip */
  .vuerd-grid-filter-state-move {
    transition: transform 0.3s;
  }
  vuerd-grid-filter-text-editor,
  .vuerd-grid-filter-body vuerd-grid-filter-radio-editor {
    float: left;
  }
  .vuerd-grid-filter-text-editor {
    width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .vuerd-grid-filter-text-editor,
  .vuerd-grid-filter-radio-editor {
    display: flex;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(--vuerd-theme-menubar, var(--vuerd-color-menubar));
  }
  input.vuerd-grid-filter-text-editor {
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 17px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
  }
  div.vuerd-grid-filter-text-editor,
  div.vuerd-grid-filter-radio-editor {
    border-bottom: solid #fff0 1.5px;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    cursor: default;
  }
  .vuerd-grid-filter-text-editor.select,
  .vuerd-grid-filter-radio-editor.select {
    background-color: var(
      --vuerd-theme-column-select,
      var(--vuerd-color-column-select)
    );
  }
  .vuerd-grid-filter-text-editor.focus,
  .vuerd-grid-filter-radio-editor.focus {
    border-bottom: solid var(--vuerd-theme-focus, var(--vuerd-color-focus))
      1.5px;
  }
  .vuerd-grid-filter-text-editor.edit,
  .vuerd-grid-filter-radio-editor.edit {
    border-bottom: solid var(--vuerd-theme-edit, var(--vuerd-color-edit)) 1.5px;
  }
  .vuerd-grid-filter-text-editor.placeholder {
    color: var(
      --vuerd-theme-font-placeholder,
      var(--vuerd-color-font-placeholder)
    );
  }
  .vuerd-grid-filter-radio-editor {
    position: relative;
  }
  .vuerd-grid-filter-radio-editor-box {
    position: absolute;
    list-style: none;
    padding: 0;
    margin: 0;
    top: ${SIZE_COLUMN_HEIGHT}px;
    left: 0;
    z-index: 100000000;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
    background-color: var(--vuerd-theme-menubar, var(--vuerd-color-menubar));
    opacity: 0.9;
  }
  .vuerd-grid-filter-radio-editor-box > li {
    padding: 5px;
    cursor: pointer;
  }
  .vuerd-grid-filter-radio-editor-box > li .icon {
    display: inline-block;
    width: 12px;
  }
  .vuerd-grid-filter-radio-editor-box > li:hover,
  .vuerd-grid-filter-radio-editor-box > li.active {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    fill: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }

  /* =============== ERD find ============== */
  .vuerd-find {
    position: absolute;
    z-index: 100000040;
    right: 190px;
    width: 300px;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    background-color: var(--vuerd-theme-menubar, var(--vuerd-color-menubar));
    opacity: 0.9;
  }

  .vuerd-find {
    position: absolute;
    z-index: 100000040;
    right: 190px;
    width: 235px;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    background-color: var(--vuerd-theme-menubar, var(--vuerd-color-menubar));
    opacity: 0.9;
    fill: #fff0;
  }
  .vuerd-find:hover {
    fill: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .vuerd-find-header {
    height: 30px;
    padding: 10px;
  }
  .vuerd-find-header h3 {
    display: inline-block;
    margin: 0 10px 0 0;
  }
  .vuerd-find-header .vuerd-button {
    float: right;
  }
  .vuerd-find-table {
    display: inline-block;
    position: relative;
  }
  .vuerd-find-table input {
    display: flex;
    width: 150px;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(--vuerd-theme-menubar, var(--vuerd-color-menubar));
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 17px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    border-bottom: solid #fff0 1.5px;
  }
  .vuerd-find-table input:focus {
    border-bottom: solid var(--vuerd-theme-edit, var(--vuerd-color-edit)) 1.5px;
  }

  .vuerd-find-table-list {
    position: absolute;
    top: 20.5px;
    left: 0;
    z-index: 100;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    background-color: var(--vuerd-theme-menubar, var(--vuerd-color-menubar));
    opacity: 0.9;
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .vuerd-find-table-list > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }
  .vuerd-find-table-list > li:hover,
  .vuerd-find-table-hint.active {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }
  .vuerd-find-table-list > li:hover .vuerd-mark,
  .vuerd-find-table-hint.active .vuerd-mark {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
  /* animation flip */
  .vuerd-find-table-hint-move {
    transition: transform 0.2s;
  }
`;

    const grid = css `
  /* =============== grid ============== */
  .vuerd-grid {
    height: calc(100% - ${SIZE_MENUBAR_HEIGHT}px);
    margin-top: ${SIZE_MENUBAR_HEIGHT}px;
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .vuerd-grid .vuerd-grid-text {
    width: 100%;
    height: 100%;
    padding: 7px 6px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    border-bottom: solid #fff0 1.5px;
    box-sizing: border-box;
  }
  .vuerd-grid .vuerd-grid-text.placeholder {
    color: var(
      --vuerd-theme-font-placeholder,
      var(--vuerd-color-font-placeholder)
    );
  }
  .vuerd-grid input.vuerd-grid-input {
    width: 100%;
    height: 100%;
    outline: none;
    border: none;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    border-bottom: solid var(--vuerd-theme-edit, var(--vuerd-color-edit)) 2px;
  }
  .vuerd-grid-column-option-editor {
    position: absolute;
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
    opacity: 0.9;
    list-style: none;
    padding: 0;
    margin: 0;
    z-index: 100;
  }
  .vuerd-grid-column-option-editor > li > input {
    outline: none;
    border: none;
    margin-right: 5px;
  }
  .vuerd-grid-column-option-editor > li {
    display: flex;
    vertical-align: middle;
    align-items: center;
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }
  .vuerd-grid-column-option-editor > li:hover,
  .vuerd-grid-column-option-editor > li.active {
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }
  .vuerd-grid-column-data-type-editor {
    position: relative;
    width: 100%;
    height: 100%;
  }
  .vuerd-grid-column-data-type-hint {
    position: absolute;
    top: 41px;
    left: 0;
    z-index: 100;
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
    background-color: var(
      --vuerd-theme-contextmenu,
      var(--vuerd-color-contextmenu)
    );
    opacity: 0.9;
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .vuerd-grid-column-data-type-hint > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }
  .vuerd-grid-column-data-type-hint > li:hover,
  .vuerd-grid-data-type-hint.active {
    background-color: var(
      --vuerd-theme-contextmenu-active,
      var(--vuerd-color-contextmenu-active)
    );
  }
  .vuerd-grid-column-data-type-hint > li:hover .vuerd-mark,
  .vuerd-grid-data-type-hint.active .vuerd-mark {
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
  /* animation flip */
  .vuerd-grid-data-type-hint-move {
    transition: transform 0.2s;
  }
`;

    const scrollbar = css `
  /* =============== scrollbar ============== */
  /* width */
  ::-webkit-scrollbar {
    width: 12px;
    height: 12px;
  }
  /* track */
  ::-webkit-scrollbar-track {
    background: #fff0;
  }
  ::-webkit-scrollbar-corner {
    background: #fff0;
  }
  /* handle */
  ::-webkit-scrollbar-thumb {
    background: var(
      --vuerd-theme-scrollbar-thumb,
      var(--vuerd-color-scrollbar-thumb)
    );
  }
  /* handle:hover */
  ::-webkit-scrollbar-thumb:hover {
    background: var(
      --vuerd-theme-scrollbar-thumb-active,
      var(--vuerd-color-scrollbar-thumb-active)
    );
  }
  /* firefox */
  .vuerd-scrollbar {
    scrollbar-color: var(
        --vuerd-theme-scrollbar-thumb,
        var(--vuerd-color-scrollbar-thumb)
      )
      #fff0;
    scrollbar-width: auto;
  }
`;

    const shareMouse = css `
  /* =============== shareMouse ============== */
  .vuerd-share-mouse {
    position: absolute;
    z-index: 100000000;
    color: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }
`;

    const vuerd = css `
  .vuerd-editor {
    position: relative;
    overflow: hidden;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family) !important;
    background-color: #f8f8f8;
  }

  .vuerd-erd {
    position: relative;
    overflow: hidden;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
    background-color: var(--vuerd-theme-canvas, var(--vuerd-color-canvas));
  }

  .vuerd-canvas {
    position: relative;
    background-color: var(--vuerd-theme-canvas, var(--vuerd-color-canvas));
  }

  .vuerd-canvas-svg {
    position: absolute;
    z-index: 1;
  }

  .vuerd-text-width {
    visibility: hidden;
    position: fixed;
    top: -100px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--vuerd-font-family);
  }
  
  .vuerd-editor-focus {
    position: fixed;
    top: -100px;
  }

  .vuerd-button {
    cursor: pointer;
  }
  .vuerd-button:hover {
    fill: var(--vuerd-theme-font-active, var(--vuerd-color-font-active));
  }

  .vuerd-visualization {
    position: relative;
    height: 100%;
    overflow: auto;
    background-color: var(
      --vuerd-theme-visualization,
      var(--vuerd-color-visualization)
    );
  }

  .vuerd-sql,
  .vuerd-generator-code {
    height: calc(100% - ${SIZE_MENUBAR_HEIGHT}px);
    margin-top: ${SIZE_MENUBAR_HEIGHT}px;
    white-space: pre;
    box-sizing: border-box;
    background-color: #f5f6fa;
    overflow: auto;
    font-family: monospace !important;
    outline: none;
    
  }

  .vuerd-icon {
    transition: fill 0.15s;
  }

  ${help}
  ${importErrorDDL}
  ${setting}
  ${tableProperties}
  ${contextmenu}
  ${sash}
  ${table}
  ${column}
  ${relationship}
  ${drawRelationship}
  ${memo}
  ${minimap}
  ${dragSelect}
  ${menubar}
  ${grid}
  ${scrollbar}
  ${shareMouse}
`;

    const monokaiSublime = css `
  /*
    Monokai Sublime style. Derived from Monokai by noformnocontent http://nn.mit-license.org/
  */
  .hljs {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    background: #23241f;
    font-weight: bold;
  }

  .hljs,
  .hljs-tag,
  .hljs-subst {
    color: #000000;
  }

  .hljs-strong,
  .hljs-emphasis {
    color: #a8a8a2;
  }

  .hljs-bullet,
  .hljs-quote,
  .hljs-regexp,
  .hljs-literal,
  .hljs-link {
    color: #5391c2;
  }
      
  .hljs-number {
    color: #dac680;
  }

  .hljs-code,
  .hljs-title,
  .hljs-section,
  .hljs-selector-class {
    color: #0043ff;
  }

  .hljs-strong {
    font-weight: bold;
  }

  .hljs-emphasis {
    font-style: italic;
  }

  .hljs-keyword,
  .hljs-selector-tag,
  .hljs-name,
  .hljs-attr {
    color: #5391c2;
  }

  .hljs-symbol,
  .hljs-attribute {
    color: #66d9ef;
  }

  .hljs-params,
  .hljs-class .hljs-title {
    color: #000000;
  }

  .hljs-string,
  .hljs-type,
  .hljs-built_in,
  .hljs-builtin-name,
  .hljs-selector-id,
  .hljs-selector-attr,
  .hljs-selector-pseudo,
  .hljs-addition,
  .hljs-variable,
  .hljs-template-variable {
    color: #408e34;
  }

  .hljs-comment,
  .hljs-deletion,
  .hljs-meta {
    color: #052800;
  }
`;

    const tuiGrid = css `
  /*!
 * TOAST UI Grid
 * @version 4.15.3 | Fri Nov 13 2020
 * @author NHN. FE Development Lab
 * @license MIT
 */
  /*!
 * TOAST UI Select Box
 * @version 1.0.0 | Thu Oct 24 2019
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
  .tui-select-box {
    position: relative;
  }

  .tui-select-box-input,
  .tui-select-box-dropdown,
  .tui-select-box-item-group-label,
  .tui-select-box-item {
    box-sizing: border-box;
  }

  .tui-select-box-input {
    border: 1px solid #ddd;
  }

  .tui-select-box-input.tui-select-box-open,
  .tui-select-box-dropdown {
    border: 1px solid #aaa;
  }

  .tui-select-box-input,
  .tui-select-box-dropdown {
    background: #fff;
  }

  .tui-select-box-input,
  .tui-select-box-item-group-label,
  .tui-select-box-item {
    padding: 0 8px;
    height: 29px;
    font-size: 13px;
    color: #333;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: pointer;
  }

  .tui-select-box-placeholder,
  .tui-select-box-item-group-label,
  .tui-select-box-item {
    line-height: 29px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .tui-select-box-placeholder,
  .tui-select-box-icon {
    height: 100%;
  }

  .tui-select-box-placeholder {
    display: inline-block;
    margin: 0;
    width: 80%;
    width: calc(100% - 12px);
    vertical-align: sub;
  }

  .tui-select-box-icon {
    display: block;
    float: right;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAECAYAAACHtL/sAAAAAXNSR0IArs4c6QAABBFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIj4KICAgICAgICAgPHhtcE1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc3RhbmNlSUQ+eG1wLmlpZDozOTU0MDZFM0JEQjExMUU2OEQ1MkUyN0M0NDdEMkIxMTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDozOTU0MDZFNEJEQjExMUU2OEQ1MkUyN0M0NDdEMkIxMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDozOTU0MDZFNkJEQjExMUU2OEQ1MkUyN0M0NDdEMkIxMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDozOTU0MDZFNUJEQjExMUU2OEQ1MkUyN0M0NDdEMkIxMTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4K/ZqkVgAAAERJREFUGBljNDY2/s+AA5w9e5YRXQqqXgAo9xEkB1aAzRA8mmFmgg1hgvIEYKIgmgjNIGUfQATciUBX8IMEidQM0gsGAPabHJ7Zbgx5AAAAAElFTkSuQmCC)
      left center no-repeat;
    width: 7px;
    overflow: hidden;
    text-indent: 100%;
  }

  .tui-select-box-open > .tui-select-box-icon {
    background-position: right center;
  }

  .tui-select-box-dropdown,
  .tui-select-box-item-group {
    margin: 0;
    padding: 0;
    list-style-type: none;
  }

  .tui-select-box-dropdown {
    position: absolute;
    border-top: none;
    /* max-height: 145px; */
    overflow: auto;
    z-index: 1;
    width: 100%;
    overflow-x: hidden;
  }

  .tui-select-box-item-group-label {
    display: block;
    font-weight: bold;
    cursor: default;
  }

  .tui-select-box-item-group > .tui-select-box-item {
    padding-left: 20px;
  }

  .tui-select-box-selected {
    background: #f4f4f4;
  }

  .tui-select-box-highlight {
    background: #e5f6ff;
    outline: none;
  }

  .tui-select-box-disabled {
    background: #f9f9f9;
    color: #c8c8c8;
    cursor: default;
  }

  .tui-select-box-hidden {
    display: none; /* for test */
  }
  .tui-grid-container {
    width: 100%;
    position: relative;
    border-width: 0;
    clear: both;
    font-size: 13px;
    font-family: Arial, "\B3CB\C6C0", Dotum, sans-serif;
  }
  .tui-grid-container ::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 17px;
    height: 17px;
  }
  .tui-grid-container ::-webkit-scrollbar-thumb {
    border: 4px solid transparent;
    background-clip: content-box;
  }
  .tui-grid-container * {
    box-sizing: content-box;
  }
  .tui-grid-container p,
  .tui-grid-container input,
  .tui-grid-container textarea {
    margin: 0;
    padding: 0;
    font-size: 13px;
    font-family: Arial, "\B3CB\C6C0", Dotum, sans-serif;
  }
  .tui-grid-container fieldset {
    margin: 0;
    padding: 0;
    border: 0;
    display: inline;
    white-space: nowrap;
  }
  .tui-grid-container input[type="text"],
  .tui-grid-container input[type="password"] {
    outline: none;
    box-sizing: border-box;
    line-height: normal;
  }
  .tui-grid-container ul,
  .tui-grid-container li {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .tui-grid-container strong,
  .tui-grid-container em {
    font-style: normal;
  }
  .tui-grid-container .tui-grid-pagination {
    margin-top: 20px;
  }
  .tui-grid-clipboard {
    position: fixed;
    top: 0px;
    left: -9999px;
    width: 100px;
    height: 100px;
  }
  .tui-grid-btn-text {
    display: inline-block;
    text-decoration: none;
  }
  .tui-grid-btn-text span {
    display: inline-block;
    position: relative;
    font-size: 11px;
    color: #333;
    padding-left: 17px;
    letter-spacing: -1px;
    line-height: 23px;
    white-space: nowrap;
    cursor: pointer;
    margin-left: 8px;
    padding-right: 7px;
  }
  .tui-grid-btn-text em {
    position: absolute;
    left: 0;
    top: 5px;
    width: 17px;
    height: 12px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=)
      no-repeat;
  }
  .tui-grid-btn-sorting {
    display: inline-block;
    overflow: hidden;
    margin-left: 6px;
    height: 16px;
    width: 11px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=) -91px -10px
      no-repeat;
    vertical-align: middle;
    cursor: pointer;
  }
  .tui-grid-btn-sorting-down {
    background-position: -133px -8px;
  }
  .tui-grid-btn-sorting-up {
    background-position: -112px -8px;
  }
  .tui-grid-btn-close {
    display: inline-block;
    overflow: hidden;
    height: 24px;
    width: 24px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==) -81px -84px
      no-repeat;
    vertical-align: middle;
    cursor: pointer;
    float: right;
  }
  .tui-grid-btn-filter {
    display: inline-block;
    overflow: hidden;
    height: 24px;
    width: 24px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==) -13px -84px
      no-repeat;
    vertical-align: middle;
    cursor: pointer;
  }
  .tui-grid-btn-filter-active {
    background-position: -47px -84px;
  }

  .tui-grid-filter-icon {
    cursor: default;
  }

  .tui-grid-layer-state {
    position: absolute;
    background: #fff;
    text-align: center;
    z-index: 15;
  }
  .tui-grid-layer-state p {
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    margin-top: -7px;
    font-size: 14px;
    color: #ccc;
  }
  .tui-grid-layer-state-content {
    padding-top: 50px;
  }
  .tui-grid-layer-state-loading {
    display: block;
    margin: 10px auto 0;
    background: url(data:image/gif;base64,R0lGODlhlgANAKIHAMzi5FnYeeXw8czh5Nnp67/a3f///////yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFFAAHACwAAAAAlgANAAADXnh60v4wykmrvTjrHdfiYCiOZNkpZqquLIg6RizPdG3feK7vfO//swcDBiwaj8ik0iBZOp/QaC8irVqvSSp2y+3Smt6wGCp8jM9ooHDYarvfpg98Tq9LPC+7fq/yJAAAIfkEBQAABwAsAAAAAJYADQAAA2V4etT+MMpJq7046x3X4mAojmTZKWaqriyIOl4sz3Rt33iu77z9MLCecEgsGo9AyCLAbDqfT6R0Sh2eDtBstsrtej9KhXbc/JrPRgl6zT7/fu24PB1s2e94FTjP7/uve3+CgykeCQAh+QQFAAAHACwAAAAAlgANAAADa3h6MP4wykmrvTjrzSFYSyeOZGmeUoiubOt2CgTOdG3feK7vfO/jMtlvSCwaj8jDBBloOp9QaHJKpaaO0Wy2yu3+rkat2Oktm23Ls3rNVjmUj7Z8bo3DX/i8HuXe+/+AETQNEoSBh4gcHwsJACH5BAUAAAcALAAAAACWAA0AAANseHrV/jDKSau9OOsd1+JgKI5k2Slmqq4siDpGLM90bd94ru987/+zBwMGLBqPyKTSIFEGntCodEqtRpfYbC3itHq/Vq04y02Cz+jAeJ1sst/wuE74kNvvb+Gwxe/7TR9/goOEEh4vhYmKKh4JACH5BAUAAAcALBoABQA8AAMAAAMUaLrcHTDKSauVLufLO9fg4o1kkAAAIfkEBQAABwAsLgAFADwAAwAAAxRoutwdMMpJq5Uu58s71+DijWSQAAAh+QQFAAAHACxCAAUAPAADAAADFGi63B0wykmrlS7nyzvX4OKNZJAAACH5BAUAAAcALAAAAACWAA0AAAN0eHow/jDKSau9OOvNIVhLJ45kaZ5SiK5s63YKZMx0bd94ru987//AYA1ykAmPyKRyyTRMmtBoNECtWq/YrNZKk0i/YOF2TB53I+G0OlduuwNn9HpOr8cHxYd9z48S8y+BgoMoKoSHiIkpIAwTDYqQkR0fCwkAIfkEBQAABwAsAAAAAJYADQAAA2Z4etT+MMpJq7046x3X4mAojmTZKWaqriyIOl4sz3Rt33iu77z9MLCecEgsGo9ACHLJZBqe0KhUejw1r9jddLutKrPg8IxLhnq/4rR6/WokCey4nPl7t+74POmj7/v/EjKAg4QsHgkAIfkEBSgABwAsAAAAAJYADQAAA154etL+MMpJq7046x3X4mAojmTZKWaqriyIOkYsz3Rt33iu73zv/7MHAwYsGo/IpNIgWTqf0GgvIq1ar0kqdsvt0presBgqfIzPaKBw2Gq736YPfE6vSzwvu36v8iQAACH5BAUAAAcALAAAAACWAA0AAANjeHrU/jDKSau9OOsd1+JgKI5k2Slmqq4siDpeLM90bd94ru+8/TCwnnBILBqPQAhyyWwiA9CodPpROq/Y7GzKlVZ/2rCY2S1/weO0WvtDr99wIrhFr9tV57t+z3e/+oCBeAsJACH5BAUAAAcALAAAAACWAA0AAANpeHow/jDKSau9OOvNIVhLJ45kaZ5SiK5s63YKBM50bd94ru987+My2W9ILBqPyMMkyWw6QYGodEqlDlPPrHZY7Xavka14jPOapeAwec1mBx/tuLwpfNnveJYqz+/7sSANEoJ/hYYcHwsJACH5BAUAAAcALAAAAACWAA0AAANteHrV/jDKSau9OOsd1+JgKI5k2Slmqq4siDpGLM90bd94ru987/+zBwMGLBqPyKTSIFk6n7yAdEqtWq9Y6i8C7Xpn2bA4vIV8z9Cxeh0om9HwuNwmfMzveK9w2Or7/yYfgIOEhRIeL4aKiyoeCQAh+QQFAAAHACxHAAUAPAADAAADFBi63P6QmUmrtTHrfHvfYBh4JJUAACH5BAUAAAcALDMABQA8AAMAAAMUGLrc/pCZSau1Met8e99gGHgklQAAIfkEBQAABwAsHwAFADwAAwAAAxQYutz+kJlJq7Ux63x732AYeCSVAAAh+QQFAAAHACwAAAAAlgANAAADdHh6MP4wykmrvTjrzSFYSyeOZGmeUoiubOt2CmTMdG3feK7vfO//wGANcpAJj8ikcsk0THKBqHRKrVqv06Z2q5RAseAwlksu97w4sXodMLvftCd8Tq/HH8WHfc/fEvMvgYKDKCqEh4iJKSAMEw2KkJEdHwsJACH5BAUAAAcALAAAAACWAA0AAANqeHrU/jDKSau9OOsd1+JgKI5k2Slmqq4siDpGLM90bd94ru987/+zBwMGLBqPyKTSIJEFntCodBpdWq/YXsRJ7Xqz4DB4G/Oap+K0+thcu99v4QNOr1+Fw5Z+zzd9+oCBghIeL4OHiCoeCQAh+QQFFAAHACwAAAAAlgANAAADXnh60v4wykmrvTjrHdfiYCiOZNkpZqquLIg6RizPdG3feK7vfO//swcDBiwaj8ik0iBZOp/QaC8irVqvSSp2y+3Smt6wGCp8jM9ooHDYarvfpg98Tq9LPC+7fq/yJAAAOw==);
    border: 0;
    width: 150px;
    height: 13px;
  }
  .tui-grid-layer-editing {
    position: absolute;
    background: #fff;
    z-index: 15;
    padding: 0 4px;
    border-style: solid;
    border-width: 1px;
    white-space: nowrap;
    box-sizing: border-box;
  }
  .tui-grid-layer-editing textarea {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    padding: 3px 10px;
    box-sizing: border-box;
    white-space: normal;
    word-break: break-all;
    overflow: hidden;
  }
  .tui-grid-layer-focus-border {
    position: absolute;
    overflow: hidden;
    z-index: 15;
  }
  .tui-grid-layer-selection {
    position: absolute;
    top: 0;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 1px;
    opacity: 0.1;
    filter: alpha(opacity=10);
  }

  .tui-grid-table {
    margin: 0;
    width: 1px;
    box-sizing: border-box;
    table-layout: fixed;
    border-collapse: collapse;
    border: 1px hidden transparent;
    border-bottom: none;
  }
  .tui-grid-lside-area .tui-grid-table {
    width: 100%;
  }
  .tui-grid-cell {
    border-width: 1px;
    border-style: solid;
    white-space: nowrap;
    padding: 0;
    overflow: hidden;
  }
  .tui-grid-cell .tui-grid-cell-content {
    padding: 12px 12px 11px;
    overflow: hidden;
    box-sizing: border-box;
    word-break: break-all;
  }
  .tui-grid-cell img {
    vertical-align: middle;
  }
  .tui-grid-cell-header {
    padding: 4px 5px;
    text-align: center;
    /* @TODO: box-sizing standardize required */
    box-sizing: border-box;
  }
  .tui-grid-cell-summary {
    padding: 0 12px;
  }
  .tui-grid-cell-disabled input[type="text"],
  .tui-grid-cell-disabled input[type="password"] {
    opacity: 0.3;
    filter: alpha(opacity=30);
  }
  .tui-grid-cell-ellipsis .tui-grid-cell-content {
    text-overflow: ellipsis;
  }
  .tui-grid-cell-has-input .tui-grid-cell-content {
    padding: 4px 5px;
  }
  .tui-grid-cell-has-tree {
    height: inherit;
    box-sizing: border-box;
  }
  .tui-grid-cell-has-tree .tui-grid-cell-content {
    padding-left: 14px;
  }
  .tui-grid-cell-content .tui-grid-content-before {
    float: left;
    margin-right: 2px;
    line-height: 1.5;
  }
  .tui-grid-cell-content .tui-grid-content-after {
    float: right;
    margin-left: 2px;
    line-height: 1.5;
  }
  .tui-grid-cell-content .tui-grid-content-input {
    display: block;
    overflow: hidden;
    line-height: 1.5;
    *margin-left: -2px;
    *padding-left: 2px;
  }
  .tui-grid-cell-content input[type="text"],
  .tui-grid-cell-content input[type="password"] {
    width: 100%;
    padding: 6px 7px;
    border: solid 1px #ddd;
  }
  .tui-grid-cell-content label + input {
    margin-left: 10px;
  }
  .tui-grid-cell-content select:not(.tui-time-picker-select) {
    box-sizing: border-box;
  }
  .tui-grid-column-resize-container {
    display: none;
    position: relative;
    width: 0;
  }
  .tui-grid-column-resize-handle {
    float: left;
    position: absolute;
    bottom: 1px;
    left: -99px;
    width: 7px;
    background: #000;
    opacity: 0;
    filter: alpha(opacity=0);
    cursor: col-resize;
  }
  .tui-grid-column-resize-handle-last {
    width: 3px;
  }
  .tui-grid-border-line {
    position: absolute;
    z-index: 15;
  }
  .tui-grid-border-line-top {
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
  }
  .tui-grid-border-line-left {
    top: 0;
    bottom: 17px;
    left: 0;
    width: 1px;
  }
  .tui-grid-border-line-right {
    top: 0;
    bottom: 0;
    right: 0;
    width: 1px;
  }
  .tui-grid-border-line-bottom {
    bottom: 0;
    left: 0;
    right: 17px;
    height: 1px;
    z-index: 10;
  }
  .tui-grid-no-scroll-x .tui-grid-border-line-left {
    bottom: 0;
    right: 0;
  }
  .tui-grid-no-scroll-y .tui-grid-border-line-bottom {
    right: 0;
  }
  .tui-grid-content-area {
    position: relative;
    border-style: solid;
    border-width: 0 0 1px;
  }
  .tui-grid-content-area.tui-grid-no-scroll-x {
    border-bottom-width: 0;
  }
  .tui-grid-header-area {
    border-style: solid;
    border-width: 0 0 1px;
    position: relative;
    overflow: hidden;
  }
  .tui-grid-header-area .tui-grid-table {
    border-top-style: solid;
  }
  .tui-grid-body-area {
    border-style: solid;
    border-width: 0;
    position: relative;
    overflow: scroll;
  }
  .tui-grid-has-summary-top .tui-grid-body-area {
    margin-top: -17px;
    border-top-width: 1px;
  }
  .tui-grid-no-scroll-x.tui-grid-has-summary-top .tui-grid-body-area {
    margin-top: 0;
  }
  .tui-grid-summary-area {
    position: relative;
    margin-top: -18px;
    border-top: 1px solid;
    overflow-y: hidden;
    overflow-x: scroll;
  }
  .tui-grid-no-scroll-x .tui-grid-summary-area {
    margin-top: -1px;
    margin-bottom: 1px;
    overflow-x: hidden;
  }
  .tui-grid-no-scroll-x .tui-grid-summary-area-right {
    bottom: 0;
  }
  .tui-grid-no-scroll-x.tui-grid-has-summary-top {
    margin-top: 0;
  }
  .tui-grid-has-summary-top .tui-grid-summary-area {
    margin-top: 0;
    border-top-style: hidden;
    margin-bottom: 0;
  }
  .tui-grid-lside-area {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    overflow: hidden;
    z-index: 5;
  }
  .tui-grid-lside-area .tui-grid-body-area {
    margin-right: -17px;
  }
  .tui-grid-lside-area .tui-grid-body-area .tui-grid-selection-layer {
    left: 1px;
  }
  .tui-grid-rside-area {
    display: none;
    overflow: hidden;
  }
  .tui-grid-rside-area .tui-grid-header-area,
  .tui-grid-rside-area .tui-grid-summary-area {
    margin-right: 17px;
  }
  .tui-grid-rside-area .tui-grid-frozen-border-top {
    position: absolute;
    top: 0;
  }
  .tui-grid-rside-area
    .tui-grid-frozen-border-top
    .tui-grid-column-resize-handle {
    top: 0;
  }
  .tui-grid-rside-area .tui-grid-frozen-border-bottom {
    position: absolute;
    bottom: 0;
    height: 17px;
  }
  .tui-grid-no-scroll-y .tui-grid-rside-area .tui-grid-header-area,
  .tui-grid-no-scroll-y .tui-grid-rside-area .tui-grid-summary-area {
    margin-right: 0;
  }
  .tui-grid-body-container {
    position: relative;
    margin-top: -1px;
  }
  .tui-grid-table-container {
    position: absolute;
  }
  .tui-grid-scrollbar-right-top {
    display: block;
    position: absolute;
    top: 0;
    right: 0;
    width: 16px;
    border-style: solid;
    border-width: 0 1px 1px 1px;
    z-index: 10;
  }
  .tui-grid-scrollbar-left-bottom {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    height: 17px;
    border-style: solid;
    border-width: 0 1px;
    z-index: 10;
  }
  .tui-grid-scrollbar-right-bottom {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 16px;
    border-style: solid;
    border-width: 1px 1px 0 1px;
    z-index: 10;
  }
  .tui-grid-no-scroll-x .tui-grid-scrollbar-right-bottom {
    height: 0;
  }
  .tui-grid-no-scroll-x.tui-grid-has-summary-bottom
    .tui-grid-scrollbar-right-bottom {
    border-bottom-width: 1px;
  }
  .tui-grid-no-scroll-y .tui-grid-scrollbar-right-bottom {
    width: 0;
    height: 16px;
    border-left: 0;
  }
  .tui-grid-scrollbar-y-inner-border {
    display: block;
    position: absolute;
    right: 17px;
    width: 1px;
    z-index: 10;
  }
  .tui-grid-scrollbar-y-outer-border {
    display: block;
    position: absolute;
    top: 0;
    bottom: 0;
    right: 0;
    width: 1px;
    z-index: 10;
  }
  .tui-grid-scrollbar-frozen-border {
    position: absolute;
    bottom: 0;
    width: 0;
    height: 17px;
    border-style: solid;
    border-width: 0 1px 0 0;
    z-index: 10;
  }
  .tui-grid-frozen-border {
    position: absolute;
    top: 0;
    bottom: 0;
    z-index: 5;
  }
  .tui-grid-height-resize-handle {
    overflow: hidden;
    background-color: #fff;
    cursor: row-resize;
    height: 17px;
    border-style: solid;
    border-width: 0 1px 1px;
    border-color: #fff;
    font-size: 0;
    text-align: center;
  }
  .tui-grid-height-resize-handle button {
    display: block;
    width: 100%;
    cursor: row-resize;
    padding: 0;
    margin: 0;
    outline: 0;
    border: 0;
    background: transparent;
  }
  .tui-grid-height-resize-handle button span {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=)
      no-repeat -39px -10px;
    display: inline-block;
    width: 16px;
    height: 17px;
  }
  .tui-grid-btn-tree {
    position: absolute;
    padding: 0;
    padding-left: 4px;
    margin-top: -8px;
    top: 50%;
    width: 15px;
    height: 15px;
    background: transparent;
    border: none;
    outline: none;
    font-size: 0;
    vertical-align: middle;
    cursor: pointer;
  }
  .tui-grid-tree-icon {
    position: absolute;
    margin-top: -7px;
    top: 50%;
    width: 22px;
    height: 14px;
    font-size: 0;
    vertical-align: middle;
  }
  .tui-grid-tree-icon i {
    display: inline-block;
    margin-left: 5px;
    width: 14px;
    height: 14px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=)
      no-repeat -14px -35px;
  }
  .tui-grid-tree-button-collapse .tui-grid-btn-tree i {
    background-position: -43px -61px;
    width: 8px;
    height: 11px;
  }
  .tui-grid-tree-button-collapse .tui-grid-tree-icon i {
    margin-left: 4px;
    background-position: -39px -35px;
    width: 14px;
    height: 14px;
  }
  .tui-grid-tree-button-expand .tui-grid-btn-tree i {
    margin-top: 2px;
    background-position: -15px -63px;
    width: 11px;
    height: 8px;
  }
  .tui-grid-tree-button-expand .tui-grid-tree-icon i {
    margin-left: 4px;
    background-position: -65px -35px;
    height: 14px;
    width: 14px;
  }
  .tui-grid-tree-wrapper-relative {
    position: relative;
    margin: -1px 0;
  }
  .tui-grid-tree-wrapper-valign-center {
    vertical-align: middle;
  }
  .tui-grid-tree-extra-content {
    position: absolute;
    margin-left: 4px;
    top: 0;
    left: 0;
    bottom: 0;
  }
  .tui-grid-tree-depth {
    display: inline-block;
    position: absolute;
    width: 22px;
    top: 0;
    bottom: 0;
  }
  .tui-grid-tree-depth i {
    display: inline-block;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=)
      no-repeat;
  }

  .tui-grid-row-hidden .tui-grid-cell {
    display: none;
  }

  .tui-grid-row-header-checkbox {
    padding: 4px 5px;
  }

  .tui-grid-filter-container {
    width: 220px;
    padding: 8px;
    border: 1px solid #ccc;
    box-sizing: border-box;
    background-color: #fff;
    position: absolute;
    top: 0;
    z-index: 100;
    left: 68px;
  }

  .tui-grid-filter-container .tui-grid-btn-filter,
  .tui-grid-btn-close {
    margin-bottom: 6px;
  }

  .tui-grid-filter-dropdown {
    box-sizing: border-box;
    margin: 2px 7px;
    height: 29px;
    width: 190px;
    border: 1px solid #ddd;
  }

  .tui-grid-filter-dropdown select {
    height: 100%;
    width: 100%;
    font-size: 13px;
    color: #333;
    border: none;
    background-color: #fff;
    cursor: pointer;
  }

  .tui-grid-filter-dropdown select:focus {
    outline: none;
  }

  .tui-grid-filter-container .tui-grid-filter-input {
    margin: 2px 7px;
    padding: 8px 7px;
    font-size: 13px;
    color: #333;
    border: 1px solid #ddd;
    width: 190px;
    height: 29px;
  }

  .tui-grid-filter-input::placeholder {
    color: rgba(51, 51, 51, 0.3);
  }

  .tui-grid-filter-comparator-container {
    margin: 2px 0;
    padding: 8px;
  }

  .tui-grid-filter-comparator {
    display: inline-block;
    margin-right: 8px;
  }

  .tui-grid-filter-comparator label {
    cursor: pointer;
  }

  .tui-grid-filter-comparator span {
    font-size: 12px;
    color: #333;
    vertical-align: middle;
  }

  .tui-grid-filter-comparator label::before {
    content: " ";
    margin-right: 4px;
    display: inline-block;
    width: 14px;
    height: 14px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -113px -35px;
    vertical-align: middle;
  }

  .tui-grid-filter-comparator-checked label::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -89px -35px;
  }

  .tui-grid-filter-comparator input[type="radio"] {
    display: none;
  }

  .tui-grid-filter-list-container .tui-grid-filter-list {
    margin: 4px 0;
    border-top: 1px solid #eee;
    border-bottom: 1px solid #eee;
    max-height: 272px;
    overflow-y: scroll;
  }

  .tui-grid-filter-list-container .tui-grid-filter-list-item {
    color: #333;
  }

  .tui-grid-filter-list-item input[type="checkbox"] {
    display: none;
  }

  .tui-grid-filter-list-item label {
    cursor: pointer;
    display: block;
    padding: 9px 8px;
  }

  .tui-grid-filter-list-item label::before {
    content: " ";
    margin-right: 6px;
    display: inline-block;
    width: 14px;
    height: 14px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -37px -118px;
    vertical-align: middle;
  }

  .tui-grid-filter-list-item-checked label::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -13px -118px;
  }

  .tui-grid-filter-list-item label span {
    font-size: 13px;
    max-width: 152px;
    word-break: break-all;
    word-wrap: break-word;
    vertical-align: middle;
  }

  .tui-grid-filter-list .tui-grid-filter-list-item-checked {
    background-color: #e5f6ff;
  }

  .tui-grid-filter-btn-container {
    margin: 4px 5px;
    text-align: right;
  }

  .tui-grid-filter-btn {
    box-sizing: border-box;
    color: #fff;
    font-size: 13px;
    height: 29px;
    width: 50px;
    border-radius: 2px;
    margin-left: 4px;
    cursor: pointer;
  }

  .tui-grid-filter-btn-apply {
    background-color: #00a9ff;
    border: 1px solid #00a9ff;
  }

  .tui-grid-filter-btn-apply:hover {
    background-color: #0088d9;
    border: 1px solid #0088d9;
  }

  .tui-grid-filter-btn-clear {
    background-color: #777777;
    border: 1px solid #777777;
  }

  .tui-grid-filter-btn-clear:hover {
    background-color: #5a6268;
    border-color: #545b62;
  }

  /* input datepicker icon */
  .tui-grid-datepicker-input-container {
    position: relative;
  }

  .tui-grid-datepicker-input-container input.tui-grid-datepicker-input {
    padding: 6px 27px 6px 7px;
  }

  .tui-grid-date-icon {
    position: absolute;
    width: 14px;
    height: 14px;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/tJREFUeAHtnX9oVtcZx899kzhrNaTSaDeIdrpCayy1xoBdZJh2CPljbmiT4EQNG/jHwG2MMgcDkxTi5hilVrY/xA2rbpJk+of7IyjrXMEaWI2zjNjBqtRGRtXRlMRm3aJ5931u7jE3N/fe9/58k/f6vXBzznnOc55zzuc+Oefc8977vkrxIAESIAESIAESIAESIAESIAESIAESIAESIIG5T8CY+00sbgvzDQ2L7g0Pv5LP5zcDzlek9rxSHxiGcab8scd+abzzzmhxW1SatdGxbNdtvLb2xfzExG9VPr/cJp6KGsYNI5f7TsXg4J+nhIy5EaBjWVTEqdT9+3/C6OTLBJl5VVb29TjOtW3btsfv3bt3rLy8fOfJkyf/7XZhwsrSsHnp0qXHMVIfw+i9c926daHamQvbgSzqy/QnI5XTqSref1/JaT9Ex9RFGbs8aLy5ufkRONUZ6DdJKOmgZb300rA5NDT0iEz/cKomCSXtVb+bnI4FKrKm8pz+3KhhqjTLuOX5yDo6OoT3CZwvWGoSnrDklihckIZNOFPu9u3bJxCa7ZTQSgf2l8CK4bpbWtoYgb4ZtsWAvTlsmcHBwddQZouj3BZL7hAHS6Zh8/Lly6+hf9PaKWmRB2tVgfWEl5Genh7MCNGPlpYW33WMtrx3795Y9Rw4cCBQPePPPDMKcAt1vTrU0yDytehBiOnhLvIjTYcPjGQ4Egh8hvtvdo2OlfwVLo9iMmsjFobFD8BhjZOF20ildawyOsnQQYAjFoCMr1rViXXWPgebB3eEbg6G/axXK65ebXeWYXqSAEcscJAd9fFPPtkV+M4QG6VSJqwTYVvgdZT5gUu5g729vT90kRcUDQwMvI714QybWAMerKuri2QziXZyxLIuXTE2SGVrAHdxvajSfsd1ura2thl5EwW9yEUBTpXD3Vqv3LXpbDjV6bVr1zYjjGQziXbSsfTVQFiMj3SsDdG3UJ3sEfXjfAmj1X8QRj5k8xL7TG/BuV6AM/UvWbLkpZqamlg247aT+1i2yykf01QsXvysrJ8gfg8X6a6cyjCumGsq5MX5KEeqEifCRzmyB9YnYVynEpviRHCqzWhrn4RxnUpsptFOscuDBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEITiPzYDF5m9H3R4c6dO39pampqDN0ie4HuvHsdOdWimg15rimZ4/vn3esxjBZ1cGNy9aC1eKx7IZ5C+HFZWVnL/fv3l0sHEL+BeA+eTPgFXjS5G6dTadsP2rbUHOv69etq0aJF8ZzLy7EMdQcdrFUthoTxDy/HUrD/aK5W/exridSDi/4inOh3eKylauXKlfMrKyvNto+MjKhr1659jueqPoWDbYdzRXqFP237YUCn+jzW6Ojoxr6+vvNhGhRIN6+qoferQLqxlPLVamwikXrkos+bN+/Mhg0bnqivr5+/ePFiheexzFPiIpM80RHdsM1O237Y9qQ6YunGRB65vEYsbdgrbDXC9curno8+VGoIp9fxRmOgenDRF2Kk+qc4Dp7u9LJmyvEkqLpw4cLHGLmeCjotpm3ft8EemamNWCtWrFD6rK6u3uhR/9wWL3sSj2fijHnImkqmP+1U/8OT6D/5u1Jf+uPkKXGRySE6oitlJiWF/zrt+5WIYt/PnldepLd0vIxlUi7OJafb8YabcKYMo1WrrKl0zr5BpQ7YvmtEx3/+7KSG6N68ebMFqX26jF/otO+nK3lh7Rey55af2ojlVtnDKsO0tkwv1IXBsQ9nkrDLRBdlls/Ucpc47btrTUnD2p8qGTxGxwrOipohCNCxQsCKqoqp6oZsKehj55M6NhXaZaIrZaZy/WNO+/7aSoW1X8ieWz4dy41KwjJMVT2yT6XNvlqr1F58gc0X8VVmckpcZPoQXSmj04VCp/1C+mHtF7Lnlk/HcqOSsEx21GXzU7YS5JgH6rJQ/9c3Jk+Ji0wO0RFdKTMpKfzXad+vRBT7fva88uhYXmQSlMt+FEaV7f39/Z9p53IzL3miI7pB97DETtr23dpaSBZog8/NSKHPCp1l8OWo4evy2rh0Gnemk9ogddp1pkPWI7vjWA89FB/phL/YFlw6FkCEdCxBJ7vk1ofQrRiZlolMFt+yTkr4Q+hU7Et7eZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZAACZBAJgjgS+1n/JBSJjqWwU6UlVKfVq9e/RF+HiTX0NBwEb8hY70wVUo9eHjaGvmxGRPR6fxzaly9i3iFD7Jx5NarLcZ7PjqBsjBi5S3FK7lcrq27uzu2zUAVp6S0Z8+eL9y6des3S5cu/e6hQ4f+m1I1s2I23nuF4iy9+S41oTo8W59TXUk4lcP+Gjy79C6enOyqqqraf/jw4XFHfuQkbP4etrc5DeAZqpN4lurbTnmcNJyqC3VtR/gx7LwSx9ZcKxv/0eQvq/3KUFdcOyZyyU/hwAWpwNkxPDz819bW1ueSqmLBggXfgxMN2e1JWuR2Wdw4HLgR7f+R2JFQ0nFtzqXy8R1rnTGuylUbOuUcNSblkp/usWZiYuIipslVSVRz9OjRT2FnF0497Uq4y5InUYVqa2urgqE3ceqliIRvWvJE6phtI/EdS3ogU6JMefYjnSnQXoMZx2gi66wG/FrV1RmZEQWY8s7DrvmL7RJKOqIp12JjY2O/xihVY8+UtMjtslKOx1tj2XsuU9519S38n68xp8aUpkBdJS64jIT7scbqSnKNpe1jQf1TrH2ekFDLkgqttVqi67Wk2paUHT0UJ2NP7hLvqYuYGr+awoJd6btCGaXwH96GUcp9bZdMb2glBoFkpkLdgMkthUS2FrRJeyijFM5OjFL1dCo7GcZjEeDOeyx8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACpUYg2bd00Hv9Jk0hEHgZIvG6p9UZ9Hd4IvxsybR6AiZ27969AK+pjTnVveROvVJLJ/uWDnovb9EUghBEp5CNAPkF2wEbQXQCVOWvgtfnza8CwD9dtV1T0vIVAZJvl2chnrhj4WXMDj/HkTzRSR1eqyF1+DlOJ35kKfV27Nix41G8A/ky2iI/dXleO5cVyhvWtZIvIxfimTmMtHoi/4UA1m63XzSnslfane9Aclo7kC6KU+lm2J0IskF818TL+BqmPyAuzobftFeNWBrcQZiZIzXHEkJ255oVp9KXabpzFdWpdBMcziU/4zsfZyadSvqcqmNJBQCalzD1xbpU4nfoxXyRFutuTdm6devTGKn+hjxxqs8xcj1/6tSpf7jplros8TVWqQNJq/0yYlnTn+lUqGe+pK2RLK1qZ80uHasI6B3ToKyxnke1Mg1OW9AXoSlFq4KOlTJquStEFebdH0JzTWVNf41W2nSurN0VFsOx3sZvHgvE2T0M9Ta+HK7o7Th+/PhnuHGRO8BpC3XrLtB0Lsl32zydXWCsvSQIeI1I1ohWEn1gI0mABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABIpPwIhSJV44Nd+8CVsWr4MFqi9t+2HbTf3wBCL/dC9eEAhVGx7FDaWftv26urpQ/xwDAwOB/ilCdTLDysV45j3D+Ng1LwKpOdbIyIg6d+6cV72UZ5xA5KnQj4s4VWdnpxoaGjLVNm3a5Kc+a3lBp7ew0+asdWgOVRx7xJJRSRxJH3anqqmpUevXr9dZDB8iArEcS5zqyJEj5ugkDuV0qvb2dlVZWVkyOGVk0qOTPV4yHZhDDY01FcpodPbsWXPKk6lPDpn+ZKQqNaeaQ9ckE02J5VgyGokD2ddTpexU9jWXPZ6JK13kTsSaCqWt2rnEoUrRqexTnle8yNckE9XFGrE0Ae1cki6lNZVuP8PkCSTiWNKsUnUo+5TnFU8ee/YtJuZYpYhK3wGWYtvnepsjO1bYz/7Cgkjbvn10Cts26pMACZAACZAACZAACZAACZAACZAACZAACZAACWSDwP8B9X0BfshR6QsAAAAASUVORK5CYII=)
      no-repeat -61px -118px;
    top: 45%;
    right: 10px;
    margin: -6px 0 0 0;
    cursor: pointer;
  }

  /* editor ui */
  .tui-grid-layer-editing-inner {
    box-sizing: border-box;
  }

  .tui-grid-editor-select-box-layer {
    position: absolute;
    z-index: 100;
  }

  .tui-grid-editor-select-box-layer * {
    box-sizing: border-box;
  }

  .tui-grid-editor-select-box-layer li {
    padding: 0 8px;
  }

  .tui-select-box-input {
    outline: none;
  }

  .tui-grid-editor-checkbox-list-layer {
    position: absolute;
    background-color: #fff;
    border: 1px solid #aaa;
    z-index: 100;
  }

  .tui-grid-editor-checkbox-list-layer * {
    box-sizing: border-box;
  }

  .tui-grid-editor-checkbox-list-layer .tui-grid-editor-checkbox {
    height: 32px;
    line-height: 32px;
  }

  .tui-grid-editor-checkbox-hovered {
    background-color: #e5f6ff;
  }

  .tui-grid-editor-checkbox input[type="checkbox"],
  .tui-grid-editor-checkbox input[type="radio"] {
    position: absolute;
    opacity: 0;
    cursor: pointer;
  }

  .tui-grid-editor-checkbox label {
    display: inline-block;
    cursor: pointer;
    width: 100%;
    height: 100%;
    margin: 0 7px;
  }

  .tui-grid-editor-checkbox label:before {
    content: " ";
    margin-right: 6px;
    display: inline-block;
    width: 14px;
    height: 14px;
    vertical-align: middle;
  }

  .tui-grid-editor-checkbox label span {
    display: inline-block;
    font-size: 12px;
    color: #333;
    vertical-align: middle;
  }

  .tui-grid-editor-label-icon-checkbox::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -37px -118px;
  }

  .tui-grid-editor-label-icon-checkbox-checked::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -13px -118px;
  }

  .tui-grid-editor-label-icon-radio::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -113px -35px;
  }

  .tui-grid-editor-label-icon-radio-checked::before {
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACMCAYAAACeTFAfAAAAAXNSR0IArs4c6QAAC/1JREFUeAHtnV9sFMcdx2fPNiEEqGPFkFYFUkilhiMKwfghNarspC9+KK0gtkUQYLUSD6loqyoqlSoRE8m0VFUUgsoDUisCtMh24YE++KWJE4lgqcGUqDKpVEAhRlXAVZxi4ib1n+v3d7eD1+vdvf179p6/I61n9je/+c3MZ3+emZ3bvVOKgQRIgARIgARIgARIgARIgARIgARIgARIgATmPwFj/jextC3MNTQsmxgZeSmXy20FnMel9pxS1wzDOF/58MO/Md59d7S0LUpnbXQsy3Ubz2afzU1N/V7lcmss4umkYdw0MpnvVw0OvjUtZMqJAB3LpCJOpSYn/4LRyZMJMnOqouLbUZxrx44dj0xMTJysrKzcfebMmX87XZigsiRsXrp06RGM1Ccxeu/evHlzoHZmgnagHPVl+pORyu5UVR98oOSwBtHJ66KMVe433dLS8iCc6jz0myWWc79l3fSSsDk0NPSgTP9wqmaJ5dytfic5HQtUZE3lOv05UcNUmS/jlOch6+joEN6ncTxjqkl82pSbomBREjbhTJk7d+6cRpxvp8TmuW9/8a0YrLvp0sYI9N2gLQbsrUHLDA4Ovooy22zltplym9jfaRI2L1++/Cr6N6Odci5yf60qsp5wM9Ld3Y0ZIXxobW31XMdoy/v3749Uz+HDh33VM/7EE6MAt1TXq2M9DSJfi+7HmB7uIT/UdHjfSBknfIEv4/7nu0bHiv8KV4YxWW4jFobFa+Cw0c7CaaTSOmYZfcrYRoAjFoCMr19/EOusAzY29+8InRwM+1mvVF29+rK9DM8LBDhigYPsqI9/8ske33eG2CiVMkGdCNsCr6HMjx3KHenp6fmJg7yoaGBg4DWsD2fZxBrwSF1dXSibcbSTI5Z56UqxQSpbA7iL60GV1juuc9lstgV5U0W9yEEBTpXB3VqP3LXpbDjVuU2bNrUgDmUzjnbSsfTVQFyKj3TMDdE3UZ3sEfXjeA6j1X8Rhw6yeYl9pjfhXM/AmfpXrFjx3KpVqyLZjNpO7mNZLqd8TFNVU/OkrJ8gfh8X6Z4cyjCu5NdUyIvyUY5UJU6Ej3JkD6xX4qhOJTbFieBUW9HWXomjOpXYTKKdYpeBBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABEiABAITCP3YDF5m9HzRYXh4+O3m5uamwC2yFujKOdeRUa2qxZDnmuIJP+pzrscwWtWRxvjqQWvxWPdSPIXws4qKitbJyck10gGkbyLdjScTfo0XTe5F6VTS9v22LTHHunHjhlq2bFk053JzLEMNo4NZ1WpIHD24OZaC/YcyWfXLb8VSDy76s3CiP+Cxlup169YtXr58eb7td+/eVdevX/8cz1V9CgfbCecK9Qp/0vaDgE70eazR0dHG3t7eviAN8qWbU7XQ+60v3UhKuVo1NhVLPXLRFy1adH7Lli2P1tfXL66pqVF4Hit/SFpkkic6ohu02UnbD9qeREcs3ZjQI5fbiKUNu8VtRrB+udXz0YdKDeFwC683+aoHF30pRqp/iuPg6U43a3k5ngRVFy5c+Bgj19f9TotJ2/dssEtmYiPW2rVrlT5qa2sbXeqf3+LVj+HxTBwRg6ypZPrTTvU/PIn+878r9ZU/Fw5Ji0yC6IiulClIiv+12/cqEca+lz23vFBv6bgZK0u5OJccTuF1J+FsGUarNllT6ZwDg0odtnzXiE7/6smChujeunWrFWcHdBmv2G7fS1fygtovZs8pP7ERy6myhSrDtLZaL9SFwckPZ5OwykQXZdbM1nKW2O07a01Lg9qfLuk/Rcfyz4qaAQjQsQLACquKqeqmbCnosPsxnZqOrTLRlTLTud4pu31vbaWC2i9mzymfjuVEJWYZpqpu2afSZl/JKrUfX2DzZXyVmRySFpkOoitl9Hmx2G6/mH5Q+8XsOeXTsZyoxCyTHXXZ/JStBAmLQF0W6v/6TuGQtMgkiI7oSpmCpPhfu32vEmHse9lzy6NjuZGJUS77URhVdvb393+mncvJvOSJjuj63cMSO0nbd2prMZmvDT4nI8U+K7SXwZejBq/LbePSbtx+HtcGqd2u/TxgPbI7jvXQgvhIJ/jFNuHSsQAioGMJOtklNz+EbsPItFpksviWdVLMH0InYl/ay0ACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACZUEAX2o/64eUyqJjZdiJijT1acOGDR/h50EyDQ0NF/EbMuYLU2nqwcJpa+jHZvKIzuWeUuPqPaSrPJCNI7debTPe99DxlYURK2cqXslkMu1dXV2RbfqqOCGlffv2PXD79u3frVy58gdHjx79IqFq5sRstPcKxVl6cp1qSnW4tj6jOuNwKpv9jXh26T08OdlZXV196Pjx4+O2/NCnsPlH2N5hN4BnqM7gWaoX7PIo53CqTtS1E/HHsPNSFFvzrWz0R5O/pg4pQ11x7JjIJT+BgAtShaNjZGTkr21tbU/FVcWSJUtehBMNWe3JucitsqhpOHAT2v9TsSOxnEe1OZ/KR3eszca4qlTt6JR91CjIJT/ZsHFqauoipsn1cVRz4sSJT2FnDw497Uq8x5THUYVqb2+vhqE3cOiliMRvmPJY6phrI9EdS3ogU6JMedaQzBRorSGfxmgi66wG/FrV1VmZIQWY8vpgN/+L7RLLeUhTjsXGxsaOYZRaZc2Uc5FbZWlOR1tjWXsuU94N9T38n2/MT40JTYG6SlxwGQkPYY3VGecaS9vHgvoXWPs8KrGWxRWba7VY12txtS0uO3oojsee3CVOqIuYGr+ZwIJd6btCGaXwH96OUcp5bRdPb2glAoF4pkLdgMKWQixbC9qkNZZRCsdBjFL1dCorGaYjEeDOeyR8LEwCJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACJEACaSMQ71s66L1+k6YYCLwMEXvdM+r0+zs8IX62ZEY9Pk/27t27BK+pjdnV3eR2vbSdx/uWDnovb9EUg+BHp5gNH/lF2wEbfnR8VOWtgtfn818FgH+6WqumnMtXBEi+VV4O6dgdCy9jdng5juSJTuLw2gypw8txDuJHlhJvx65dux7CO5DPoy3yU5d92rnMWN6wzkq+jFxIl00wkuqJ/BcC2MtW+yVzKmulXbkOnM5oB85L4lS6GVYngmwQ3zXxPL6G6U9Ii7PhN+1VE5YGw4jLJiTmWELI6lxz4lT6Ms10rpI6lW6CzbnkZ3wX4yhLp5I+J+pYUgGA5iROfLEulXgFvZgv0WLdqSnbt2//BkaqvyFPnOpzjFxPnz179h9OummXxb7GSjuQpNovI5Y5/eWdCvUslnNzJEuq2jmzS8cqAXrbNChrrKdRrUyDMxb0JWhKyaqgYyWMWu4KUUX+7g9xfk1lTn9N5nneucrtrrAUjvUOfvNYIM5tMNQ7+HK4krfj1KlTn+HGRe4AZyzUzbvAvHNJvtPm6dwCY+2pIOA2IpkjWir6wEaSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmUnoARpkq8cJp/8yZoWbwO5qu+pO0HbTf1gxMI/dO9eEEgUG14FDeQftL26+rqAv1zDAwM+PqnCNTJMlYuxTPvZYyPXXMjkJhjDX+h1LHrbtVSXu4EQk+FXmDEqZrexmsp/ylovbjOS3vu8vxOb0Gnzbnr0fypOfKIJaOSOJIOVqfKfgmv2H9V5zBeSAQiOZY41Q8HCqOTOJTdqfoalap9ID04ZWTSo5M1nZ4ezJ+WRpoKZTQ6dq0w5cnUJ0GmPxmp0uZUhdbzb1wEIjmWjEbiQNb1VJqdyrrmsqbjgr2Q7ESaCgWUONdbjYVRKo1OZZ3y3NILySHi6mukEUs3YoXpXLKDmKY1lW4/4/gJxOJY0ixxrjQG65Tnlk5jv+a6zbE51lx3JEz9+g4wTFmW8SYQ2rGCfvbn3YzZuUnbt45Os2unhARIgARIgARIgARIgARIgARIgARIgARIgARIYCEQ+D9RZOqPG2fqIQAAAABJRU5ErkJggg==)
      no-repeat -89px -35px;
  }

  .tui-grid-editor-datepicker-layer {
    margin-top: -4px;
    position: absolute;
    z-index: 100;
  }

  .tui-grid-editor-datepicker-layer * {
    box-sizing: border-box;
  }
`;

    const tuiGridTheme = css `
  .tui-grid-border-line-top {
    border-top: 1px solid var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .tui-grid-no-scroll-x .tui-grid-border-line-bottom {
    border-bottom: 1px solid var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .tui-grid-frozen-border {
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .tui-grid-container ::-webkit-scrollbar {
    background-color: #fff0;
  }
  .tui-grid-container ::-webkit-scrollbar-thumb {
    background-color: var(
      --vuerd-theme-scrollbar-thumb,
      var(--vuerd-color-scrollbar-thumb)
    );
  }
  .tui-grid-container ::-webkit-scrollbar-thumb:hover {
    background-color: var(
      --vuerd-theme-scrollbar-thumb-active,
      var(--vuerd-color-scrollbar-thumb-active)
    );
  }
  .tui-grid-container {
    scrollbar-3dlight-color: var(
      --vuerd-theme-scrollbar-thumb,
      var(--vuerd-color-scrollbar-thumb)
    );
    scrollbar-darkshadow-color: var(
      --vuerd-theme-scrollbar-thumb,
      var(--vuerd-color-scrollbar-thumb)
    );
    scrollbar-track-color: var(
      --vuerd-theme-scrollbar-thumb,
      var(--vuerd-color-scrollbar-thumb)
    );
    scrollbar-shadow-color: var(
      --vuerd-theme-scrollbar-thumb,
      var(--vuerd-color-scrollbar-thumb)
    );
    scrollbar-face-color: var(
      --vuerd-theme-scrollbar-thumb,
      var(--vuerd-color-scrollbar-thumb)
    );
    scrollbar-highlight-color: var(
      --vuerd-theme-scrollbar-thumb,
      var(--vuerd-color-scrollbar-thumb)
    );
    scrollbar-arrow-color: var(
      --vuerd-theme-scrollbar-thumb,
      var(--vuerd-color-scrollbar-thumb)
    );
  }
  .tui-grid-border-line-bottom {
    border-bottom: 1px solid var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .tui-grid-content-area {
    border-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .tui-grid-scrollbar-y-inner-border {
    background-color: #fff0;
  }
  .tui-grid-scrollbar-y-outer-border {
    background-color: #fff0;
  }
  .tui-grid-scrollbar-right-top {
    background-color: #fff0;
    border-color: #fff0;
  }
  .tui-grid-scrollbar-right-bottom {
    background-color: #fff0;
    border-color: #fff0;
  }
  .tui-grid-scrollbar-left-bottom {
    background-color: #fff0;
    border-color: #fff0;
  }
  .tui-grid-scrollbar-frozen-border {
    background-color: #fff0;
    border-color: #fff0;
  }
  .tui-grid-height-resize-handle {
    background-color: #fff0;
    border-color: #fff0;
  }
  .tui-grid-pagination {
    background-color: transparent;
    border-color: transparent;
  }
  .tui-grid-layer-selection {
    background-color: var(--vuerd-theme-focus, var(--vuerd-color-focus));
    border-color: var(--vuerd-theme-focus, var(--vuerd-color-focus));
  }
  .tui-grid-header-area {
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    border-color: var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .tui-grid-body-area {
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .tui-grid-summary-area {
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    border-color: var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .tui-grid-has-summary-top .tui-grid-body-area {
    border-color: var(--vuerd-theme-table, var(--vuerd-color-table));
  }
  .tui-grid-cell {
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    border-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    border-left-width: 0;
    border-right-width: 0;
    border-top-width: 1px;
    border-bottom-width: 1px;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .tui-grid-cell-editable {
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .tui-grid-show-lside-area
    .tui-grid-lside-area
    .tui-grid-header-area
    .tui-grid-table {
    border-right-style: solid;
  }
  .tui-grid-cell-header {
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    border-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    border-left-width: 1px;
    border-right-width: 1px;
    border-top-width: 1px;
    border-bottom-width: 1px;
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .tui-grid-show-lside-area
    .tui-grid-lside-area
    .tui-grid-body-area
    .tui-grid-table {
    border-right-style: hidden;
  }
  .tui-grid-cell-row-header {
    background-color: #fff;
    border-color: #eee;
    border-left-width: 0;
    border-right-width: 0;
    border-top-width: 1px;
    border-bottom-width: 1px;
    color: #333;
  }
  .tui-grid-show-lside-area
    .tui-grid-lside-area
    .tui-grid-summary-area
    .tui-grid-table {
    border-right-style: hidden;
  }
  .tui-grid-cell-summary {
    background-color: #fff;
    border-color: #eee;
    border-left-width: 0;
    border-right-width: 0;
    color: #333;
  }
  .tui-grid-cell-required {
    background-color: #fffdeb;
  }
  .tui-grid-cell-disabled {
    background-color: #f9f9f9;
    color: #c1c1c1;
  }
  .tui-grid-cell-invalid.tui-grid-cell {
    background-color: #ffe5e5;
  }
  .tui-grid-cell-header.tui-grid-cell-selected {
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    color: var(--vuerd-theme-font, var(--vuerd-color-font));
  }
  .tui-grid-cell-row-header.tui-grid-cell-selected {
    background-color: #e5f6ff;
  }
  .tui-grid-layer-focus-border {
    background-color: var(--vuerd-theme-focus, var(--vuerd-color-focus));
  }
  .tui-grid-layer-editing {
    border-color: var(--vuerd-theme-focus, var(--vuerd-color-focus));
    background-color: var(--vuerd-theme-table, var(--vuerd-color-table));
    padding: 0;
    border: none;
  }
  .tui-grid-layer-focus-deactive .tui-grid-layer-focus-border {
    background-color: #aaa;
  }
  .tui-grid-cell-dummy {
    background-color: #fff;
  }

  .tui-grid-layer-state {
    background-color: var(
      --vuerd-theme-table,
      var(--vuerd-color-table)
    ) !important;
  }
  .tui-grid-layer-state p {
    color: var(--vuerd-theme-font, var(--vuerd-color-font)) !important;
  }
`;

    const Layout = css `
  ${monokaiSublime}
  ${tuiGrid}
  ${tuiGridTheme}
  ${vuerd}
`;
    const ratioWidth = 16;
    const ratioHeight = 9;
    const defaultWidth = 1200;
    const defaultHeight = (defaultWidth / ratioWidth) * ratioHeight;

    /**
     * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
     * https://developer.mozilla.org/ko/docs/Web/API/KeyboardEvent/key/Key_Values
     * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
     * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values
     */
    const moveKeys = [
        "ArrowUp",
        "ArrowRight",
        "ArrowDown",
        "ArrowLeft",
    ];
    function createKeymap() {
        return {
            edit: [
                {
                    metaKey: false,
                    ctrlKey: false,
                    altKey: false,
                    shiftKey: false,
                    key: "Enter",
                },
            ],
            stop: [
                {
                    metaKey: false,
                    ctrlKey: false,
                    altKey: false,
                    shiftKey: false,
                    key: "Escape",
                },
            ],
            find: [
                {
                    metaKey: false,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "F",
                },
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: true,
                    shiftKey: false,
                    key: "F",
                },
            ],
            undo: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: false,
                    shiftKey: false,
                    key: "Z",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: false,
                    shiftKey: false,
                    key: "Z",
                },
            ],
            redo: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: false,
                    shiftKey: true,
                    key: "Z",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: false,
                    shiftKey: true,
                    key: "Z",
                },
            ],
            addTable: [
                {
                    metaKey: false,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "N",
                },
            ],
            addColumn: [
                {
                    metaKey: false,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "Enter",
                },
            ],
            addMemo: [
                {
                    metaKey: false,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "M",
                },
            ],
            removeTable: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: false,
                    shiftKey: false,
                    key: "Delete",
                },
            ],
            removeColumn: [
                {
                    metaKey: false,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "Delete",
                },
            ],
            primaryKey: [
                {
                    metaKey: false,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "K",
                },
            ],
            selectAllTable: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: true,
                    shiftKey: false,
                    key: "A",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "A",
                },
            ],
            selectAllColumn: [
                {
                    metaKey: false,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "A",
                },
            ],
            copyColumn: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: false,
                    shiftKey: false,
                    key: "C",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: false,
                    shiftKey: false,
                    key: "C",
                },
            ],
            pasteColumn: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: false,
                    shiftKey: false,
                    key: "V",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: false,
                    shiftKey: false,
                    key: "V",
                },
            ],
            relationshipZeroOneN: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: true,
                    shiftKey: false,
                    key: "1",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "1",
                },
            ],
            relationshipZeroOne: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: true,
                    shiftKey: false,
                    key: "2",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "2",
                },
            ],
            relationshipZeroN: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: true,
                    shiftKey: false,
                    key: "3",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "3",
                },
            ],
            relationshipOneOnly: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: true,
                    shiftKey: false,
                    key: "4",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "4",
                },
            ],
            relationshipOneN: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: true,
                    shiftKey: false,
                    key: "5",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "5",
                },
            ],
            relationshipOne: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: true,
                    shiftKey: false,
                    key: "6",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "6",
                },
            ],
            relationshipN: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: true,
                    shiftKey: false,
                    key: "7",
                },
                {
                    metaKey: true,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "7",
                },
            ],
            tableProperties: [
                {
                    metaKey: false,
                    ctrlKey: true,
                    altKey: false,
                    shiftKey: false,
                    key: "Space",
                },
                {
                    metaKey: false,
                    ctrlKey: false,
                    altKey: true,
                    shiftKey: false,
                    key: "Space",
                },
            ],
        };
    }
    const multipleKeys = [
        "altKey",
        "metaKey",
        "ctrlKey",
        "shiftKey",
    ];
    function keymapMatch(event, keymapOptions) {
        let result = false;
        for (const keymapOption of keymapOptions) {
            const isMultipleKey = !multipleKeys.some((multipleKey) => !(keymapOption[multipleKey] === event[multipleKey]));
            if (keymapOption.key) {
                result =
                    isMultipleKey &&
                    (event.key.toUpperCase() === keymapOption.key.toUpperCase() ||
                        event.code.toUpperCase() === keymapOption.key.toUpperCase() ||
                        event.code.toUpperCase() === `Key${keymapOption.key}`.toUpperCase() ||
                        event.code.toUpperCase() ===
                        `Digit${keymapOption.key}`.toUpperCase());
            }
            else {
                result = isMultipleKey;
            }
            if (result) {
                break;
            }
        }
        return result;
    }
    function keymapOptionToString(keymapOption) {
        if (!keymapOption)
            return "";
        const result = [];
        if (keymapOption.metaKey) {
            result.push("Cmd");
        }
        if (keymapOption.ctrlKey) {
            result.push("Ctrl");
        }
        if (keymapOption.altKey) {
            result.push("Alt");
        }
        if (keymapOption.shiftKey) {
            result.push("Shift");
        }
        if (keymapOption.key) {
            result.push(keymapOption.key);
        }
        return result.join(" + ");
    }
    function keymapOptionToStringJoin(keymapOptions) {
        return keymapOptions.map((option) => keymapOptionToString(option)).join(", ");
    }

    function createWindowEventObservable() {
        const mousemove$ = fromEvent(window, "mousemove");
        const touchmove$ = fromEvent(window, "touchmove");
        const mouseup$ = fromEvent(window, "mouseup");
        const touchend$ = fromEvent(window, "touchend");
        const touchstart$ = fromEvent(window, "touchstart");
        let touchX = 0;
        let touchY = 0;
        const subTouchstart = touchstart$.subscribe((event) => {
            touchX = event.touches[0].clientX;
            touchY = event.touches[0].clientY;
        });
        const ratioIgnore = ["macintosh", "firefox"];
        const userAgent = window.navigator.userAgent.toLowerCase();
        return {
            requestAnimationFrame$: of(null, animationFrameScheduler).pipe(repeat()),
            mousedown$: fromEvent(window, "mousedown"),
            mouseup$,
            mousemove$,
            touchstart$,
            touchend$,
            touchmove$,
            move$: merge(mousemove$.pipe(map((event) => {
                let movementX = event.movementX / window.devicePixelRatio;
                let movementY = event.movementY / window.devicePixelRatio;
                // firefox
                if (ratioIgnore.some((target) => userAgent.indexOf(target) !== -1)) {
                    movementX = event.movementX;
                    movementY = event.movementY;
                }
                return {
                    movementX,
                    movementY,
                    x: event.clientX,
                    y: event.clientY,
                    event,
                };
            })), touchmove$.pipe(map((event) => {
                const movementX = event.touches[0].clientX - touchX;
                const movementY = event.touches[0].clientY - touchY;
                touchX = event.touches[0].clientX;
                touchY = event.touches[0].clientY;
                return {
                    movementX,
                    movementY,
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY,
                    event,
                };
            }))),
            moveEnd$: merge(mouseup$, touchend$),
            destroy() {
                subTouchstart.unsubscribe();
            },
        };
    }
    class EventBus {
        constructor() {
            this.bus = document.createElement("div");
        }
        on(eventName) {
            return new Observable((observer) => {
                const handler = (event) => observer.next(event);
                this.bus.addEventListener(eventName, handler);
                return () => this.bus.removeEventListener(eventName, handler);
            });
        }
        emit(eventName, detail) {
            this.bus.dispatchEvent(new CustomEvent(eventName, {
                detail,
            }));
        }
    }
    var Editor;
    (function (Editor) {
        Editor["importErrorDDL"] = "Editor.importErrorDDL";
        Editor["tableProperties"] = "Editor.tableProperties";
    })(Editor || (Editor = {}));
    var ERD;
    (function (ERD) {
        ERD["contextmenuEnd"] = "ERD.contextmenuEnd";
    })(ERD || (ERD = {}));
    var ColumnDataTypeHint;
    (function (ColumnDataTypeHint) {
        ColumnDataTypeHint["arrowUp"] = "ColumnDataTypeHint.arrowUp";
        ColumnDataTypeHint["arrowDown"] = "ColumnDataTypeHint.arrowDown";
        ColumnDataTypeHint["arrowRight"] = "ColumnDataTypeHint.arrowRight";
        ColumnDataTypeHint["arrowLeft"] = "ColumnDataTypeHint.arrowLeft";
        ColumnDataTypeHint["startFilter"] = "ColumnDataTypeHint.startFilter";
    })(ColumnDataTypeHint || (ColumnDataTypeHint = {}));
    var Visualization;
    (function (Visualization) {
        Visualization["startPreview"] = "Visualization.startPreview";
        Visualization["endPreview"] = "Visualization.endPreview";
        Visualization["dragStart"] = "Visualization.dragStart";
        Visualization["dragEnd"] = "Visualization.dragEnd";
    })(Visualization || (Visualization = {}));
    var Table;
    (function (Table) {
        Table["moveValid"] = "Table.moveValid";
    })(Table || (Table = {}));
    var Memo;
    (function (Memo) {
        Memo["moveValid"] = "Memo.moveValid";
    })(Memo || (Memo = {}));
    var Help;
    (function (Help) {
        Help["close"] = "Help.close";
    })(Help || (Help = {}));
    var ImportErrorDDL;
    (function (ImportErrorDDL) {
        ImportErrorDDL["close"] = "ImportErrorDDL.close";
    })(ImportErrorDDL || (ImportErrorDDL = {}));
    var Setting;
    (function (Setting) {
        Setting["close"] = "Setting.close";
    })(Setting || (Setting = {}));
    var TableProperties;
    (function (TableProperties) {
        TableProperties["close"] = "TableProperties.close";
        TableProperties["closeOnly"] = "TableProperties.closeOnly";
    })(TableProperties || (TableProperties = {}));
    var Menubar;
    (function (Menubar) {
        Menubar["filter"] = "Menubar.filter";
        Menubar["find"] = "Menubar.find";
    })(Menubar || (Menubar = {}));
    var Filter;
    (function (Filter) {
        Filter["close"] = "Filter.close";
    })(Filter || (Filter = {}));
    var Find;
    (function (Find) {
        Find["close"] = "Find.close";
    })(Find || (Find = {}));
    const Bus = {
        Editor,
        ERD,
        ColumnDataTypeHint,
        Visualization,
        Table,
        Memo,
        Help,
        ImportErrorDDL,
        Setting,
        TableProperties,
        Menubar,
        Filter,
        Find,
    };

    function createTheme() {
        return {
            canvas: "#282828",
            table: "#191919",
            tableActive: "#14496d",
            focus: "#00a9ff",
            keyPK: "#B4B400",
            keyFK: "#dda8b1",
            keyPFK: "#60b9c4",
            font: "#a2a2a2",
            fontActive: "white",
            fontPlaceholder: "#6D6D6D",
            contextmenu: "#191919",
            contextmenuActive: "#383d41",
            edit: "#ffc107",
            columnSelect: "#232a2f",
            columnActive: "#372908",
            minimapShadow: "black",
            scrollBarThumb: "#6D6D6D",
            scrollBarThumbActive: "#a2a2a2",
            menubar: "black",
            visualization: "#191919",
        };
    }

    const canvasTypeList = [
        "ERD",
        "SQL",
        "Grid",
        "GeneratorCode",
        "Visualization",
    ];
    const databaseList = [
        "MariaDB",
        "MSSQL",
        "MySQL",
        "Oracle",
        "PostgreSQL",
        "SQLite",
    ];
    const languageList = [
        "GraphQL",
        "C#",
        "Java",
        "Kotlin",
        "TypeScript",
        "JPA",
        "Scala",
    ];
    const nameCaseList = [
        "none",
        "camelCase",
        "pascalCase",
        "snakeCase",
    ];
    function createCanvasState() {
        return {
            width: 2000,
            height: 2000,
            scrollTop: 0,
            scrollLeft: 0,
            show: {
                tableComment: true,
                columnComment: true,
                columnDataType: true,
                columnDefault: true,
                columnAutoIncrement: false,
                columnPrimaryKey: true,
                columnUnique: false,
                columnNotNull: true,
                relationship: true,
            },
            database: "MySQL",
            databaseName: "",
            canvasType: "ERD",
            language: "GraphQL",
            tableCase: "pascalCase",
            columnCase: "camelCase",
            setting: {
                relationshipDataTypeSync: true,
                columnOrder: [
                    "columnName",
                    "columnDataType",
                    "columnNotNull",
                    "columnUnique",
                    "columnAutoIncrement",
                    "columnDefault",
                    "columnComment",
                ],
            },
        };
    }

    function createTableState() {
        return {
            tables: [],
            indexes: [],
        };
    }

    function createMemoState() {
        return {
            memos: [],
        };
    }

    const oneRelationshipTypes = [
        "ZeroOne",
        "OneOnly",
        "One",
    ];
    const nRelationshipTypes = [
        "ZeroOneN",
        "ZeroN",
        "OneN",
        "N",
    ];
    function createRelationshipState() {
        return {
            relationships: [],
        };
    }

    const filterColumnTypes = [
        "tableName",
        "tableComment",
        "option",
        "name",
        "dataType",
        "default",
        "comment",
    ];
    const textFilterCodeList = [
        "eq",
        "ne",
        "contain",
        "start",
        "end",
    ];
    const filterOperatorTypes = ["AND", "OR"];
    function createEditorState() {
        return {
            focus: true,
            focusTable: null,
            editTable: null,
            draggableColumn: null,
            drawRelationship: null,
            copyColumns: [],
            findActive: false,
            filterActive: false,
            filterStateList: [],
            filterOperatorType: "OR",
            focusFilter: null,
            editFilter: null,
            draggableFilterState: null,
            hasUndo: false,
            hasRedo: false,
            undoManager: true,
        };
    }

    function createShareState() {
        return {
            userMouseList: [],
        };
    }

    function getColumn(tables, tableId, columnId) {
        const table = getData(tables, tableId);
        if (table) {
            return getData(table.columns, columnId);
        }
        return null;
    }
    function getChangeOption(tables, tableId, columnId, columnOptionKey) {
        let value = false;
        const column = getColumn(tables, tableId, columnId);
        if (column) {
            value = !column.option[columnOptionKey];
        }
        return value;
    }
    function getColumns(table, columnIds) {
        const columns = [];
        columnIds.forEach((columnId) => {
            const column = getData(table.columns, columnId);
            if (column) {
                columns.push(column);
            }
        });
        return columns;
    }
    function getDataTypeSyncColumns(stack, tables, relationships, targetColumns = []) {
        const target = stack.pop();
        if (target) {
            if (getIndex(targetColumns, target.id) === null) {
                targetColumns.push(target);
                relationships.forEach((relationship) => {
                    const { start, end } = relationship;
                    const index = start.columnIds.indexOf(target.id);
                    if (index !== -1) {
                        const columnId = end.columnIds[index];
                        const column = getColumn(tables, end.tableId, columnId);
                        if (column) {
                            stack.push(column);
                        }
                    }
                    else {
                        const index = end.columnIds.indexOf(target.id);
                        if (index !== -1) {
                            const columnId = start.columnIds[index];
                            const column = getColumn(tables, start.tableId, columnId);
                            if (column) {
                                stack.push(column);
                            }
                        }
                    }
                });
            }
            getDataTypeSyncColumns(stack, tables, relationships, targetColumns);
        }
        return targetColumns;
    }

    class RelationshipModel {
        constructor(data) {
            this.identification = false;
            this.start = {
                tableId: "",
                columnIds: [],
                x: 0,
                y: 0,
                direction: "bottom",
            };
            this.end = {
                tableId: "",
                columnIds: [],
                x: 0,
                y: 0,
                direction: "bottom",
            };
            const { addRelationship, loadRelationship } = data;
            if (addRelationship) {
                const { id, relationshipType, start, end } = addRelationship;
                this.id = id;
                this.relationshipType = relationshipType;
                this.start.tableId = start.tableId;
                this.start.columnIds = [...start.columnIds];
                this.end.tableId = end.tableId;
                this.end.columnIds = [...end.columnIds];
            }
            else if (loadRelationship &&
                typeof loadRelationship.id === "string" &&
                typeof loadRelationship.identification === "boolean" &&
                typeof loadRelationship.relationshipType === "string" &&
                typeof loadRelationship.start === "object" &&
                loadRelationship.start !== null &&
                typeof loadRelationship.end === "object" &&
                loadRelationship.end !== null &&
                typeof loadRelationship.start.tableId === "string" &&
                typeof loadRelationship.start.x === "number" &&
                typeof loadRelationship.start.y === "number" &&
                typeof loadRelationship.start.direction === "string" &&
                Array.isArray(loadRelationship.start.columnIds) &&
                typeof loadRelationship.end.tableId === "string" &&
                typeof loadRelationship.end.x === "number" &&
                typeof loadRelationship.end.y === "number" &&
                typeof loadRelationship.end.direction === "string" &&
                Array.isArray(loadRelationship.end.columnIds)) {
                const { id, identification, relationshipType, start, end, } = loadRelationship;
                this.id = id;
                this.identification = identification;
                this.relationshipType = relationshipType;
                this.start = cloneDeep(start);
                this.end = cloneDeep(end);
            }
            else {
                throw new Error("not found relationship");
            }
        }
    }

    function addRelationship(relationshipType, startTable, endTableId) {
        const columnIds = startTable.columns
            .filter((column) => column.option.primaryKey)
            .map((column) => column.id);
        return {
            type: "relationship.add",
            data: {
                id: uuid(),
                relationshipType,
                start: {
                    tableId: startTable.id,
                    columnIds,
                },
                end: {
                    tableId: endTableId,
                    columnIds: columnIds.map(() => uuid()),
                },
            },
        };
    }
    function executeAddRelationship(store, data) {
        const { relationships } = store.relationshipState;
        const { tables } = store.tableState;
        const { start, end } = data;
        const startTable = getData(tables, start.tableId);
        const endTable = getData(tables, end.tableId);
        if (start.columnIds.length !== 0 && startTable && endTable) {
            relationships.push(new RelationshipModel({ addRelationship: data }));
            relationshipSort(tables, relationships);
        }
    }
    function removeRelationship(relationshipIds) {
        return {
            type: "relationship.remove",
            data: {
                relationshipIds,
            },
        };
    }
    function executeRemoveRelationship(store, data) {
        const { relationships } = store.relationshipState;
        for (let i = 0; i < relationships.length; i++) {
            const relationship = relationships[i];
            if (data.relationshipIds.some((relationshipId) => relationshipId === relationship.id)) {
                relationships.splice(i, 1);
                i--;
                // relationship valid
                removeValidRelationshipColumnId(store, relationship.end.tableId, relationship.end.columnIds);
            }
        }
    }
    function changeRelationshipType(relationshipId, relationshipType) {
        return {
            type: "relationship.changeRelationshipType",
            data: {
                relationshipId,
                relationshipType,
            },
        };
    }
    function executeChangeRelationshipType(store, data) {
        const { relationships } = store.relationshipState;
        const relationship = getData(relationships, data.relationshipId);
        if (relationship) {
            relationship.relationshipType = data.relationshipType;
        }
    }
    function executeChangeIdentification(store, data) {
        const { relationships } = store.relationshipState;
        const relationship = getData(relationships, data.relationshipId);
        if (relationship) {
            relationship.identification = data.identification;
        }
    }
    function loadRelationship(relationship) {
        return {
            type: "relationship.load",
            data: relationship,
        };
    }
    function executeLoadRelationship(store, data) {
        const { relationships } = store.relationshipState;
        const { tables } = store.tableState;
        relationships.push(new RelationshipModel({ loadRelationship: data }));
        // valid end column ui key
        const table = getData(tables, data.end.tableId);
        if (table) {
            data.end.columnIds.forEach((columnId) => {
                const column = getData(table.columns, columnId);
                if (column) {
                    if (column.option.primaryKey) {
                        column.ui.pfk = true;
                        column.ui.pk = false;
                        column.ui.fk = false;
                    }
                    else {
                        column.ui.pfk = false;
                        column.ui.pk = false;
                        column.ui.fk = true;
                    }
                }
            });
        }
    }

    // ==================== Draw Relationship ===================
    const TABLE_PADDING = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const PATH_HEIGHT = 40;
    const PATH_END_HEIGHT = PATH_HEIGHT + 20;
    const PATH_LINE_HEIGHT = 35;
    const LINE_SIZE = 10;
    const LINE_HEIGHT = 16;
    const CIRCLE_HEIGHT = 26;
    const directions = ["top", "bottom", "left", "right"];
    function getCoordinate(table) {
        const width = table.width() + TABLE_PADDING;
        const height = table.height() + TABLE_PADDING;
        const ui = table.ui;
        return {
            width,
            height,
            top: {
                x: ui.left + width / 2,
                y: ui.top,
            },
            bottom: {
                x: ui.left + width / 2,
                y: ui.top + height,
            },
            left: {
                x: ui.left,
                y: ui.top + height / 2,
            },
            right: {
                x: ui.left + width,
                y: ui.top + height / 2,
            },
            lt: {
                x: ui.left,
                y: ui.top,
            },
            rt: {
                x: ui.left + width,
                y: ui.top,
            },
            lb: {
                x: ui.left,
                y: ui.top + height,
            },
            rb: {
                x: ui.left + width,
                y: ui.top + height,
            },
        };
    }
    function getDistance(a, b) {
        return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
    }
    function directionFilter(key) {
        return directions.some((direction) => direction === key);
    }
    function getDrawDirection(draw) {
        let direction = "bottom";
        if (draw.start) {
            const start = getCoordinate(draw.start.table);
            let min = getDistance(start.bottom, draw.end);
            draw.start.x = start.bottom.x;
            draw.start.y = start.bottom.y;
            Object.keys(start)
                .filter(directionFilter)
                .forEach((key) => {
                    const k = key;
                    const temp = getDistance(start[k], draw.end);
                    if (min > temp) {
                        min = temp;
                        direction = k;
                        if (draw.start) {
                            draw.start.x = start[k].x;
                            draw.start.y = start[k].y;
                        }
                    }
                });
        }
        return direction;
    }
    function getDrawPath(direction, draw) {
        const line = {
            start: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
            },
        };
        const path = {
            M: { x: 0, y: 0 },
            L: { x: 0, y: 0 },
            Q: { x: 0, y: 0 },
            d() {
                return `M ${this.M.x} ${this.M.y} L ${this.L.x} ${this.L.y}`;
            },
        };
        if (draw.start) {
            line.start.x1 = draw.start.x;
            line.start.y1 = draw.start.y;
            line.start.x2 = draw.start.x;
            line.start.y2 = draw.start.y;
            let change = 1;
            if (direction === "left" || direction === "right") {
                if (direction === "left") {
                    change *= -1;
                }
                line.start.x2 = draw.start.x + change * PATH_HEIGHT;
                path.M.x = line.start.x2;
                path.M.y = draw.start.y;
            }
            else if (direction === "top" || direction === "bottom") {
                if (direction === "top") {
                    change *= -1;
                }
                line.start.y2 = draw.start.y + change * PATH_HEIGHT;
                path.M.x = draw.start.x;
                path.M.y = line.start.y2;
            }
        }
        path.L.x = draw.end.x;
        path.L.y = draw.end.y;
        return {
            path,
            line,
        };
    }
    function getDrawLine(direction, draw) {
        const line = {
            start: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
            },
        };
        if (draw.start) {
            line.start.x1 = draw.start.x;
            line.start.y1 = draw.start.y;
            line.start.x2 = draw.start.x;
            line.start.y2 = draw.start.y;
            let change = 1;
            if (direction === "left" || direction === "right") {
                if (direction === "left") {
                    change *= -1;
                }
                line.start.x1 = line.start.x2 += change * LINE_HEIGHT;
                line.start.y1 -= LINE_SIZE;
                line.start.y2 += LINE_SIZE;
            }
            else if (direction === "top" || direction === "bottom") {
                if (direction === "top") {
                    change *= -1;
                }
                line.start.y1 = line.start.y2 += change * LINE_HEIGHT;
                line.start.x1 -= LINE_SIZE;
                line.start.x2 += LINE_SIZE;
            }
        }
        return line;
    }
    function getDraw(draw) {
        const drawPath = {
            path: {
                path: {
                    M: { x: 0, y: 0 },
                    L: { x: 0, y: 0 },
                    Q: { x: 0, y: 0 },
                    d() {
                        return `M ${this.M.x} ${this.M.y} L ${this.L.x} ${this.L.y}`;
                    },
                },
                line: {
                    start: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                },
            },
            line: {
                start: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                },
            },
        };
        if (draw.start) {
            const direction = getDrawDirection(draw);
            drawPath.path = getDrawPath(direction, draw);
            drawPath.line = getDrawLine(direction, draw);
        }
        return drawPath;
    }
    function getRelationshipGraph(graphs, table) {
        let target = null;
        for (const graph of graphs) {
            if (graph.table.id === table.id) {
                target = graph;
                break;
            }
        }
        return target;
    }
    function getDirection(start, end, relationship) {
        const direction = {
            start: "bottom",
            end: "bottom",
        };
        let min = getDistance(start.bottom, end.bottom);
        relationship.start.x = start.bottom.x;
        relationship.start.y = start.bottom.y;
        relationship.end.x = end.bottom.x;
        relationship.end.y = end.bottom.y;
        Object.keys(start)
            .filter(directionFilter)
            .forEach((key) => {
                Object.keys(end)
                    .filter(directionFilter)
                    .forEach((key2) => {
                        const k = key;
                        const k2 = key2;
                        const temp = getDistance(start[k], end[k2]);
                        if (min > temp) {
                            min = temp;
                            direction.start = k;
                            direction.end = k2;
                            relationship.start.x = start[k].x;
                            relationship.start.y = start[k].y;
                            relationship.end.x = end[k2].x;
                            relationship.end.y = end[k2].y;
                        }
                    });
            });
        return direction;
    }
    function relationshipOverlayPoint(direction, graph) {
        const len = graph[direction].length;
        const margin = {
            x: graph.coordinate.width / len,
            y: graph.coordinate.height / len,
        };
        const padding = {
            x: margin.x / 2,
            y: margin.y / 2,
        };
        const xArray = [];
        const yArray = [];
        if (direction === "left" || direction === "right") {
            let sum = graph.coordinate.lt.y - padding.y;
            for (let i = 0; i < len; i++) {
                sum += margin.y;
                yArray.push(sum);
            }
        }
        else if (direction === "top" || direction === "bottom") {
            let sum = graph.coordinate.lt.x - padding.x;
            for (let i = 0; i < len; i++) {
                sum += margin.x;
                xArray.push(sum);
            }
        }
        return {
            xArray,
            yArray,
        };
    }
    function sortDistance(a, b) {
        return a.distance - b.distance;
    }
    function relationshipOverlayOrder(direction, table, relationships) {
        const startPoints = [];
        const endPoints = [];
        relationships.forEach((relationship) => {
            if (relationship.start.tableId === relationship.end.tableId) {
                // self relationship
                if (direction === "top") {
                    startPoints.push(relationship.start);
                    endPoints.push(relationship.end);
                }
                else if (direction === "right") {
                    startPoints.push(relationship.end);
                    endPoints.push(relationship.start);
                }
            }
            else if (relationship.start.tableId === table.id) {
                startPoints.push(relationship.start);
                endPoints.push(relationship.end);
            }
            else {
                startPoints.push(relationship.end);
                endPoints.push(relationship.start);
            }
        });
        const start = {
            x: startPoints[0].x,
            y: startPoints[0].y,
        };
        const distances = [];
        endPoints.forEach((endPoint, index) => {
            distances.push({
                start: startPoints[index],
                end: endPoints[index],
                distance: getDistance(start, endPoint),
            });
        });
        distances.sort(sortDistance);
        return distances;
    }
    function relationshipOverlayFirstCheck(direction, order, point) {
        let result = true;
        if (direction === "left" || direction === "right") {
            result =
                getDistance({ x: order.start.x, y: point.yArray[0] }, order.end) <
                getDistance({ x: order.start.x, y: point.yArray[point.yArray.length - 1] }, order.end);
        }
        else if (direction === "top" || direction === "bottom") {
            result =
                getDistance({ x: point.xArray[0], y: order.start.y }, order.end) <
                getDistance({ x: point.xArray[point.xArray.length - 1], y: order.start.y }, order.end);
        }
        return result;
    }
    function relationshipOverlaySort(direction, graph) {
        const point = relationshipOverlayPoint(direction, graph);
        let distances = relationshipOverlayOrder(direction, graph.table, graph[direction]);
        if (distances.length > 1) {
            if (!relationshipOverlayFirstCheck(direction, distances[0], point)) {
                distances = distances.reverse();
            }
        }
        if (direction === "left" || direction === "right") {
            point.yArray.forEach((y, index) => {
                distances[index].start.y = y;
            });
        }
        else if (direction === "top" || direction === "bottom") {
            point.xArray.forEach((x, index) => {
                distances[index].start.x = x;
            });
        }
    }
    function relationshipSort(tables, relationships) {
        const graphs = [];
        relationships.forEach((relationship) => {
            const tableStart = getData(tables, relationship.start.tableId);
            const tableEnd = getData(tables, relationship.end.tableId);
            if (tableStart && tableEnd) {
                if (relationship.start.tableId === relationship.end.tableId) {
                    relationship.start.direction = "top";
                    relationship.end.direction = "right";
                    const graph = getRelationshipGraph(graphs, tableStart);
                    if (graph) {
                        relationship.start.x = graph.coordinate.rt.x - 20;
                        relationship.start.y = graph.coordinate.rt.y;
                        relationship.end.x = graph.coordinate.rt.x;
                        relationship.end.y = graph.coordinate.rt.y + 20;
                        graph.top.push(relationship);
                        graph.right.push(relationship);
                    }
                    else {
                        const coordinate = getCoordinate(tableStart);
                        relationship.start.x = coordinate.rt.x - 20;
                        relationship.start.y = coordinate.rt.y;
                        relationship.end.x = coordinate.rt.x;
                        relationship.end.y = coordinate.rt.y + 20;
                        graphs.push({
                            table: tableStart,
                            coordinate,
                            top: [relationship],
                            bottom: [],
                            left: [],
                            right: [relationship],
                        });
                    }
                }
                else {
                    const coordinateStart = getCoordinate(tableStart);
                    const coordinateEnd = getCoordinate(tableEnd);
                    const direction = getDirection(coordinateStart, coordinateEnd, relationship);
                    const graphStart = getRelationshipGraph(graphs, tableStart);
                    const graphEnd = getRelationshipGraph(graphs, tableEnd);
                    relationship.start.direction = direction.start;
                    relationship.end.direction = direction.end;
                    if (graphStart) {
                        graphStart[direction.start].push(relationship);
                    }
                    else {
                        const graph = {
                            table: tableStart,
                            coordinate: coordinateStart,
                            top: [],
                            bottom: [],
                            left: [],
                            right: [],
                        };
                        graph[direction.start].push(relationship);
                        graphs.push(graph);
                    }
                    if (graphEnd) {
                        graphEnd[direction.end].push(relationship);
                    }
                    else {
                        const graph = {
                            table: tableEnd,
                            coordinate: coordinateEnd,
                            top: [],
                            bottom: [],
                            left: [],
                            right: [],
                        };
                        graph[direction.end].push(relationship);
                        graphs.push(graph);
                    }
                }
            }
        });
        graphs.forEach((graph) => {
            directions.forEach((value) => {
                const direction = value;
                const len = graph[direction].length;
                if (len >= 2) {
                    relationshipOverlaySort(direction, graph);
                }
            });
        });
    }
    function getPath(start, end) {
        const line = {
            start: {
                x1: start.x,
                y1: start.y,
                x2: start.x,
                y2: start.y,
            },
            end: {
                x1: end.x,
                y1: end.y,
                x2: end.x,
                y2: end.y,
            },
        };
        const path = {
            M: { x: 0, y: 0 },
            L: { x: 0, y: 0 },
            Q: { x: 0, y: 0 },
            d() {
                return `M ${this.M.x} ${this.M.y} L ${this.L.x} ${this.L.y}`;
            },
        };
        let change = 1;
        if (start.direction === "left" || start.direction === "right") {
            if (start.direction === "left") {
                change *= -1;
            }
            line.start.x2 = start.x + change * PATH_HEIGHT;
            path.M.x = line.start.x2;
            path.M.y = start.y;
        }
        else if (start.direction === "top" || start.direction === "bottom") {
            if (start.direction === "top") {
                change *= -1;
            }
            line.start.y2 = start.y + change * PATH_HEIGHT;
            path.M.x = start.x;
            path.M.y = line.start.y2;
        }
        change = 1;
        if (end.direction === "left" || end.direction === "right") {
            if (end.direction === "left") {
                change *= -1;
            }
            line.end.x2 = end.x + change * PATH_END_HEIGHT;
            line.end.x1 += change * PATH_LINE_HEIGHT;
            path.L.x = line.end.x2;
            path.L.y = end.y;
        }
        else if (end.direction === "top" || end.direction === "bottom") {
            if (end.direction === "top") {
                change *= -1;
            }
            line.end.y2 = end.y + change * PATH_END_HEIGHT;
            line.end.y1 += change * PATH_LINE_HEIGHT;
            path.L.x = end.x;
            path.L.y = line.end.y2;
        }
        return {
            line,
            path,
        };
    }
    function getLine(start, end) {
        const line = {
            start: {
                x1: start.x,
                y1: start.y,
                x2: start.x,
                y2: start.y,
            },
            end: {
                base: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                base2: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                left: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                center: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                center2: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                right: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
            },
        };
        const circle = {
            cx: end.x,
            cy: end.y,
        };
        let change = 1;
        if (start.direction === "left" || start.direction === "right") {
            if (start.direction === "left") {
                change *= -1;
            }
            line.start.x1 = line.start.x2 += change * LINE_HEIGHT;
            line.start.y1 -= LINE_SIZE;
            line.start.y2 += LINE_SIZE;
        }
        else if (start.direction === "top" || start.direction === "bottom") {
            if (start.direction === "top") {
                change *= -1;
            }
            line.start.y1 = line.start.y2 += change * LINE_HEIGHT;
            line.start.x1 -= LINE_SIZE;
            line.start.x2 += LINE_SIZE;
        }
        change = 1;
        if (end.direction === "left" || end.direction === "right") {
            if (end.direction === "left") {
                change *= -1;
            }
            line.end.base.x1 = line.end.base.x2 += change * LINE_HEIGHT;
            line.end.base2.x1 = line.end.base2.x2 += change * (LINE_SIZE + LINE_HEIGHT);
            line.end.center.x1 = line.end.left.x1 = line.end.right.x1 =
                line.end.base.x1;
            line.end.base.y1 -= LINE_SIZE;
            line.end.base.y2 += LINE_SIZE;
            line.end.base2.y1 -= LINE_SIZE;
            line.end.base2.y2 += LINE_SIZE;
            line.end.left.y2 += LINE_SIZE;
            line.end.right.y2 -= LINE_SIZE;
            line.end.center2.x1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
            circle.cx += change * CIRCLE_HEIGHT;
        }
        else if (end.direction === "top" || end.direction === "bottom") {
            if (end.direction === "top") {
                change *= -1;
            }
            line.end.base.y1 = line.end.base.y2 += change * LINE_HEIGHT;
            line.end.base2.y1 = line.end.base2.y2 += change * (LINE_SIZE + LINE_HEIGHT);
            line.end.center.y1 = line.end.left.y1 = line.end.right.y1 =
                line.end.base.y1;
            line.end.base.x1 -= LINE_SIZE;
            line.end.base.x2 += LINE_SIZE;
            line.end.base2.x1 -= LINE_SIZE;
            line.end.base2.x2 += LINE_SIZE;
            line.end.left.x2 += LINE_SIZE;
            line.end.right.x2 -= LINE_SIZE;
            line.end.center2.y1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
            circle.cy += change * CIRCLE_HEIGHT;
        }
        return {
            line,
            circle,
        };
    }
    function getRelationshipPath(relationship) {
        return {
            path: getPath(relationship.start, relationship.end),
            line: getLine(relationship.start, relationship.end),
        };
    }
    // ==================== Draw Relationship END ===================
    function validIdentification(store) {
        const { relationships } = store.relationshipState;
        const { tables } = store.tableState;
        relationships.forEach((relationship) => {
            const { end } = relationship;
            const table = getData(tables, end.tableId);
            if (table) {
                const columns = getColumns(table, end.columnIds);
                const identification = !columns.some((column) => !column.option.primaryKey);
                if (identification !== relationship.identification) {
                    executeChangeIdentification(store, {
                        relationshipId: relationship.id,
                        identification,
                    });
                }
            }
        });
    }
    function removeValidTableRelationship(store, tableIds) {
        const { relationships } = store.relationshipState;
        const removeRelationshipIds = [];
        relationships.forEach((relationship) => {
            const { start, end } = relationship;
            if (tableIds.some((tableId) => tableId === start.tableId || tableId === end.tableId)) {
                removeRelationshipIds.push(relationship.id);
            }
        });
        if (removeRelationshipIds.length !== 0) {
            executeRemoveRelationship(store, {
                relationshipIds: removeRelationshipIds,
            });
        }
    }
    function removeValidColumnRelationship(store, table, columnIds) {
        const { relationships } = store.relationshipState;
        const removeRelationshipIds = [];
        const validColumnUIKeyList = [];
        relationships.forEach((relationship) => {
            const { start, end } = relationship;
            const validColumnUIKey = {
                startTableId: start.tableId,
                endTableId: end.tableId,
                columnIds: [],
            };
            if (table.id === start.tableId) {
                for (let i = 0; i < start.columnIds.length; i++) {
                    const id = start.columnIds[i];
                    if (columnIds.some((columnId) => columnId === id)) {
                        validColumnUIKey.columnIds.push(end.columnIds[i]);
                        start.columnIds.splice(i, 1);
                        end.columnIds.splice(i, 1);
                        i--;
                    }
                }
            }
            else if (table.id === end.tableId) {
                for (let i = 0; i < end.columnIds.length; i++) {
                    const id = end.columnIds[i];
                    if (columnIds.some((columnId) => columnId === id)) {
                        validColumnUIKey.columnIds.push(id);
                        start.columnIds.splice(i, 1);
                        end.columnIds.splice(i, 1);
                        i--;
                    }
                }
            }
            if (start.columnIds.length === 0) {
                removeRelationshipIds.push(relationship.id);
            }
            validColumnUIKeyList.push(validColumnUIKey);
        });
        if (removeRelationshipIds.length !== 0) {
            executeRemoveRelationship(store, {
                relationshipIds: removeRelationshipIds,
            });
        }
        validColumnUIKeyList.forEach((validColumnUIKey) => {
            if (validColumnUIKey.columnIds.length !== 0) {
                removeValidRelationshipColumnId(store, validColumnUIKey.startTableId, validColumnUIKey.columnIds);
                removeValidRelationshipColumnId(store, validColumnUIKey.endTableId, validColumnUIKey.columnIds);
            }
        });
    }
    function removeValidRelationshipColumnId(store, tableId, columnIds) {
        const { tables } = store.tableState;
        const table = getData(tables, tableId);
        if (table) {
            columnIds.forEach((columnId) => {
                const column = getData(table.columns, columnId);
                if (column === null || column === void 0 ? void 0 : column.ui.fk) {
                    column.ui.fk = false;
                }
                else if (column === null || column === void 0 ? void 0 : column.ui.pfk) {
                    column.ui.pfk = false;
                    column.ui.pk = true;
                }
            });
        }
    }

    function removeValidColumnIndex(store, table, columnIds) {
        const { indexes } = store.tableState;
        const tableIndexes = indexes.filter((index) => index.tableId === table.id);
        tableIndexes.forEach((index) => {
            for (let i = 0; i < index.columns.length; i++) {
                const id = index.columns[i].id;
                if (columnIds.some((columnId) => columnId === id)) {
                    index.columns.splice(i, 1);
                    i--;
                }
            }
        });
    }
    function removeValidTableIndex(store, tableIds) {
        const { indexes } = store.tableState;
        for (let i = 0; i < indexes.length; i++) {
            const id = indexes[i].tableId;
            if (tableIds.some((tableId) => tableId === id)) {
                indexes.splice(i, 1);
                i--;
            }
        }
    }

    function nextZIndex(tables, memos) {
        let max = 1;
        tables.forEach((table) => {
            if (max < table.ui.zIndex) {
                max = table.ui.zIndex;
            }
        });
        memos.forEach((memo) => {
            if (max < memo.ui.zIndex) {
                max = memo.ui.zIndex;
            }
        });
        return max + 1;
    }
    function nextPoint(store, tables, memos) {
        const point = {
            top: SIZE_START_Y + store.canvasState.scrollTop,
            left: SIZE_START_X + store.canvasState.scrollLeft,
        };
        let isPosition = true;
        while (isPosition) {
            isPosition = false;
            for (const table of tables) {
                if (table.ui.top === point.top && table.ui.left === point.left) {
                    isPosition = true;
                    point.top += SIZE_START_ADD;
                    point.left += SIZE_START_ADD;
                    break;
                }
            }
            for (const memo of memos) {
                if (memo.ui.top === point.top && memo.ui.left === point.left) {
                    isPosition = true;
                    point.top += SIZE_START_ADD;
                    point.left += SIZE_START_ADD;
                    break;
                }
            }
        }
        return point;
    }
    function getMaxWidthColumn(columns, show) {
        const columnWidth = {
            width: 0,
            name: 0,
            comment: 0,
            dataType: 0,
            default: 0,
            notNull: 0,
            autoIncrement: 0,
            unique: 0,
        };
        columns.forEach((column) => {
            if (columnWidth.name < column.ui.widthName) {
                columnWidth.name = column.ui.widthName;
            }
            if (show.columnComment && columnWidth.comment < column.ui.widthComment) {
                columnWidth.comment = column.ui.widthComment;
            }
            if (show.columnDataType && columnWidth.dataType < column.ui.widthDataType) {
                columnWidth.dataType = column.ui.widthDataType;
            }
            if (show.columnDefault && columnWidth.default < column.ui.widthDefault) {
                columnWidth.default = column.ui.widthDefault;
            }
        });
        if (show.columnNotNull) {
            columnWidth.notNull = SIZE_COLUMN_OPTION_NN;
        }
        if (show.columnAutoIncrement) {
            columnWidth.autoIncrement = SIZE_COLUMN_OPTION_AI;
        }
        if (show.columnUnique) {
            columnWidth.unique = SIZE_COLUMN_OPTION_QU;
        }
        Object.keys(columnWidth)
            .filter((key) => key !== "width")
            .forEach((key) => {
                const k = key;
                if (columnWidth[k] !== 0) {
                    columnWidth.width += columnWidth[k] + SIZE_COLUMN_MARGIN_RIGHT;
                }
            });
        return columnWidth;
    }
    function getDefaultWidthColumn(show) {
        let width = SIZE_MIN_WIDTH + SIZE_COLUMN_MARGIN_RIGHT;
        if (show.columnComment) {
            width += SIZE_MIN_WIDTH + SIZE_COLUMN_MARGIN_RIGHT;
        }
        if (show.columnDataType) {
            width += SIZE_MIN_WIDTH + SIZE_COLUMN_MARGIN_RIGHT;
        }
        if (show.columnDefault) {
            width += SIZE_MIN_WIDTH + SIZE_COLUMN_MARGIN_RIGHT;
        }
        if (show.columnNotNull) {
            width += SIZE_COLUMN_OPTION_NN + SIZE_COLUMN_MARGIN_RIGHT;
        }
        if (show.columnAutoIncrement) {
            width += SIZE_COLUMN_OPTION_AI + SIZE_COLUMN_MARGIN_RIGHT;
        }
        if (show.columnUnique) {
            width += SIZE_COLUMN_OPTION_QU + SIZE_COLUMN_MARGIN_RIGHT;
        }
        return width;
    }
    function orderByNameASC(tables) {
        return [...tables].sort((a, b) => {
            const nameA = a.name.toLowerCase();
            const nameB = b.name.toLowerCase();
            if (nameA < nameB) {
                return -1;
            }
            else if (nameA > nameB) {
                return 1;
            }
            return 0;
        });
    }
    function virtualTable(current, table) {
        const { minX, minY, maxX, maxY } = current;
        const coordinate = getCoordinate(table);
        return ((minX < coordinate.lt.x &&
            coordinate.lt.x < maxX &&
            minY < coordinate.lt.y &&
            coordinate.lt.y < maxY) ||
            (minX < coordinate.lb.x &&
                coordinate.lb.x < maxX &&
                minY < coordinate.lb.y &&
                coordinate.lb.y < maxY) ||
            (minX < coordinate.rt.x &&
                coordinate.rt.x < maxX &&
                minY < coordinate.rt.y &&
                coordinate.rt.y < maxY) ||
            (minX < coordinate.rb.x &&
                coordinate.rb.x < maxX &&
                minY < coordinate.rb.y &&
                coordinate.rb.y < maxY));
    }
    function orderByRelationship(tables, relationships) {
        const firstTables = [];
        const reshapeTables = [];
        const sortTables = [];
        tables.forEach((table) => {
            const endRelationships = relationships
                .filter((relationship) => relationship.end.tableId === table.id)
                .map((relationship) => relationship.start.tableId);
            if (endRelationships.length === 0) {
                firstTables.push(table);
            }
            else {
                reshapeTables.push(table);
                sortTables.push(table);
            }
        });
        reshapeTables.forEach((table) => {
            const firstIndex = firstTableIndex(sortTables, relationships
                .filter((relationship) => relationship.start.tableId === table.id)
                .map((relationship) => relationship.end.tableId));
            const currentIndex = getIndex(sortTables, table.id);
            if (currentIndex !== null) {
                sortTables.splice(currentIndex, 1);
            }
            sortTables.splice(firstIndex, 0, table);
        });
        return [...firstTables, ...sortTables];
    }
    function firstTableIndex(tables, tableIds) {
        let index = tables.length - 1;
        for (let i = 0; i < tables.length; i++) {
            const id = tables[i].id;
            if (tableIds.some((tableId) => tableId === id)) {
                index = i;
                break;
            }
        }
        return index;
    }

    class TableModel {
        constructor(data, show) {
            this.name = "";
            this.comment = "";
            this.columns = [];
            this.ui = {
                active: false,
                left: SIZE_START_X,
                top: SIZE_START_Y,
                zIndex: 2,
                widthName: SIZE_MIN_WIDTH,
                widthComment: SIZE_MIN_WIDTH,
            };
            const { addTable, loadTable } = data;
            this._show = show;
            if (addTable) {
                const { id, ui } = addTable;
                this.id = id;
                this.ui = Object.assign(this.ui, ui);
            }
            else if (loadTable &&
                typeof loadTable.id === "string" &&
                typeof loadTable.name === "string" &&
                typeof loadTable.comment === "string" &&
                Array.isArray(loadTable.columns) &&
                typeof loadTable.ui === "object" &&
                loadTable.ui !== null &&
                typeof loadTable.ui.active === "boolean" &&
                typeof loadTable.ui.left === "number" &&
                typeof loadTable.ui.top === "number" &&
                typeof loadTable.ui.zIndex === "number" &&
                typeof loadTable.ui.widthName === "number" &&
                typeof loadTable.ui.widthComment === "number") {
                const { id, name, comment, columns, ui } = loadTable;
                this.id = id;
                this.name = name;
                this.comment = comment;
                this.columns = columns;
                this.ui = Object.assign(this.ui, ui);
            }
            else {
                throw new Error("not found table");
            }
        }
        width() {
            // table header width
            let width = this.ui.widthName + SIZE_COLUMN_MARGIN_RIGHT;
            if (this._show.tableComment) {
                width += this.ui.widthComment + SIZE_COLUMN_MARGIN_RIGHT;
            }
            // default width column
            const defaultWidthColumn = getDefaultWidthColumn(this._show) +
                SIZE_COLUMN_CLOSE +
                SIZE_COLUMN_KEY +
                SIZE_COLUMN_MARGIN_RIGHT;
            if (width < defaultWidthColumn) {
                width = defaultWidthColumn;
            }
            // max width column
            const maxWidthColumn = this.maxWidthColumn().width +
                SIZE_COLUMN_CLOSE +
                SIZE_COLUMN_KEY +
                SIZE_COLUMN_MARGIN_RIGHT;
            if (width < maxWidthColumn) {
                width = maxWidthColumn;
            }
            return width;
        }
        height() {
            return SIZE_TABLE_HEADER_HEIGHT + this.columns.length * SIZE_COLUMN_HEIGHT;
        }
        maxWidthColumn() {
            return getMaxWidthColumn(this.columns, this._show);
        }
    }

    class MemoModel {
        constructor(data) {
            this.value = "";
            const { addMemo, loadMemo } = data;
            if (addMemo) {
                const { id, ui } = addMemo;
                this.id = id;
                this.ui = Object.assign({}, ui);
            }
            else if (loadMemo &&
                typeof loadMemo.id === "string" &&
                typeof loadMemo.value === "string" &&
                typeof loadMemo.ui === "object" &&
                loadMemo.ui !== null &&
                typeof loadMemo.ui.active === "boolean" &&
                typeof loadMemo.ui.top === "number" &&
                typeof loadMemo.ui.left === "number" &&
                typeof loadMemo.ui.width === "number" &&
                typeof loadMemo.ui.height === "number" &&
                typeof loadMemo.ui.zIndex === "number") {
                const { id, value, ui } = loadMemo;
                this.id = id;
                this.value = value;
                this.ui = Object.assign({}, ui);
            }
            else {
                throw new Error("not found memo");
            }
        }
    }

    const MEMO_PADDING = SIZE_MEMO_PADDING * 2;
    function addMemo(store) {
        const { tableState, memoState } = store;
        const point = nextPoint(store, tableState.tables, memoState.memos);
        return {
            type: "memo.add",
            data: {
                id: uuid(),
                ui: {
                    active: true,
                    left: point.left,
                    top: point.top,
                    zIndex: nextZIndex(tableState.tables, memoState.memos),
                    width: SIZE_MEMO_WIDTH,
                    height: SIZE_MEMO_HEIGHT,
                },
            },
        };
    }
    function executeAddMemo(store, data) {
        const { memos } = store.memoState;
        executeSelectEndTable(store);
        executeSelectEndMemo(store);
        memos.push(new MemoModel({ addMemo: data }));
        store.editorState.focus = true;
    }
    function executeAddOnlyMemo(store, data) {
        const { memos } = store.memoState;
        memos.push(new MemoModel({ addMemo: data }));
        store.editorState.focus = false;
    }
    function moveMemo(store, ctrlKey, movementX, movementY, memoId) {
        const { tableState, memoState } = store;
        return {
            type: "memo.move",
            data: {
                movementX,
                movementY,
                tableIds: ctrlKey
                    ? tableState.tables
                        .filter((table) => table.ui.active)
                        .map((table) => table.id)
                    : [],
                memoIds: ctrlKey
                    ? memoState.memos
                        .filter((memo) => memo.ui.active)
                        .map((memo) => memo.id)
                    : [memoId],
            },
        };
    }
    function executeMoveMemo(store, data) {
        const { tables } = store.tableState;
        const { memos } = store.memoState;
        const { relationships } = store.relationshipState;
        data.tableIds.forEach((tableId) => {
            const table = getData(tables, tableId);
            if (table) {
                table.ui.left += data.movementX;
                table.ui.top += data.movementY;
            }
        });
        data.memoIds.forEach((memoId) => {
            const memo = getData(memos, memoId);
            if (memo) {
                memo.ui.left += data.movementX;
                memo.ui.top += data.movementY;
            }
        });
        if (data.tableIds.length !== 0) {
            relationshipSort(tables, relationships);
        }
    }
    function removeMemo(store, memoId) {
        const { memos } = store.memoState;
        return {
            type: "memo.remove",
            data: {
                memoIds: memoId
                    ? [memoId]
                    : memos.filter((memo) => memo.ui.active).map((memo) => memo.id),
            },
        };
    }
    function executeRemoveMemo(store, data) {
        const { memos } = store.memoState;
        for (let i = 0; i < memos.length; i++) {
            const id = memos[i].id;
            if (data.memoIds.some((memoId) => memoId === id)) {
                memos.splice(i, 1);
                i--;
            }
        }
    }
    function selectMemo(store, ctrlKey, memoId) {
        const { tableState, memoState } = store;
        return {
            type: "memo.select",
            data: {
                ctrlKey,
                memoId,
                zIndex: nextZIndex(tableState.tables, memoState.memos),
            },
        };
    }
    function executeSelectMemo(store, data) {
        const { memos } = store.memoState;
        const targetMemo = getData(memos, data.memoId);
        if (targetMemo) {
            targetMemo.ui.zIndex = data.zIndex;
            if (data.ctrlKey) {
                targetMemo.ui.active = true;
            }
            else {
                memos.forEach((memo) => {
                    memo.ui.active = memo.id === data.memoId;
                });
                executeSelectEndTable(store);
            }
        }
    }
    function selectEndMemo() {
        return {
            type: "memo.selectEnd",
            data: null,
        };
    }
    function executeSelectEndMemo(store) {
        const { memos } = store.memoState;
        memos.forEach((memo) => (memo.ui.active = false));
    }
    function selectAllMemo() {
        return {
            type: "memo.selectAll",
            data: null,
        };
    }
    function executeSelectAllMemo(store) {
        const { memos } = store.memoState;
        memos.forEach((memo) => (memo.ui.active = true));
    }
    function changeMemoValue(memoId, value) {
        return {
            type: "memo.changeValue",
            data: {
                memoId,
                value,
            },
        };
    }
    function executeChangeMemoValue(store, data) {
        const { memos } = store.memoState;
        const memo = getData(memos, data.memoId);
        if (memo) {
            memo.value = data.value;
        }
    }
    function resizeMemo(memoId, top, left, width, height) {
        return {
            type: "memo.resize",
            data: {
                memoId,
                top,
                left,
                width,
                height,
            },
        };
    }
    function executeResizeMemo(store, data) {
        const { memos } = store.memoState;
        const memo = getData(memos, data.memoId);
        if (memo) {
            memo.ui.top = data.top;
            memo.ui.left = data.left;
            memo.ui.width = data.width;
            memo.ui.height = data.height;
        }
    }
    function dragSelectMemo(min, max) {
        return {
            type: "memo.dragSelect",
            data: {
                min,
                max,
            },
        };
    }
    function executeDragSelectMemo(store, data) {
        const { memos } = store.memoState;
        const { min, max } = data;
        memos.forEach((memo) => {
            const centerX = memo.ui.left + memo.ui.width / 2 + MEMO_PADDING;
            const centerY = memo.ui.top + memo.ui.height / 2 + MEMO_PADDING;
            memo.ui.active =
                min.x <= centerX &&
                max.x >= centerX &&
                min.y <= centerY &&
                max.y >= centerY;
        });
    }
    function loadMemo(memo) {
        return {
            type: "memo.load",
            data: memo,
        };
    }
    function executeLoadMemo(store, data) {
        const { memos } = store.memoState;
        memos.push(new MemoModel({ loadMemo: data }));
    }

    function focusFilterStateEnd(focusFilterStateList) {
        focusFilterStateList.forEach((focusFilterState) => {
            Object.keys(focusFilterStateKeyFocusTypeKeyMap).forEach((key) => {
                const k = key;
                focusFilterState[k] = false;
            });
        });
    }
    function focusEnd(focusFilter) {
        focusFilter.focusFilterOperatorType = false;
        focusFilterStateEnd(focusFilter.focusFilterStateList);
    }
    function selectEndFilterState(focusFilterStateList) {
        focusFilterStateList.forEach((focusFilterState) => (focusFilterState.select = false));
    }
    function selectAllFilterState(focusFilterStateList) {
        focusFilterStateList.forEach((focusFilterState) => (focusFilterState.select = true));
    }

    const focusFilterStateKeyFocusTypeKeyMap = {
        focusColumnType: "columnType",
        focusFilterCode: "filterCode",
        focusValue: "value",
    };
    const focusTypeKeyFocusFilterStateKeyMap = {
        columnType: "focusColumnType",
        filterCode: "focusFilterCode",
        value: "focusValue",
    };
    const focusTypes = ["columnType", "filterCode", "value"];
    class FocusFilterStateModel {
        constructor(filterState) {
            this.select = false;
            this.focusColumnType = false;
            this.focusFilterCode = false;
            this.focusValue = false;
            this._filterState = filterState;
        }
        get id() {
            return this._filterState.id;
        }
        get currentFocus() {
            let focusType = null;
            Object.keys(focusFilterStateKeyFocusTypeKeyMap).forEach((key) => {
                const k = key;
                if (this[k]) {
                    focusType = focusFilterStateKeyFocusTypeKeyMap[k];
                }
            });
            return focusType;
        }
        focus(focusType) {
            const focusFilterStateKey = focusTypeKeyFocusFilterStateKeyMap[focusType];
            this[focusFilterStateKey] = true;
        }
        nextFocus() {
            const focusType = this.currentFocus;
            if (focusType) {
                let index = focusTypes.indexOf(focusType);
                if (index === focusTypes.length - 1) {
                    index = -1;
                }
                const nextFocusType = focusTypes[index + 1];
                const focusFilterStateKey = focusTypeKeyFocusFilterStateKeyMap[nextFocusType];
                focusFilterStateEnd([this]);
                this[focusFilterStateKey] = true;
            }
        }
        preFocus() {
            const focusType = this.currentFocus;
            if (focusType) {
                let index = focusTypes.indexOf(focusType);
                if (index === 0) {
                    index = focusTypes.length;
                }
                const preFocusType = focusTypes[index - 1];
                const focusFilterStateKey = focusTypeKeyFocusFilterStateKeyMap[preFocusType];
                focusFilterStateEnd([this]);
                this[focusFilterStateKey] = true;
            }
        }
        isLastFocus() {
            const focusType = this.currentFocus;
            if (focusType) {
                const index = focusTypes.indexOf(focusType);
                return index === focusTypes.length - 1;
            }
            return false;
        }
        isFirstFocus() {
            const focusType = this.currentFocus;
            if (focusType) {
                const index = focusTypes.indexOf(focusType);
                return index === 0;
            }
            return false;
        }
    }

    class FocusFilterModel {
        constructor(filterStateList, store) {
            this.focusFilterOperatorType = true;
            this.focusFilterStateList = [];
            this._observeCall = true;
            this._currentFocusFilterState = null;
            this._subscriptionList = [];
            this._filterStateList = filterStateList;
            this._store = store;
            filterStateList.forEach((filterState) => {
                this.focusFilterStateList.push(new FocusFilterStateModel(filterState));
            });
            this._subscriptionList.push(store.observe(filterStateList, () => this.createFocusFilterStateList()));
        }
        get currentFocus() {
            var _a;
            if ((_a = this._currentFocusFilterState) === null || _a === void 0 ? void 0 : _a.currentFocus) {
                return this._currentFocusFilterState.currentFocus;
            }
            return "filterOperatorType";
        }
        get currentFocusId() {
            var _a;
            if ((_a = this._currentFocusFilterState) === null || _a === void 0 ? void 0 : _a.currentFocus) {
                return this._currentFocusFilterState.id;
            }
            return null;
        }
        get selectFilterStateList() {
            return this.focusFilterStateList
                .filter((focusFilterState) => focusFilterState.select)
                .map((focusFilterState) => getData(this._filterStateList, focusFilterState.id))
                .filter((filterState) => filterState !== null);
        }
        move(focusMoveFilter) {
            if (!focusMoveFilter.shiftKey) {
                selectEndFilterState(this.focusFilterStateList);
            }
            switch (focusMoveFilter.moveKey) {
                case "ArrowUp":
                    if (this.focusFilterStateList.length !== 0) {
                        if (this._currentFocusFilterState === null) {
                            // move 1 -> N
                            focusEnd(this);
                            this._currentFocusFilterState = this.focusFilterStateList[this.focusFilterStateList.length - 1];
                            this._currentFocusFilterState.select = true;
                            this._currentFocusFilterState.focusColumnType = true;
                        }
                        else {
                            const index = getIndex(this.focusFilterStateList, this._currentFocusFilterState.id);
                            if (index !== null) {
                                if (index === 0) {
                                    // move N -> 1
                                    focusFilterStateEnd(this.focusFilterStateList);
                                    selectEndFilterState(this.focusFilterStateList);
                                    this._currentFocusFilterState = null;
                                    this.focusFilterOperatorType = true;
                                }
                                else {
                                    // move N -> N
                                    const currentFocus = this._currentFocusFilterState.currentFocus;
                                    if (currentFocus) {
                                        focusEnd(this);
                                        this._currentFocusFilterState = this.focusFilterStateList[index - 1];
                                        this._currentFocusFilterState.select = true;
                                        this._currentFocusFilterState.focus(currentFocus);
                                    }
                                }
                            }
                        }
                    }
                    break;
                case "ArrowDown":
                    if (this.focusFilterStateList.length !== 0) {
                        if (this._currentFocusFilterState === null) {
                            // move 1 -> N
                            focusEnd(this);
                            this._currentFocusFilterState = this.focusFilterStateList[0];
                            this._currentFocusFilterState.select = true;
                            this._currentFocusFilterState.focusColumnType = true;
                        }
                        else {
                            const index = getIndex(this.focusFilterStateList, this._currentFocusFilterState.id);
                            if (index !== null) {
                                if (index === this.focusFilterStateList.length - 1) {
                                    // move N -> 1
                                    focusFilterStateEnd(this.focusFilterStateList);
                                    selectEndFilterState(this.focusFilterStateList);
                                    this._currentFocusFilterState = null;
                                    this.focusFilterOperatorType = true;
                                }
                                else {
                                    // move N -> N
                                    const currentFocus = this._currentFocusFilterState.currentFocus;
                                    if (currentFocus) {
                                        focusEnd(this);
                                        this._currentFocusFilterState = this.focusFilterStateList[index + 1];
                                        this._currentFocusFilterState.select = true;
                                        this._currentFocusFilterState.focus(currentFocus);
                                    }
                                }
                            }
                        }
                    }
                    break;
                case "ArrowLeft":
                    if (this._currentFocusFilterState) {
                        // move N -> N
                        this._currentFocusFilterState.select = true;
                        this._currentFocusFilterState.preFocus();
                    }
                    break;
                case "ArrowRight":
                    if (this._currentFocusFilterState) {
                        // move N -> N
                        this._currentFocusFilterState.select = true;
                        this._currentFocusFilterState.nextFocus();
                    }
                    break;
                case "Tab":
                    if (focusMoveFilter.shiftKey) {
                        this.move({
                            moveKey: "ArrowLeft",
                            shiftKey: false,
                        });
                        if (this._currentFocusFilterState &&
                            this._currentFocusFilterState.isLastFocus()) {
                            this.move({
                                moveKey: "ArrowUp",
                                shiftKey: false,
                            });
                        }
                    }
                    else {
                        this.move({
                            moveKey: "ArrowRight",
                            shiftKey: false,
                        });
                        if (this._currentFocusFilterState) {
                            const index = getIndex(this.focusFilterStateList, this._currentFocusFilterState.id);
                            const isLast = index === this.focusFilterStateList.length - 1;
                            if (isLast && this._currentFocusFilterState.isFirstFocus()) {
                                this._store.dispatch(addFilterState());
                            }
                            else if (this._currentFocusFilterState.isFirstFocus()) {
                                this.move({
                                    moveKey: "ArrowDown",
                                    shiftKey: false,
                                });
                            }
                        }
                        else {
                            if (this.focusFilterStateList.length === 0) {
                                this._store.dispatch(addFilterState());
                            }
                            else {
                                this.move({
                                    moveKey: "ArrowDown",
                                    shiftKey: false,
                                });
                            }
                        }
                    }
                    break;
            }
            this._observeCall = !this._observeCall;
        }
        focus(focusData) {
            const { focusTargetFilter, focusTargetFilterState } = focusData;
            if (focusTargetFilter) {
                focusFilterStateEnd(this.focusFilterStateList);
                selectEndFilterState(this.focusFilterStateList);
                this._currentFocusFilterState = null;
                this.focusFilterOperatorType = true;
            }
            else if (focusTargetFilterState) {
                const targetFocusColumn = getData(this.focusFilterStateList, focusTargetFilterState.filterStateId);
                if (targetFocusColumn) {
                    focusEnd(this);
                    if (focusTargetFilterState.shiftKey && this._currentFocusFilterState) {
                        // multiple range select
                        const currentIndex = getIndex(this.focusFilterStateList, this._currentFocusFilterState.id);
                        const targetIndex = getIndex(this.focusFilterStateList, targetFocusColumn.id);
                        if (currentIndex !== null && targetIndex !== null) {
                            range(currentIndex, targetIndex).forEach((index) => {
                                this.focusFilterStateList[index].select = true;
                            });
                        }
                    }
                    else if (!focusTargetFilterState.ctrlKey) {
                        selectEndFilterState(this.focusFilterStateList);
                    }
                    this._currentFocusFilterState = targetFocusColumn;
                    this._currentFocusFilterState.select = true;
                    this._currentFocusFilterState.focus(focusTargetFilterState.focusType);
                }
            }
        }
        selectAll() {
            selectAllFilterState(this.focusFilterStateList);
            this._observeCall = !this._observeCall;
        }
        selectEnd() {
            selectEndFilterState(this.focusFilterStateList);
            this._observeCall = !this._observeCall;
        }
        destroy() {
            this._subscriptionList.forEach((sub) => sub.unsubscribe());
        }
        createFocusFilterStateList() {
            var _a, _b;
            const oldSize = this.focusFilterStateList.length;
            const size = this._filterStateList.length;
            let currentFilterStateIndex = null;
            let currentFocusType = "columnType";
            if ((_a = this._currentFocusFilterState) === null || _a === void 0 ? void 0 : _a.currentFocus) {
                currentFilterStateIndex = getIndex(this.focusFilterStateList, this._currentFocusFilterState.id);
                currentFocusType = this._currentFocusFilterState.currentFocus;
            }
            this.focusFilterStateList = [];
            this._filterStateList.forEach((filterState) => {
                this.focusFilterStateList.push(new FocusFilterStateModel(filterState));
            });
            // currentFocus reload
            if ((_b = this._currentFocusFilterState) === null || _b === void 0 ? void 0 : _b.currentFocus) {
                const targetFocusColumn = getData(this.focusFilterStateList, this._currentFocusFilterState.id);
                if (targetFocusColumn) {
                    targetFocusColumn.select = true;
                    targetFocusColumn.focus(this._currentFocusFilterState.currentFocus);
                    this._currentFocusFilterState = targetFocusColumn;
                }
            }
            if (oldSize < size) {
                // add focus
                focusEnd(this);
                selectEndFilterState(this.focusFilterStateList);
                this._currentFocusFilterState = this.focusFilterStateList[this.focusFilterStateList.length - 1];
                this._currentFocusFilterState.select = true;
                this._currentFocusFilterState.focus("columnType");
            }
            else if (oldSize > size && currentFilterStateIndex !== null) {
                // remove focus
                focusEnd(this);
                if (size === 0) {
                    this._currentFocusFilterState = null;
                    this.focusFilterOperatorType = true;
                }
                else {
                    let targetIndex = this.focusFilterStateList.length - 1;
                    if (currentFilterStateIndex === 0) {
                        targetIndex = 0;
                    }
                    else if (currentFilterStateIndex - 1 < size) {
                        targetIndex = currentFilterStateIndex - 1;
                    }
                    selectEndFilterState(this.focusFilterStateList);
                    this._currentFocusFilterState = this.focusFilterStateList[targetIndex];
                    this._currentFocusFilterState.select = true;
                    this._currentFocusFilterState.focus(currentFocusType);
                }
            }
        }
    }

    function focusTableEnd(focusTable) {
        focusTable.focusName = false;
        focusTable.focusComment = false;
    }
    function focusColumnEnd(focusColumns) {
        focusColumns.forEach((focusColumn) => {
            Object.keys(focusColumnKeyFocusTypeKeyMap).forEach((key) => {
                const k = key;
                focusColumn[k] = false;
            });
        });
    }
    function focusEnd$1(focusTable) {
        focusTableEnd(focusTable);
        focusColumnEnd(focusTable.focusColumns);
    }
    function selectEndColumn(focusColumns) {
        focusColumns.forEach((focusColumn) => (focusColumn.select = false));
    }
    function selectAllColumn(focusColumns) {
        focusColumns.forEach((focusColumn) => (focusColumn.select = true));
    }
    function currentFocusShowList(show, setting) {
        const focusTypes = [];
        setting.columnOrder.forEach((columnType) => {
            if (columnType === "columnName") {
                focusTypes.push(columnType);
            }
            else if (show[columnType]) {
                focusTypes.push(columnType);
            }
        });
        return focusTypes;
    }

    const focusColumnKeyFocusTypeKeyMap = {
        focusUnique: "columnUnique",
        focusAutoIncrement: "columnAutoIncrement",
        focusName: "columnName",
        focusDataType: "columnDataType",
        focusNotNull: "columnNotNull",
        focusDefault: "columnDefault",
        focusComment: "columnComment",
    };
    const focusTypeKeyFocusColumnKeyMap = {
        columnUnique: "focusUnique",
        columnAutoIncrement: "focusAutoIncrement",
        columnName: "focusName",
        columnDataType: "focusDataType",
        columnNotNull: "focusNotNull",
        columnDefault: "focusDefault",
        columnComment: "focusComment",
    };
    class FocusColumnModel {
        constructor(column, show, setting) {
            this.select = false;
            this.focusUnique = false;
            this.focusAutoIncrement = false;
            this.focusName = false;
            this.focusDataType = false;
            this.focusNotNull = false;
            this.focusDefault = false;
            this.focusComment = false;
            this._column = column;
            this._show = show;
            this._setting = setting;
        }
        get id() {
            return this._column.id;
        }
        get currentFocus() {
            let focusType = null;
            Object.keys(focusColumnKeyFocusTypeKeyMap).forEach((key) => {
                const k = key;
                if (this[k]) {
                    focusType = focusColumnKeyFocusTypeKeyMap[k];
                }
            });
            return focusType;
        }
        get currentFocusShowList() {
            return currentFocusShowList(this._show, this._setting);
        }
        focus(focusType) {
            const focusColumnKey = focusTypeKeyFocusColumnKeyMap[focusType];
            this[focusColumnKey] = true;
        }
        nextFocus() {
            const focusType = this.currentFocus;
            if (focusType) {
                const focusTypes = this.currentFocusShowList;
                let index = focusTypes.indexOf(focusType);
                if (index === focusTypes.length - 1) {
                    index = -1;
                }
                const nextFocusType = focusTypes[index + 1];
                const focusColumnKey = focusTypeKeyFocusColumnKeyMap[nextFocusType];
                focusColumnEnd([this]);
                this[focusColumnKey] = true;
            }
        }
        preFocus() {
            const focusType = this.currentFocus;
            if (focusType) {
                const focusTypes = this.currentFocusShowList;
                let index = focusTypes.indexOf(focusType);
                if (index === 0) {
                    index = focusTypes.length;
                }
                const preFocusType = focusTypes[index - 1];
                const focusColumnKey = focusTypeKeyFocusColumnKeyMap[preFocusType];
                focusColumnEnd([this]);
                this[focusColumnKey] = true;
            }
        }
        isLastFocus() {
            const focusType = this.currentFocus;
            if (focusType) {
                const focusTypes = this.currentFocusShowList;
                const index = focusTypes.indexOf(focusType);
                return index === focusTypes.length - 1;
            }
            return false;
        }
        isFirstFocus() {
            const focusType = this.currentFocus;
            if (focusType) {
                const focusTypes = this.currentFocusShowList;
                const index = focusTypes.indexOf(focusType);
                return index === 0;
            }
            return false;
        }
    }

    class ColumnModel {
        constructor(data) {
            this.name = "";
            this.comment = "";
            this.dataType = "";
            this.default = "";
            this.option = {
                autoIncrement: false,
                primaryKey: false,
                unique: false,
                notNull: false,
            };
            this.ui = {
                active: false,
                pk: false,
                fk: false,
                pfk: false,
                widthName: SIZE_MIN_WIDTH,
                widthComment: SIZE_MIN_WIDTH,
                widthDataType: SIZE_MIN_WIDTH,
                widthDefault: SIZE_MIN_WIDTH,
            };
            const { addColumn, addCustomColumn } = data;
            if (addColumn) {
                const { id } = addColumn;
                this.id = id;
            }
            else if (addCustomColumn) {
                const { id, option, ui, value } = addCustomColumn;
                this.id = id;
                if (option) {
                    this.option = Object.assign(this.option, option);
                }
                if (ui) {
                    this.ui = Object.assign(this.ui, ui);
                }
                if (value) {
                    this.name = value.name;
                    this.comment = value.comment;
                    this.dataType = value.dataType;
                    this.default = value.default;
                    this.ui.widthName = value.widthName;
                    this.ui.widthComment = value.widthComment;
                    this.ui.widthDataType = value.widthDataType;
                    this.ui.widthDefault = value.widthDefault;
                }
            }
            else {
                throw new Error("not found column");
            }
        }
    }

    function addColumn(store, tableId) {
        return {
            type: "column.add",
            data: tableId
                ? [
                    {
                        id: uuid(),
                        tableId,
                    },
                ]
                : store.tableState.tables
                    .filter((table) => table.ui.active)
                    .map((table) => {
                        return {
                            id: uuid(),
                            tableId: table.id,
                        };
                    }),
        };
    }
    function executeAddColumn(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        executeEditTableEnd(store);
        data.forEach((addColumn, index) => {
            const table = getData(tables, addColumn.tableId);
            if (table) {
                if (index === data.length - 1) {
                    executeFocusTable(store, {
                        tableId: table.id,
                    });
                }
                table.columns.push(new ColumnModel({ addColumn }));
            }
        });
        relationshipSort(tables, relationships);
    }
    function executeAddOnlyColumn(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        data.forEach((addColumn, index) => {
            const table = getData(tables, addColumn.tableId);
            if (table) {
                table.columns.push(new ColumnModel({ addColumn }));
            }
        });
        relationshipSort(tables, relationships);
    }
    function addCustomColumn(option, ui, value, tableIds) {
        return {
            type: "column.addCustom",
            data: tableIds.map((tableId) => {
                return {
                    tableId,
                    id: uuid(),
                    option,
                    ui,
                    value,
                };
            }),
        };
    }
    function executeAddCustomColumn(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        data.forEach((addCustomColumn) => {
            const table = getData(tables, addCustomColumn.tableId);
            if (table) {
                table.columns.push(new ColumnModel({ addCustomColumn }));
            }
        });
        relationshipSort(tables, relationships);
    }
    function removeColumn(tableId, columnIds) {
        return {
            type: "column.remove",
            data: {
                tableId,
                columnIds,
            },
        };
    }
    function executeRemoveColumn(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        const table = getData(tables, data.tableId);
        if (table) {
            for (let i = 0; i < table.columns.length; i++) {
                const column = table.columns[i];
                if (data.columnIds.some((columnId) => columnId === column.id)) {
                    table.columns.splice(i, 1);
                    i--;
                }
            }
            // relationship valid
            removeValidColumnIndex(store, table, data.columnIds);
            removeValidColumnRelationship(store, table, data.columnIds);
            validIdentification(store);
            relationshipSort(tables, relationships);
        }
    }
    function removeOnlyColumn(tableId, columnIds) {
        return {
            type: "column.removeOnly",
            data: {
                tableId,
                columnIds,
            },
        };
    }
    function executeRemoveOnlyColumn(store, data) {
        const { tables } = store.tableState;
        const table = getData(tables, data.tableId);
        if (table) {
            for (let i = 0; i < table.columns.length; i++) {
                const column = table.columns[i];
                if (data.columnIds.some((columnId) => columnId === column.id)) {
                    table.columns.splice(i, 1);
                    i--;
                }
            }
        }
    }
    function changeColumnName(helper, tableId, columnId, value) {
        let width = helper.getTextWidth(value);
        if (width < SIZE_MIN_WIDTH) {
            width = SIZE_MIN_WIDTH;
        }
        return {
            type: "column.changeName",
            data: {
                tableId,
                columnId,
                value,
                width,
            },
        };
    }
    function executeChangeColumnName(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        const column = getColumn(tables, data.tableId, data.columnId);
        if (column) {
            column.name = data.value;
            column.ui.widthName = data.width;
            relationshipSort(tables, relationships);
        }
    }
    function changeColumnComment(helper, tableId, columnId, value) {
        let width = helper.getTextWidth(value);
        if (width < SIZE_MIN_WIDTH) {
            width = SIZE_MIN_WIDTH;
        }
        return {
            type: "column.changeComment",
            data: {
                tableId,
                columnId,
                value,
                width,
            },
        };
    }
    function executeChangeColumnComment(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        const column = getColumn(tables, data.tableId, data.columnId);
        if (column) {
            column.comment = data.value;
            column.ui.widthComment = data.width;
            relationshipSort(tables, relationships);
        }
    }
    function changeColumnDataType(helper, tableId, columnId, value) {
        let width = helper.getTextWidth(value);
        if (width < SIZE_MIN_WIDTH) {
            width = SIZE_MIN_WIDTH;
        }
        return {
            type: "column.changeDataType",
            data: {
                tableId,
                columnId,
                value,
                width,
            },
        };
    }
    function executeChangeColumnDataType(store, data) {
        const { setting } = store.canvasState;
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        const targetColumn = getColumn(tables, data.tableId, data.columnId);
        if (targetColumn) {
            let columns = [targetColumn];
            if (setting.relationshipDataTypeSync) {
                columns = getDataTypeSyncColumns([targetColumn], tables, relationships);
            }
            columns.forEach((column) => {
                column.dataType = data.value;
                column.ui.widthDataType = data.width;
            });
            relationshipSort(tables, relationships);
        }
    }
    function changeColumnDefault(helper, tableId, columnId, value) {
        let width = helper.getTextWidth(value);
        if (width < SIZE_MIN_WIDTH) {
            width = SIZE_MIN_WIDTH;
        }
        return {
            type: "column.changeDefault",
            data: {
                tableId,
                columnId,
                value,
                width,
            },
        };
    }
    function executeChangeColumnDefault(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        const column = getColumn(tables, data.tableId, data.columnId);
        if (column) {
            column.default = data.value;
            column.ui.widthDefault = data.width;
            relationshipSort(tables, relationships);
        }
    }
    function changeColumnAutoIncrement(store, tableId, columnId) {
        const { tables } = store.tableState;
        return {
            type: "column.changeAutoIncrement",
            data: {
                tableId,
                columnId,
                value: getChangeOption(tables, tableId, columnId, "autoIncrement"),
            },
        };
    }
    function executeChangeColumnAutoIncrement(store, data) {
        const { tables } = store.tableState;
        const column = getColumn(tables, data.tableId, data.columnId);
        if (column) {
            column.option.autoIncrement = data.value;
        }
    }
    function changeColumnPrimaryKey(store, tableId, columnId) {
        const { tables } = store.tableState;
        return {
            type: "column.changePrimaryKey",
            data: {
                tableId,
                columnId,
                value: getChangeOption(tables, tableId, columnId, "primaryKey"),
            },
        };
    }
    function executeChangeColumnPrimaryKey(store, data) {
        const { tables } = store.tableState;
        const table = getData(tables, data.tableId);
        const column = getColumn(tables, data.tableId, data.columnId);
        if (table && column) {
            if (data.value) {
                if (column.ui.fk) {
                    column.ui.fk = false;
                    column.ui.pfk = true;
                }
                else {
                    column.ui.pk = true;
                }
                if (!column.option.notNull) {
                    executeChangeColumnNotNull(store, {
                        tableId: data.tableId,
                        columnId: data.columnId,
                        value: true,
                    });
                }
            }
            else {
                if (column.ui.pfk) {
                    column.ui.pfk = false;
                    column.ui.fk = true;
                }
                else {
                    column.ui.pk = false;
                }
            }
            column.option.primaryKey = data.value;
            // relationship valid
            validIdentification(store);
        }
    }
    function changeColumnUnique(store, tableId, columnId) {
        const { tables } = store.tableState;
        return {
            type: "column.changeUnique",
            data: {
                tableId,
                columnId,
                value: getChangeOption(tables, tableId, columnId, "unique"),
            },
        };
    }
    function executeChangeColumnUnique(store, data) {
        const { tables } = store.tableState;
        const column = getColumn(tables, data.tableId, data.columnId);
        if (column) {
            column.option.unique = data.value;
        }
    }
    function changeColumnNotNull(store, tableId, columnId) {
        const { tables } = store.tableState;
        return {
            type: "column.changeNotNull",
            data: {
                tableId,
                columnId,
                value: getChangeOption(tables, tableId, columnId, "notNull"),
            },
        };
    }
    function executeChangeColumnNotNull(store, data) {
        const { tables } = store.tableState;
        const column = getColumn(tables, data.tableId, data.columnId);
        if (column) {
            column.option.notNull = data.value;
        }
    }
    function moveColumn(tableId, columnIds, targetTableId, targetColumnId) {
        return {
            type: "column.move",
            data: {
                tableId,
                columnIds,
                targetTableId,
                targetColumnId,
            },
        };
    }
    function executeMoveColumn(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        const currentTable = getData(tables, data.tableId);
        const currentColumns = [];
        data.columnIds.forEach((columnId) => {
            const column = getColumn(tables, data.tableId, columnId);
            if (column) {
                currentColumns.push(column);
            }
        });
        const targetTable = getData(tables, data.targetTableId);
        const targetColumn = getColumn(tables, data.targetTableId, data.targetColumnId);
        if (currentTable &&
            targetTable &&
            currentColumns.length !== 0 &&
            targetColumn) {
            if (data.tableId === data.targetTableId &&
                !data.columnIds.some((columnId) => columnId === data.targetColumnId)) {
                const targetIndex = getIndex(currentTable.columns, targetColumn.id);
                if (targetIndex !== null) {
                    currentColumns.forEach((currentColumn) => {
                        const currentIndex = getIndex(currentTable.columns, currentColumn.id);
                        if (currentIndex !== null) {
                            currentTable.columns.splice(currentIndex, 1);
                        }
                    });
                    currentTable.columns.splice(targetIndex, 0, ...currentColumns);
                }
            }
            else if (data.tableId !== data.targetTableId &&
                !data.columnIds.some((columnId) => columnId === data.targetColumnId)) {
                const targetIndex = getIndex(targetTable.columns, targetColumn.id);
                if (targetIndex !== null) {
                    currentColumns.forEach((currentColumn) => {
                        const currentIndex = getIndex(currentTable.columns, currentColumn.id);
                        if (currentIndex !== null) {
                            currentTable.columns.splice(currentIndex, 1);
                        }
                    });
                    targetTable.columns.splice(targetIndex, 0, ...currentColumns);
                    executeDraggableColumn(store, {
                        tableId: data.targetTableId,
                        columnIds: data.columnIds,
                    });
                    // relationship valid
                    removeValidColumnIndex(store, currentTable, data.columnIds);
                    removeValidColumnRelationship(store, currentTable, data.columnIds);
                    validIdentification(store);
                    relationshipSort(tables, relationships);
                }
            }
        }
    }
    function activeColumn(relationship) {
        const { start, end } = relationship;
        return {
            type: "column.active",
            data: [
                {
                    tableId: start.tableId,
                    columnIds: start.columnIds,
                },
                {
                    tableId: end.tableId,
                    columnIds: end.columnIds,
                },
            ],
        };
    }
    function executeActiveColumn(store, data) {
        const { tables } = store.tableState;
        data.forEach((activeColumn) => {
            const table = getData(tables, activeColumn.tableId);
            if (table) {
                activeColumn.columnIds.forEach((columnId) => {
                    const column = getData(table.columns, columnId);
                    if (column) {
                        column.ui.active = true;
                    }
                });
            }
        });
    }
    function activeEndColumn(relationship) {
        const { start, end } = relationship;
        return {
            type: "column.activeEnd",
            data: [
                {
                    tableId: start.tableId,
                    columnIds: start.columnIds,
                },
                {
                    tableId: end.tableId,
                    columnIds: end.columnIds,
                },
            ],
        };
    }
    function executeActiveEndColumn(store, data) {
        const { tables } = store.tableState;
        data.forEach((activeColumn) => {
            const table = getData(tables, activeColumn.tableId);
            if (table) {
                activeColumn.columnIds.forEach((columnId) => {
                    const column = getData(table.columns, columnId);
                    if (column) {
                        column.ui.active = false;
                    }
                });
            }
        });
    }
    function loadColumn(tableId, columns, indexList) {
        return {
            type: "column.load",
            data: {
                tableId,
                columns,
                indexList,
            },
        };
    }
    function executeLoadColumn(store, data) {
        const { tables } = store.tableState;
        const table = getData(tables, data.tableId);
        if (table) {
            data.columns.forEach((column, index) => {
                column.ui.active = false;
                table.columns.splice(data.indexList[index], 0, column);
            });
        }
    }

    class FocusTableModel {
        constructor(table, store) {
            this.focusName = true;
            this.focusComment = false;
            this.focusColumns = [];
            this._observeCall = true;
            this._currentFocusColumn = null;
            this._subscriptionList = [];
            const { show, setting } = store.canvasState;
            this._table = table;
            this._store = store;
            this._table.columns.forEach((column) => {
                this.focusColumns.push(new FocusColumnModel(column, show, setting));
            });
            this._subscriptionList.push(store.observe(this._table.columns, () => this.createFocusColumns()));
        }
        get id() {
            return this._table.id;
        }
        get currentFocus() {
            var _a;
            if ((_a = this._currentFocusColumn) === null || _a === void 0 ? void 0 : _a.currentFocus) {
                return this._currentFocusColumn.currentFocus;
            }
            else if (this.focusComment) {
                return "tableComment";
            }
            return "tableName";
        }
        get currentFocusId() {
            if (this._currentFocusColumn === null) {
                return this.id;
            }
            else {
                return this._currentFocusColumn.id;
            }
        }
        get selectColumns() {
            return this.focusColumns
                .filter((focusColumn) => focusColumn.select)
                .map((focusColumn) => getData(this._table.columns, focusColumn.id))
                .filter((column) => column !== null);
        }
        move(focusMoveTable) {
            const { show } = this._store.canvasState;
            if (!focusMoveTable.shiftKey) {
                selectEndColumn(this.focusColumns);
            }
            switch (focusMoveTable.moveKey) {
                case "ArrowUp":
                    if (this.focusColumns.length !== 0) {
                        if (this._currentFocusColumn === null) {
                            // move table -> column
                            focusEnd$1(this);
                            this._currentFocusColumn = this.focusColumns[this.focusColumns.length - 1];
                            this._currentFocusColumn.select = true;
                            this._currentFocusColumn.focusName = true;
                        }
                        else {
                            const index = getIndex(this.focusColumns, this._currentFocusColumn.id);
                            if (index !== null) {
                                if (index === 0) {
                                    // move column -> table
                                    focusEnd$1(this);
                                    selectEndColumn(this.focusColumns);
                                    this._currentFocusColumn = null;
                                    this.focusName = true;
                                }
                                else {
                                    // move column -> column
                                    const currentFocus = this._currentFocusColumn.currentFocus;
                                    if (currentFocus) {
                                        focusEnd$1(this);
                                        this._currentFocusColumn = this.focusColumns[index - 1];
                                        this._currentFocusColumn.select = true;
                                        this._currentFocusColumn.focus(currentFocus);
                                    }
                                }
                            }
                        }
                    }
                    break;
                case "ArrowDown":
                    if (this.focusColumns.length !== 0) {
                        if (this._currentFocusColumn === null) {
                            // move table -> column
                            focusEnd$1(this);
                            this._currentFocusColumn = this.focusColumns[0];
                            this._currentFocusColumn.select = true;
                            this._currentFocusColumn.focusName = true;
                        }
                        else {
                            const index = getIndex(this.focusColumns, this._currentFocusColumn.id);
                            if (index !== null) {
                                if (index === this.focusColumns.length - 1) {
                                    // move column -> table
                                    focusEnd$1(this);
                                    selectEndColumn(this.focusColumns);
                                    this._currentFocusColumn = null;
                                    this.focusName = true;
                                }
                                else {
                                    // move column -> column
                                    const currentFocus = this._currentFocusColumn.currentFocus;
                                    if (currentFocus) {
                                        focusEnd$1(this);
                                        this._currentFocusColumn = this.focusColumns[index + 1];
                                        this._currentFocusColumn.select = true;
                                        this._currentFocusColumn.focus(currentFocus);
                                    }
                                }
                            }
                        }
                    }
                    break;
                case "ArrowLeft":
                    if (this._currentFocusColumn === null && show.tableComment) {
                        // move table -> table
                        focusColumnEnd(this.focusColumns);
                        selectEndColumn(this.focusColumns);
                        this.focusName = !this.focusName;
                        this.focusComment = !this.focusComment;
                    }
                    else if (this._currentFocusColumn) {
                        // move column -> column
                        this._currentFocusColumn.select = true;
                        this._currentFocusColumn.preFocus();
                    }
                    break;
                case "ArrowRight":
                    if (this._currentFocusColumn === null && show.tableComment) {
                        // move table -> table
                        focusColumnEnd(this.focusColumns);
                        selectEndColumn(this.focusColumns);
                        this.focusName = !this.focusName;
                        this.focusComment = !this.focusComment;
                    }
                    else if (this._currentFocusColumn) {
                        // move column -> column
                        this._currentFocusColumn.select = true;
                        this._currentFocusColumn.nextFocus();
                    }
                    break;
                case "Tab":
                    if (focusMoveTable.shiftKey) {
                        this.move({
                            moveKey: "ArrowLeft",
                            shiftKey: false,
                        });
                        if (this._currentFocusColumn &&
                            this._currentFocusColumn.isLastFocus()) {
                            this.move({
                                moveKey: "ArrowUp",
                                shiftKey: false,
                            });
                        }
                    }
                    else {
                        this.move({
                            moveKey: "ArrowRight",
                            shiftKey: false,
                        });
                        if (this._currentFocusColumn === null && this.focusName) {
                            if (this.focusColumns.length === 0) {
                                this._store.dispatch(addColumn(this._store), findActiveEnd());
                            }
                            else {
                                this.move({
                                    moveKey: "ArrowDown",
                                    shiftKey: false,
                                });
                            }
                        }
                        else if (this._currentFocusColumn) {
                            const columnIndex = getIndex(this.focusColumns, this._currentFocusColumn.id);
                            const isLastColumn = columnIndex === this.focusColumns.length - 1;
                            if (isLastColumn && this._currentFocusColumn.isFirstFocus()) {
                                this._store.dispatch(addColumn(this._store), findActiveEnd());
                            }
                            else if (this._currentFocusColumn.isFirstFocus()) {
                                this.move({
                                    moveKey: "ArrowDown",
                                    shiftKey: false,
                                });
                            }
                        }
                    }
                    break;
            }
            this._observeCall = !this._observeCall;
        }
        focus(focusData) {
            const { focusTargetTable, focusTargetColumn } = focusData;
            if (focusTargetTable) {
                // focus table
                focusEnd$1(this);
                selectEndColumn(this.focusColumns);
                this._currentFocusColumn = null;
                if (focusTargetTable.focusType === "tableComment") {
                    this.focusComment = true;
                }
                else {
                    this.focusName = true;
                }
            }
            else if (focusTargetColumn) {
                // focus column
                const targetFocusColumn = getData(this.focusColumns, focusTargetColumn.columnId);
                if (targetFocusColumn) {
                    focusEnd$1(this);
                    if (focusTargetColumn.shiftKey && this._currentFocusColumn) {
                        // multiple range select
                        const currentIndex = getIndex(this.focusColumns, this._currentFocusColumn.id);
                        const targetIndex = getIndex(this.focusColumns, targetFocusColumn.id);
                        if (currentIndex !== null && targetIndex !== null) {
                            range(currentIndex, targetIndex).forEach((index) => {
                                this.focusColumns[index].select = true;
                            });
                        }
                    }
                    else if (!focusTargetColumn.ctrlKey) {
                        selectEndColumn(this.focusColumns);
                    }
                    this._currentFocusColumn = targetFocusColumn;
                    this._currentFocusColumn.select = true;
                    this._currentFocusColumn.focus(focusTargetColumn.focusType);
                }
            }
        }
        selectAll() {
            selectAllColumn(this.focusColumns);
            this._observeCall = !this._observeCall;
        }
        selectEnd() {
            selectEndColumn(this.focusColumns);
            this._observeCall = !this._observeCall;
        }
        destroy() {
            this._subscriptionList.forEach((sub) => sub.unsubscribe());
        }
        createFocusColumns() {
            var _a, _b;
            const { show, setting } = this._store.canvasState;
            const oldColumnsSize = this.focusColumns.length;
            const columnsSize = this._table.columns.length;
            let currentColumnIndex = null;
            let currentFocusType = currentFocusShowList(show, setting)[0];
            if ((_a = this._currentFocusColumn) === null || _a === void 0 ? void 0 : _a.currentFocus) {
                currentColumnIndex = getIndex(this.focusColumns, this._currentFocusColumn.id);
                currentFocusType = this._currentFocusColumn.currentFocus;
            }
            this.focusColumns = [];
            this._table.columns.forEach((column) => {
                this.focusColumns.push(new FocusColumnModel(column, show, setting));
            });
            // currentFocusColumn reload
            if ((_b = this._currentFocusColumn) === null || _b === void 0 ? void 0 : _b.currentFocus) {
                const targetFocusColumn = getData(this.focusColumns, this._currentFocusColumn.id);
                if (targetFocusColumn) {
                    targetFocusColumn.select = true;
                    targetFocusColumn.focus(this._currentFocusColumn.currentFocus);
                    this._currentFocusColumn = targetFocusColumn;
                }
            }
            if (oldColumnsSize < columnsSize) {
                // addColumn focus
                focusEnd$1(this);
                selectEndColumn(this.focusColumns);
                this._currentFocusColumn = this.focusColumns[this.focusColumns.length - 1];
                this._currentFocusColumn.select = true;
                this._currentFocusColumn.focus(currentFocusShowList(show, setting)[0]);
            }
            else if (oldColumnsSize > columnsSize && currentColumnIndex !== null) {
                // removeColumn focus
                focusEnd$1(this);
                if (columnsSize === 0) {
                    this._currentFocusColumn = null;
                    this.focusName = true;
                }
                else {
                    let targetIndex = this.focusColumns.length - 1;
                    if (currentColumnIndex === 0) {
                        targetIndex = 0;
                    }
                    else if (currentColumnIndex - 1 < columnsSize) {
                        targetIndex = currentColumnIndex - 1;
                    }
                    selectEndColumn(this.focusColumns);
                    this._currentFocusColumn = this.focusColumns[targetIndex];
                    this._currentFocusColumn.select = true;
                    this._currentFocusColumn.focus(currentFocusType);
                }
            }
        }
    }

    class FilterStateModel {
        constructor(data) {
            this.columnType = "tableName";
            this.filterCode = "contain";
            this.value = "";
            const { addFilterState } = data;
            if (addFilterState) {
                const { id } = addFilterState;
                this.id = id;
            }
            else {
                throw new Error("not found filter");
            }
        }
    }

    class IndexModel {
        constructor(data) {
            this.name = "";
            this.columns = [];
            this.unique = false;
            const { addIndex, loadIndex } = data;
            if (addIndex) {
                const { id, tableId } = addIndex;
                this.id = id;
                this.tableId = tableId;
            }
            else if (loadIndex &&
                typeof loadIndex.id === "string" &&
                typeof loadIndex.name === "string" &&
                typeof loadIndex.tableId === "string" &&
                typeof loadIndex.unique === "boolean" &&
                Array.isArray(loadIndex.columns)) {
                const { id, name, tableId, columns, unique } = loadIndex;
                this.id = id;
                this.name = name;
                this.tableId = tableId;
                this.columns = cloneDeep(columns);
                this.unique = unique;
            }
            else {
                throw new Error("not found index");
            }
        }
    }

    function addIndex(tableId) {
        return {
            type: "index.add",
            data: {
                id: uuid(),
                tableId,
            },
        };
    }
    function executeAddIndex(store, data) {
        const { indexes } = store.tableState;
        indexes.push(new IndexModel({ addIndex: data }));
    }
    function removeIndex(indexIds) {
        return {
            type: "index.remove",
            data: {
                indexIds,
            },
        };
    }
    function executeRemoveIndex(store, data) {
        const { indexes } = store.tableState;
        for (let i = 0; i < indexes.length; i++) {
            const id = indexes[i].id;
            if (data.indexIds.some((indexId) => indexId === id)) {
                indexes.splice(i, 1);
                i--;
            }
        }
    }
    function changeIndexName(indexId, value) {
        return {
            type: "index.changeName",
            data: {
                indexId,
                value,
            },
        };
    }
    function executeChangeIndexName(store, data) {
        const { indexes } = store.tableState;
        const index = getData(indexes, data.indexId);
        if (index) {
            index.name = data.value;
        }
    }
    function changeIndexUnique(indexId, value) {
        return {
            type: "index.changeUnique",
            data: {
                indexId,
                value,
            },
        };
    }
    function executeChangeIndexUnique(store, data) {
        const { indexes } = store.tableState;
        const index = getData(indexes, data.indexId);
        if (index) {
            index.unique = data.value;
        }
    }
    function addIndexColumn(indexId, columnId) {
        return {
            type: "index.addColumn",
            data: {
                indexId,
                columnId,
            },
        };
    }
    function executeAddIndexColumn(store, data) {
        const { indexes } = store.tableState;
        const index = getData(indexes, data.indexId);
        if (index && !index.columns.some((column) => column.id === data.columnId)) {
            index.columns.push({
                id: data.columnId,
                orderType: "ASC",
            });
        }
    }
    function removeIndexColumn(indexId, columnId) {
        return {
            type: "index.removeColumn",
            data: {
                indexId,
                columnId,
            },
        };
    }
    function executeRemoveIndexColumn(store, data) {
        const { indexes } = store.tableState;
        const index = getData(indexes, data.indexId);
        if (index) {
            const targetIndex = getIndex(index.columns, data.columnId);
            if (targetIndex !== null) {
                index.columns.splice(targetIndex, 1);
            }
        }
    }
    function moveIndexColumn(indexId, columnId, targetColumnId) {
        return {
            type: "index.moveColumn",
            data: {
                indexId,
                columnId,
                targetColumnId,
            },
        };
    }
    function executeMoveIndexColumn(store, data) {
        const { indexes } = store.tableState;
        const index = getData(indexes, data.indexId);
        if (index && data.columnId !== data.targetColumnId) {
            const currentColumn = getData(index.columns, data.columnId);
            const currentIndex = getIndex(index.columns, data.columnId);
            const targetIndex = getIndex(index.columns, data.targetColumnId);
            if (currentColumn && currentIndex !== null && targetIndex !== null) {
                index.columns.splice(currentIndex, 1);
                index.columns.splice(targetIndex, 0, currentColumn);
            }
        }
    }
    function changeIndexColumnOrderType(indexId, columnId, value) {
        return {
            type: "index.changeColumnOrderType",
            data: {
                indexId,
                columnId,
                value,
            },
        };
    }
    function executeChangeIndexColumnOrderType(store, data) {
        const { indexes } = store.tableState;
        const index = getData(indexes, data.indexId);
        if (index) {
            const column = getData(index.columns, data.columnId);
            if (column) {
                column.orderType = data.value;
            }
        }
    }
    function loadIndex(index) {
        return {
            type: "index.load",
            data: index,
        };
    }
    function executeLoadIndex(store, data) {
        const { indexes } = store.tableState;
        indexes.push(new IndexModel({ loadIndex: data }));
    }

    function executeFocusTable(store, data) {
        var _a;
        const { tableState, editorState } = store;
        const table = getData(tableState.tables, data.tableId);
        if (table &&
            (editorState.focusTable === null ||
                editorState.focusTable.id !== data.tableId)) {
            if (((_a = editorState.focusTable) === null || _a === void 0 ? void 0 : _a.id) !== table.id) {
                executeFocusTableEnd(store);
                editorState.focusTable = new FocusTableModel(table, store);
            }
        }
    }
    function focusTableEnd$1() {
        return {
            type: "editor.focusTableEnd",
            data: null,
        };
    }
    function executeFocusTableEnd(store) {
        var _a;
        const { editorState } = store;
        (_a = editorState.focusTable) === null || _a === void 0 ? void 0 : _a.destroy();
        editorState.focusTable = null;
        executeEditTableEnd(store);
    }
    function focusMoveTable(moveKey, shiftKey) {
        return {
            type: "editor.focusMoveTable",
            data: {
                moveKey,
                shiftKey,
            },
        };
    }
    function executeFocusMoveTable(store, data) {
        const { focusTable } = store.editorState;
        focusTable === null || focusTable === void 0 ? void 0 : focusTable.move(data);
        executeEditTableEnd(store);
    }
    function focusTargetTable(focusType) {
        return {
            type: "editor.focusTargetTable",
            data: {
                focusType,
            },
        };
    }
    function executeFocusTargetTable(store, data) {
        const { focusTable } = store.editorState;
        focusTable === null || focusTable === void 0 ? void 0 : focusTable.focus({
            focusTargetTable: data,
        });
        executeEditTableEnd(store);
    }
    function focusTargetColumn(columnId, focusType, ctrlKey, shiftKey) {
        return {
            type: "editor.focusTargetColumn",
            data: {
                columnId,
                focusType,
                ctrlKey,
                shiftKey,
            },
        };
    }
    function executeFocusTargetColumn(store, data) {
        const { focusTable } = store.editorState;
        focusTable === null || focusTable === void 0 ? void 0 : focusTable.focus({
            focusTargetColumn: data,
        });
        executeEditTableEnd(store);
    }
    function selectAllColumn$1() {
        return {
            type: "editor.selectAllColumn",
            data: null,
        };
    }
    function executeSelectAllColumn(store) {
        const { focusTable } = store.editorState;
        focusTable === null || focusTable === void 0 ? void 0 : focusTable.selectAll();
    }
    function executeSelectEndColumn(store) {
        const { focusTable } = store.editorState;
        focusTable === null || focusTable === void 0 ? void 0 : focusTable.selectEnd();
    }
    function editTable(id, focusType) {
        return {
            type: "editor.editTable",
            data: {
                id,
                focusType,
            },
        };
    }
    function executeEditTable(store, data) {
        const { editorState } = store;
        editorState.editTable = data;
    }
    function editTableEnd() {
        return {
            type: "editor.editTableEnd",
            data: null,
        };
    }
    function executeEditTableEnd(store) {
        const { editorState } = store;
        editorState.editTable = null;
    }
    function draggableColumn(store, tableId, columnId, ctrlKey) {
        const columnIds = [];
        const { focusTable } = store.editorState;
        if (ctrlKey && focusTable) {
            focusTable.selectColumns.forEach((column) => columnIds.push(column.id));
        }
        else {
            columnIds.push(columnId);
        }
        return {
            type: "editor.draggableColumn",
            data: {
                tableId,
                columnIds,
            },
        };
    }
    function executeDraggableColumn(store, data) {
        const { editorState } = store;
        editorState.draggableColumn = data;
    }
    function draggableColumnEnd() {
        return {
            type: "editor.draggableColumnEnd",
            data: null,
        };
    }
    function executeDraggableColumnEnd(store) {
        const { editorState } = store;
        editorState.draggableColumn = null;
    }
    function drawStartRelationship(relationshipType) {
        return {
            type: "editor.drawStartRelationship",
            data: {
                relationshipType,
            },
        };
    }
    function executeDrawStartRelationship(store, data) {
        var _a;
        const { editorState } = store;
        if (((_a = editorState.drawRelationship) === null || _a === void 0 ? void 0 : _a.relationshipType) === data.relationshipType) {
            executeDrawEndRelationship(store);
        }
        else {
            editorState.drawRelationship = {
                relationshipType: data.relationshipType,
                start: null,
                end: {
                    x: 0,
                    y: 0,
                },
            };
        }
    }
    function executeDrawStartAddRelationship(store, data) {
        const { tables } = store.tableState;
        const { drawRelationship } = store.editorState;
        const table = getData(tables, data.tableId);
        if (drawRelationship && table) {
            if (!table.columns.some((column) => column.option.primaryKey)) {
                store.dispatch(addCustomColumn({
                    autoIncrement: false,
                    primaryKey: true,
                    unique: false,
                    notNull: true,
                }, {
                    active: false,
                    pk: true,
                    fk: false,
                    pfk: false,
                }, null, [table.id]));
            }
            drawRelationship.start = {
                table,
                x: table.ui.left,
                y: table.ui.top,
            };
        }
    }
    function drawEndRelationship() {
        return {
            type: "editor.drawEndRelationship",
            data: null,
        };
    }
    function executeDrawEndRelationship(store) {
        store.editorState.drawRelationship = null;
    }
    function drawRelationship$1(x, y) {
        return {
            type: "editor.drawRelationship",
            data: {
                x,
                y,
            },
        };
    }
    function executeDrawRelationship(store, data) {
        const { drawRelationship } = store.editorState;
        if (drawRelationship === null || drawRelationship === void 0 ? void 0 : drawRelationship.start) {
            drawRelationship.end.x = data.x;
            drawRelationship.end.y = data.y;
        }
    }
    function loadJson(value) {
        return {
            type: "editor.loadJson",
            data: {
                value,
            },
        };
    }
    function executeLoadJson(store, data) {
        const { canvasState, tableState, relationshipState } = store;
        executeClear(store);
        try {
            const json = JSON.parse(data.value);
            const canvasStateAny = store.canvasState;
            const canvasJson = json.canvas;
            if (isObject$1(canvasJson)) {
                Object.keys(canvasStateAny).forEach((key) => {
                    if (!isEmpty(canvasJson[key])) {
                        switch (key) {
                            case "show":
                                Object.keys(canvasState.show).forEach((showKey) => {
                                    if (typeof canvasJson.show[showKey] === "boolean") {
                                        canvasStateAny.show[showKey] = canvasJson.show[showKey];
                                    }
                                });
                                break;
                            case "database":
                                if (databaseList.some((value) => value === canvasJson.database)) {
                                    canvasState.database = canvasJson.database;
                                }
                                break;
                            case "canvasType":
                                if (canvasTypeList.some((value) => value === canvasJson.canvasType)) {
                                    canvasState.canvasType = canvasJson.canvasType;
                                }
                                break;
                            case "language":
                                if (languageList.some((value) => value === canvasJson.language)) {
                                    canvasState.language = canvasJson.language;
                                }
                                break;
                            case "tableCase":
                                if (nameCaseList.some((value) => value === canvasJson.tableCase)) {
                                    canvasState.tableCase = canvasJson.tableCase;
                                }
                                break;
                            case "columnCase":
                                if (nameCaseList.some((value) => value === canvasJson.columnCase)) {
                                    canvasState.columnCase = canvasJson.columnCase;
                                }
                                break;
                            case "width":
                            case "height":
                            case "scrollTop":
                            case "scrollLeft":
                                if (typeof canvasJson[key] === "number") {
                                    canvasState[key] = canvasJson[key];
                                }
                                break;
                            case "databaseName":
                                if (typeof canvasJson[key] === "string") {
                                    canvasState[key] = canvasJson[key];
                                }
                                break;
                            case "setting":
                                if (typeof canvasJson.setting.relationshipDataTypeSync === "boolean") {
                                    canvasState.setting.relationshipDataTypeSync =
                                        canvasJson.setting.relationshipDataTypeSync;
                                }
                                if (Array.isArray(canvasJson.setting.columnOrder) &&
                                    canvasJson.setting.columnOrder.length === 7 &&
                                    canvasJson.setting.columnOrder.indexOf("columnName") !== -1 &&
                                    canvasJson.setting.columnOrder.indexOf("columnDataType") !==
                                    -1 &&
                                    canvasJson.setting.columnOrder.indexOf("columnNotNull") !==
                                    -1 &&
                                    canvasJson.setting.columnOrder.indexOf("columnDefault") !==
                                    -1 &&
                                    canvasJson.setting.columnOrder.indexOf("columnComment") !==
                                    -1 &&
                                    canvasJson.setting.columnOrder.indexOf("columnUnique") !== -1 &&
                                    canvasJson.setting.columnOrder.indexOf("columnAutoIncrement") !== -1) {
                                    canvasState.setting.columnOrder.splice(0, canvasState.setting.columnOrder.length);
                                    canvasState.setting.columnOrder.push(...canvasJson.setting.columnOrder);
                                }
                                break;
                        }
                    }
                });
            }
            const tableJson = json.table;
            if (isObject$1(tableJson)) {
                if (Array.isArray(tableJson.tables)) {
                    tableJson.tables.forEach((loadTable) => {
                        executeLoadTable(store, loadTable);
                    });
                }
                if (Array.isArray(tableJson.indexes)) {
                    tableJson.indexes.forEach((loadIndex) => {
                        executeLoadIndex(store, loadIndex);
                    });
                }
            }
            const memoJson = json.memo;
            if (isObject$1(memoJson)) {
                if (Array.isArray(memoJson.memos)) {
                    memoJson.memos.forEach((loadMemo) => {
                        executeLoadMemo(store, loadMemo);
                    });
                }
            }
            const relationshipJson = json.relationship;
            if (isObject$1(relationshipJson)) {
                if (Array.isArray(relationshipJson.relationships)) {
                    relationshipJson.relationships.forEach((loadRelationship) => {
                        executeLoadRelationship(store, loadRelationship);
                    });
                }
                relationshipSort(tableState.tables, relationshipState.relationships);
            }
        }
        catch (err) {
            Logger.error(err);
        }
    }
    function initLoadJson(value) {
        return {
            type: "editor.initLoadJson",
            data: {
                value,
            },
        };
    }
    function copyColumn(tableId, columnIds) {
        return {
            type: "editor.copyColumn",
            data: {
                tableId,
                columnIds,
            },
        };
    }
    function executeCopyColumn(store, data) {
        const { tables } = store.tableState;
        const { copyColumns } = store.editorState;
        const table = getData(tables, data.tableId);
        if (table) {
            copyColumns.splice(0, copyColumns.length);
            data.columnIds.forEach((columnId) => {
                const column = getData(table.columns, columnId);
                if (column) {
                    copyColumns.push(column);
                }
            });
        }
    }
    function pasteColumn(store) {
        return {
            type: "editor.pasteColumn",
            data: {
                tableIds: store.tableState.tables
                    .filter((table) => table.ui.active)
                    .map((table) => table.id),
            },
        };
    }
    function executePasteColumn(store, data) {
        const { copyColumns } = store.editorState;
        if (copyColumns.length !== 0) {
            const batchCommand = [];
            copyColumns.forEach((column) => {
                const { option, ui } = column;
                batchCommand.push(addCustomColumn({
                    autoIncrement: option.autoIncrement,
                    primaryKey: option.primaryKey,
                    unique: option.unique,
                    notNull: option.notNull,
                }, {
                    active: false,
                    pk: option.primaryKey,
                    fk: false,
                    pfk: false,
                }, {
                    name: column.name,
                    dataType: column.dataType,
                    default: column.default,
                    comment: column.comment,
                    widthName: ui.widthName,
                    widthDataType: ui.widthDataType,
                    widthDefault: ui.widthDefault,
                    widthComment: ui.widthComment,
                }, data.tableIds));
            });
            store.dispatch(...batchCommand);
        }
    }
    function clear() {
        return {
            type: "editor.clear",
            data: null,
        };
    }
    function executeClear(store) {
        const { tables } = store.tableState;
        const { memos } = store.memoState;
        const { relationships } = store.relationshipState;
        tables.splice(0, tables.length);
        memos.splice(0, memos.length);
        relationships.splice(0, relationships.length);
    }
    function addFilterState() {
        return {
            type: "editor.addFilterState",
            data: {
                id: uuid(),
            },
        };
    }
    function executeAddFilterState(store, data) {
        const { filterStateList } = store.editorState;
        executeEditFilterEnd(store);
        filterStateList.push(new FilterStateModel({ addFilterState: data }));
    }
    function removeFilterState(filterStateIds) {
        return {
            type: "editor.removeFilterState",
            data: {
                filterStateIds,
            },
        };
    }
    function executeRemoveFilterState(store, data) {
        const { filterStateList } = store.editorState;
        for (let i = 0; i < filterStateList.length; i++) {
            const id = filterStateList[i].id;
            if (data.filterStateIds.some((filterStateId) => filterStateId === id)) {
                filterStateList.splice(i, 1);
                i--;
            }
        }
    }
    function executeFocusFilter(store) {
        const { editorState } = store;
        editorState.focusFilter = new FocusFilterModel(editorState.filterStateList, store);
    }
    function executeFocusFilterEnd(store) {
        var _a;
        const { editorState } = store;
        (_a = editorState.focusFilter) === null || _a === void 0 ? void 0 : _a.destroy();
        editorState.focusFilter = null;
    }
    function filterActive() {
        return {
            type: "editor.filterActive",
            data: null,
        };
    }
    function executeFilterActive(store) {
        const { editorState } = store;
        editorState.filterActive = true;
        executeFocusFilter(store);
    }
    function filterActiveEnd() {
        return {
            type: "editor.filterActiveEnd",
            data: null,
        };
    }
    function executeFilterActiveEnd(store) {
        const { editorState } = store;
        editorState.filterActive = false;
        executeFocusFilterEnd(store);
        executeEditFilterEnd(store);
    }
    function focusMoveFilter(moveKey, shiftKey) {
        return {
            type: "editor.focusMoveFilter",
            data: {
                moveKey,
                shiftKey,
            },
        };
    }
    function executeFocusMoveFilter(store, data) {
        const { focusFilter } = store.editorState;
        focusFilter === null || focusFilter === void 0 ? void 0 : focusFilter.move(data);
        executeEditFilterEnd(store);
    }
    function focusTargetFilter(focusType) {
        return {
            type: "editor.focusTargetFilter",
            data: {
                focusType,
            },
        };
    }
    function executeFocusTargetFilter(store, data) {
        const { focusFilter } = store.editorState;
        focusFilter === null || focusFilter === void 0 ? void 0 : focusFilter.focus({
            focusTargetFilter: data,
        });
        executeEditFilterEnd(store);
    }
    function focusTargetFilterState(filterStateId, focusType, ctrlKey, shiftKey) {
        return {
            type: "editor.focusTargetFilterState",
            data: {
                filterStateId,
                focusType,
                ctrlKey,
                shiftKey,
            },
        };
    }
    function executeFocusTargetFilterState(store, data) {
        const { focusFilter } = store.editorState;
        focusFilter === null || focusFilter === void 0 ? void 0 : focusFilter.focus({
            focusTargetFilterState: data,
        });
        executeEditFilterEnd(store);
    }
    function selectAllFilterState$1() {
        return {
            type: "editor.selectAllFilterState",
            data: null,
        };
    }
    function executeSelectAllFilterState(store) {
        const { focusFilter } = store.editorState;
        focusFilter === null || focusFilter === void 0 ? void 0 : focusFilter.selectAll();
    }
    function executeSelectEndFilterState(store) {
        const { focusFilter } = store.editorState;
        focusFilter === null || focusFilter === void 0 ? void 0 : focusFilter.selectEnd();
    }
    function editFilter(focusType, id) {
        return {
            type: "editor.editFilter",
            data: {
                id,
                focusType,
            },
        };
    }
    function executeEditFilter(store, data) {
        const { editorState } = store;
        editorState.editFilter = data;
    }
    function editFilterEnd() {
        return {
            type: "editor.editFilterEnd",
            data: null,
        };
    }
    function executeEditFilterEnd(store) {
        const { editorState } = store;
        editorState.editFilter = null;
    }
    function changeFilterStateColumnType(filterStateId, value) {
        return {
            type: "editor.changeFilterStateColumnType",
            data: {
                filterStateId,
                value,
            },
        };
    }
    function executeChangeFilterStateColumnType(store, data) {
        const { filterStateList } = store.editorState;
        const filetState = getData(filterStateList, data.filterStateId);
        if (filetState) {
            filetState.columnType = data.value;
        }
    }
    function changeFilterStateFilterCode(filterStateId, value) {
        return {
            type: "editor.changeFilterStateFilterCode",
            data: {
                filterStateId,
                value,
            },
        };
    }
    function executeChangeFilterStateFilterCode(store, data) {
        const { filterStateList } = store.editorState;
        const filetState = getData(filterStateList, data.filterStateId);
        if (filetState) {
            filetState.filterCode = data.value;
        }
    }
    function changeFilterStateValue(filterStateId, value) {
        return {
            type: "editor.changeFilterStateValue",
            data: {
                filterStateId,
                value,
            },
        };
    }
    function executeChangeFilterStateValue(store, data) {
        const { filterStateList } = store.editorState;
        const filetState = getData(filterStateList, data.filterStateId);
        if (filetState) {
            filetState.value = data.value;
        }
    }
    function changeFilterOperatorType(value) {
        return {
            type: "editor.changeFilterOperatorType",
            data: {
                value,
            },
        };
    }
    function executeChangeFilterOperatorType(store, data) {
        store.editorState.filterOperatorType = data.value;
    }
    function draggableFilterState(store, filterStateId, ctrlKey) {
        const filterStateIds = [];
        const { focusFilter } = store.editorState;
        if (ctrlKey && focusFilter) {
            focusFilter.selectFilterStateList.forEach((selectFilterState) => filterStateIds.push(selectFilterState.id));
        }
        else {
            filterStateIds.push(filterStateId);
        }
        return {
            type: "editor.draggableFilterState",
            data: {
                filterStateIds,
            },
        };
    }
    function executeDraggableFilterState(store, data) {
        const { editorState } = store;
        editorState.draggableFilterState = data;
    }
    function draggableFilterStateEnd() {
        return {
            type: "editor.draggableFilterStateEnd",
            data: null,
        };
    }
    function executeDraggableFilterStateEnd(store) {
        const { editorState } = store;
        editorState.draggableFilterState = null;
    }
    function moveFilterState(filterStateIds, targetFilterStateId) {
        return {
            type: "editor.moveFilterState",
            data: {
                filterStateIds,
                targetFilterStateId,
            },
        };
    }
    function executeMoveFilterState(store, data) {
        const { filterStateList } = store.editorState;
        const currentFilterStateList = [];
        data.filterStateIds.forEach((filterStateId) => {
            const filterState = getData(filterStateList, filterStateId);
            if (filterState) {
                currentFilterStateList.push(filterState);
            }
        });
        const targetFilterState = getData(filterStateList, data.targetFilterStateId);
        if (currentFilterStateList.length !== 0 && targetFilterState) {
            if (!data.filterStateIds.some((filterStateId) => filterStateId === data.targetFilterStateId)) {
                const targetIndex = getIndex(filterStateList, targetFilterState.id);
                if (targetIndex !== null) {
                    currentFilterStateList.forEach((currentFilterState) => {
                        const currentIndex = getIndex(filterStateList, currentFilterState.id);
                        if (currentIndex !== null) {
                            filterStateList.splice(currentIndex, 1);
                        }
                    });
                    filterStateList.splice(targetIndex, 0, ...currentFilterStateList);
                }
            }
        }
    }
    function findActive() {
        return {
            type: "editor.findActive",
            data: null,
        };
    }
    function executeFindActive(store) {
        const { editorState } = store;
        editorState.findActive = true;
        executeSelectEndTable(store);
        executeSelectEndMemo(store);
    }
    function findActiveEnd() {
        return {
            type: "editor.findActiveEnd",
            data: null,
        };
    }
    function executeFindActiveEnd(store) {
        const { editorState } = store;
        editorState.findActive = false;
    }
    function hasUndoRedo(hasUndo, hasRedo) {
        return {
            type: "editor.hasUndoRedo",
            data: {
                hasUndo,
                hasRedo,
            },
        };
    }
    function executeHasUndoRedo(store, data) {
        const { editorState } = store;
        editorState.hasUndo = data.hasUndo;
        editorState.hasRedo = data.hasRedo;
    }

    const TABLE_PADDING$1 = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const TABLE_SORT_PADDING = TABLE_PADDING$1 * 4;
    function addTable(store) {
        const { tableState, memoState } = store;
        const point = nextPoint(store, tableState.tables, memoState.memos);
        return {
            type: "table.add",
            data: {
                id: uuid(),
                ui: {
                    active: true,
                    left: point.left,
                    top: point.top,
                    zIndex: nextZIndex(tableState.tables, memoState.memos),
                },
            },
        };
    }
    function executeAddTable(store, data) {
        const { tables } = store.tableState;
        executeSelectEndTable(store);
        executeSelectEndMemo(store);
        tables.push(new TableModel({ addTable: data }, store.canvasState.show));
        executeFocusTable(store, { tableId: data.id });
    }
    function executeAddOnlyTable(store, data) {
        const { tables } = store.tableState;
        tables.push(new TableModel({ addTable: data }, store.canvasState.show));
    }
    function moveTable(store, ctrlKey, movementX, movementY, tableId) {
        const { tableState, memoState } = store;
        return {
            type: "table.move",
            data: {
                movementX,
                movementY,
                tableIds: ctrlKey
                    ? tableState.tables
                        .filter((table) => table.ui.active)
                        .map((table) => table.id)
                    : [tableId],
                memoIds: ctrlKey
                    ? memoState.memos
                        .filter((memo) => memo.ui.active)
                        .map((memo) => memo.id)
                    : [],
            },
        };
    }
    function executeMoveTable(store, data) {
        const { tables } = store.tableState;
        const { memos } = store.memoState;
        const { relationships } = store.relationshipState;
        data.tableIds.forEach((tableId) => {
            const table = getData(tables, tableId);
            if (table) {
                table.ui.left += data.movementX;
                table.ui.top += data.movementY;
            }
        });
        data.memoIds.forEach((memoId) => {
            const memo = getData(memos, memoId);
            if (memo) {
                memo.ui.left += data.movementX;
                memo.ui.top += data.movementY;
            }
        });
        relationshipSort(tables, relationships);
    }
    function removeTable(store, tableId) {
        const { tables } = store.tableState;
        return {
            type: "table.remove",
            data: {
                tableIds: tableId
                    ? [tableId]
                    : tables.filter((table) => table.ui.active).map((table) => table.id),
            },
        };
    }
    function executeRemoveTable(store, data) {
        const { tables } = store.tableState;
        for (let i = 0; i < tables.length; i++) {
            const id = tables[i].id;
            if (data.tableIds.some((tableId) => tableId === id)) {
                tables.splice(i, 1);
                i--;
            }
        }
        // relationship valid
        removeValidTableIndex(store, data.tableIds);
        removeValidTableRelationship(store, data.tableIds);
    }
    function selectTable(store, ctrlKey, tableId) {
        const { tableState, memoState } = store;
        return {
            type: "table.select",
            data: {
                ctrlKey,
                tableId,
                zIndex: nextZIndex(tableState.tables, memoState.memos),
            },
        };
    }
    function executeSelectTable(store, data) {
        const { tables } = store.tableState;
        const { drawRelationship } = store.editorState;
        const targetTable = getData(tables, data.tableId);
        if (targetTable) {
            targetTable.ui.zIndex = data.zIndex;
            if (data.ctrlKey) {
                targetTable.ui.active = true;
            }
            else {
                tables.forEach((table) => {
                    table.ui.active = table.id === data.tableId;
                });
                executeSelectEndMemo(store);
            }
            executeFocusTable(store, { tableId: data.tableId });
            if (drawRelationship) {
                if (drawRelationship.start) {
                    const batchCommand = [];
                    const addRelationshipCommand = addRelationship(drawRelationship.relationshipType, drawRelationship.start.table, data.tableId);
                    const startTable = drawRelationship.start.table;
                    // create end table column
                    const createEndColumns = [];
                    const { start, end } = addRelationshipCommand.data;
                    start.columnIds.forEach((startColumnId, index) => {
                        const startColumn = getData(startTable.columns, startColumnId);
                        if (startColumn) {
                            createEndColumns.push({
                                tableId: end.tableId,
                                id: end.columnIds[index],
                                option: null,
                                ui: {
                                    active: false,
                                    pk: false,
                                    fk: true,
                                    pfk: false,
                                },
                                value: {
                                    name: startColumn.name,
                                    comment: startColumn.comment,
                                    dataType: startColumn.dataType,
                                    default: startColumn.default,
                                    widthName: startColumn.ui.widthName,
                                    widthComment: startColumn.ui.widthComment,
                                    widthDataType: startColumn.ui.widthDataType,
                                    widthDefault: startColumn.ui.widthDefault,
                                },
                            });
                        }
                    });
                    batchCommand.push({
                        type: "column.addCustom",
                        data: createEndColumns,
                    }, addRelationshipCommand);
                    store.dispatch(...batchCommand);
                    executeDrawEndRelationship(store);
                }
                else {
                    executeDrawStartAddRelationship(store, { tableId: data.tableId });
                }
            }
        }
    }
    function selectEndTable() {
        return {
            type: "table.selectEnd",
            data: null,
        };
    }
    function executeSelectEndTable(store) {
        const { tables } = store.tableState;
        tables.forEach((table) => (table.ui.active = false));
        executeFocusTableEnd(store);
    }
    function selectAllTable() {
        return {
            type: "table.selectAll",
            data: null,
        };
    }
    function executeSelectAllTable(store) {
        const { tables } = store.tableState;
        tables.forEach((table) => (table.ui.active = true));
    }
    function selectOnlyTable(store, tableId) {
        const { tableState, memoState } = store;
        return {
            type: "table.selectOnly",
            data: {
                tableId,
                zIndex: nextZIndex(tableState.tables, memoState.memos),
            },
        };
    }
    function executeSelectOnlyTable(store, data) {
        const { tables } = store.tableState;
        const targetTable = getData(tables, data.tableId);
        if (targetTable) {
            targetTable.ui.zIndex = data.zIndex;
        }
        tables.forEach((table) => {
            table.ui.active = table.id === data.tableId;
        });
        executeSelectEndMemo(store);
    }
    function changeTableName(helper, tableId, value) {
        let width = helper.getTextWidth(value);
        if (width < SIZE_MIN_WIDTH) {
            width = SIZE_MIN_WIDTH;
        }
        return {
            type: "table.changeName",
            data: {
                tableId,
                value,
                width,
            },
        };
    }
    function executeChangeTableName(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        const table = getData(tables, data.tableId);
        if (table) {
            table.name = data.value;
            table.ui.widthName = data.width;
            relationshipSort(tables, relationships);
        }
    }
    function changeTableComment(helper, tableId, value) {
        let width = helper.getTextWidth(value);
        if (width < SIZE_MIN_WIDTH) {
            width = SIZE_MIN_WIDTH;
        }
        return {
            type: "table.changeComment",
            data: {
                tableId,
                value,
                width,
            },
        };
    }
    function executeChangeTableComment(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        const table = getData(tables, data.tableId);
        if (table) {
            table.comment = data.value;
            table.ui.widthComment = data.width;
            relationshipSort(tables, relationships);
        }
    }
    function dragSelectTable(min, max) {
        return {
            type: "table.dragSelect",
            data: {
                min,
                max,
            },
        };
    }
    function executeDragSelectTable(store, data) {
        const { tables } = store.tableState;
        const { min, max } = data;
        tables.forEach((table) => {
            const centerX = table.ui.left + table.width() / 2 + TABLE_PADDING$1;
            const centerY = table.ui.top + table.height() / 2 + TABLE_PADDING$1;
            table.ui.active =
                min.x <= centerX &&
                max.x >= centerX &&
                min.y <= centerY &&
                max.y >= centerY;
        });
    }
    function sortTable() {
        return {
            type: "table.sort",
            data: null,
        };
    }
    function executeSortTable(store) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        const canvasWidth = store.canvasState.width;
        tables.sort((a, b) => a.columns.length - b.columns.length);
        let widthSum = 50;
        let currentHeight = 50;
        let maxHeight = 50;
        tables.forEach((table) => {
            const width = table.width() + TABLE_SORT_PADDING;
            const height = table.height() + TABLE_SORT_PADDING;
            if (widthSum + width > canvasWidth) {
                currentHeight += maxHeight;
                maxHeight = 0;
                widthSum = 50;
            }
            if (maxHeight < height) {
                maxHeight = height;
            }
            table.ui.top = currentHeight;
            table.ui.left = widthSum;
            widthSum += width;
        });
        relationshipSort(tables, relationships);
    }
    function loadTable(table) {
        return {
            type: "table.load",
            data: table,
        };
    }
    function executeLoadTable(store, data) {
        const { tables } = store.tableState;
        const { show } = store.canvasState;
        tables.push(new TableModel({ loadTable: data }, show));
    }

    function moveCanvas(scrollTop, scrollLeft) {
        return {
            type: "canvas.move",
            data: {
                scrollTop,
                scrollLeft,
            },
        };
    }
    function executeMoveCanvas(store, data) {
        const { canvasState } = store;
        canvasState.scrollTop = data.scrollTop;
        canvasState.scrollLeft = data.scrollLeft;
    }
    function resizeCanvas(width, height) {
        return {
            type: "canvas.resize",
            data: {
                width,
                height,
            },
        };
    }
    function executeResizeCanvas(store, data) {
        const { canvasState } = store;
        canvasState.width = data.width;
        canvasState.height = data.height;
    }
    function changeCanvasShow(store, showKey) {
        const { show } = store.canvasState;
        return {
            type: "canvas.changeShow",
            data: {
                showKey,
                value: !show[showKey],
            },
        };
    }
    function executeChangeCanvasShow(store, data) {
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        const { show } = store.canvasState;
        show[data.showKey] = data.value;
        relationshipSort(tables, relationships);
    }
    function changeDatabase(database) {
        return {
            type: "canvas.changeDatabase",
            data: {
                database,
            },
        };
    }
    function executeChangeDatabase(store, data) {
        store.canvasState.database = data.database;
    }
    function changeDatabaseName(value) {
        return {
            type: "canvas.changeDatabaseName",
            data: {
                value,
            },
        };
    }
    function executeChangeDatabaseName(store, data) {
        store.canvasState.databaseName = data.value;
    }
    function changeCanvasType(canvasType) {
        return {
            type: "canvas.changeCanvasType",
            data: {
                canvasType,
            },
        };
    }
    function executeChangeCanvasType(store, data) {
        store.canvasState.canvasType = data.canvasType;
    }
    function changeLanguage(language) {
        return {
            type: "canvas.changeLanguage",
            data: {
                language,
            },
        };
    }
    function executeChangeLanguage(store, data) {
        store.canvasState.language = data.language;
    }
    function changeTableCase(nameCase) {
        return {
            type: "canvas.changeTableCase",
            data: {
                nameCase,
            },
        };
    }
    function executeChangeTableCase(store, data) {
        store.canvasState.tableCase = data.nameCase;
    }
    function changeColumnCase(nameCase) {
        return {
            type: "canvas.changeColumnCase",
            data: {
                nameCase,
            },
        };
    }
    function executeChangeColumnCase(store, data) {
        store.canvasState.columnCase = data.nameCase;
    }
    function changeRelationshipDataTypeSync(value) {
        return {
            type: "canvas.changeRelationshipDataTypeSync",
            data: {
                value,
            },
        };
    }
    function executeChangeRelationshipDataTypeSync(store, data) {
        store.canvasState.setting.relationshipDataTypeSync = data.value;
    }
    function moveColumnOrder(columnType, targetColumnType) {
        return {
            type: "canvas.moveColumnOrder",
            data: {
                columnType,
                targetColumnType,
            },
        };
    }
    function executeMoveColumnOrder(store, data) {
        const { columnOrder } = store.canvasState.setting;
        if (data.columnType !== data.targetColumnType) {
            const targetIndex = columnOrder.indexOf(data.targetColumnType);
            const currentIndex = columnOrder.indexOf(data.columnType);
            if (targetIndex !== -1 && currentIndex !== -1) {
                columnOrder.splice(currentIndex, 1);
                columnOrder.splice(targetIndex, 0, data.columnType);
            }
        }
    }

    function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector(compare) {
        if (compare.length === 1) compare = ascendingComparator(compare);
        return {
            left: function(a, x, lo, hi) {
                if (lo == null) lo = 0;
                if (hi == null) hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0) lo = mid + 1;
                    else hi = mid;
                }
                return lo;
            },
            right: function(a, x, lo, hi) {
                if (lo == null) lo = 0;
                if (hi == null) hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0) hi = mid;
                    else lo = mid + 1;
                }
                return lo;
            }
        };
    }

    function ascendingComparator(f) {
        return function(d, x) {
            return ascending(f(d), x);
        };
    }

    var ascendingBisect = bisector(ascending);

    var noop = {value: function() {}};

    function dispatch$1() {
        for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
            if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
            _[t] = [];
        }
        return new Dispatch(_);
    }

    function Dispatch(_) {
        this._ = _;
    }

    function parseTypenames(typenames, types) {
        return typenames.trim().split(/^|\s+/).map(function(t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
            if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
            return {type: t, name: name};
        });
    }

    Dispatch.prototype = dispatch$1.prototype = {
        constructor: Dispatch,
        on: function(typename, callback) {
            var _ = this._,
                T = parseTypenames(typename + "", _),
                t,
                i = -1,
                n = T.length;

            // If no callback was specified, return the callback of the given type and name.
            if (arguments.length < 2) {
                while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
                return;
            }

            // If a type was specified, set the callback for the given type and name.
            // Otherwise, if a null callback was specified, remove callbacks of the given name.
            if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
            while (++i < n) {
                if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
                else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
            }

            return this;
        },
        copy: function() {
            var copy = {}, _ = this._;
            for (var t in _) copy[t] = _[t].slice();
            return new Dispatch(copy);
        },
        call: function(type, that) {
            if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
            if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
            for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
        },
        apply: function(type, that, args) {
            if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
            for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
        }
    };

    function get(type, name) {
        for (var i = 0, n = type.length, c; i < n; ++i) {
            if ((c = type[i]).name === name) {
                return c.value;
            }
        }
    }

    function set(type, name, callback) {
        for (var i = 0, n = type.length; i < n; ++i) {
            if (type[i].name === name) {
                type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
                break;
            }
        }
        if (callback != null) type.push({name: name, value: callback});
        return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: xhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
        var prefix = name += "", i = prefix.indexOf(":");
        if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
        return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
    }

    function creatorInherit(name) {
        return function() {
            var document = this.ownerDocument,
                uri = this.namespaceURI;
            return uri === xhtml && document.documentElement.namespaceURI === xhtml
                ? document.createElement(name)
                : document.createElementNS(uri, name);
        };
    }

    function creatorFixed(fullname) {
        return function() {
            return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
    }

    function creator(name) {
        var fullname = namespace(name);
        return (fullname.local
            ? creatorFixed
            : creatorInherit)(fullname);
    }

    function none() {}

    function selector(selector) {
        return selector == null ? none : function() {
            return this.querySelector(selector);
        };
    }

    function selection_select(select) {
        if (typeof select !== "function") select = selector(select);

        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node) subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                }
            }
        }

        return new Selection(subgroups, this._parents);
    }

    function empty$2() {
        return [];
    }

    function selectorAll(selector) {
        return selector == null ? empty$2 : function() {
            return this.querySelectorAll(selector);
        };
    }

    function selection_selectAll(select) {
        if (typeof select !== "function") select = selectorAll(select);

        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    subgroups.push(select.call(node, node.__data__, i, group));
                    parents.push(node);
                }
            }
        }

        return new Selection(subgroups, parents);
    }

    function matcher(selector) {
        return function() {
            return this.matches(selector);
        };
    }

    function selection_filter(match) {
        if (typeof match !== "function") match = matcher(match);

        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }

        return new Selection(subgroups, this._parents);
    }

    function sparse(update) {
        return new Array(update.length);
    }

    function selection_enter() {
        return new Selection(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum;
    }

    EnterNode.prototype = {
        constructor: EnterNode,
        appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
        insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
        querySelector: function(selector) { return this._parent.querySelector(selector); },
        querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant(x) {
        return function() {
            return x;
        };
    }

    var keyPrefix = "$"; // Protect against keys like __proto__.

    function bindIndex(parent, group, enter, update, exit, data) {
        var i = 0,
            node,
            groupLength = group.length,
            dataLength = data.length;

        // Put any non-null nodes that fit into update.
        // Put any null nodes into enter.
        // Put any remaining data into enter.
        for (; i < dataLength; ++i) {
            if (node = group[i]) {
                node.__data__ = data[i];
                update[i] = node;
            } else {
                enter[i] = new EnterNode(parent, data[i]);
            }
        }

        // Put any non-null nodes that dont fit into exit.
        for (; i < groupLength; ++i) {
            if (node = group[i]) {
                exit[i] = node;
            }
        }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
        var i,
            node,
            nodeByKeyValue = {},
            groupLength = group.length,
            dataLength = data.length,
            keyValues = new Array(groupLength),
            keyValue;

        // Compute the key for each node.
        // If multiple nodes have the same key, the duplicates are added to exit.
        for (i = 0; i < groupLength; ++i) {
            if (node = group[i]) {
                keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
                if (keyValue in nodeByKeyValue) {
                    exit[i] = node;
                } else {
                    nodeByKeyValue[keyValue] = node;
                }
            }
        }

        // Compute the key for each datum.
        // If there a node associated with this key, join and add it to update.
        // If there is not (or the key is a duplicate), add it to enter.
        for (i = 0; i < dataLength; ++i) {
            keyValue = keyPrefix + key.call(parent, data[i], i, data);
            if (node = nodeByKeyValue[keyValue]) {
                update[i] = node;
                node.__data__ = data[i];
                nodeByKeyValue[keyValue] = null;
            } else {
                enter[i] = new EnterNode(parent, data[i]);
            }
        }

        // Add any remaining nodes that were not bound to data to exit.
        for (i = 0; i < groupLength; ++i) {
            if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
                exit[i] = node;
            }
        }
    }

    function selection_data(value, key) {
        if (!value) {
            data = new Array(this.size()), j = -1;
            this.each(function(d) { data[++j] = d; });
            return data;
        }

        var bind = key ? bindKey : bindIndex,
            parents = this._parents,
            groups = this._groups;

        if (typeof value !== "function") value = constant(value);

        for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
            var parent = parents[j],
                group = groups[j],
                groupLength = group.length,
                data = value.call(parent, parent && parent.__data__, j, parents),
                dataLength = data.length,
                enterGroup = enter[j] = new Array(dataLength),
                updateGroup = update[j] = new Array(dataLength),
                exitGroup = exit[j] = new Array(groupLength);

            bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

            // Now connect the enter nodes to their following update node, such that
            // appendChild can insert the materialized enter node before this node,
            // rather than at the end of the parent node.
            for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
                if (previous = enterGroup[i0]) {
                    if (i0 >= i1) i1 = i0 + 1;
                    while (!(next = updateGroup[i1]) && ++i1 < dataLength);
                    previous._next = next || null;
                }
            }
        }

        update = new Selection(update, parents);
        update._enter = enter;
        update._exit = exit;
        return update;
    }

    function selection_exit() {
        return new Selection(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
        var enter = this.enter(), update = this, exit = this.exit();
        enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
        if (onupdate != null) update = onupdate(update);
        if (onexit == null) exit.remove(); else onexit(exit);
        return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(selection) {

        for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }

        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }

        return new Selection(merges, this._parents);
    }

    function selection_order() {

        for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
            for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }

        return this;
    }

    function selection_sort(compare) {
        if (!compare) compare = ascending$1;

        function compareNode(a, b) {
            return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }

        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    sortgroup[i] = node;
                }
            }
            sortgroup.sort(compareNode);
        }

        return new Selection(sortgroups, this._parents).order();
    }

    function ascending$1(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
        var callback = arguments[0];
        arguments[0] = this;
        callback.apply(null, arguments);
        return this;
    }

    function selection_nodes() {
        var nodes = new Array(this.size()), i = -1;
        this.each(function() { nodes[++i] = this; });
        return nodes;
    }

    function selection_node() {

        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
                var node = group[i];
                if (node) return node;
            }
        }

        return null;
    }

    function selection_size() {
        var size = 0;
        this.each(function() { ++size; });
        return size;
    }

    function selection_empty() {
        return !this.node();
    }

    function selection_each(callback) {

        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
                if (node = group[i]) callback.call(node, node.__data__, i, group);
            }
        }

        return this;
    }

    function attrRemove(name) {
        return function() {
            this.removeAttribute(name);
        };
    }

    function attrRemoveNS(fullname) {
        return function() {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }

    function attrConstant(name, value) {
        return function() {
            this.setAttribute(name, value);
        };
    }

    function attrConstantNS(fullname, value) {
        return function() {
            this.setAttributeNS(fullname.space, fullname.local, value);
        };
    }

    function attrFunction(name, value) {
        return function() {
            var v = value.apply(this, arguments);
            if (v == null) this.removeAttribute(name);
            else this.setAttribute(name, v);
        };
    }

    function attrFunctionNS(fullname, value) {
        return function() {
            var v = value.apply(this, arguments);
            if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
            else this.setAttributeNS(fullname.space, fullname.local, v);
        };
    }

    function selection_attr(name, value) {
        var fullname = namespace(name);

        if (arguments.length < 2) {
            var node = this.node();
            return fullname.local
                ? node.getAttributeNS(fullname.space, fullname.local)
                : node.getAttribute(fullname);
        }

        return this.each((value == null
            ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
                ? (fullname.local ? attrFunctionNS : attrFunction)
                : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
    }

    function defaultView(node) {
        return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
            || (node.document && node) // node is a Window
            || node.defaultView; // node is a Document
    }

    function styleRemove(name) {
        return function() {
            this.style.removeProperty(name);
        };
    }

    function styleConstant(name, value, priority) {
        return function() {
            this.style.setProperty(name, value, priority);
        };
    }

    function styleFunction(name, value, priority) {
        return function() {
            var v = value.apply(this, arguments);
            if (v == null) this.style.removeProperty(name);
            else this.style.setProperty(name, v, priority);
        };
    }

    function selection_style(name, value, priority) {
        return arguments.length > 1
            ? this.each((value == null
                ? styleRemove : typeof value === "function"
                    ? styleFunction
                    : styleConstant)(name, value, priority == null ? "" : priority))
            : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
        return node.style.getPropertyValue(name)
            || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
        return function() {
            delete this[name];
        };
    }

    function propertyConstant(name, value) {
        return function() {
            this[name] = value;
        };
    }

    function propertyFunction(name, value) {
        return function() {
            var v = value.apply(this, arguments);
            if (v == null) delete this[name];
            else this[name] = v;
        };
    }

    function selection_property(name, value) {
        return arguments.length > 1
            ? this.each((value == null
                ? propertyRemove : typeof value === "function"
                    ? propertyFunction
                    : propertyConstant)(name, value))
            : this.node()[name];
    }

    function classArray(string) {
        return string.trim().split(/^|\s+/);
    }

    function classList(node) {
        return node.classList || new ClassList(node);
    }

    function ClassList(node) {
        this._node = node;
        this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
        add: function(name) {
            var i = this._names.indexOf(name);
            if (i < 0) {
                this._names.push(name);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        remove: function(name) {
            var i = this._names.indexOf(name);
            if (i >= 0) {
                this._names.splice(i, 1);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        contains: function(name) {
            return this._names.indexOf(name) >= 0;
        }
    };

    function classedAdd(node, names) {
        var list = classList(node), i = -1, n = names.length;
        while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
        var list = classList(node), i = -1, n = names.length;
        while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
        return function() {
            classedAdd(this, names);
        };
    }

    function classedFalse(names) {
        return function() {
            classedRemove(this, names);
        };
    }

    function classedFunction(names, value) {
        return function() {
            (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
        };
    }

    function selection_classed(name, value) {
        var names = classArray(name + "");

        if (arguments.length < 2) {
            var list = classList(this.node()), i = -1, n = names.length;
            while (++i < n) if (!list.contains(names[i])) return false;
            return true;
        }

        return this.each((typeof value === "function"
            ? classedFunction : value
                ? classedTrue
                : classedFalse)(names, value));
    }

    function textRemove() {
        this.textContent = "";
    }

    function textConstant(value) {
        return function() {
            this.textContent = value;
        };
    }

    function textFunction(value) {
        return function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        };
    }

    function selection_text(value) {
        return arguments.length
            ? this.each(value == null
                ? textRemove : (typeof value === "function"
                    ? textFunction
                    : textConstant)(value))
            : this.node().textContent;
    }

    function htmlRemove() {
        this.innerHTML = "";
    }

    function htmlConstant(value) {
        return function() {
            this.innerHTML = value;
        };
    }

    function htmlFunction(value) {
        return function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        };
    }

    function selection_html(value) {
        return arguments.length
            ? this.each(value == null
                ? htmlRemove : (typeof value === "function"
                    ? htmlFunction
                    : htmlConstant)(value))
            : this.node().innerHTML;
    }

    function raise() {
        if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
        return this.each(raise);
    }

    function lower() {
        if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
        return this.each(lower);
    }

    function selection_append(name) {
        var create = typeof name === "function" ? name : creator(name);
        return this.select(function() {
            return this.appendChild(create.apply(this, arguments));
        });
    }

    function constantNull() {
        return null;
    }

    function selection_insert(name, before) {
        var create = typeof name === "function" ? name : creator(name),
            select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
        return this.select(function() {
            return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
        });
    }

    function remove() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
    }

    function selection_remove() {
        return this.each(remove);
    }

    function selection_cloneShallow() {
        var clone = this.cloneNode(false), parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
        var clone = this.cloneNode(true), parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
        return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
        return arguments.length
            ? this.property("__data__", value)
            : this.node().__data__;
    }

    var filterEvents = {};

    var event = null;

    if (typeof document !== "undefined") {
        var element = document.documentElement;
        if (!("onmouseenter" in element)) {
            filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
        }
    }

    function filterContextListener(listener, index, group) {
        listener = contextListener(listener, index, group);
        return function(event) {
            var related = event.relatedTarget;
            if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
                listener.call(this, event);
            }
        };
    }

    function contextListener(listener, index, group) {
        return function(event1) {
            var event0 = event; // Events can be reentrant (e.g., focus).
            event = event1;
            try {
                listener.call(this, this.__data__, index, group);
            } finally {
                event = event0;
            }
        };
    }

    function parseTypenames$1(typenames) {
        return typenames.trim().split(/^|\s+/).map(function(t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
            return {type: t, name: name};
        });
    }

    function onRemove(typename) {
        return function() {
            var on = this.__on;
            if (!on) return;
            for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
                if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
                    this.removeEventListener(o.type, o.listener, o.capture);
                } else {
                    on[++i] = o;
                }
            }
            if (++i) on.length = i;
            else delete this.__on;
        };
    }

    function onAdd(typename, value, capture) {
        var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
        return function(d, i, group) {
            var on = this.__on, o, listener = wrap(value, i, group);
            if (on) for (var j = 0, m = on.length; j < m; ++j) {
                if ((o = on[j]).type === typename.type && o.name === typename.name) {
                    this.removeEventListener(o.type, o.listener, o.capture);
                    this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                    o.value = value;
                    return;
                }
            }
            this.addEventListener(typename.type, listener, capture);
            o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
            if (!on) this.__on = [o];
            else on.push(o);
        };
    }

    function selection_on(typename, value, capture) {
        var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

        if (arguments.length < 2) {
            var on = this.node().__on;
            if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
                for (i = 0, o = on[j]; i < n; ++i) {
                    if ((t = typenames[i]).type === o.type && t.name === o.name) {
                        return o.value;
                    }
                }
            }
            return;
        }

        on = value ? onAdd : onRemove;
        if (capture == null) capture = false;
        for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
        return this;
    }

    function customEvent(event1, listener, that, args) {
        var event0 = event;
        event1.sourceEvent = event;
        event = event1;
        try {
            return listener.apply(that, args);
        } finally {
            event = event0;
        }
    }

    function dispatchEvent(node, type, params) {
        var window = defaultView(node),
            event = window.CustomEvent;

        if (typeof event === "function") {
            event = new event(type, params);
        } else {
            event = window.document.createEvent("Event");
            if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
            else event.initEvent(type, false, false);
        }

        node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
        return function() {
            return dispatchEvent(this, type, params);
        };
    }

    function dispatchFunction(type, params) {
        return function() {
            return dispatchEvent(this, type, params.apply(this, arguments));
        };
    }

    function selection_dispatch(type, params) {
        return this.each((typeof params === "function"
            ? dispatchFunction
            : dispatchConstant)(type, params));
    }

    var root = [null];

    function Selection(groups, parents) {
        this._groups = groups;
        this._parents = parents;
    }

    function selection() {
        return new Selection([[document.documentElement]], root);
    }

    Selection.prototype = selection.prototype = {
        constructor: Selection,
        select: selection_select,
        selectAll: selection_selectAll,
        filter: selection_filter,
        data: selection_data,
        enter: selection_enter,
        exit: selection_exit,
        join: selection_join,
        merge: selection_merge,
        order: selection_order,
        sort: selection_sort,
        call: selection_call,
        nodes: selection_nodes,
        node: selection_node,
        size: selection_size,
        empty: selection_empty,
        each: selection_each,
        attr: selection_attr,
        style: selection_style,
        property: selection_property,
        classed: selection_classed,
        text: selection_text,
        html: selection_html,
        raise: selection_raise,
        lower: selection_lower,
        append: selection_append,
        insert: selection_insert,
        remove: selection_remove,
        clone: selection_clone,
        datum: selection_datum,
        on: selection_on,
        dispatch: selection_dispatch
    };

    function select(selector) {
        return typeof selector === "string"
            ? new Selection([[document.querySelector(selector)]], [document.documentElement])
            : new Selection([[selector]], root);
    }

    function create(name) {
        return select(creator(name).call(document.documentElement));
    }

    function sourceEvent() {
        var current = event, source;
        while (source = current.sourceEvent) current = source;
        return current;
    }

    function point(node, event) {
        var svg = node.ownerSVGElement || node;

        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            point.x = event.clientX, point.y = event.clientY;
            point = point.matrixTransform(node.getScreenCTM().inverse());
            return [point.x, point.y];
        }

        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }

    function mouse(node) {
        var event = sourceEvent();
        if (event.changedTouches) event = event.changedTouches[0];
        return point(node, event);
    }

    function touch(node, touches, identifier) {
        if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

        for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
                return point(node, touch);
            }
        }

        return null;
    }

    function nopropagation() {
        event.stopImmediatePropagation();
    }

    function noevent() {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    function dragDisable(view) {
        var root = view.document.documentElement,
            selection = select(view).on("dragstart.drag", noevent, true);
        if ("onselectstart" in root) {
            selection.on("selectstart.drag", noevent, true);
        } else {
            root.__noselect = root.style.MozUserSelect;
            root.style.MozUserSelect = "none";
        }
    }

    function yesdrag(view, noclick) {
        var root = view.document.documentElement,
            selection = select(view).on("dragstart.drag", null);
        if (noclick) {
            selection.on("click.drag", noevent, true);
            setTimeout(function() { selection.on("click.drag", null); }, 0);
        }
        if ("onselectstart" in root) {
            selection.on("selectstart.drag", null);
        } else {
            root.style.MozUserSelect = root.__noselect;
            delete root.__noselect;
        }
    }

    function constant$1(x) {
        return function() {
            return x;
        };
    }

    function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
        this.target = target;
        this.type = type;
        this.subject = subject;
        this.identifier = id;
        this.active = active;
        this.x = x;
        this.y = y;
        this.dx = dx;
        this.dy = dy;
        this._ = dispatch;
    }

    DragEvent.prototype.on = function() {
        var value = this._.on.apply(this._, arguments);
        return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter() {
        return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
        return this.parentNode;
    }

    function defaultSubject(d) {
        return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable() {
        return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
        var filter = defaultFilter,
            container = defaultContainer,
            subject = defaultSubject,
            touchable = defaultTouchable,
            gestures = {},
            listeners = dispatch$1("start", "drag", "end"),
            active = 0,
            mousedownx,
            mousedowny,
            mousemoving,
            touchending,
            clickDistance2 = 0;

        function drag(selection) {
            selection
                .on("mousedown.drag", mousedowned)
                .filter(touchable)
                .on("touchstart.drag", touchstarted)
                .on("touchmove.drag", touchmoved)
                .on("touchend.drag touchcancel.drag", touchended)
                .style("touch-action", "none")
                .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
        }

        function mousedowned() {
            if (touchending || !filter.apply(this, arguments)) return;
            var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
            if (!gesture) return;
            select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
            dragDisable(event.view);
            nopropagation();
            mousemoving = false;
            mousedownx = event.clientX;
            mousedowny = event.clientY;
            gesture("start");
        }

        function mousemoved() {
            noevent();
            if (!mousemoving) {
                var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
                mousemoving = dx * dx + dy * dy > clickDistance2;
            }
            gestures.mouse("drag");
        }

        function mouseupped() {
            select(event.view).on("mousemove.drag mouseup.drag", null);
            yesdrag(event.view, mousemoving);
            noevent();
            gestures.mouse("end");
        }

        function touchstarted() {
            if (!filter.apply(this, arguments)) return;
            var touches = event.changedTouches,
                c = container.apply(this, arguments),
                n = touches.length, i, gesture;

            for (i = 0; i < n; ++i) {
                if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) {
                    nopropagation();
                    gesture("start");
                }
            }
        }

        function touchmoved() {
            var touches = event.changedTouches,
                n = touches.length, i, gesture;

            for (i = 0; i < n; ++i) {
                if (gesture = gestures[touches[i].identifier]) {
                    noevent();
                    gesture("drag");
                }
            }
        }

        function touchended() {
            var touches = event.changedTouches,
                n = touches.length, i, gesture;

            if (touchending) clearTimeout(touchending);
            touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
            for (i = 0; i < n; ++i) {
                if (gesture = gestures[touches[i].identifier]) {
                    nopropagation();
                    gesture("end");
                }
            }
        }

        function beforestart(id, container, point, that, args) {
            var p = point(container, id), s, dx, dy,
                sublisteners = listeners.copy();

            if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
                if ((event.subject = s = subject.apply(that, args)) == null) return false;
                dx = s.x - p[0] || 0;
                dy = s.y - p[1] || 0;
                return true;
            })) return;

            return function gesture(type) {
                var p0 = p, n;
                switch (type) {
                    case "start": gestures[id] = gesture, n = active++; break;
                    case "end": delete gestures[id], --active; // nobreak
                    case "drag": p = point(container, id), n = active; break;
                }
                customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
            };
        }

        drag.filter = function(_) {
            return arguments.length ? (filter = typeof _ === "function" ? _ : constant$1(!!_), drag) : filter;
        };

        drag.container = function(_) {
            return arguments.length ? (container = typeof _ === "function" ? _ : constant$1(_), drag) : container;
        };

        drag.subject = function(_) {
            return arguments.length ? (subject = typeof _ === "function" ? _ : constant$1(_), drag) : subject;
        };

        drag.touchable = function(_) {
            return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$1(!!_), drag) : touchable;
        };

        drag.on = function() {
            var value = listeners.on.apply(listeners, arguments);
            return value === listeners ? drag : value;
        };

        drag.clickDistance = function(_) {
            return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
        };

        return drag;
    }

    function define(constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
    }

    function extend(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition) prototype[key] = definition[key];
        return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
        aliceblue: 0xf0f8ff,
        antiquewhite: 0xfaebd7,
        aqua: 0x00ffff,
        aquamarine: 0x7fffd4,
        azure: 0xf0ffff,
        beige: 0xf5f5dc,
        bisque: 0xffe4c4,
        black: 0x000000,
        blanchedalmond: 0xffebcd,
        blue: 0x0000ff,
        blueviolet: 0x8a2be2,
        brown: 0xa52a2a,
        burlywood: 0xdeb887,
        cadetblue: 0x5f9ea0,
        chartreuse: 0x7fff00,
        chocolate: 0xd2691e,
        coral: 0xff7f50,
        cornflowerblue: 0x6495ed,
        cornsilk: 0xfff8dc,
        crimson: 0xdc143c,
        cyan: 0x00ffff,
        darkblue: 0x00008b,
        darkcyan: 0x008b8b,
        darkgoldenrod: 0xb8860b,
        darkgray: 0xa9a9a9,
        darkgreen: 0x006400,
        darkgrey: 0xa9a9a9,
        darkkhaki: 0xbdb76b,
        darkmagenta: 0x8b008b,
        darkolivegreen: 0x556b2f,
        darkorange: 0xff8c00,
        darkorchid: 0x9932cc,
        darkred: 0x8b0000,
        darksalmon: 0xe9967a,
        darkseagreen: 0x8fbc8f,
        darkslateblue: 0x483d8b,
        darkslategray: 0x2f4f4f,
        darkslategrey: 0x2f4f4f,
        darkturquoise: 0x00ced1,
        darkviolet: 0x9400d3,
        deeppink: 0xff1493,
        deepskyblue: 0x00bfff,
        dimgray: 0x696969,
        dimgrey: 0x696969,
        dodgerblue: 0x1e90ff,
        firebrick: 0xb22222,
        floralwhite: 0xfffaf0,
        forestgreen: 0x228b22,
        fuchsia: 0xff00ff,
        gainsboro: 0xdcdcdc,
        ghostwhite: 0xf8f8ff,
        gold: 0xffd700,
        goldenrod: 0xdaa520,
        gray: 0x808080,
        green: 0x008000,
        greenyellow: 0xadff2f,
        grey: 0x808080,
        honeydew: 0xf0fff0,
        hotpink: 0xff69b4,
        indianred: 0xcd5c5c,
        indigo: 0x4b0082,
        ivory: 0xfffff0,
        khaki: 0xf0e68c,
        lavender: 0xe6e6fa,
        lavenderblush: 0xfff0f5,
        lawngreen: 0x7cfc00,
        lemonchiffon: 0xfffacd,
        lightblue: 0xadd8e6,
        lightcoral: 0xf08080,
        lightcyan: 0xe0ffff,
        lightgoldenrodyellow: 0xfafad2,
        lightgray: 0xd3d3d3,
        lightgreen: 0x90ee90,
        lightgrey: 0xd3d3d3,
        lightpink: 0xffb6c1,
        lightsalmon: 0xffa07a,
        lightseagreen: 0x20b2aa,
        lightskyblue: 0x87cefa,
        lightslategray: 0x778899,
        lightslategrey: 0x778899,
        lightsteelblue: 0xb0c4de,
        lightyellow: 0xffffe0,
        lime: 0x00ff00,
        limegreen: 0x32cd32,
        linen: 0xfaf0e6,
        magenta: 0xff00ff,
        maroon: 0x800000,
        mediumaquamarine: 0x66cdaa,
        mediumblue: 0x0000cd,
        mediumorchid: 0xba55d3,
        mediumpurple: 0x9370db,
        mediumseagreen: 0x3cb371,
        mediumslateblue: 0x7b68ee,
        mediumspringgreen: 0x00fa9a,
        mediumturquoise: 0x48d1cc,
        mediumvioletred: 0xc71585,
        midnightblue: 0x191970,
        mintcream: 0xf5fffa,
        mistyrose: 0xffe4e1,
        moccasin: 0xffe4b5,
        navajowhite: 0xffdead,
        navy: 0x000080,
        oldlace: 0xfdf5e6,
        olive: 0x808000,
        olivedrab: 0x6b8e23,
        orange: 0xffa500,
        orangered: 0xff4500,
        orchid: 0xda70d6,
        palegoldenrod: 0xeee8aa,
        palegreen: 0x98fb98,
        paleturquoise: 0xafeeee,
        palevioletred: 0xdb7093,
        papayawhip: 0xffefd5,
        peachpuff: 0xffdab9,
        peru: 0xcd853f,
        pink: 0xffc0cb,
        plum: 0xdda0dd,
        powderblue: 0xb0e0e6,
        purple: 0x800080,
        rebeccapurple: 0x663399,
        red: 0xff0000,
        rosybrown: 0xbc8f8f,
        royalblue: 0x4169e1,
        saddlebrown: 0x8b4513,
        salmon: 0xfa8072,
        sandybrown: 0xf4a460,
        seagreen: 0x2e8b57,
        seashell: 0xfff5ee,
        sienna: 0xa0522d,
        silver: 0xc0c0c0,
        skyblue: 0x87ceeb,
        slateblue: 0x6a5acd,
        slategray: 0x708090,
        slategrey: 0x708090,
        snow: 0xfffafa,
        springgreen: 0x00ff7f,
        steelblue: 0x4682b4,
        tan: 0xd2b48c,
        teal: 0x008080,
        thistle: 0xd8bfd8,
        tomato: 0xff6347,
        turquoise: 0x40e0d0,
        violet: 0xee82ee,
        wheat: 0xf5deb3,
        white: 0xffffff,
        whitesmoke: 0xf5f5f5,
        yellow: 0xffff00,
        yellowgreen: 0x9acd32
    };

    define(Color, color, {
        copy: function(channels) {
            return Object.assign(new this.constructor, this, channels);
        },
        displayable: function() {
            return this.rgb().displayable();
        },
        hex: color_formatHex, // Deprecated! Use color.formatHex.
        formatHex: color_formatHex,
        formatHsl: color_formatHsl,
        formatRgb: color_formatRgb,
        toString: color_formatRgb
    });

    function color_formatHex() {
        return this.rgb().formatHex();
    }

    function color_formatHsl() {
        return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
        return this.rgb().formatRgb();
    }

    function color(format) {
        var m, l;
        format = (format + "").trim().toLowerCase();
        return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
            : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
                : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
                    : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
                        : null) // invalid hex
            : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
                : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
                    : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
                        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
                            : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
                                : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
                                    : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
                                        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
                                            : null;
    }

    function rgbn(n) {
        return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
        if (a <= 0) r = g = b = NaN;
        return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
        if (!(o instanceof Color)) o = color(o);
        if (!o) return new Rgb;
        o = o.rgb();
        return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
    }

    define(Rgb, rgb, extend(Color, {
        brighter: function(k) {
            k = k == null ? brighter : Math.pow(brighter, k);
            return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker: function(k) {
            k = k == null ? darker : Math.pow(darker, k);
            return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb: function() {
            return this;
        },
        displayable: function() {
            return (-0.5 <= this.r && this.r < 255.5)
                && (-0.5 <= this.g && this.g < 255.5)
                && (-0.5 <= this.b && this.b < 255.5)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        hex: rgb_formatHex, // Deprecated! Use color.formatHex.
        formatHex: rgb_formatHex,
        formatRgb: rgb_formatRgb,
        toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
        return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "rgb(" : "rgba(")
            + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.b) || 0))
            + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
        value = Math.max(0, Math.min(255, Math.round(value) || 0));
        return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
        if (a <= 0) h = s = l = NaN;
        else if (l <= 0 || l >= 1) h = s = NaN;
        else if (s <= 0) h = NaN;
        return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
        if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color)) o = color(o);
        if (!o) return new Hsl;
        if (o instanceof Hsl) return o;
        o = o.rgb();
        var r = o.r / 255,
            g = o.g / 255,
            b = o.b / 255,
            min = Math.min(r, g, b),
            max = Math.max(r, g, b),
            h = NaN,
            s = max - min,
            l = (max + min) / 2;
        if (s) {
            if (r === max) h = (g - b) / s + (g < b) * 6;
            else if (g === max) h = (b - r) / s + 2;
            else h = (r - g) / s + 4;
            s /= l < 0.5 ? max + min : 2 - max - min;
            h *= 60;
        } else {
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new Hsl(h, s, l, o.opacity);
    }

    function hsl(h, s, l, opacity) {
        return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }

    define(Hsl, hsl, extend(Color, {
        brighter: function(k) {
            k = k == null ? brighter : Math.pow(brighter, k);
            return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function(k) {
            k = k == null ? darker : Math.pow(darker, k);
            return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function() {
            var h = this.h % 360 + (this.h < 0) * 360,
                s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
                l = this.l,
                m2 = l + (l < 0.5 ? l : 1 - l) * s,
                m1 = 2 * l - m2;
            return new Rgb(
                hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
                hsl2rgb(h, m1, m2),
                hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
                this.opacity
            );
        },
        displayable: function() {
            return (0 <= this.s && this.s <= 1 || isNaN(this.s))
                && (0 <= this.l && this.l <= 1)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        formatHsl: function() {
            var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
            return (a === 1 ? "hsl(" : "hsla(")
                + (this.h || 0) + ", "
                + (this.s || 0) * 100 + "%, "
                + (this.l || 0) * 100 + "%"
                + (a === 1 ? ")" : ", " + a + ")");
        }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
        return (h < 60 ? m1 + (m2 - m1) * h / 60
            : h < 180 ? m2
                : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
                    : m1) * 255;
    }

    function constant$2(x) {
        return function() {
            return x;
        };
    }

    function linear(a, d) {
        return function(t) {
            return a + t * d;
        };
    }

    function exponential(a, b, y) {
        return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
            return Math.pow(a + t * b, y);
        };
    }

    function gamma(y) {
        return (y = +y) === 1 ? nogamma : function(a, b) {
            return b - a ? exponential(a, b, y) : constant$2(isNaN(a) ? b : a);
        };
    }

    function nogamma(a, b) {
        var d = b - a;
        return d ? linear(a, d) : constant$2(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
        var color = gamma(y);

        function rgb$1(start, end) {
            var r = color((start = rgb(start)).r, (end = rgb(end)).r),
                g = color(start.g, end.g),
                b = color(start.b, end.b),
                opacity = nogamma(start.opacity, end.opacity);
            return function(t) {
                start.r = r(t);
                start.g = g(t);
                start.b = b(t);
                start.opacity = opacity(t);
                return start + "";
            };
        }

        rgb$1.gamma = rgbGamma;

        return rgb$1;
    })(1);

    function interpolateNumber(a, b) {
        return a = +a, b = +b, function(t) {
            return a * (1 - t) + b * t;
        };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
        return function() {
            return b;
        };
    }

    function one(b) {
        return function(t) {
            return b(t) + "";
        };
    }

    function interpolateString(a, b) {
        var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
            am, // current match in a
            bm, // current match in b
            bs, // string preceding current number in b, if any
            i = -1, // index in s
            s = [], // string constants and placeholders
            q = []; // number interpolators

        // Coerce inputs to strings.
        a = a + "", b = b + "";

        // Interpolate pairs of numbers in a & b.
        while ((am = reA.exec(a))
        && (bm = reB.exec(b))) {
            if ((bs = bm.index) > bi) { // a string precedes the next number in b
                bs = b.slice(bi, bs);
                if (s[i]) s[i] += bs; // coalesce with previous string
                else s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
                if (s[i]) s[i] += bm; // coalesce with previous string
                else s[++i] = bm;
            } else { // interpolate non-matching numbers
                s[++i] = null;
                q.push({i: i, x: interpolateNumber(am, bm)});
            }
            bi = reB.lastIndex;
        }

        // Add remains of b.
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i]) s[i] += bs; // coalesce with previous string
            else s[++i] = bs;
        }

        // Special optimization for only a single match.
        // Otherwise, interpolate each of the numbers and rejoin the string.
        return s.length < 2 ? (q[0]
            ? one(q[0].x)
            : zero(b))
            : (b = q.length, function(t) {
                for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
                return s.join("");
            });
    }

    var degrees = 180 / Math.PI;

    var identity$1 = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        scaleX: 1,
        scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
        var scaleX, scaleY, skewX;
        if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
        if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
        if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
        if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
        return {
            translateX: e,
            translateY: f,
            rotate: Math.atan2(b, a) * degrees,
            skewX: Math.atan(skewX) * degrees,
            scaleX: scaleX,
            scaleY: scaleY
        };
    }

    var cssNode,
        cssRoot,
        cssView,
        svgNode;

    function parseCss(value) {
        if (value === "none") return identity$1;
        if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
        cssNode.style.transform = value;
        value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
        cssRoot.removeChild(cssNode);
        value = value.slice(7, -1).split(",");
        return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
    }

    function parseSvg(value) {
        if (value == null) return identity$1;
        if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svgNode.setAttribute("transform", value);
        if (!(value = svgNode.transform.baseVal.consolidate())) return identity$1;
        value = value.matrix;
        return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

        function pop(s) {
            return s.length ? s.pop() + " " : "";
        }

        function translate(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
                var i = s.push("translate(", null, pxComma, null, pxParen);
                q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
            } else if (xb || yb) {
                s.push("translate(" + xb + pxComma + yb + pxParen);
            }
        }

        function rotate(a, b, s, q) {
            if (a !== b) {
                if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
                q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
            } else if (b) {
                s.push(pop(s) + "rotate(" + b + degParen);
            }
        }

        function skewX(a, b, s, q) {
            if (a !== b) {
                q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
            } else if (b) {
                s.push(pop(s) + "skewX(" + b + degParen);
            }
        }

        function scale(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
                var i = s.push(pop(s) + "scale(", null, ",", null, ")");
                q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
            } else if (xb !== 1 || yb !== 1) {
                s.push(pop(s) + "scale(" + xb + "," + yb + ")");
            }
        }

        return function(a, b) {
            var s = [], // string constants and placeholders
                q = []; // number interpolators
            a = parse(a), b = parse(b);
            translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
            rotate(a.rotate, b.rotate, s, q);
            skewX(a.skewX, b.skewX, s, q);
            scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
            a = b = null; // gc
            return function(t) {
                var i = -1, n = q.length, o;
                while (++i < n) s[(o = q[i]).i] = o.x(t);
                return s.join("");
            };
        };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var frame = 0, // is an animation frame pending?
        timeout = 0, // is a timeout pending?
        interval = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
        return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
        clockNow = 0;
    }

    function Timer() {
        this._call =
            this._time =
                this._next = null;
    }

    Timer.prototype = timer$1.prototype = {
        constructor: Timer,
        restart: function(callback, delay, time) {
            if (typeof callback !== "function") throw new TypeError("callback is not a function");
            time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
            if (!this._next && taskTail !== this) {
                if (taskTail) taskTail._next = this;
                else taskHead = this;
                taskTail = this;
            }
            this._call = callback;
            this._time = time;
            sleep();
        },
        stop: function() {
            if (this._call) {
                this._call = null;
                this._time = Infinity;
                sleep();
            }
        }
    };

    function timer$1(callback, delay, time) {
        var t = new Timer;
        t.restart(callback, delay, time);
        return t;
    }

    function timerFlush() {
        now(); // Get the current time, if not already set.
        ++frame; // Pretend weve set an alarm, if we havent already.
        var t = taskHead, e;
        while (t) {
            if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
            t = t._next;
        }
        --frame;
    }

    function wake() {
        clockNow = (clockLast = clock.now()) + clockSkew;
        frame = timeout = 0;
        try {
            timerFlush();
        } finally {
            frame = 0;
            nap();
            clockNow = 0;
        }
    }

    function poke() {
        var now = clock.now(), delay = now - clockLast;
        if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
        var t0, t1 = taskHead, t2, time = Infinity;
        while (t1) {
            if (t1._call) {
                if (time > t1._time) time = t1._time;
                t0 = t1, t1 = t1._next;
            } else {
                t2 = t1._next, t1._next = null;
                t1 = t0 ? t0._next = t2 : taskHead = t2;
            }
        }
        taskTail = t0;
        sleep(time);
    }

    function sleep(time) {
        if (frame) return; // Soonest alarm already set, or will be.
        if (timeout) timeout = clearTimeout(timeout);
        var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
        if (delay > 24) {
            if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
            if (interval) interval = clearInterval(interval);
        } else {
            if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
            frame = 1, setFrame(wake);
        }
    }

    function timeout$1(callback, delay, time) {
        var t = new Timer;
        delay = delay == null ? 0 : +delay;
        t.restart(function(elapsed) {
            t.stop();
            callback(elapsed + delay);
        }, delay, time);
        return t;
    }

    var emptyOn = dispatch$1("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
        var schedules = node.__transition;
        if (!schedules) node.__transition = {};
        else if (id in schedules) return;
        create$1(node, id, {
            name: name,
            index: index, // For context during callback.
            group: group, // For context during callback.
            on: emptyOn,
            tween: emptyTween,
            time: timing.time,
            delay: timing.delay,
            duration: timing.duration,
            ease: timing.ease,
            timer: null,
            state: CREATED
        });
    }

    function init(node, id) {
        var schedule = get$1(node, id);
        if (schedule.state > CREATED) throw new Error("too late; already scheduled");
        return schedule;
    }

    function set$1(node, id) {
        var schedule = get$1(node, id);
        if (schedule.state > STARTED) throw new Error("too late; already running");
        return schedule;
    }

    function get$1(node, id) {
        var schedule = node.__transition;
        if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
        return schedule;
    }

    function create$1(node, id, self) {
        var schedules = node.__transition,
            tween;

        // Initialize the self timer when the transition is created.
        // Note the actual delay is not known until the first callback!
        schedules[id] = self;
        self.timer = timer$1(schedule, 0, self.time);

        function schedule(elapsed) {
            self.state = SCHEDULED;
            self.timer.restart(start, self.delay, self.time);

            // If the elapsed delay is less than our first sleep, start immediately.
            if (self.delay <= elapsed) start(elapsed - self.delay);
        }

        function start(elapsed) {
            var i, j, n, o;

            // If the state is not SCHEDULED, then we previously errored on start.
            if (self.state !== SCHEDULED) return stop();

            for (i in schedules) {
                o = schedules[i];
                if (o.name !== self.name) continue;

                // While this element already has a starting transition during this frame,
                // defer starting an interrupting transition until that transition has a
                // chance to tick (and possibly end); see d3/d3-transition#54!
                if (o.state === STARTED) return timeout$1(start);

                // Interrupt the active transition, if any.
                if (o.state === RUNNING) {
                    o.state = ENDED;
                    o.timer.stop();
                    o.on.call("interrupt", node, node.__data__, o.index, o.group);
                    delete schedules[i];
                }

                // Cancel any pre-empted transitions.
                else if (+i < id) {
                    o.state = ENDED;
                    o.timer.stop();
                    o.on.call("cancel", node, node.__data__, o.index, o.group);
                    delete schedules[i];
                }
            }

            // Defer the first tick to end of the current frame; see d3/d3#1576.
            // Note the transition may be canceled after start and before the first tick!
            // Note this must be scheduled before the start event; see d3/d3-transition#16!
            // Assuming this is successful, subsequent callbacks go straight to tick.
            timeout$1(function() {
                if (self.state === STARTED) {
                    self.state = RUNNING;
                    self.timer.restart(tick, self.delay, self.time);
                    tick(elapsed);
                }
            });

            // Dispatch the start event.
            // Note this must be done before the tween are initialized.
            self.state = STARTING;
            self.on.call("start", node, node.__data__, self.index, self.group);
            if (self.state !== STARTING) return; // interrupted
            self.state = STARTED;

            // Initialize the tween, deleting null tween.
            tween = new Array(n = self.tween.length);
            for (i = 0, j = -1; i < n; ++i) {
                if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
                    tween[++j] = o;
                }
            }
            tween.length = j + 1;
        }

        function tick(elapsed) {
            var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
                i = -1,
                n = tween.length;

            while (++i < n) {
                tween[i].call(node, t);
            }

            // Dispatch the end event.
            if (self.state === ENDING) {
                self.on.call("end", node, node.__data__, self.index, self.group);
                stop();
            }
        }

        function stop() {
            self.state = ENDED;
            self.timer.stop();
            delete schedules[id];
            for (var i in schedules) return; // eslint-disable-line no-unused-vars
            delete node.__transition;
        }
    }

    function interrupt(node, name) {
        var schedules = node.__transition,
            schedule,
            active,
            empty = true,
            i;

        if (!schedules) return;

        name = name == null ? null : name + "";

        for (i in schedules) {
            if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
            active = schedule.state > STARTING && schedule.state < ENDING;
            schedule.state = ENDED;
            schedule.timer.stop();
            schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
            delete schedules[i];
        }

        if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
        return this.each(function() {
            interrupt(this, name);
        });
    }

    function tweenRemove(id, name) {
        var tween0, tween1;
        return function() {
            var schedule = set$1(this, id),
                tween = schedule.tween;

            // If this node shared tween with the previous node,
            // just assign the updated shared tween and were done!
            // Otherwise, copy-on-write.
            if (tween !== tween0) {
                tween1 = tween0 = tween;
                for (var i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1 = tween1.slice();
                        tween1.splice(i, 1);
                        break;
                    }
                }
            }

            schedule.tween = tween1;
        };
    }

    function tweenFunction(id, name, value) {
        var tween0, tween1;
        if (typeof value !== "function") throw new Error;
        return function() {
            var schedule = set$1(this, id),
                tween = schedule.tween;

            // If this node shared tween with the previous node,
            // just assign the updated shared tween and were done!
            // Otherwise, copy-on-write.
            if (tween !== tween0) {
                tween1 = (tween0 = tween).slice();
                for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1[i] = t;
                        break;
                    }
                }
                if (i === n) tween1.push(t);
            }

            schedule.tween = tween1;
        };
    }

    function transition_tween(name, value) {
        var id = this._id;

        name += "";

        if (arguments.length < 2) {
            var tween = get$1(this.node(), id).tween;
            for (var i = 0, n = tween.length, t; i < n; ++i) {
                if ((t = tween[i]).name === name) {
                    return t.value;
                }
            }
            return null;
        }

        return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
        var id = transition._id;

        transition.each(function() {
            var schedule = set$1(this, id);
            (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
        });

        return function(node) {
            return get$1(node, id).value[name];
        };
    }

    function interpolate(a, b) {
        var c;
        return (typeof b === "number" ? interpolateNumber
            : b instanceof color ? interpolateRgb
                : (c = color(b)) ? (b = c, interpolateRgb)
                    : interpolateString)(a, b);
    }

    function attrRemove$1(name) {
        return function() {
            this.removeAttribute(name);
        };
    }

    function attrRemoveNS$1(fullname) {
        return function() {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }

    function attrConstant$1(name, interpolate, value1) {
        var string00,
            string1 = value1 + "",
            interpolate0;
        return function() {
            var string0 = this.getAttribute(name);
            return string0 === string1 ? null
                : string0 === string00 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, value1);
        };
    }

    function attrConstantNS$1(fullname, interpolate, value1) {
        var string00,
            string1 = value1 + "",
            interpolate0;
        return function() {
            var string0 = this.getAttributeNS(fullname.space, fullname.local);
            return string0 === string1 ? null
                : string0 === string00 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, value1);
        };
    }

    function attrFunction$1(name, interpolate, value) {
        var string00,
            string10,
            interpolate0;
        return function() {
            var string0, value1 = value(this), string1;
            if (value1 == null) return void this.removeAttribute(name);
            string0 = this.getAttribute(name);
            string1 = value1 + "";
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
    }

    function attrFunctionNS$1(fullname, interpolate, value) {
        var string00,
            string10,
            interpolate0;
        return function() {
            var string0, value1 = value(this), string1;
            if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
            string0 = this.getAttributeNS(fullname.space, fullname.local);
            string1 = value1 + "";
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
    }

    function transition_attr(name, value) {
        var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
        return this.attrTween(name, typeof value === "function"
            ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
            : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
                : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
        return function(t) {
            this.setAttribute(name, i.call(this, t));
        };
    }

    function attrInterpolateNS(fullname, i) {
        return function(t) {
            this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
        };
    }

    function attrTweenNS(fullname, value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
            return t0;
        }
        tween._value = value;
        return tween;
    }

    function attrTween(name, value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
            return t0;
        }
        tween._value = value;
        return tween;
    }

    function transition_attrTween(name, value) {
        var key = "attr." + name;
        if (arguments.length < 2) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== "function") throw new Error;
        var fullname = namespace(name);
        return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
        return function() {
            init(this, id).delay = +value.apply(this, arguments);
        };
    }

    function delayConstant(id, value) {
        return value = +value, function() {
            init(this, id).delay = value;
        };
    }

    function transition_delay(value) {
        var id = this._id;

        return arguments.length
            ? this.each((typeof value === "function"
                ? delayFunction
                : delayConstant)(id, value))
            : get$1(this.node(), id).delay;
    }

    function durationFunction(id, value) {
        return function() {
            set$1(this, id).duration = +value.apply(this, arguments);
        };
    }

    function durationConstant(id, value) {
        return value = +value, function() {
            set$1(this, id).duration = value;
        };
    }

    function transition_duration(value) {
        var id = this._id;

        return arguments.length
            ? this.each((typeof value === "function"
                ? durationFunction
                : durationConstant)(id, value))
            : get$1(this.node(), id).duration;
    }

    function easeConstant(id, value) {
        if (typeof value !== "function") throw new Error;
        return function() {
            set$1(this, id).ease = value;
        };
    }

    function transition_ease(value) {
        var id = this._id;

        return arguments.length
            ? this.each(easeConstant(id, value))
            : get$1(this.node(), id).ease;
    }

    function transition_filter(match) {
        if (typeof match !== "function") match = matcher(match);

        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }

        return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
        if (transition._id !== this._id) throw new Error;

        for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }

        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }

        return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
        return (name + "").trim().split(/^|\s+/).every(function(t) {
            var i = t.indexOf(".");
            if (i >= 0) t = t.slice(0, i);
            return !t || t === "start";
        });
    }

    function onFunction(id, name, listener) {
        var on0, on1, sit = start(name) ? init : set$1;
        return function() {
            var schedule = sit(this, id),
                on = schedule.on;

            // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and were done!
            // Otherwise, copy-on-write.
            if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

            schedule.on = on1;
        };
    }

    function transition_on(name, listener) {
        var id = this._id;

        return arguments.length < 2
            ? get$1(this.node(), id).on.on(name)
            : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
        return function() {
            var parent = this.parentNode;
            for (var i in this.__transition) if (+i !== id) return;
            if (parent) parent.removeChild(this);
        };
    }

    function transition_remove() {
        return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
        var name = this._name,
            id = this._id;

        if (typeof select !== "function") select = selector(select);

        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node) subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                    schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
                }
            }
        }

        return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
        var name = this._name,
            id = this._id;

        if (typeof select !== "function") select = selectorAll(select);

        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
                        if (child = children[k]) {
                            schedule(child, name, id, k, children, inherit);
                        }
                    }
                    subgroups.push(children);
                    parents.push(node);
                }
            }
        }

        return new Transition(subgroups, parents, name, id);
    }

    var Selection$1 = selection.prototype.constructor;

    function transition_selection() {
        return new Selection$1(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
        var string00,
            string10,
            interpolate0;
        return function() {
            var string0 = styleValue(this, name),
                string1 = (this.style.removeProperty(name), styleValue(this, name));
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, string10 = string1);
        };
    }

    function styleRemove$1(name) {
        return function() {
            this.style.removeProperty(name);
        };
    }

    function styleConstant$1(name, interpolate, value1) {
        var string00,
            string1 = value1 + "",
            interpolate0;
        return function() {
            var string0 = styleValue(this, name);
            return string0 === string1 ? null
                : string0 === string00 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, value1);
        };
    }

    function styleFunction$1(name, interpolate, value) {
        var string00,
            string10,
            interpolate0;
        return function() {
            var string0 = styleValue(this, name),
                value1 = value(this),
                string1 = value1 + "";
            if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
    }

    function styleMaybeRemove(id, name) {
        var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
        return function() {
            var schedule = set$1(this, id),
                on = schedule.on,
                listener = schedule.value[key] == null ? remove || (remove = styleRemove$1(name)) : undefined;

            // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and were done!
            // Otherwise, copy-on-write.
            if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

            schedule.on = on1;
        };
    }

    function transition_style(name, value, priority) {
        var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
        return value == null ? this
                .styleTween(name, styleNull(name, i))
                .on("end.style." + name, styleRemove$1(name))
            : typeof value === "function" ? this
                    .styleTween(name, styleFunction$1(name, i, tweenValue(this, "style." + name, value)))
                    .each(styleMaybeRemove(this._id, name))
                : this
                    .styleTween(name, styleConstant$1(name, i, value), priority)
                    .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
        return function(t) {
            this.style.setProperty(name, i.call(this, t), priority);
        };
    }

    function styleTween(name, value, priority) {
        var t, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
            return t;
        }
        tween._value = value;
        return tween;
    }

    function transition_styleTween(name, value, priority) {
        var key = "style." + (name += "");
        if (arguments.length < 2) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== "function") throw new Error;
        return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant$1(value) {
        return function() {
            this.textContent = value;
        };
    }

    function textFunction$1(value) {
        return function() {
            var value1 = value(this);
            this.textContent = value1 == null ? "" : value1;
        };
    }

    function transition_text(value) {
        return this.tween("text", typeof value === "function"
            ? textFunction$1(tweenValue(this, "text", value))
            : textConstant$1(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
        return function(t) {
            this.textContent = i.call(this, t);
        };
    }

    function textTween(value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
            return t0;
        }
        tween._value = value;
        return tween;
    }

    function transition_textTween(value) {
        var key = "text";
        if (arguments.length < 1) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== "function") throw new Error;
        return this.tween(key, textTween(value));
    }

    function transition_transition() {
        var name = this._name,
            id0 = this._id,
            id1 = newId();

        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    var inherit = get$1(node, id0);
                    schedule(node, name, id1, i, group, {
                        time: inherit.time + inherit.delay + inherit.duration,
                        delay: 0,
                        duration: inherit.duration,
                        ease: inherit.ease
                    });
                }
            }
        }

        return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
        var on0, on1, that = this, id = that._id, size = that.size();
        return new Promise(function(resolve, reject) {
            var cancel = {value: reject},
                end = {value: function() { if (--size === 0) resolve(); }};

            that.each(function() {
                var schedule = set$1(this, id),
                    on = schedule.on;

                // If this node shared a dispatch with the previous node,
                // just assign the updated shared dispatch and were done!
                // Otherwise, copy-on-write.
                if (on !== on0) {
                    on1 = (on0 = on).copy();
                    on1._.cancel.push(cancel);
                    on1._.interrupt.push(cancel);
                    on1._.end.push(end);
                }

                schedule.on = on1;
            });
        });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
        this._groups = groups;
        this._parents = parents;
        this._name = name;
        this._id = id;
    }

    function transition(name) {
        return selection().transition(name);
    }

    function newId() {
        return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
        constructor: Transition,
        select: transition_select,
        selectAll: transition_selectAll,
        filter: transition_filter,
        merge: transition_merge,
        selection: transition_selection,
        transition: transition_transition,
        call: selection_prototype.call,
        nodes: selection_prototype.nodes,
        node: selection_prototype.node,
        size: selection_prototype.size,
        empty: selection_prototype.empty,
        each: selection_prototype.each,
        on: transition_on,
        attr: transition_attr,
        attrTween: transition_attrTween,
        style: transition_style,
        styleTween: transition_styleTween,
        text: transition_text,
        textTween: transition_textTween,
        remove: transition_remove,
        tween: transition_tween,
        delay: transition_delay,
        duration: transition_duration,
        ease: transition_ease,
        end: transition_end
    };

    function cubicInOut(t) {
        return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var defaultTiming = {
        time: null, // Set on use.
        delay: 0,
        duration: 250,
        ease: cubicInOut
    };

    function inherit(node, id) {
        var timing;
        while (!(timing = node.__transition) || !(timing = timing[id])) {
            if (!(node = node.parentNode)) {
                return defaultTiming.time = now(), defaultTiming;
            }
        }
        return timing;
    }

    function selection_transition(name) {
        var id,
            timing;

        if (name instanceof Transition) {
            id = name._id, name = name._name;
        } else {
            id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
        }

        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    schedule(node, name, id, i, group, timing || inherit(node, id));
                }
            }
        }

        return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var prefix = "$";

    function Map$1() {}

    Map$1.prototype = map$1.prototype = {
        constructor: Map$1,
        has: function(key) {
            return (prefix + key) in this;
        },
        get: function(key) {
            return this[prefix + key];
        },
        set: function(key, value) {
            this[prefix + key] = value;
            return this;
        },
        remove: function(key) {
            var property = prefix + key;
            return property in this && delete this[property];
        },
        clear: function() {
            for (var property in this) if (property[0] === prefix) delete this[property];
        },
        keys: function() {
            var keys = [];
            for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
            return keys;
        },
        values: function() {
            var values = [];
            for (var property in this) if (property[0] === prefix) values.push(this[property]);
            return values;
        },
        entries: function() {
            var entries = [];
            for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
            return entries;
        },
        size: function() {
            var size = 0;
            for (var property in this) if (property[0] === prefix) ++size;
            return size;
        },
        empty: function() {
            for (var property in this) if (property[0] === prefix) return false;
            return true;
        },
        each: function(f) {
            for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
        }
    };

    function map$1(object, f) {
        var map = new Map$1;

        // Copy constructor.
        if (object instanceof Map$1) object.each(function(value, key) { map.set(key, value); });

        // Index array by numeric index or specified key function.
        else if (Array.isArray(object)) {
            var i = -1,
                n = object.length,
                o;

            if (f == null) while (++i < n) map.set(i, object[i]);
            else while (++i < n) map.set(f(o = object[i], i, object), o);
        }

        // Convert object to map.
        else if (object) for (var key in object) map.set(key, object[key]);

        return map;
    }

    function Set$1() {}

    var proto = map$1.prototype;

    Set$1.prototype = set$2.prototype = {
        constructor: Set$1,
        has: proto.has,
        add: function(value) {
            value += "";
            this[prefix + value] = value;
            return this;
        },
        remove: proto.remove,
        clear: proto.clear,
        values: proto.keys,
        size: proto.size,
        empty: proto.empty,
        each: proto.each
    };

    function set$2(object, f) {
        var set = new Set$1;

        // Copy constructor.
        if (object instanceof Set$1) object.each(function(value) { set.add(value); });

        // Otherwise, assume its an array.
        else if (object) {
            var i = -1, n = object.length;
            if (f == null) while (++i < n) set.add(object[i]);
            else while (++i < n) set.add(f(object[i], i, object));
        }

        return set;
    }

    function constant$3(x) {
        return function() {
            return x;
        };
    }

    function jiggle() {
        return (Math.random() - 0.5) * 1e-6;
    }

    function tree_add(d) {
        var x = +this._x.call(null, d),
            y = +this._y.call(null, d);
        return add(this.cover(x, y), x, y, d);
    }

    function add(tree, x, y, d) {
        if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

        var parent,
            node = tree._root,
            leaf = {data: d},
            x0 = tree._x0,
            y0 = tree._y0,
            x1 = tree._x1,
            y1 = tree._y1,
            xm,
            ym,
            xp,
            yp,
            right,
            bottom,
            i,
            j;

        // If the tree is empty, initialize the root as a leaf.
        if (!node) return tree._root = leaf, tree;

        // Find the existing leaf for the new point, or add it.
        while (node.length) {
            if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
            if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
            if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
        }

        // Is the new point is exactly coincident with the existing point?
        xp = +tree._x.call(null, node.data);
        yp = +tree._y.call(null, node.data);
        if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

        // Otherwise, split the leaf node until the old and new point are separated.
        do {
            parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
            if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
            if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
        return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
        var d, i, n = data.length,
            x,
            y,
            xz = new Array(n),
            yz = new Array(n),
            x0 = Infinity,
            y0 = Infinity,
            x1 = -Infinity,
            y1 = -Infinity;

        // Compute the points and their extent.
        for (i = 0; i < n; ++i) {
            if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
            xz[i] = x;
            yz[i] = y;
            if (x < x0) x0 = x;
            if (x > x1) x1 = x;
            if (y < y0) y0 = y;
            if (y > y1) y1 = y;
        }

        // If there were no (valid) points, abort.
        if (x0 > x1 || y0 > y1) return this;

        // Expand the tree to cover the new points.
        this.cover(x0, y0).cover(x1, y1);

        // Add the new points.
        for (i = 0; i < n; ++i) {
            add(this, xz[i], yz[i], data[i]);
        }

        return this;
    }

    function tree_cover(x, y) {
        if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

        var x0 = this._x0,
            y0 = this._y0,
            x1 = this._x1,
            y1 = this._y1;

        // If the quadtree has no extent, initialize them.
        // Integer extent are necessary so that if we later double the extent,
        // the existing quadrant boundaries dont change due to floating point error!
        if (isNaN(x0)) {
            x1 = (x0 = Math.floor(x)) + 1;
            y1 = (y0 = Math.floor(y)) + 1;
        }

        // Otherwise, double repeatedly to cover.
        else {
            var z = x1 - x0,
                node = this._root,
                parent,
                i;

            while (x0 > x || x >= x1 || y0 > y || y >= y1) {
                i = (y < y0) << 1 | (x < x0);
                parent = new Array(4), parent[i] = node, node = parent, z *= 2;
                switch (i) {
                    case 0: x1 = x0 + z, y1 = y0 + z; break;
                    case 1: x0 = x1 - z, y1 = y0 + z; break;
                    case 2: x1 = x0 + z, y0 = y1 - z; break;
                    case 3: x0 = x1 - z, y0 = y1 - z; break;
                }
            }

            if (this._root && this._root.length) this._root = node;
        }

        this._x0 = x0;
        this._y0 = y0;
        this._x1 = x1;
        this._y1 = y1;
        return this;
    }

    function tree_data() {
        var data = [];
        this.visit(function(node) {
            if (!node.length) do data.push(node.data); while (node = node.next)
        });
        return data;
    }

    function tree_extent(_) {
        return arguments.length
            ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
            : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
        this.node = node;
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
    }

    function tree_find(x, y, radius) {
        var data,
            x0 = this._x0,
            y0 = this._y0,
            x1,
            y1,
            x2,
            y2,
            x3 = this._x1,
            y3 = this._y1,
            quads = [],
            node = this._root,
            q,
            i;

        if (node) quads.push(new Quad(node, x0, y0, x3, y3));
        if (radius == null) radius = Infinity;
        else {
            x0 = x - radius, y0 = y - radius;
            x3 = x + radius, y3 = y + radius;
            radius *= radius;
        }

        while (q = quads.pop()) {

            // Stop searching if this quadrant cant contain a closer node.
            if (!(node = q.node)
                || (x1 = q.x0) > x3
                || (y1 = q.y0) > y3
                || (x2 = q.x1) < x0
                || (y2 = q.y1) < y0) continue;

            // Bisect the current quadrant.
            if (node.length) {
                var xm = (x1 + x2) / 2,
                    ym = (y1 + y2) / 2;

                quads.push(
                    new Quad(node[3], xm, ym, x2, y2),
                    new Quad(node[2], x1, ym, xm, y2),
                    new Quad(node[1], xm, y1, x2, ym),
                    new Quad(node[0], x1, y1, xm, ym)
                );

                // Visit the closest quadrant first.
                if (i = (y >= ym) << 1 | (x >= xm)) {
                    q = quads[quads.length - 1];
                    quads[quads.length - 1] = quads[quads.length - 1 - i];
                    quads[quads.length - 1 - i] = q;
                }
            }

            // Visit this point. (Visiting coincident points isnt necessary!)
            else {
                var dx = x - +this._x.call(null, node.data),
                    dy = y - +this._y.call(null, node.data),
                    d2 = dx * dx + dy * dy;
                if (d2 < radius) {
                    var d = Math.sqrt(radius = d2);
                    x0 = x - d, y0 = y - d;
                    x3 = x + d, y3 = y + d;
                    data = node.data;
                }
            }
        }

        return data;
    }

    function tree_remove(d) {
        if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

        var parent,
            node = this._root,
            retainer,
            previous,
            next,
            x0 = this._x0,
            y0 = this._y0,
            x1 = this._x1,
            y1 = this._y1,
            x,
            y,
            xm,
            ym,
            right,
            bottom,
            i,
            j;

        // If the tree is empty, initialize the root as a leaf.
        if (!node) return this;

        // Find the leaf node for the point.
        // While descending, also retain the deepest parent with a non-removed sibling.
        if (node.length) while (true) {
            if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
            if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
            if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
            if (!node.length) break;
            if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
        }

        // Find the point to remove.
        while (node.data !== d) if (!(previous = node, node = node.next)) return this;
        if (next = node.next) delete node.next;

        // If there are multiple coincident points, remove just the point.
        if (previous) return (next ? previous.next = next : delete previous.next), this;

        // If this is the root point, remove it.
        if (!parent) return this._root = next, this;

        // Remove this leaf.
        next ? parent[i] = next : delete parent[i];

        // If the parent now contains exactly one leaf, collapse superfluous parents.
        if ((node = parent[0] || parent[1] || parent[2] || parent[3])
            && node === (parent[3] || parent[2] || parent[1] || parent[0])
            && !node.length) {
            if (retainer) retainer[j] = node;
            else this._root = node;
        }

        return this;
    }

    function removeAll(data) {
        for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
        return this;
    }

    function tree_root() {
        return this._root;
    }

    function tree_size() {
        var size = 0;
        this.visit(function(node) {
            if (!node.length) do ++size; while (node = node.next)
        });
        return size;
    }

    function tree_visit(callback) {
        var quads = [], q, node = this._root, child, x0, y0, x1, y1;
        if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
        while (q = quads.pop()) {
            if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
                var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
                if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
                if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
                if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
                if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
            }
        }
        return this;
    }

    function tree_visitAfter(callback) {
        var quads = [], next = [], q;
        if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
        while (q = quads.pop()) {
            var node = q.node;
            if (node.length) {
                var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
                if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
                if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
                if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
                if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
            }
            next.push(q);
        }
        while (q = next.pop()) {
            callback(q.node, q.x0, q.y0, q.x1, q.y1);
        }
        return this;
    }

    function defaultX(d) {
        return d[0];
    }

    function tree_x(_) {
        return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
        return d[1];
    }

    function tree_y(_) {
        return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
        var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
        return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
        this._x = x;
        this._y = y;
        this._x0 = x0;
        this._y0 = y0;
        this._x1 = x1;
        this._y1 = y1;
        this._root = undefined;
    }

    function leaf_copy(leaf) {
        var copy = {data: leaf.data}, next = copy;
        while (leaf = leaf.next) next = next.next = {data: leaf.data};
        return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
        var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
            node = this._root,
            nodes,
            child;

        if (!node) return copy;

        if (!node.length) return copy._root = leaf_copy(node), copy;

        nodes = [{source: node, target: copy._root = new Array(4)}];
        while (node = nodes.pop()) {
            for (var i = 0; i < 4; ++i) {
                if (child = node.source[i]) {
                    if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
                    else node.target[i] = leaf_copy(child);
                }
            }
        }

        return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function index(d) {
        return d.index;
    }

    function find(nodeById, nodeId) {
        var node = nodeById.get(nodeId);
        if (!node) throw new Error("missing: " + nodeId);
        return node;
    }

    function forceLink(links) {
        var id = index,
            strength = defaultStrength,
            strengths,
            distance = constant$3(30),
            distances,
            nodes,
            count,
            bias,
            iterations = 1;

        if (links == null) links = [];

        function defaultStrength(link) {
            return 1 / Math.min(count[link.source.index], count[link.target.index]);
        }

        function force(alpha) {
            for (var k = 0, n = links.length; k < iterations; ++k) {
                for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
                    link = links[i], source = link.source, target = link.target;
                    x = target.x + target.vx - source.x - source.vx || jiggle();
                    y = target.y + target.vy - source.y - source.vy || jiggle();
                    l = Math.sqrt(x * x + y * y);
                    l = (l - distances[i]) / l * alpha * strengths[i];
                    x *= l, y *= l;
                    target.vx -= x * (b = bias[i]);
                    target.vy -= y * b;
                    source.vx += x * (b = 1 - b);
                    source.vy += y * b;
                }
            }
        }

        function initialize() {
            if (!nodes) return;

            var i,
                n = nodes.length,
                m = links.length,
                nodeById = map$1(nodes, id),
                link;

            for (i = 0, count = new Array(n); i < m; ++i) {
                link = links[i], link.index = i;
                if (typeof link.source !== "object") link.source = find(nodeById, link.source);
                if (typeof link.target !== "object") link.target = find(nodeById, link.target);
                count[link.source.index] = (count[link.source.index] || 0) + 1;
                count[link.target.index] = (count[link.target.index] || 0) + 1;
            }

            for (i = 0, bias = new Array(m); i < m; ++i) {
                link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
            }

            strengths = new Array(m), initializeStrength();
            distances = new Array(m), initializeDistance();
        }

        function initializeStrength() {
            if (!nodes) return;

            for (var i = 0, n = links.length; i < n; ++i) {
                strengths[i] = +strength(links[i], i, links);
            }
        }

        function initializeDistance() {
            if (!nodes) return;

            for (var i = 0, n = links.length; i < n; ++i) {
                distances[i] = +distance(links[i], i, links);
            }
        }

        force.initialize = function(_) {
            nodes = _;
            initialize();
        };

        force.links = function(_) {
            return arguments.length ? (links = _, initialize(), force) : links;
        };

        force.id = function(_) {
            return arguments.length ? (id = _, force) : id;
        };

        force.iterations = function(_) {
            return arguments.length ? (iterations = +_, force) : iterations;
        };

        force.strength = function(_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant$3(+_), initializeStrength(), force) : strength;
        };

        force.distance = function(_) {
            return arguments.length ? (distance = typeof _ === "function" ? _ : constant$3(+_), initializeDistance(), force) : distance;
        };

        return force;
    }

    function x(d) {
        return d.x;
    }

    function y(d) {
        return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function forceSimulation(nodes) {
        var simulation,
            alpha = 1,
            alphaMin = 0.001,
            alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
            alphaTarget = 0,
            velocityDecay = 0.6,
            forces = map$1(),
            stepper = timer$1(step),
            event = dispatch$1("tick", "end");

        if (nodes == null) nodes = [];

        function step() {
            tick();
            event.call("tick", simulation);
            if (alpha < alphaMin) {
                stepper.stop();
                event.call("end", simulation);
            }
        }

        function tick(iterations) {
            var i, n = nodes.length, node;

            if (iterations === undefined) iterations = 1;

            for (var k = 0; k < iterations; ++k) {
                alpha += (alphaTarget - alpha) * alphaDecay;

                forces.each(function (force) {
                    force(alpha);
                });

                for (i = 0; i < n; ++i) {
                    node = nodes[i];
                    if (node.fx == null) node.x += node.vx *= velocityDecay;
                    else node.x = node.fx, node.vx = 0;
                    if (node.fy == null) node.y += node.vy *= velocityDecay;
                    else node.y = node.fy, node.vy = 0;
                }
            }

            return simulation;
        }

        function initializeNodes() {
            for (var i = 0, n = nodes.length, node; i < n; ++i) {
                node = nodes[i], node.index = i;
                if (node.fx != null) node.x = node.fx;
                if (node.fy != null) node.y = node.fy;
                if (isNaN(node.x) || isNaN(node.y)) {
                    var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
                    node.x = radius * Math.cos(angle);
                    node.y = radius * Math.sin(angle);
                }
                if (isNaN(node.vx) || isNaN(node.vy)) {
                    node.vx = node.vy = 0;
                }
            }
        }

        function initializeForce(force) {
            if (force.initialize) force.initialize(nodes);
            return force;
        }

        initializeNodes();

        return simulation = {
            tick: tick,

            restart: function() {
                return stepper.restart(step), simulation;
            },

            stop: function() {
                return stepper.stop(), simulation;
            },

            nodes: function(_) {
                return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
            },

            alpha: function(_) {
                return arguments.length ? (alpha = +_, simulation) : alpha;
            },

            alphaMin: function(_) {
                return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
            },

            alphaDecay: function(_) {
                return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
            },

            alphaTarget: function(_) {
                return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
            },

            velocityDecay: function(_) {
                return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
            },

            force: function(name, _) {
                return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
            },

            find: function(x, y, radius) {
                var i = 0,
                    n = nodes.length,
                    dx,
                    dy,
                    d2,
                    node,
                    closest;

                if (radius == null) radius = Infinity;
                else radius *= radius;

                for (i = 0; i < n; ++i) {
                    node = nodes[i];
                    dx = x - node.x;
                    dy = y - node.y;
                    d2 = dx * dx + dy * dy;
                    if (d2 < radius) closest = node, radius = d2;
                }

                return closest;
            },

            on: function(name, _) {
                return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
            }
        };
    }

    function forceManyBody() {
        var nodes,
            node,
            alpha,
            strength = constant$3(-30),
            strengths,
            distanceMin2 = 1,
            distanceMax2 = Infinity,
            theta2 = 0.81;

        function force(_) {
            var i, n = nodes.length, tree = quadtree(nodes, x, y).visitAfter(accumulate);
            for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
        }

        function initialize() {
            if (!nodes) return;
            var i, n = nodes.length, node;
            strengths = new Array(n);
            for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
        }

        function accumulate(quad) {
            var strength = 0, q, c, weight = 0, x, y, i;

            // For internal nodes, accumulate forces from child quadrants.
            if (quad.length) {
                for (x = y = i = 0; i < 4; ++i) {
                    if ((q = quad[i]) && (c = Math.abs(q.value))) {
                        strength += q.value, weight += c, x += c * q.x, y += c * q.y;
                    }
                }
                quad.x = x / weight;
                quad.y = y / weight;
            }

            // For leaf nodes, accumulate forces from coincident quadrants.
            else {
                q = quad;
                q.x = q.data.x;
                q.y = q.data.y;
                do strength += strengths[q.data.index];
                while (q = q.next);
            }

            quad.value = strength;
        }

        function apply(quad, x1, _, x2) {
            if (!quad.value) return true;

            var x = quad.x - node.x,
                y = quad.y - node.y,
                w = x2 - x1,
                l = x * x + y * y;

            // Apply the Barnes-Hut approximation if possible.
            // Limit forces for very close nodes; randomize direction if coincident.
            if (w * w / theta2 < l) {
                if (l < distanceMax2) {
                    if (x === 0) x = jiggle(), l += x * x;
                    if (y === 0) y = jiggle(), l += y * y;
                    if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
                    node.vx += x * quad.value * alpha / l;
                    node.vy += y * quad.value * alpha / l;
                }
                return true;
            }

            // Otherwise, process points directly.
            else if (quad.length || l >= distanceMax2) return;

            // Limit forces for very close nodes; randomize direction if coincident.
            if (quad.data !== node || quad.next) {
                if (x === 0) x = jiggle(), l += x * x;
                if (y === 0) y = jiggle(), l += y * y;
                if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            }

            do if (quad.data !== node) {
                w = strengths[quad.data.index] * alpha / l;
                node.vx += x * w;
                node.vy += y * w;
            } while (quad = quad.next);
        }

        force.initialize = function(_) {
            nodes = _;
            initialize();
        };

        force.strength = function(_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant$3(+_), initialize(), force) : strength;
        };

        force.distanceMin = function(_) {
            return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
        };

        force.distanceMax = function(_) {
            return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
        };

        force.theta = function(_) {
            return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
        };

        return force;
    }

    function forceX(x) {
        var strength = constant$3(0.1),
            nodes,
            strengths,
            xz;

        if (typeof x !== "function") x = constant$3(x == null ? 0 : +x);

        function force(alpha) {
            for (var i = 0, n = nodes.length, node; i < n; ++i) {
                node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
            }
        }

        function initialize() {
            if (!nodes) return;
            var i, n = nodes.length;
            strengths = new Array(n);
            xz = new Array(n);
            for (i = 0; i < n; ++i) {
                strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
            }
        }

        force.initialize = function(_) {
            nodes = _;
            initialize();
        };

        force.strength = function(_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant$3(+_), initialize(), force) : strength;
        };

        force.x = function(_) {
            return arguments.length ? (x = typeof _ === "function" ? _ : constant$3(+_), initialize(), force) : x;
        };

        return force;
    }

    function forceY(y) {
        var strength = constant$3(0.1),
            nodes,
            strengths,
            yz;

        if (typeof y !== "function") y = constant$3(y == null ? 0 : +y);

        function force(alpha) {
            for (var i = 0, n = nodes.length, node; i < n; ++i) {
                node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
            }
        }

        function initialize() {
            if (!nodes) return;
            var i, n = nodes.length;
            strengths = new Array(n);
            yz = new Array(n);
            for (i = 0; i < n; ++i) {
                strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
            }
        }

        force.initialize = function(_) {
            nodes = _;
            initialize();
        };

        force.strength = function(_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant$3(+_), initialize(), force) : strength;
        };

        force.y = function(_) {
            return arguments.length ? (y = typeof _ === "function" ? _ : constant$3(+_), initialize(), force) : y;
        };

        return force;
    }

    function initRange(domain, range) {
        switch (arguments.length) {
            case 0: break;
            case 1: this.range(domain); break;
            default: this.range(range).domain(domain); break;
        }
        return this;
    }

    var array = Array.prototype;
    var slice = array.slice;

    var implicit = {name: "implicit"};

    function ordinal() {
        var index = map$1(),
            domain = [],
            range = [],
            unknown = implicit;

        function scale(d) {
            var key = d + "", i = index.get(key);
            if (!i) {
                if (unknown !== implicit) return unknown;
                index.set(key, i = domain.push(d));
            }
            return range[(i - 1) % range.length];
        }

        scale.domain = function(_) {
            if (!arguments.length) return domain.slice();
            domain = [], index = map$1();
            var i = -1, n = _.length, d, key;
            while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
            return scale;
        };

        scale.range = function(_) {
            return arguments.length ? (range = slice.call(_), scale) : range.slice();
        };

        scale.unknown = function(_) {
            return arguments.length ? (unknown = _, scale) : unknown;
        };

        scale.copy = function() {
            return ordinal(domain, range).unknown(unknown);
        };

        initRange.apply(scale, arguments);

        return scale;
    }

    function colors(specifier) {
        var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
        while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
        return colors;
    }

    var schemeCategory10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    function shareMouse$1(x, y) {
        return {
            type: "share.mouse",
            data: {
                x,
                y,
            },
        };
    }
    function executeShareMouse(store, data, user) {
        const { userMouseList } = store.shareState;
        const userMouse = getData(userMouseList, user.id);
        if (userMouse) {
            userMouse.name = user.name;
            userMouse.x = data.x;
            userMouse.y = data.y;
            clearTimeout(userMouse._timeoutID);
            userMouse._timeoutID = setTimeout(() => {
                executeShareMouseEnd(store, { id: user.id });
            }, 1000 * 30);
        }
        else {
            userMouseList.push({
                id: user.id,
                name: user.name,
                color: schemeCategory10[userMouseList.length % 10],
                x: data.x,
                y: data.y,
                _timeoutID: setTimeout(() => {
                    executeShareMouseEnd(store, { id: user.id });
                }, 1000 * 30),
            });
        }
    }
    function executeShareMouseEnd(store, data) {
        const { userMouseList } = store.shareState;
        const index = getIndex(userMouseList, data.id);
        if (index !== null) {
            userMouseList.splice(index, 1);
        }
    }

    const changeCommandTypes = [
        // table
        "table.add",
        "table.addOnly",
        "table.move",
        "table.remove",
        "table.changeName",
        "table.changeComment",
        "table.sort",
        // column
        "column.add",
        "column.addOnly",
        "column.addCustom",
        "column.remove",
        "column.changeName",
        "column.changeComment",
        "column.changeDataType",
        "column.changeDefault",
        "column.changeAutoIncrement",
        "column.changePrimaryKey",
        "column.changeUnique",
        "column.changeNotNull",
        "column.move",
        // relationship
        "relationship.add",
        "relationship.remove",
        "relationship.changeRelationshipType",
        "relationship.changeIdentification",
        // index
        "index.add",
        "index.remove",
        "index.changeName",
        "index.changeUnique",
        "index.addColumn",
        "index.removeColumn",
        "index.moveColumn",
        "index.changeColumnOrderType",
        // memo
        "memo.add",
        "memo.addOnly",
        "memo.move",
        "memo.remove",
        "memo.changeValue",
        "memo.resize",
        // canvas
        "canvas.move",
        "canvas.resize",
        "canvas.changeShow",
        "canvas.changeDatabase",
        "canvas.changeDatabaseName",
        "canvas.changeCanvasType",
        "canvas.changeLanguage",
        "canvas.changeTableCase",
        "canvas.changeColumnCase",
        "canvas.changeRelationshipDataTypeSync",
        "canvas.moveColumnOrder",
        // editor
        "editor.loadJson",
        "editor.clear",
    ];
    const undoCommandTypes = [
        // table
        "table.add",
        "table.addOnly",
        "table.move",
        "table.remove",
        "table.changeName",
        "table.changeComment",
        "table.sort",
        // column
        "column.add",
        "column.addOnly",
        "column.addCustom",
        "column.remove",
        "column.changeName",
        "column.changeComment",
        "column.changeDataType",
        "column.changeDefault",
        "column.changeAutoIncrement",
        "column.changePrimaryKey",
        "column.changeUnique",
        "column.changeNotNull",
        "column.move",
        // relationship
        "relationship.add",
        "relationship.remove",
        "relationship.changeRelationshipType",
        "relationship.changeIdentification",
        // memo
        "memo.add",
        "memo.addOnly",
        "memo.move",
        "memo.remove",
        "memo.changeValue",
        "memo.resize",
        // canvas
        "canvas.move",
        "canvas.resize",
        "canvas.changeShow",
        "canvas.changeDatabase",
        "canvas.changeDatabaseName",
        // editor
        "editor.loadJson",
        "editor.clear",
    ];
    const streamCommandTypes = [
        "table.move",
        "memo.move",
        "memo.resize",
        "canvas.move",
    ];
    const shareCommandTypes = [
        // table
        "table.add",
        "table.addOnly",
        "table.move",
        "table.remove",
        "table.changeName",
        "table.changeComment",
        "table.sort",
        // column
        "column.add",
        "column.addOnly",
        "column.addCustom",
        "column.remove",
        "column.changeName",
        "column.changeComment",
        "column.changeDataType",
        "column.changeDefault",
        "column.changeAutoIncrement",
        "column.changePrimaryKey",
        "column.changeUnique",
        "column.changeNotNull",
        "column.move",
        // relationship
        "relationship.add",
        "relationship.remove",
        "relationship.changeRelationshipType",
        "relationship.changeIdentification",
        // index
        "index.add",
        "index.remove",
        "index.changeName",
        "index.changeUnique",
        "index.addColumn",
        "index.removeColumn",
        "index.moveColumn",
        "index.changeColumnOrderType",
        // memo
        "memo.add",
        "memo.addOnly",
        "memo.move",
        "memo.remove",
        "memo.changeValue",
        "memo.resize",
        // canvas
        "canvas.resize",
        "canvas.changeShow",
        "canvas.changeDatabase",
        "canvas.changeDatabaseName",
        "canvas.changeRelationshipDataTypeSync",
        // editor
        "editor.loadJson",
        "editor.clear",
        // share
        "share.mouse",
    ];
    function executeCommand(store, commands) {
        commands.forEach((command) => {
            if (/^table\./.test(command.type)) {
                executeTableCommand(store, command);
            }
            else if (/^column\./.test(command.type)) {
                executeColumnCommand(store, command);
            }
            else if (/^relationship\./.test(command.type)) {
                executeRelationshipCommand(store, command);
            }
            else if (/^index\./.test(command.type)) {
                executeIndexCommand(store, command);
            }
            else if (/^memo\./.test(command.type)) {
                executeMemoCommand(store, command);
            }
            else if (/^canvas\./.test(command.type)) {
                executeCanvasCommand(store, command);
            }
            else if (/^editor\./.test(command.type)) {
                executeEditorCommand(store, command);
            }
            else if (/^share\./.test(command.type)) {
                executeShareCommand(store, command);
            }
        });
    }
    function executeTableCommand(store, command) {
        switch (command.type) {
            case "table.add":
                executeAddTable(store, command.data);
                break;
            case "table.addOnly":
                executeAddOnlyTable(store, command.data);
                break;
            case "table.move":
                executeMoveTable(store, command.data);
                break;
            case "table.remove":
                executeRemoveTable(store, command.data);
                break;
            case "table.select":
                executeSelectTable(store, command.data);
                break;
            case "table.selectEnd":
                executeSelectEndTable(store);
                break;
            case "table.selectAll":
                executeSelectAllTable(store);
                break;
            case "table.selectOnly":
                executeSelectOnlyTable(store, command.data);
                break;
            case "table.changeName":
                executeChangeTableName(store, command.data);
                break;
            case "table.changeComment":
                executeChangeTableComment(store, command.data);
                break;
            case "table.dragSelect":
                executeDragSelectTable(store, command.data);
                break;
            case "table.sort":
                executeSortTable(store);
                break;
            case "table.load":
                executeLoadTable(store, command.data);
                break;
        }
    }
    function executeColumnCommand(store, command) {
        switch (command.type) {
            case "column.add":
                executeAddColumn(store, command.data);
                break;
            case "column.addOnly":
                executeAddOnlyColumn(store, command.data);
                break;
            case "column.addCustom":
                executeAddCustomColumn(store, command.data);
                break;
            case "column.remove":
                executeRemoveColumn(store, command.data);
                break;
            case "column.removeOnly":
                executeRemoveOnlyColumn(store, command.data);
                break;
            case "column.changeName":
                executeChangeColumnName(store, command.data);
                break;
            case "column.changeComment":
                executeChangeColumnComment(store, command.data);
                break;
            case "column.changeDataType":
                executeChangeColumnDataType(store, command.data);
                break;
            case "column.changeDefault":
                executeChangeColumnDefault(store, command.data);
                break;
            case "column.changeAutoIncrement":
                executeChangeColumnAutoIncrement(store, command.data);
                break;
            case "column.changePrimaryKey":
                executeChangeColumnPrimaryKey(store, command.data);
                break;
            case "column.changeUnique":
                executeChangeColumnUnique(store, command.data);
                break;
            case "column.changeNotNull":
                executeChangeColumnNotNull(store, command.data);
                break;
            case "column.move":
                executeMoveColumn(store, command.data);
                break;
            case "column.active":
                executeActiveColumn(store, command.data);
                break;
            case "column.activeEnd":
                executeActiveEndColumn(store, command.data);
                break;
            case "column.load":
                executeLoadColumn(store, command.data);
                break;
        }
    }
    function executeRelationshipCommand(store, command) {
        switch (command.type) {
            case "relationship.add":
                executeAddRelationship(store, command.data);
                break;
            case "relationship.remove":
                executeRemoveRelationship(store, command.data);
                break;
            case "relationship.changeRelationshipType":
                executeChangeRelationshipType(store, command.data);
                break;
            case "relationship.changeIdentification":
                executeChangeIdentification(store, command.data);
                break;
            case "relationship.load":
                executeLoadRelationship(store, command.data);
                break;
        }
    }
    function executeIndexCommand(store, command) {
        switch (command.type) {
            case "index.add":
                executeAddIndex(store, command.data);
                break;
            case "index.remove":
                executeRemoveIndex(store, command.data);
                break;
            case "index.changeName":
                executeChangeIndexName(store, command.data);
                break;
            case "index.changeUnique":
                executeChangeIndexUnique(store, command.data);
                break;
            case "index.addColumn":
                executeAddIndexColumn(store, command.data);
                break;
            case "index.removeColumn":
                executeRemoveIndexColumn(store, command.data);
                break;
            case "index.moveColumn":
                executeMoveIndexColumn(store, command.data);
                break;
            case "index.changeColumnOrderType":
                executeChangeIndexColumnOrderType(store, command.data);
                break;
            case "index.load":
                executeLoadIndex(store, command.data);
                break;
        }
    }
    function executeMemoCommand(store, command) {
        switch (command.type) {
            case "memo.add":
                executeAddMemo(store, command.data);
                break;
            case "memo.addOnly":
                executeAddOnlyMemo(store, command.data);
                break;
            case "memo.move":
                executeMoveMemo(store, command.data);
                break;
            case "memo.remove":
                executeRemoveMemo(store, command.data);
                break;
            case "memo.select":
                executeSelectMemo(store, command.data);
                break;
            case "memo.selectEnd":
                executeSelectEndMemo(store);
                break;
            case "memo.selectAll":
                executeSelectAllMemo(store);
                break;
            case "memo.changeValue":
                executeChangeMemoValue(store, command.data);
                break;
            case "memo.resize":
                executeResizeMemo(store, command.data);
                break;
            case "memo.dragSelect":
                executeDragSelectMemo(store, command.data);
                break;
            case "memo.load":
                executeLoadMemo(store, command.data);
                break;
        }
    }
    function executeCanvasCommand(store, command) {
        switch (command.type) {
            case "canvas.move":
                executeMoveCanvas(store, command.data);
                break;
            case "canvas.resize":
                executeResizeCanvas(store, command.data);
                break;
            case "canvas.changeShow":
                executeChangeCanvasShow(store, command.data);
                break;
            case "canvas.changeDatabase":
                executeChangeDatabase(store, command.data);
                break;
            case "canvas.changeDatabaseName":
                executeChangeDatabaseName(store, command.data);
                break;
            case "canvas.changeCanvasType":
                executeChangeCanvasType(store, command.data);
                break;
            case "canvas.changeLanguage":
                executeChangeLanguage(store, command.data);
                break;
            case "canvas.changeTableCase":
                executeChangeTableCase(store, command.data);
                break;
            case "canvas.changeColumnCase":
                executeChangeColumnCase(store, command.data);
                break;
            case "canvas.changeRelationshipDataTypeSync":
                executeChangeRelationshipDataTypeSync(store, command.data);
                break;
            case "canvas.moveColumnOrder":
                executeMoveColumnOrder(store, command.data);
                break;
        }
    }
    function executeEditorCommand(store, command) {
        switch (command.type) {
            case "editor.focusTable":
                executeFocusTable(store, command.data);
                break;
            case "editor.focusTableEnd":
                executeFocusTableEnd(store);
                break;
            case "editor.focusMoveTable":
                executeFocusMoveTable(store, command.data);
                break;
            case "editor.focusTargetTable":
                executeFocusTargetTable(store, command.data);
                break;
            case "editor.focusTargetColumn":
                executeFocusTargetColumn(store, command.data);
                break;
            case "editor.selectAllColumn":
                executeSelectAllColumn(store);
                break;
            case "editor.selectEndColumn":
                executeSelectEndColumn(store);
                break;
            case "editor.editTable":
                executeEditTable(store, command.data);
                break;
            case "editor.editTableEnd":
                executeEditTableEnd(store);
                break;
            case "editor.draggableColumn":
                executeDraggableColumn(store, command.data);
                break;
            case "editor.draggableColumnEnd":
                executeDraggableColumnEnd(store);
                break;
            case "editor.drawStartRelationship":
                executeDrawStartRelationship(store, command.data);
                break;
            case "editor.drawStartAddRelationship":
                executeDrawStartAddRelationship(store, command.data);
                break;
            case "editor.drawEndRelationship":
                executeDrawEndRelationship(store);
                break;
            case "editor.drawRelationship":
                executeDrawRelationship(store, command.data);
                break;
            case "editor.loadJson":
                executeLoadJson(store, command.data);
                break;
            case "editor.initLoadJson":
                executeLoadJson(store, command.data);
                break;
            case "editor.copyColumn":
                executeCopyColumn(store, command.data);
                break;
            case "editor.pasteColumn":
                executePasteColumn(store, command.data);
                break;
            case "editor.clear":
                executeClear(store);
                break;
            case "editor.addFilterState":
                executeAddFilterState(store, command.data);
                break;
            case "editor.removeFilterState":
                executeRemoveFilterState(store, command.data);
                break;
            case "editor.focusFilter":
                executeFocusFilter(store);
                break;
            case "editor.focusFilterEnd":
                executeFocusFilterEnd(store);
                break;
            case "editor.filterActive":
                executeFilterActive(store);
                break;
            case "editor.filterActiveEnd":
                executeFilterActiveEnd(store);
                break;
            case "editor.focusMoveFilter":
                executeFocusMoveFilter(store, command.data);
                break;
            case "editor.focusTargetFilter":
                executeFocusTargetFilter(store, command.data);
                break;
            case "editor.focusTargetFilterState":
                executeFocusTargetFilterState(store, command.data);
                break;
            case "editor.selectAllFilterState":
                executeSelectAllFilterState(store);
                break;
            case "editor.selectEndFilterState":
                executeSelectEndFilterState(store);
                break;
            case "editor.editFilter":
                executeEditFilter(store, command.data);
                break;
            case "editor.editFilterEnd":
                executeEditFilterEnd(store);
                break;
            case "editor.changeFilterStateColumnType":
                executeChangeFilterStateColumnType(store, command.data);
                break;
            case "editor.changeFilterStateFilterCode":
                executeChangeFilterStateFilterCode(store, command.data);
                break;
            case "editor.changeFilterStateValue":
                executeChangeFilterStateValue(store, command.data);
                break;
            case "editor.changeFilterOperatorType":
                executeChangeFilterOperatorType(store, command.data);
                break;
            case "editor.draggableFilterState":
                executeDraggableFilterState(store, command.data);
                break;
            case "editor.draggableFilterStateEnd":
                executeDraggableFilterStateEnd(store);
                break;
            case "editor.moveFilterState":
                executeMoveFilterState(store, command.data);
                break;
            case "editor.findActive":
                executeFindActive(store);
                break;
            case "editor.findActiveEnd":
                executeFindActiveEnd(store);
                break;
            case "editor.hasUndoRedo":
                executeHasUndoRedo(store, command.data);
                break;
        }
    }
    function executeShareCommand(store, command) {
        if (command.user) {
            switch (command.type) {
                case "share.mouse":
                    executeShareMouse(store, command.data, command.user);
                    break;
                case "share.mouseEnd":
                    executeShareMouseEnd(store, command.data);
                    break;
            }
        }
    }

    class UndoManager {
        constructor(effect) {
            this.commands = [];
            this.index = -1;
            this.limit = 0;
            this.run = false;
            this.effect = effect;
        }
        get hasUndo() {
            return this.index !== -1;
        }
        get hasRedo() {
            return this.index < this.commands.length - 1;
        }
        add(command) {
            if (this.run)
                return;
            this.commands.splice(this.index + 1, this.commands.length - this.index);
            this.commands.push(command);
            if (this.limit !== 0 && this.commands.length > this.limit) {
                this.commands = this.commands.slice(this.commands.length - this.limit, this.commands.length);
            }
            this.index = this.commands.length - 1;
            this.effect();
        }
        undo() {
            const command = this.commands[this.index];
            this.execute(command, "undo");
            this.index--;
            this.effect();
        }
        redo() {
            const command = this.commands[this.index + 1];
            this.execute(command, "redo");
            this.index++;
            this.effect();
        }
        clear() {
            const prevSize = this.commands.length;
            this.commands = [];
            this.index = -1;
            if (prevSize > 0) {
                this.effect();
            }
        }
        setLimit(limit) {
            this.limit = limit;
        }
        execute(command, key) {
            this.run = true;
            command[key]();
            this.run = false;
        }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, basedir, module) {
        return module = {
            path: basedir,
            exports: {},
            require: function (path, base) {
                return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
            }
        }, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
        throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var domToImage = createCommonjsModule(function (module) {
        (function (global) {

            var util = newUtil();
            var inliner = newInliner();
            var fontFaces = newFontFaces();
            var images = newImages();

            // Default impl options
            var defaultOptions = {
                // Default is to fail on error, no placeholder
                imagePlaceholder: undefined,
                // Default cache bust is false, it will use the cache
                cacheBust: false
            };

            var domtoimage = {
                toSvg: toSvg,
                toPng: toPng,
                toJpeg: toJpeg,
                toBlob: toBlob,
                toPixelData: toPixelData,
                impl: {
                    fontFaces: fontFaces,
                    images: images,
                    util: util,
                    inliner: inliner,
                    options: {}
                }
            };

            module.exports = domtoimage;


            /**
             * @param {Node} node - The DOM Node object to render
             * @param {Object} options - Rendering options
             * @param {Function} options.filter - Should return true if passed node should be included in the output
             *          (excluding node means excluding it's children as well). Not called on the root node.
             * @param {String} options.bgcolor - color for the background, any valid CSS color value.
             * @param {Number} options.width - width to be applied to node before rendering.
             * @param {Number} options.height - height to be applied to node before rendering.
             * @param {Object} options.style - an object whose properties to be copied to node's style before rendering.
             * @param {Number} options.quality - a Number between 0 and 1 indicating image quality (applicable to JPEG only),
             defaults to 1.0.
             * @param {String} options.imagePlaceholder - dataURL to use as a placeholder for failed images, default behaviour is to fail fast on images we can't fetch
             * @param {Boolean} options.cacheBust - set to true to cache bust by appending the time to the request url
             * @return {Promise} - A promise that is fulfilled with a SVG image data URL
             * */
            function toSvg(node, options) {
                options = options || {};
                copyOptions(options);
                return Promise.resolve(node)
                    .then(function (node) {
                        return cloneNode(node, options.filter, true);
                    })
                    .then(embedFonts)
                    .then(inlineImages)
                    .then(applyOptions)
                    .then(function (clone) {
                        return makeSvgDataUri(clone,
                            options.width || util.width(node),
                            options.height || util.height(node)
                        );
                    });

                function applyOptions(clone) {
                    if (options.bgcolor) clone.style.backgroundColor = options.bgcolor;

                    if (options.width) clone.style.width = options.width + 'px';
                    if (options.height) clone.style.height = options.height + 'px';

                    if (options.style)
                        Object.keys(options.style).forEach(function (property) {
                            clone.style[property] = options.style[property];
                        });

                    return clone;
                }
            }

            /**
             * @param {Node} node - The DOM Node object to render
             * @param {Object} options - Rendering options, @see {@link toSvg}
             * @return {Promise} - A promise that is fulfilled with a Uint8Array containing RGBA pixel data.
             * */
            function toPixelData(node, options) {
                return draw(node, options || {})
                    .then(function (canvas) {
                        return canvas.getContext('2d').getImageData(
                            0,
                            0,
                            util.width(node),
                            util.height(node)
                        ).data;
                    });
            }

            /**
             * @param {Node} node - The DOM Node object to render
             * @param {Object} options - Rendering options, @see {@link toSvg}
             * @return {Promise} - A promise that is fulfilled with a PNG image data URL
             * */
            function toPng(node, options) {
                return draw(node, options || {})
                    .then(function (canvas) {
                        return canvas.toDataURL();
                    });
            }

            /**
             * @param {Node} node - The DOM Node object to render
             * @param {Object} options - Rendering options, @see {@link toSvg}
             * @return {Promise} - A promise that is fulfilled with a JPEG image data URL
             * */
            function toJpeg(node, options) {
                options = options || {};
                return draw(node, options)
                    .then(function (canvas) {
                        return canvas.toDataURL('image/jpeg', options.quality || 1.0);
                    });
            }

            /**
             * @param {Node} node - The DOM Node object to render
             * @param {Object} options - Rendering options, @see {@link toSvg}
             * @return {Promise} - A promise that is fulfilled with a PNG image blob
             * */
            function toBlob(node, options) {
                return draw(node, options || {})
                    .then(util.canvasToBlob);
            }

            function copyOptions(options) {
                // Copy options to impl options for use in impl
                if(typeof(options.imagePlaceholder) === 'undefined') {
                    domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;
                } else {
                    domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder;
                }

                if(typeof(options.cacheBust) === 'undefined') {
                    domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;
                } else {
                    domtoimage.impl.options.cacheBust = options.cacheBust;
                }
            }

            function draw(domNode, options) {
                return toSvg(domNode, options)
                    .then(util.makeImage)
                    .then(util.delay(100))
                    .then(function (image) {
                        var canvas = newCanvas(domNode);
                        canvas.getContext('2d').drawImage(image, 0, 0);
                        return canvas;
                    });

                function newCanvas(domNode) {
                    var canvas = document.createElement('canvas');
                    canvas.width = options.width || util.width(domNode);
                    canvas.height = options.height || util.height(domNode);

                    if (options.bgcolor) {
                        var ctx = canvas.getContext('2d');
                        ctx.fillStyle = options.bgcolor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }

                    return canvas;
                }
            }

            function cloneNode(node, filter, root) {
                if (!root && filter && !filter(node)) return Promise.resolve();

                return Promise.resolve(node)
                    .then(makeNodeCopy)
                    .then(function (clone) {
                        return cloneChildren(node, clone, filter);
                    })
                    .then(function (clone) {
                        return processClone(node, clone);
                    });

                function makeNodeCopy(node) {
                    if (node instanceof HTMLCanvasElement) return util.makeImage(node.toDataURL());
                    return node.cloneNode(false);
                }

                function cloneChildren(original, clone, filter) {
                    var children = original.childNodes;
                    if (children.length === 0) return Promise.resolve(clone);

                    return cloneChildrenInOrder(clone, util.asArray(children), filter)
                        .then(function () {
                            return clone;
                        });

                    function cloneChildrenInOrder(parent, children, filter) {
                        var done = Promise.resolve();
                        children.forEach(function (child) {
                            done = done
                                .then(function () {
                                    return cloneNode(child, filter);
                                })
                                .then(function (childClone) {
                                    if (childClone) parent.appendChild(childClone);
                                });
                        });
                        return done;
                    }
                }

                function processClone(original, clone) {
                    if (!(clone instanceof Element)) return clone;

                    return Promise.resolve()
                        .then(cloneStyle)
                        .then(clonePseudoElements)
                        .then(copyUserInput)
                        .then(fixSvg)
                        .then(function () {
                            return clone;
                        });

                    function cloneStyle() {
                        copyStyle(window.getComputedStyle(original), clone.style);

                        function copyStyle(source, target) {
                            if (source.cssText) target.cssText = source.cssText;
                            else copyProperties(source, target);

                            function copyProperties(source, target) {
                                util.asArray(source).forEach(function (name) {
                                    target.setProperty(
                                        name,
                                        source.getPropertyValue(name),
                                        source.getPropertyPriority(name)
                                    );
                                });
                            }
                        }
                    }

                    function clonePseudoElements() {
                        [':before', ':after'].forEach(function (element) {
                            clonePseudoElement(element);
                        });

                        function clonePseudoElement(element) {
                            var style = window.getComputedStyle(original, element);
                            var content = style.getPropertyValue('content');

                            if (content === '' || content === 'none') return;

                            var className = util.uid();
                            clone.className = clone.className + ' ' + className;
                            var styleElement = document.createElement('style');
                            styleElement.appendChild(formatPseudoElementStyle(className, element, style));
                            clone.appendChild(styleElement);

                            function formatPseudoElementStyle(className, element, style) {
                                var selector = '.' + className + ':' + element;
                                var cssText = style.cssText ? formatCssText(style) : formatCssProperties(style);
                                return document.createTextNode(selector + '{' + cssText + '}');

                                function formatCssText(style) {
                                    var content = style.getPropertyValue('content');
                                    return style.cssText + ' content: ' + content + ';';
                                }

                                function formatCssProperties(style) {

                                    return util.asArray(style)
                                        .map(formatProperty)
                                        .join('; ') + ';';

                                    function formatProperty(name) {
                                        return name + ': ' +
                                            style.getPropertyValue(name) +
                                            (style.getPropertyPriority(name) ? ' !important' : '');
                                    }
                                }
                            }
                        }
                    }

                    function copyUserInput() {
                        if (original instanceof HTMLTextAreaElement) clone.innerHTML = original.value;
                        if (original instanceof HTMLInputElement) clone.setAttribute("value", original.value);
                    }

                    function fixSvg() {
                        if (!(clone instanceof SVGElement)) return;
                        clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

                        if (!(clone instanceof SVGRectElement)) return;
                        ['width', 'height'].forEach(function (attribute) {
                            var value = clone.getAttribute(attribute);
                            if (!value) return;

                            clone.style.setProperty(attribute, value);
                        });
                    }
                }
            }

            function embedFonts(node) {
                return fontFaces.resolveAll()
                    .then(function (cssText) {
                        var styleNode = document.createElement('style');
                        node.appendChild(styleNode);
                        styleNode.appendChild(document.createTextNode(cssText));
                        return node;
                    });
            }

            function inlineImages(node) {
                return images.inlineAll(node)
                    .then(function () {
                        return node;
                    });
            }

            function makeSvgDataUri(node, width, height) {
                return Promise.resolve(node)
                    .then(function (node) {
                        node.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
                        return new XMLSerializer().serializeToString(node);
                    })
                    .then(util.escapeXhtml)
                    .then(function (xhtml) {
                        return '<foreignObject x="0" y="0" width="100%" height="100%">' + xhtml + '</foreignObject>';
                    })
                    .then(function (foreignObject) {
                        return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' +
                            foreignObject + '</svg>';
                    })
                    .then(function (svg) {
                        return 'data:image/svg+xml;charset=utf-8,' + svg;
                    });
            }

            function newUtil() {
                return {
                    escape: escape,
                    parseExtension: parseExtension,
                    mimeType: mimeType,
                    dataAsUrl: dataAsUrl,
                    isDataUrl: isDataUrl,
                    canvasToBlob: canvasToBlob,
                    resolveUrl: resolveUrl,
                    getAndEncode: getAndEncode,
                    uid: uid(),
                    delay: delay,
                    asArray: asArray,
                    escapeXhtml: escapeXhtml,
                    makeImage: makeImage,
                    width: width,
                    height: height
                };

                function mimes() {
                    /*
                 * Only WOFF and EOT mime types for fonts are 'real'
                 * see http://www.iana.org/assignments/media-types/media-types.xhtml
                 */
                    var WOFF = 'application/font-woff';
                    var JPEG = 'image/jpeg';

                    return {
                        'woff': WOFF,
                        'woff2': WOFF,
                        'ttf': 'application/font-truetype',
                        'eot': 'application/vnd.ms-fontobject',
                        'png': 'image/png',
                        'jpg': JPEG,
                        'jpeg': JPEG,
                        'gif': 'image/gif',
                        'tiff': 'image/tiff',
                        'svg': 'image/svg+xml'
                    };
                }

                function parseExtension(url) {
                    var match = /\.([^\.\/]*?)$/g.exec(url);
                    if (match) return match[1];
                    else return '';
                }

                function mimeType(url) {
                    var extension = parseExtension(url).toLowerCase();
                    return mimes()[extension] || '';
                }

                function isDataUrl(url) {
                    return url.search(/^(data:)/) !== -1;
                }

                function toBlob(canvas) {
                    return new Promise(function (resolve) {
                        var binaryString = window.atob(canvas.toDataURL().split(',')[1]);
                        var length = binaryString.length;
                        var binaryArray = new Uint8Array(length);

                        for (var i = 0; i < length; i++)
                            binaryArray[i] = binaryString.charCodeAt(i);

                        resolve(new Blob([binaryArray], {
                            type: 'image/png'
                        }));
                    });
                }

                function canvasToBlob(canvas) {
                    if (canvas.toBlob)
                        return new Promise(function (resolve) {
                            canvas.toBlob(resolve);
                        });

                    return toBlob(canvas);
                }

                function resolveUrl(url, baseUrl) {
                    var doc = document.implementation.createHTMLDocument();
                    var base = doc.createElement('base');
                    doc.head.appendChild(base);
                    var a = doc.createElement('a');
                    doc.body.appendChild(a);
                    base.href = baseUrl;
                    a.href = url;
                    return a.href;
                }

                function uid() {
                    var index = 0;

                    return function () {
                        return 'u' + fourRandomChars() + index++;

                        function fourRandomChars() {
                            /* see http://stackoverflow.com/a/6248722/2519373 */
                            return ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
                        }
                    };
                }

                function makeImage(uri) {
                    return new Promise(function (resolve, reject) {
                        var image = new Image();
                        image.onload = function () {
                            resolve(image);
                        };
                        image.onerror = reject;
                        image.src = uri;
                    });
                }

                function getAndEncode(url) {
                    var TIMEOUT = 30000;
                    if(domtoimage.impl.options.cacheBust) {
                        // Cache bypass so we dont have CORS issues with cached images
                        // Source: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
                        url += ((/\?/).test(url) ? "&" : "?") + (new Date()).getTime();
                    }

                    return new Promise(function (resolve) {
                        var request = new XMLHttpRequest();

                        request.onreadystatechange = done;
                        request.ontimeout = timeout;
                        request.responseType = 'blob';
                        request.timeout = TIMEOUT;
                        request.open('GET', url, true);
                        request.send();

                        var placeholder;
                        if(domtoimage.impl.options.imagePlaceholder) {
                            var split = domtoimage.impl.options.imagePlaceholder.split(/,/);
                            if(split && split[1]) {
                                placeholder = split[1];
                            }
                        }

                        function done() {
                            if (request.readyState !== 4) return;

                            if (request.status !== 200) {
                                if(placeholder) {
                                    resolve(placeholder);
                                } else {
                                    fail('cannot fetch resource: ' + url + ', status: ' + request.status);
                                }

                                return;
                            }

                            var encoder = new FileReader();
                            encoder.onloadend = function () {
                                var content = encoder.result.split(/,/)[1];
                                resolve(content);
                            };
                            encoder.readAsDataURL(request.response);
                        }

                        function timeout() {
                            if(placeholder) {
                                resolve(placeholder);
                            } else {
                                fail('timeout of ' + TIMEOUT + 'ms occured while fetching resource: ' + url);
                            }
                        }

                        function fail(message) {
                            console.error(message);
                            resolve('');
                        }
                    });
                }

                function dataAsUrl(content, type) {
                    return 'data:' + type + ';base64,' + content;
                }

                function escape(string) {
                    return string.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1');
                }

                function delay(ms) {
                    return function (arg) {
                        return new Promise(function (resolve) {
                            setTimeout(function () {
                                resolve(arg);
                            }, ms);
                        });
                    };
                }

                function asArray(arrayLike) {
                    var array = [];
                    var length = arrayLike.length;
                    for (var i = 0; i < length; i++) array.push(arrayLike[i]);
                    return array;
                }

                function escapeXhtml(string) {
                    return string.replace(/#/g, '%23').replace(/\n/g, '%0A');
                }

                function width(node) {
                    var leftBorder = px(node, 'border-left-width');
                    var rightBorder = px(node, 'border-right-width');
                    return node.scrollWidth + leftBorder + rightBorder;
                }

                function height(node) {
                    var topBorder = px(node, 'border-top-width');
                    var bottomBorder = px(node, 'border-bottom-width');
                    return node.scrollHeight + topBorder + bottomBorder;
                }

                function px(node, styleProperty) {
                    var value = window.getComputedStyle(node).getPropertyValue(styleProperty);
                    return parseFloat(value.replace('px', ''));
                }
            }

            function newInliner() {
                var URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;

                return {
                    inlineAll: inlineAll,
                    shouldProcess: shouldProcess,
                    impl: {
                        readUrls: readUrls,
                        inline: inline
                    }
                };

                function shouldProcess(string) {
                    return string.search(URL_REGEX) !== -1;
                }

                function readUrls(string) {
                    var result = [];
                    var match;
                    while ((match = URL_REGEX.exec(string)) !== null) {
                        result.push(match[1]);
                    }
                    return result.filter(function (url) {
                        return !util.isDataUrl(url);
                    });
                }

                function inline(string, url, baseUrl, get) {
                    return Promise.resolve(url)
                        .then(function (url) {
                            return baseUrl ? util.resolveUrl(url, baseUrl) : url;
                        })
                        .then(get || util.getAndEncode)
                        .then(function (data) {
                            return util.dataAsUrl(data, util.mimeType(url));
                        })
                        .then(function (dataUrl) {
                            return string.replace(urlAsRegex(url), '$1' + dataUrl + '$3');
                        });

                    function urlAsRegex(url) {
                        return new RegExp('(url\\([\'"]?)(' + util.escape(url) + ')([\'"]?\\))', 'g');
                    }
                }

                function inlineAll(string, baseUrl, get) {
                    if (nothingToInline()) return Promise.resolve(string);

                    return Promise.resolve(string)
                        .then(readUrls)
                        .then(function (urls) {
                            var done = Promise.resolve(string);
                            urls.forEach(function (url) {
                                done = done.then(function (string) {
                                    return inline(string, url, baseUrl, get);
                                });
                            });
                            return done;
                        });

                    function nothingToInline() {
                        return !shouldProcess(string);
                    }
                }
            }

            function newFontFaces() {
                return {
                    resolveAll: resolveAll,
                    impl: {
                        readAll: readAll
                    }
                };

                function resolveAll() {
                    return readAll()
                        .then(function (webFonts) {
                            return Promise.all(
                                webFonts.map(function (webFont) {
                                    return webFont.resolve();
                                })
                            );
                        })
                        .then(function (cssStrings) {
                            return cssStrings.join('\n');
                        });
                }

                function readAll() {
                    return Promise.resolve(util.asArray(document.styleSheets))
                        .then(getCssRules)
                        .then(selectWebFontRules)
                        .then(function (rules) {
                            return rules.map(newWebFont);
                        });

                    function selectWebFontRules(cssRules) {
                        return cssRules
                            .filter(function (rule) {
                                return rule.type === CSSRule.FONT_FACE_RULE;
                            })
                            .filter(function (rule) {
                                return inliner.shouldProcess(rule.style.getPropertyValue('src'));
                            });
                    }

                    function getCssRules(styleSheets) {
                        var cssRules = [];
                        styleSheets.forEach(function (sheet) {
                            try {
                                util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));
                            } catch (e) {
                                console.log('Error while reading CSS rules from ' + sheet.href, e.toString());
                            }
                        });
                        return cssRules;
                    }

                    function newWebFont(webFontRule) {
                        return {
                            resolve: function resolve() {
                                var baseUrl = (webFontRule.parentStyleSheet || {}).href;
                                return inliner.inlineAll(webFontRule.cssText, baseUrl);
                            },
                            src: function () {
                                return webFontRule.style.getPropertyValue('src');
                            }
                        };
                    }
                }
            }

            function newImages() {
                return {
                    inlineAll: inlineAll,
                    impl: {
                        newImage: newImage
                    }
                };

                function newImage(element) {
                    return {
                        inline: inline
                    };

                    function inline(get) {
                        if (util.isDataUrl(element.src)) return Promise.resolve();

                        return Promise.resolve(element.src)
                            .then(get || util.getAndEncode)
                            .then(function (data) {
                                return util.dataAsUrl(data, util.mimeType(element.src));
                            })
                            .then(function (dataUrl) {
                                return new Promise(function (resolve, reject) {
                                    element.onload = resolve;
                                    element.onerror = reject;
                                    element.src = dataUrl;
                                });
                            });
                    }
                }

                function inlineAll(node) {
                    if (!(node instanceof Element)) return Promise.resolve(node);

                    return inlineBackground(node)
                        .then(function () {
                            if (node instanceof HTMLImageElement)
                                return newImage(node).inline();
                            else
                                return Promise.all(
                                    util.asArray(node.childNodes).map(function (child) {
                                        return inlineAll(child);
                                    })
                                );
                        });

                    function inlineBackground(node) {
                        var background = node.style.getPropertyValue('background');

                        if (!background) return Promise.resolve(node);

                        return inliner.inlineAll(background)
                            .then(function (inlined) {
                                node.style.setProperty(
                                    'background',
                                    inlined,
                                    node.style.getPropertyPriority('background')
                                );
                            })
                            .then(function () {
                                return node;
                            });
                    }
                }
            }
        })();
    });

    /*!
     * @dineug/sql-ddl-parser
     * @version 0.1.2 | Wed Sep 30 2020
     * @author dineug <dineug2@gmail.com>
     * @license MIT
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var MariaDBKeywords = [];

    var MSSQLKeywords = [];

    var MySQLKeywords = [
        "ADD",
        "ALTER",
        "AND",
        "AS",
        "ASC",
        "AUTO_INCREMENT",
        "BY",
        "CASCADE",
        "COLUMN",
        "COMMENT",
        "CONSTRAINT",
        "CREATE",
        "DATABASE",
        "DEFAULT",
        "DELETE",
        "DESC",
        "DROP",
        "EXISTS",
        "FOREIGN",
        "IF",
        "INDEX",
        "KEY",
        "LIKE",
        "NOT",
        "NULL",
        "ON",
        "OR",
        "PRIMARY",
        "REFERENCES",
        "RENAME",
        "SCHEMA",
        "SELECT",
        "SET",
        "TABLE",
        "UNION",
        "UNIQUE",
        "USE",
    ];

    var OracleKeywords = [];

    var PostgreSQLKeywords = [];

    var SQLiteKeywords = ["AUTOINCREMENT"];

    /**
     * https://mariadb.com/kb/en/data-types/
     */
    var MariaDBTypes = [
        "BIGINT",
        "BINARY",
        "BIT",
        "BLOB",
        "BOOL",
        "BOOLEAN",
        "CHAR",
        "DATE",
        "DATETIME",
        "DEC",
        "DECIMAL",
        "DOUBLE PRECISION",
        "DOUBLE",
        "ENUM",
        "FIXED",
        "FLOAT",
        "GEOMETRY",
        "GEOMETRYCOLLECTION",
        "INT",
        "INTEGER",
        "JSON",
        "LINESTRING",
        "LONGBLOB",
        "LONGTEXT",
        "MEDIUMBLOB",
        "MEDIUMINT",
        "MEDIUMTEXT",
        "MULTILINESTRING",
        "MULTIPOINT",
        "MULTIPOLYGON",
        "NUMERIC",
        "POINT",
        "POLYGON",
        "REAL",
        "SET",
        "SMALLINT",
        "TEXT",
        "TIME",
        "TIMESTAMP",
        "TINYBLOB",
        "TINYINT",
        "TINYTEXT",
        "VARBINARY",
        "VARCHAR",
        "YEAR",
    ];

    /**
     * https://docs.microsoft.com/ko-kr/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver15
     */
    var MSSQLTypes = [
        "BIGINT",
        "BINARY",
        "BIT",
        "CHAR",
        "DATE",
        "DATETIME",
        "DATETIME2",
        "DATETIMEOFFSET",
        "DECIMAL",
        "FLOAT",
        "GEOGRAPHY",
        "GEOMETRY",
        "IMAGE",
        "INT",
        "MONEY",
        "NCHAR",
        "NTEXT",
        "NUMERIC",
        "NVARCHAR",
        "REAL",
        "SMALLDATETIME",
        "SMALLINT",
        "SMALLMONEY",
        "SQL_VARIANT",
        "TEXT",
        "TIME",
        "TINYINT",
        "UNIQUEIDENTIFIER",
        "VARBINARY",
        "VARCHAR",
        "XML",
    ];

    /**
     * https://dev.mysql.com/doc/refman/8.0/en/data-types.html
     */
    var MySQLTypes = [
        "BIGINT",
        "BINARY",
        "BIT",
        "BLOB",
        "BOOL",
        "BOOLEAN",
        "CHAR",
        "DATE",
        "DATETIME",
        "DEC",
        "DECIMAL",
        "DOUBLE PRECISION",
        "DOUBLE",
        "ENUM",
        "FLOAT",
        "GEOMETRY",
        "GEOMETRYCOLLECTION",
        "INT",
        "INTEGER",
        "JSON",
        "LINESTRING",
        "LONGBLOB",
        "LONGTEXT",
        "MEDIUMBLOB",
        "MEDIUMINT",
        "MEDIUMTEXT",
        "MULTILINESTRING",
        "MULTIPOINT",
        "MULTIPOLYGON",
        "NUMERIC",
        "POINT",
        "POLYGON",
        "SET",
        "SMALLINT",
        "TEXT",
        "TIME",
        "TIMESTAMP",
        "TINYBLOB",
        "TINYINT",
        "TINYTEXT",
        "VARBINARY",
        "VARCHAR",
        "YEAR",
    ];

    /**
     * https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT012
     */
    var OracleTypes = [
        "BFILE",
        "BINARY_DOUBLE",
        "BINARY_FLOAT",
        "BLOB",
        "CHAR",
        "CLOB",
        "DATE",
        "DATETIME",
        "LONG RAW",
        "LONG",
        "NCHAR",
        "NCLOB",
        "NUMBER",
        "NVARCHAR2",
        "RAW",
        "TIMESTAMP WITH LOCAL TIME ZONE",
        "TIMESTAMP WITH TIME ZONE",
        "TIMESTAMP",
        "UriType",
        "VARCHAR",
        "VARCHAR2",
        "XMLType",
    ];

    /**
     * https://www.postgresql.org/docs/current/datatype.html
     */
    var PostgreSQLTypes = [
        "BIGINT",
        "BIGSERIAL",
        "BIT VARYING",
        "BIT",
        "BOOL",
        "BOOLEAN",
        "BOX",
        "BYTEA",
        "CHAR",
        "CHARACTER VARYING",
        "CHARACTER",
        "CIDR",
        "CIRCLE",
        "DATE",
        "DECIMAL",
        "DOUBLE PRECISION",
        "FLOAT4",
        "FLOAT8",
        "INET",
        "INT",
        "INT2",
        "INT4",
        "INT8",
        "INTEGER",
        "INTERVAL",
        "JSON",
        "JSONB",
        "LINE",
        "LSEG",
        "MACADDR",
        "MACADDR8",
        "MONEY",
        "NUMERIC",
        "PATH",
        "PG_LSN",
        "POINT",
        "POLYGON",
        "REAL",
        "SERIAL",
        "SERIAL2",
        "SERIAL4",
        "SERIAL8",
        "SMALLINT",
        "SMALLSERIAL",
        "TEXT",
        "TIME WITH",
        "TIME",
        "TIMESTAMP WITH",
        "TIMESTAMP",
        "TIMESTAMPTZ",
        "TIMETZ",
        "TSQUERY",
        "TSVECTOR",
        "TXID_SNAPSHOT",
        "UUID",
        "VARBIT",
        "VARCHAR",
        "XML",
    ];

    /**
     * https://www.sqlite.org/datatype3.html
     */
    var SQLiteTypes = [
        "BLOB",
        "INTEGER",
        "NUMERIC",
        "REAL",
        "TEXT",
    ];

    var tokenMatch = {
        whiteSpace: /(?:\s+|#.*|-- +.*|\/\*(?:[\s\S])*?\*\/)+/,
        leftParen: "(",
        rightParen: ")",
        comma: ",",
        period: ".",
        equal: "=",
        semicolon: ";",
        doubleQuote: "\"",
        singleQuote: "'",
        backtick: "`",
        keywords: getKeywords(),
        string: /[a-z0-9_]/i,
        unknown: /.+/,
        dataTypes: getDataTypes(),
    };
    function getDataTypes() {
        var keywords = __spreadArrays(MariaDBTypes, MSSQLTypes, MySQLTypes, OracleTypes, PostgreSQLTypes, SQLiteTypes);
        return Array.from(new Set(keywords.map(function (keyword) { return keyword.toUpperCase(); })));
    }
    function getKeywords() {
        var keywords = __spreadArrays(MariaDBKeywords, MSSQLKeywords, MySQLKeywords, OracleKeywords, PostgreSQLKeywords, SQLiteKeywords, getDataTypes());
        return Array.from(new Set(keywords.map(function (keyword) { return keyword.toUpperCase(); })));
    }
    function keywordEqual(token, value) {
        return (token.type === "keyword" &&
            token.value.toUpperCase() === value.toUpperCase());
    }
    function isExtraString(token) {
        if (!token)
            return false;
        return (token.type === "doubleQuoteString" ||
            token.type === "singleQuoteString" ||
            token.type === "backtickString");
    }
    function isStringKeyword(token) {
        if (!token)
            return false;
        var value = token.value.toUpperCase();
        return token.type === "string" && tokenMatch.keywords.includes(value);
    }
    function isKeyword(token) {
        if (!token)
            return false;
        return token.type === "keyword";
    }
    function isString(token) {
        if (!token)
            return false;
        return token.type === "string";
    }
    function isPeriod(token) {
        if (!token)
            return false;
        return token.type === "period";
    }
    function isLeftParen(token) {
        if (!token)
            return false;
        return token.type === "leftParen";
    }
    function isRightParen(token) {
        if (!token)
            return false;
        return token.type === "rightParen";
    }
    function isSemicolon(token) {
        if (!token)
            return false;
        return token.type === "semicolon";
    }
    function isComma(token) {
        if (!token)
            return false;
        return token.type === "comma";
    }
    function isCurrent(list, current) {
        return list.length > current;
    }
    function isNewStatement(token) {
        if (!token)
            return false;
        return (keywordEqual(token, "CREATE") ||
            keywordEqual(token, "ALTER") ||
            keywordEqual(token, "DROP") ||
            keywordEqual(token, "USE") ||
            keywordEqual(token, "RENAME") ||
            keywordEqual(token, "DELETE") ||
            keywordEqual(token, "SELECT"));
    }
    function isCreateTable(tokens) {
        return (tokens.length > 2 &&
            keywordEqual(tokens[0], "CREATE") &&
            keywordEqual(tokens[1], "TABLE"));
    }
    function isCreateIndex(tokens) {
        return (tokens.length > 2 &&
            keywordEqual(tokens[0], "CREATE") &&
            keywordEqual(tokens[1], "INDEX"));
    }
    function isCreateUniqueIndex(tokens) {
        return (tokens.length > 3 &&
            keywordEqual(tokens[0], "CREATE") &&
            keywordEqual(tokens[1], "UNIQUE") &&
            keywordEqual(tokens[2], "INDEX"));
    }
    function isAlterTableAddPrimaryKey(tokens) {
        return ((tokens.length > 6 &&
            keywordEqual(tokens[0], "ALTER") &&
            keywordEqual(tokens[1], "TABLE") &&
            keywordEqual(tokens[3], "ADD") &&
            keywordEqual(tokens[4], "PRIMARY") &&
            keywordEqual(tokens[5], "KEY")) ||
            (tokens.length > 8 &&
                keywordEqual(tokens[0], "ALTER") &&
                keywordEqual(tokens[1], "TABLE") &&
                keywordEqual(tokens[3], "ADD") &&
                keywordEqual(tokens[4], "CONSTRAINT") &&
                keywordEqual(tokens[6], "PRIMARY") &&
                keywordEqual(tokens[7], "KEY")));
    }
    function isAlterTableAddForeignKey(tokens) {
        return ((tokens.length > 6 &&
            keywordEqual(tokens[0], "ALTER") &&
            keywordEqual(tokens[1], "TABLE") &&
            keywordEqual(tokens[3], "ADD") &&
            keywordEqual(tokens[4], "FOREIGN") &&
            keywordEqual(tokens[5], "KEY")) ||
            (tokens.length > 8 &&
                keywordEqual(tokens[0], "ALTER") &&
                keywordEqual(tokens[1], "TABLE") &&
                keywordEqual(tokens[3], "ADD") &&
                keywordEqual(tokens[4], "CONSTRAINT") &&
                keywordEqual(tokens[6], "FOREIGN") &&
                keywordEqual(tokens[7], "KEY")));
    }
    function isAlterTableAddUnique(tokens) {
        return ((tokens.length > 5 &&
            keywordEqual(tokens[0], "ALTER") &&
            keywordEqual(tokens[1], "TABLE") &&
            keywordEqual(tokens[3], "ADD") &&
            keywordEqual(tokens[4], "UNIQUE")) ||
            (tokens.length > 7 &&
                keywordEqual(tokens[0], "ALTER") &&
                keywordEqual(tokens[1], "TABLE") &&
                keywordEqual(tokens[3], "ADD") &&
                keywordEqual(tokens[4], "CONSTRAINT") &&
                keywordEqual(tokens[6], "UNIQUE")));
    }
    function isDataType(token) {
        if (!token)
            return false;
        var value = token.value.toUpperCase();
        return token.type === "keyword" && tokenMatch.dataTypes.includes(value);
    }
    function isNot(token) {
        if (!token)
            return false;
        return keywordEqual(token, "NOT");
    }
    function isNull(token) {
        if (!token)
            return false;
        return keywordEqual(token, "NULL");
    }
    function isDefault(token) {
        if (!token)
            return false;
        return keywordEqual(token, "DEFAULT");
    }
    function isComment(token) {
        if (!token)
            return false;
        return keywordEqual(token, "COMMENT");
    }
    function isAutoIncrement(token) {
        if (!token)
            return false;
        return (keywordEqual(token, "AUTO_INCREMENT") ||
            keywordEqual(token, "AUTOINCREMENT"));
    }
    function isPrimary(token) {
        if (!token)
            return false;
        return keywordEqual(token, "PRIMARY");
    }
    function isKey(token) {
        if (!token)
            return false;
        return keywordEqual(token, "KEY");
    }
    function isUnique(token) {
        if (!token)
            return false;
        return keywordEqual(token, "UNIQUE");
    }
    function isConstraint(token) {
        if (!token)
            return false;
        return keywordEqual(token, "CONSTRAINT");
    }
    function isIndex(token) {
        if (!token)
            return false;
        return keywordEqual(token, "INDEX");
    }
    function isForeign(token) {
        if (!token)
            return false;
        return keywordEqual(token, "FOREIGN");
    }
    function isReferences(token) {
        if (!token)
            return false;
        return keywordEqual(token, "REFERENCES");
    }
    function isDESC(token) {
        if (!token)
            return false;
        return keywordEqual(token, "DESC");
    }
    function isOn(token) {
        if (!token)
            return false;
        return keywordEqual(token, "ON");
    }
    function isTable(token) {
        if (!token)
            return false;
        return keywordEqual(token, "TABLE");
    }

    function createTable(tokens) {
        var current = { value: 0 };
        var ast = {
            type: "create.table",
            name: "",
            comment: "",
            columns: [],
            indexes: [],
            foreignKeys: [],
        };
        while (isCurrent(tokens, current.value)) {
            var token = tokens[current.value];
            if (isLeftParen(token)) {
                current.value++;
                var _a = createTableColumns(tokens, current), columns = _a.columns, indexes = _a.indexes, foreignKeys = _a.foreignKeys;
                ast.columns = columns;
                ast.indexes = indexes;
                ast.foreignKeys = foreignKeys;
                continue;
            }
            if (isString(token) && !ast.name) {
                ast.name = token.value;
                token = tokens[++current.value];
                if (isPeriod(token)) {
                    token = tokens[++current.value];
                    if (isString(token)) {
                        ast.name = token.value;
                        current.value++;
                    }
                }
                continue;
            }
            if (isComment(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    ast.comment = token.value;
                    current.value++;
                }
                continue;
            }
            current.value++;
        }
        return ast;
    }
    function createTableColumns(tokens, current) {
        var columns = [];
        var indexes = [];
        var foreignKeys = [];
        var primaryKeyColumnNames = [];
        var uniqueColumnNames = [];
        var column = {
            name: "",
            dataType: "",
            default: "",
            comment: "",
            primaryKey: false,
            autoIncrement: false,
            unique: false,
            nullable: true,
        };
        while (isCurrent(tokens, current.value)) {
            var token = tokens[current.value];
            if (isString(token) && !column.name) {
                column.name = token.value;
                current.value++;
                continue;
            }
            if (isLeftParen(token)) {
                token = tokens[++current.value];
                while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                    token = tokens[++current.value];
                }
                current.value++;
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    current.value++;
                }
                continue;
            }
            if (isPrimary(token)) {
                token = tokens[++current.value];
                if (isKey(token)) {
                    token = tokens[++current.value];
                    if (isLeftParen(token)) {
                        token = tokens[++current.value];
                        while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                            if (isString(token)) {
                                primaryKeyColumnNames.push(token.value.toUpperCase());
                            }
                            token = tokens[++current.value];
                        }
                        current.value++;
                    }
                    else {
                        column.primaryKey = true;
                    }
                }
                continue;
            }
            if (isForeign(token)) {
                var foreignKey = parserForeignKey(tokens, current);
                if (foreignKey) {
                    foreignKeys.push(foreignKey);
                }
                continue;
            }
            if (isIndex(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    var name_1 = token.value;
                    var indexColumns = [];
                    token = tokens[++current.value];
                    if (isLeftParen(token)) {
                        token = tokens[++current.value];
                        var indexColumn = {
                            name: "",
                            sort: "ASC",
                        };
                        while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                            if (isString(token)) {
                                indexColumn.name = token.value;
                            }
                            if (isDESC(token)) {
                                indexColumn.sort = "DESC";
                            }
                            if (isComma(token)) {
                                indexColumns.push(indexColumn);
                                indexColumn = {
                                    name: "",
                                    sort: "ASC",
                                };
                            }
                            token = tokens[++current.value];
                        }
                        if (!indexColumns.includes(indexColumn) && indexColumn.name !== "") {
                            indexColumns.push(indexColumn);
                        }
                        if (indexColumns.length) {
                            indexes.push({
                                name: name_1,
                                unique: false,
                                columns: indexColumns,
                            });
                        }
                        current.value++;
                    }
                }
                continue;
            }
            if (isUnique(token)) {
                token = tokens[++current.value];
                if (isLeftParen(token)) {
                    token = tokens[++current.value];
                    while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                        if (isString(token)) {
                            uniqueColumnNames.push(token.value.toUpperCase());
                        }
                        token = tokens[++current.value];
                    }
                    current.value++;
                }
                else {
                    column.unique = true;
                }
                continue;
            }
            if (isNot(token)) {
                token = tokens[++current.value];
                if (isNull(token)) {
                    column.nullable = false;
                    current.value++;
                }
                continue;
            }
            if (isDefault(token)) {
                token = tokens[++current.value];
                if (isString(token) || isKeyword(token)) {
                    column.default = token.value;
                    current.value++;
                }
                continue;
            }
            if (isComment(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    column.comment = token.value;
                    current.value++;
                }
                continue;
            }
            if (isAutoIncrement(token)) {
                column.autoIncrement = true;
                current.value++;
                continue;
            }
            if (isDataType(token)) {
                var value = token.value;
                token = tokens[++current.value];
                if (isLeftParen(token)) {
                    value += "(";
                    token = tokens[++current.value];
                    while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                        value += token.value;
                        token = tokens[++current.value];
                    }
                    value += ")";
                    current.value++;
                }
                column.dataType = value;
                continue;
            }
            if (isComma(token)) {
                if (column.name || column.dataType) {
                    columns.push(column);
                }
                column = {
                    name: "",
                    dataType: "",
                    default: "",
                    comment: "",
                    primaryKey: false,
                    autoIncrement: false,
                    unique: false,
                    nullable: true,
                };
                current.value++;
                continue;
            }
            if (isRightParen(token)) {
                current.value++;
                break;
            }
            current.value++;
        }
        if (!columns.includes(column) && (column.name || column.dataType)) {
            columns.push(column);
        }
        columns.forEach(function (column) {
            if (primaryKeyColumnNames.includes(column.name.toUpperCase())) {
                column.primaryKey = true;
            }
            if (uniqueColumnNames.includes(column.name.toUpperCase())) {
                column.unique = true;
            }
        });
        return {
            columns: columns,
            indexes: indexes,
            foreignKeys: foreignKeys,
        };
    }
    function parserForeignKey(tokens, current) {
        var foreignKey = {
            columnNames: [],
            refTableName: "",
            refColumnNames: [],
        };
        var token = tokens[++current.value];
        if (isKey(token)) {
            token = tokens[++current.value];
            if (isLeftParen(token)) {
                token = tokens[++current.value];
                while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                    if (isString(token)) {
                        foreignKey.columnNames.push(token.value);
                    }
                    token = tokens[++current.value];
                }
                token = tokens[++current.value];
            }
            if (isReferences(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    foreignKey.refTableName = token.value;
                    token = tokens[++current.value];
                    if (isPeriod(token)) {
                        token = tokens[++current.value];
                        if (isString(token)) {
                            foreignKey.refTableName = token.value;
                            token = tokens[++current.value];
                        }
                    }
                    if (isLeftParen(token)) {
                        token = tokens[++current.value];
                        while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                            if (isString(token)) {
                                foreignKey.refColumnNames.push(token.value);
                            }
                            token = tokens[++current.value];
                        }
                        token = tokens[++current.value];
                    }
                }
            }
            if (foreignKey.columnNames.length &&
                foreignKey.columnNames.length === foreignKey.refColumnNames.length) {
                return foreignKey;
            }
        }
        return null;
    }

    function createIndex(tokens, unique) {
        if (unique === void 0) { unique = false; }
        var current = 0;
        var ast = {
            type: "create.index",
            name: "",
            unique: unique,
            tableName: "",
            columns: [],
        };
        while (isCurrent(tokens, current)) {
            var token = tokens[current];
            if (isIndex(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    ast.name = token.value;
                }
                continue;
            }
            if (isOn(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    ast.tableName = token.value;
                    token = tokens[++current];
                    if (isLeftParen(token)) {
                        token = tokens[++current];
                        var indexColumn = {
                            name: "",
                            sort: "ASC",
                        };
                        while (isCurrent(tokens, current) && !isRightParen(token)) {
                            if (isString(token)) {
                                indexColumn.name = token.value;
                            }
                            if (isDESC(token)) {
                                indexColumn.sort = "DESC";
                            }
                            if (isComma(token)) {
                                ast.columns.push(indexColumn);
                                indexColumn = {
                                    name: "",
                                    sort: "ASC",
                                };
                            }
                            token = tokens[++current];
                        }
                        if (!ast.columns.includes(indexColumn) && indexColumn.name !== "") {
                            ast.columns.push(indexColumn);
                        }
                        current++;
                    }
                }
                continue;
            }
            current++;
        }
        return ast;
    }

    function createUniqueIndex(tokens) {
        return createIndex(tokens, true);
    }

    function alterTableAddPrimaryKey(tokens) {
        var current = 0;
        var ast = {
            type: "alter.table.add.primaryKey",
            name: "",
            columnNames: [],
        };
        while (isCurrent(tokens, current)) {
            var token = tokens[current];
            if (isTable(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    ast.name = token.value;
                    token = tokens[++current];
                    if (isPeriod(token)) {
                        token = tokens[++current];
                        if (isString(token)) {
                            ast.name = token.value;
                            current++;
                        }
                    }
                }
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    current++;
                }
                continue;
            }
            if (isPrimary(token)) {
                token = tokens[++current];
                if (isKey(token)) {
                    token = tokens[++current];
                    if (isLeftParen(token)) {
                        token = tokens[++current];
                        while (isCurrent(tokens, current) && !isRightParen(token)) {
                            if (isString(token)) {
                                ast.columnNames.push(token.value);
                            }
                            token = tokens[++current];
                        }
                        token = tokens[++current];
                    }
                }
                continue;
            }
            current++;
        }
        return ast;
    }

    function alterTableAddForeignKey(tokens) {
        var current = { value: 0 };
        var ast = {
            type: "alter.table.add.foreignKey",
            name: "",
            columnNames: [],
            refTableName: "",
            refColumnNames: [],
        };
        while (isCurrent(tokens, current.value)) {
            var token = tokens[current.value];
            if (isTable(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    ast.name = token.value;
                    token = tokens[++current.value];
                    if (isPeriod(token)) {
                        token = tokens[++current.value];
                        if (isString(token)) {
                            ast.name = token.value;
                            current.value++;
                        }
                    }
                }
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    current.value++;
                }
                continue;
            }
            if (isForeign(token)) {
                var foreignKey = parserForeignKey(tokens, current);
                if (foreignKey) {
                    ast.columnNames = foreignKey.columnNames;
                    ast.refTableName = foreignKey.refTableName;
                    ast.refColumnNames = foreignKey.refColumnNames;
                }
                continue;
            }
            current.value++;
        }
        return ast;
    }

    function alterTableAddUnique(tokens) {
        var current = 0;
        var ast = {
            type: "alter.table.add.unique",
            name: "",
            columnNames: [],
        };
        while (isCurrent(tokens, current)) {
            var token = tokens[current];
            if (isTable(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    ast.name = token.value;
                    token = tokens[++current];
                    if (isPeriod(token)) {
                        token = tokens[++current];
                        if (isString(token)) {
                            ast.name = token.value;
                            current++;
                        }
                    }
                }
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    current++;
                }
                continue;
            }
            if (isUnique(token)) {
                token = tokens[++current];
                if (isLeftParen(token)) {
                    token = tokens[++current];
                    while (isCurrent(tokens, current) && !isRightParen(token)) {
                        if (isString(token)) {
                            ast.columnNames.push(token.value);
                        }
                        token = tokens[++current];
                    }
                    current++;
                }
                continue;
            }
            current++;
        }
        return ast;
    }

    /**
     * https://github.com/jamiebuilds/the-super-tiny-compiler
     */
    function tokenizer(input) {
        var current = 0;
        var tokens = [];
        while (current < input.length) {
            var char = input[current];
            if (tokenMatch.whiteSpace.test(char)) {
                current++;
                continue;
            }
            if (char === tokenMatch.leftParen) {
                tokens.push({
                    type: "leftParen",
                    value: "(",
                });
                current++;
                continue;
            }
            if (char === tokenMatch.rightParen) {
                tokens.push({
                    type: "rightParen",
                    value: ")",
                });
                current++;
                continue;
            }
            if (char === tokenMatch.comma) {
                tokens.push({
                    type: "comma",
                    value: ",",
                });
                current++;
                continue;
            }
            if (char === tokenMatch.period) {
                tokens.push({
                    type: "period",
                    value: ".",
                });
                current++;
                continue;
            }
            if (char === tokenMatch.equal) {
                tokens.push({
                    type: "equal",
                    value: "=",
                });
                current++;
                continue;
            }
            if (char === tokenMatch.semicolon) {
                tokens.push({
                    type: "semicolon",
                    value: ";",
                });
                current++;
                continue;
            }
            if (char === tokenMatch.doubleQuote) {
                var value = "";
                char = input[++current];
                while (char !== tokenMatch.doubleQuote) {
                    value += char;
                    char = input[++current];
                }
                char = input[++current];
                tokens.push({ type: "doubleQuoteString", value: value });
                continue;
            }
            if (char === tokenMatch.singleQuote) {
                var value = "";
                char = input[++current];
                while (char !== tokenMatch.singleQuote) {
                    value += char;
                    char = input[++current];
                }
                char = input[++current];
                tokens.push({ type: "singleQuoteString", value: value });
                continue;
            }
            if (char === tokenMatch.backtick) {
                var value = "";
                char = input[++current];
                while (char !== tokenMatch.backtick) {
                    value += char;
                    char = input[++current];
                }
                char = input[++current];
                tokens.push({ type: "backtickString", value: value });
                continue;
            }
            if (tokenMatch.string.test(char)) {
                var value = "";
                while (tokenMatch.string.test(char)) {
                    value += char;
                    char = input[++current];
                }
                tokens.push({ type: "string", value: value });
                continue;
            }
            if (tokenMatch.unknown.test(char)) {
                var value = "";
                while (tokenMatch.unknown.test(char)) {
                    value += char;
                    char = input[++current];
                }
                tokens.push({ type: "unknown", value: value });
                continue;
            }
            current++;
        }
        tokens.forEach(function (token) {
            if (isExtraString(token)) {
                token.type = "string";
            }
            else if (isStringKeyword(token)) {
                token.type = "keyword";
            }
        });
        return tokens;
    }
    function parser(tokens) {
        var current = 0;
        var tokenStatements = [];
        var statements = [];
        while (current < tokens.length) {
            var token = tokens[current];
            if (isNewStatement(token)) {
                var statement = [];
                statement.push(token);
                token = tokens[++current];
                while (current < tokens.length &&
                !isNewStatement(token) &&
                !isSemicolon(token)) {
                    statement.push(token);
                    token = tokens[++current];
                }
                tokenStatements.push(statement);
            }
            if (token && isNewStatement(token)) {
                continue;
            }
            current++;
        }
        tokenStatements.forEach(function (tokenStatement) {
            if (isCreateTable(tokenStatement)) {
                statements.push(createTable(tokenStatement));
            }
            else if (isCreateIndex(tokenStatement)) {
                statements.push(createIndex(tokenStatement));
            }
            else if (isCreateUniqueIndex(tokenStatement)) {
                statements.push(createUniqueIndex(tokenStatement));
            }
            else if (isAlterTableAddPrimaryKey(tokenStatement)) {
                statements.push(alterTableAddPrimaryKey(tokenStatement));
            }
            else if (isAlterTableAddForeignKey(tokenStatement)) {
                statements.push(alterTableAddForeignKey(tokenStatement));
            }
            else if (isAlterTableAddUnique(tokenStatement)) {
                statements.push(alterTableAddUnique(tokenStatement));
            }
        });
        return statements;
    }
    function DDLParser(input) {
        var tokens = tokenizer(input);
        return parser(tokens);
    }

    function reshape(statements) {
        const shape = {
            tables: [],
            indexes: [],
            primaryKeys: [],
            foreignKeys: [],
            uniques: [],
        };
        statements.forEach((statement) => {
            switch (statement.type) {
                case "create.table":
                    const table = statement;
                    if (table.name) {
                        shape.tables.push(table);
                    }
                    break;
                case "create.index":
                    const index = statement;
                    if (index.tableName && index.columns.length) {
                        shape.indexes.push(index);
                    }
                    break;
                case "alter.table.add.primaryKey":
                    const primaryKey = statement;
                    if (primaryKey.name && primaryKey.columnNames.length) {
                        shape.primaryKeys.push(primaryKey);
                    }
                    break;
                case "alter.table.add.foreignKey":
                    const foreignKey = statement;
                    if (foreignKey.name &&
                        foreignKey.columnNames.length &&
                        foreignKey.refTableName &&
                        foreignKey.refColumnNames.length &&
                        foreignKey.columnNames.length === foreignKey.refColumnNames.length) {
                        shape.foreignKeys.push(foreignKey);
                    }
                    break;
                case "alter.table.add.unique":
                    const unique = statement;
                    if (unique.name && unique.columnNames.length) {
                        shape.uniques.push(unique);
                    }
                    break;
            }
        });
        return shape;
    }
    function findByName(list, name) {
        for (const item of list) {
            if (item.name.toUpperCase() === name.toUpperCase()) {
                return item;
            }
        }
        return null;
    }
    function mergeTable(shape) {
        const { tables, indexes, primaryKeys, foreignKeys, uniques } = shape;
        indexes.forEach((index) => {
            const table = findByName(tables, index.tableName);
            if (table) {
                table.indexes.push({
                    name: index.name,
                    unique: index.unique,
                    columns: index.columns,
                });
            }
        });
        primaryKeys.forEach((primaryKey) => {
            const table = findByName(tables, primaryKey.name);
            if (table) {
                primaryKey.columnNames.forEach((columnName) => {
                    const column = findByName(table.columns, columnName);
                    if (column) {
                        column.primaryKey = true;
                    }
                });
            }
        });
        uniques.forEach((unique) => {
            const table = findByName(tables, unique.name);
            if (table) {
                unique.columnNames.forEach((columnName) => {
                    const column = findByName(table.columns, columnName);
                    if (column) {
                        column.unique = true;
                    }
                });
            }
        });
        foreignKeys.forEach((foreignKey) => {
            const table = findByName(tables, foreignKey.name);
            if (table) {
                table.foreignKeys.push({
                    columnNames: foreignKey.columnNames,
                    refTableName: foreignKey.refTableName,
                    refColumnNames: foreignKey.refColumnNames,
                });
            }
        });
        return tables;
    }
    function createJsonFormat(canvasSize, database) {
        const canvas = createCanvasState();
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        canvas.database = database;
        return {
            canvas,
            table: createTableState(),
            memo: createMemoState(),
            relationship: createRelationshipState(),
        };
    }
    function createJson(statements, helper, database) {
        const shape = reshape(statements);
        const tables = mergeTable(shape);
        let canvasSize = tables.length * 100;
        if (canvasSize < SIZE_CANVAS_MIN) {
            canvasSize = SIZE_CANVAS_MIN;
        }
        if (canvasSize > SIZE_CANVAS_MAX) {
            canvasSize = SIZE_CANVAS_MAX;
        }
        const data = createJsonFormat(canvasSize, database);
        tables.forEach((table) => {
            data.table.tables.push(createTable$1(helper, table));
        });
        createRelationship(data, tables);
        createIndex$1(data, tables);
        return JSON.stringify(data);
    }
    function createTable$1(helper, table) {
        const newTable = {
            id: uuid(),
            name: table.name,
            comment: table.comment,
            columns: [],
            ui: {
                active: false,
                top: 0,
                left: 0,
                widthName: SIZE_MIN_WIDTH,
                widthComment: SIZE_MIN_WIDTH,
                zIndex: 2,
            },
        };
        const widthName = helper.getTextWidth(newTable.name);
        if (SIZE_MIN_WIDTH < widthName) {
            newTable.ui.widthName = widthName;
        }
        const widthComment = helper.getTextWidth(newTable.comment);
        if (SIZE_MIN_WIDTH < widthComment) {
            newTable.ui.widthComment = widthComment;
        }
        table.columns.forEach((column) => {
            newTable.columns.push(createColumn(helper, column));
        });
        return newTable;
    }
    function createColumn(helper, column) {
        const newColumn = {
            id: uuid(),
            name: column.name,
            comment: column.comment,
            dataType: column.dataType,
            default: column.default,
            option: {
                autoIncrement: column.autoIncrement,
                primaryKey: column.primaryKey,
                unique: column.unique,
                notNull: !column.nullable,
            },
            ui: {
                active: false,
                pk: column.primaryKey,
                fk: false,
                pfk: false,
                widthName: SIZE_MIN_WIDTH,
                widthComment: SIZE_MIN_WIDTH,
                widthDataType: SIZE_MIN_WIDTH,
                widthDefault: SIZE_MIN_WIDTH,
            },
        };
        const widthName = helper.getTextWidth(newColumn.name);
        if (SIZE_MIN_WIDTH < widthName) {
            newColumn.ui.widthName = widthName;
        }
        const widthComment = helper.getTextWidth(newColumn.comment);
        if (SIZE_MIN_WIDTH < widthComment) {
            newColumn.ui.widthComment = widthComment;
        }
        const widthDataType = helper.getTextWidth(newColumn.dataType);
        if (SIZE_MIN_WIDTH < widthDataType) {
            newColumn.ui.widthDataType = widthDataType;
        }
        const widthDefault = helper.getTextWidth(newColumn.default);
        if (SIZE_MIN_WIDTH < widthDefault) {
            newColumn.ui.widthDefault = widthDefault;
        }
        return newColumn;
    }
    function createRelationship(data, tables) {
        tables.forEach((table) => {
            if (table.foreignKeys) {
                const endTable = findByName(data.table.tables, table.name);
                if (endTable) {
                    table.foreignKeys.forEach((foreignKey) => {
                        const startTable = findByName(data.table.tables, foreignKey.refTableName);
                        if (startTable) {
                            const startColumns = [];
                            const endColumns = [];
                            foreignKey.refColumnNames.forEach((refColumnName) => {
                                const column = findByName(startTable.columns, refColumnName);
                                if (column) {
                                    startColumns.push(column);
                                }
                            });
                            foreignKey.columnNames.forEach((columnName) => {
                                const column = findByName(endTable.columns, columnName);
                                if (column) {
                                    endColumns.push(column);
                                    if (column.ui.pk) {
                                        column.ui.pk = false;
                                        column.ui.pfk = true;
                                    }
                                    else {
                                        column.ui.fk = true;
                                    }
                                }
                            });
                            data.relationship.relationships.push({
                                id: uuid(),
                                identification: !endColumns.some((column) => !column.ui.pfk),
                                relationshipType: "ZeroOneN",
                                start: {
                                    tableId: startTable.id,
                                    columnIds: startColumns.map((column) => column.id),
                                    x: 0,
                                    y: 0,
                                    direction: "top",
                                },
                                end: {
                                    tableId: endTable.id,
                                    columnIds: endColumns.map((column) => column.id),
                                    x: 0,
                                    y: 0,
                                    direction: "top",
                                },
                            });
                        }
                    });
                }
            }
        });
    }
    function createIndex$1(data, tables) {
        tables.forEach((table) => {
            if (table.indexes) {
                table.indexes.forEach((index) => {
                    const targetTable = findByName(data.table.tables, table.name);
                    if (targetTable) {
                        const indexColumns = [];
                        index.columns.forEach((column) => {
                            const targetColumn = findByName(targetTable.columns, column.name);
                            if (targetColumn) {
                                indexColumns.push({
                                    id: targetColumn.id,
                                    orderType: column.sort,
                                });
                            }
                        });
                        if (indexColumns.length !== 0) {
                            data.table.indexes.push({
                                id: uuid(),
                                name: index.name,
                                tableId: targetTable.id,
                                columns: indexColumns,
                                unique: index.unique,
                            });
                        }
                    }
                });
            }
        });
    }

    let exportFileCallback = null;
    function createJsonFormat$1(store) {
        const { canvasState, tableState, memoState, relationshipState } = store;
        return {
            canvas: canvasState,
            table: tableState,
            memo: memoState,
            relationship: relationshipState,
        };
    }
    function createJsonStringify(store, space) {
        return JSON.stringify(createJsonFormat$1(store), (key, value) => {
            if (key === "_show") {
                return undefined;
            }
            return value;
        }, space);
    }
    function exportPNG(root, selector, name) {
        const el = root.querySelector(selector);
        if (el) {
            domToImage.toBlob(el).then((blob) => {
                executeExport(blob, (name === null || name === void 0 ? void 0 : name.trim()) === ""
                    ? `autosql-${new Date().getFullYear()+""+new Date().getMonth()+""+new Date().getDate()+""+"_"+new Date().getHours()+""+new Date().getMinutes()+""+new Date().getSeconds()+""}_autosql.png`
                    : `${name}-${new Date().getFullYear()+""+new Date().getMonth()+""+new Date().getDate()+""+"_"+new Date().getHours()+""+new Date().getMinutes()+""+new Date().getSeconds()+""}_autosql.png`);
            });
        }
    }
    function exportJSON(json, name) {
        const blobJson = new Blob([json], { type: "application/json" });
        executeExport(blobJson, (name === null || name === void 0 ? void 0 : name.trim()) === ""
            ? `autosql-${new Date().getFullYear()+""+new Date().getMonth()+""+new Date().getDate()+""+"_"+new Date().getHours()+""+new Date().getMinutes()+""+new Date().getSeconds()+""}_autosql.json`
            : `${name}-${new Date().getFullYear()+""+new Date().getMonth()+""+new Date().getDate()+""+"_"+new Date().getHours()+""+new Date().getMinutes()+""+new Date().getSeconds()+""}_autosql.json`);
    }
    function exportSQLDDL(sql, name) {
        const blobSQL = new Blob([sql]);
        executeExport(blobSQL, (name === null || name === void 0 ? void 0 : name.trim()) === ""
            ? `autosql-${new Date().getFullYear()+""+new Date().getMonth()+""+new Date().getDate()+""+"_"+new Date().getHours()+""+new Date().getMinutes()+""+new Date().getSeconds()+""}_autosql.sql`
            : `${name}-${new Date().getFullYear()+""+new Date().getMonth()+""+new Date().getDate()+""+"_"+new Date().getHours()+""+new Date().getMinutes()+""+new Date().getSeconds()+""}_autosql.sql`);
    }
    function executeExport(blob, fileName) {
        if (exportFileCallback) {
            exportFileCallback(blob, fileName);
        }
        else {
            const exportHelper = document.createElement("a");
            exportHelper.href = window.URL.createObjectURL(blob);
            exportHelper.download = fileName;
            exportHelper.click();
        }
    }
    function setExportFileCallback(callback) {
        exportFileCallback = callback;
    }
    function importJSON(store) {
        const importHelperJSON = document.createElement("input");
        importHelperJSON.setAttribute("type", "file");
        importHelperJSON.setAttribute("accept", ".json");
        importHelperJSON.addEventListener("change", (event) => {
            const input = event.target;
            if (input.files) {
                const file = input.files[0];
                if (/\.(json)$/i.test(file.name)) {
                    const reader = new FileReader();
                    reader.readAsText(file);
                    reader.onload = () => {
                        const value = reader.result;
                        if (typeof value === "string") {
                            store.dispatch(loadJson(value));
                        }
                    };
                }
                else {
                    alert("Just upload the json file");
                }
            }
        });
        importHelperJSON.click();
    }
    function importSQL(context) {
        const { store, helper, eventBus } = context;
        const importHelperSQL = document.createElement("input");
        importHelperSQL.setAttribute("type", "file");
        importHelperSQL.setAttribute("accept", ".sql");
        importHelperSQL.addEventListener("change", (event) => {
            const input = event.target;
            if (input.files) {
                const file = input.files[0];
                if (/\.(sql)$/i.test(file.name)) {
                    const reader = new FileReader();
                    reader.readAsText(file);
                    reader.onload = () => {
                        const value = reader.result;
                        if (typeof value === "string") {
                            try {
                                const statements = DDLParser(value);
                                const json = createJson(statements, helper, store.canvasState.database);
                                store.dispatch(loadJson(json), sortTable());
                            }
                            catch (err) {
                                eventBus.emit(Bus.Editor.importErrorDDL, {
                                    message: err.message,
                                });
                            }
                        }
                    };
                }
                else {
                    alert("Just upload the sql file");
                }
            }
        });
        importHelperSQL.click();
    }

    function executeUndoCommand(store, undoManager, commands) {
        const batchUndoCommand = [];
        const batchRedoCommand = [];
        commands.forEach((command) => {
            if (/^table\./.test(command.type)) {
                executeTableCommand$1(store, command, batchUndoCommand, batchRedoCommand);
            }
            else if (/^column\./.test(command.type)) {
                executeColumnCommand$1(store, command, batchUndoCommand, batchRedoCommand);
            }
            else if (/^relationship\./.test(command.type)) {
                executeRelationshipCommand$1(store, command, batchUndoCommand, batchRedoCommand);
            }
            else if (/^memo\./.test(command.type)) {
                executeMemoCommand$1(store, command, batchUndoCommand, batchRedoCommand);
            }
            else if (/^canvas\./.test(command.type)) {
                executeCanvasCommand$1(store, command, batchUndoCommand, batchRedoCommand);
            }
            else if (/^editor\./.test(command.type)) {
                executeEditorCommand$1(store, command, batchUndoCommand, batchRedoCommand);
            }
        });
        const resizeMemoCommands = commands.filter((command) => command.type === "memo.resize");
        if (resizeMemoCommands.length > 1) {
            const undoCommand = resizeMemoCommands[0];
            const redoCommand = resizeMemoCommands[resizeMemoCommands.length - 1];
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(redoCommand);
        }
        const moveCanvasCommands = commands.filter((command) => command.type === "canvas.move");
        if (moveCanvasCommands.length === 1) {
            const { scrollTop, scrollLeft } = store.canvasState;
            const undoCommand = moveCanvasCommands[0];
            const redoCommand = moveCanvas(scrollTop, scrollLeft);
            if (Math.abs(undoCommand.data.scrollTop - scrollTop) +
                Math.abs(undoCommand.data.scrollLeft - scrollLeft) >
                50) {
                batchUndoCommand.push(undoCommand);
                batchRedoCommand.push(redoCommand);
            }
        }
        else if (moveCanvasCommands.length > 1) {
            const undoCommand = moveCanvasCommands[0];
            const redoCommand = moveCanvasCommands[moveCanvasCommands.length - 1];
            if (Math.abs(undoCommand.data.scrollTop - redoCommand.data.scrollTop) +
                Math.abs(undoCommand.data.scrollLeft - redoCommand.data.scrollLeft) >
                50) {
                batchUndoCommand.push(undoCommand);
                batchRedoCommand.push(redoCommand);
            }
        }
        const moveTableCommands = commands.filter((command) => command.type === "table.move");
        if (moveTableCommands.length > 0) {
            const data = moveTableCommands[0].data;
            const tableIds = data.tableIds;
            const memoIds = data.memoIds;
            let movementX = 0;
            let movementY = 0;
            moveTableCommands.forEach((moveTableCommand) => {
                const data = moveTableCommand.data;
                movementX += data.movementX;
                movementY += data.movementY;
            });
            const undoCommand = {
                type: "table.move",
                data: {
                    movementX: -1 * movementX,
                    movementY: -1 * movementY,
                    tableIds,
                    memoIds,
                },
            };
            const redoCommand = {
                type: "table.move",
                data: {
                    movementX,
                    movementY,
                    tableIds,
                    memoIds,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(redoCommand);
        }
        const moveMemoCommands = commands.filter((command) => command.type === "memo.move");
        if (moveMemoCommands.length > 0) {
            const data = moveMemoCommands[0].data;
            const tableIds = data.tableIds;
            const memoIds = data.memoIds;
            let movementX = 0;
            let movementY = 0;
            moveMemoCommands.forEach((moveTableCommand) => {
                const data = moveTableCommand.data;
                movementX += data.movementX;
                movementY += data.movementY;
            });
            const undoCommand = {
                type: "memo.move",
                data: {
                    movementX: -1 * movementX,
                    movementY: -1 * movementY,
                    tableIds,
                    memoIds,
                },
            };
            const redoCommand = {
                type: "memo.move",
                data: {
                    movementX,
                    movementY,
                    tableIds,
                    memoIds,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(redoCommand);
        }
        if (batchUndoCommand.length && batchRedoCommand.length) {
            undoManager.add({
                undo() {
                    store.undo$.next(batchUndoCommand);
                },
                redo() {
                    store.undo$.next(batchRedoCommand);
                },
            });
        }
    }
    function executeTableCommand$1(store, command, batchUndoCommand, batchRedoCommand) {
        const { tables, indexes } = store.tableState;
        const { relationships } = store.relationshipState;
        if (command.type === "table.add" || command.type === "table.addOnly") {
            const data = command.data;
            batchUndoCommand.push(removeTable(store, data.id));
            batchRedoCommand.push(command);
        }
        else if (command.type === "table.remove") {
            const data = command.data;
            const undoTables = [];
            const undoRelationships = [];
            const undoIndexes = [];
            data.tableIds.forEach((tableId) => {
                const table = getData(tables, tableId);
                if (table) {
                    undoTables.push(cloneDeep(table));
                    relationships.forEach((relationship) => {
                        const { start, end } = relationship;
                        if (tableId === start.tableId || tableId === end.tableId) {
                            undoRelationships.push(cloneDeep(relationship));
                        }
                    });
                    const tableIndexes = indexes.filter((index) => index.tableId === table.id);
                    tableIndexes.forEach((index) => {
                        undoIndexes.push(cloneDeep(index));
                    });
                }
            });
            undoTables.forEach((table) => batchUndoCommand.push(loadTable(table)));
            if (undoRelationships.length > 0) {
                batchUndoCommand.push(removeRelationship(undoRelationships.map((relationship) => relationship.id)));
                undoRelationships.forEach((relationship) => {
                    batchUndoCommand.push(loadRelationship(relationship));
                });
            }
            if (undoIndexes.length > 0) {
                batchUndoCommand.push(removeIndex(undoIndexes.map((index) => index.id)));
                undoIndexes.forEach((index) => {
                    batchUndoCommand.push(loadIndex(index));
                });
            }
            batchRedoCommand.push(command);
        }
        else if (command.type === "table.changeName") {
            const data = command.data;
            const table = getData(tables, data.tableId);
            if (table) {
                const undoCommand = {
                    type: "table.changeName",
                    data: {
                        tableId: data.tableId,
                        value: table.name,
                        width: table.ui.widthName,
                    },
                };
                batchUndoCommand.push(undoCommand);
                batchRedoCommand.push(command);
            }
        }
        else if (command.type === "table.changeComment") {
            const data = command.data;
            const table = getData(tables, data.tableId);
            if (table) {
                const undoCommand = {
                    type: "table.changeComment",
                    data: {
                        tableId: data.tableId,
                        value: table.comment,
                        width: table.ui.widthComment,
                    },
                };
                batchUndoCommand.push(undoCommand);
                batchRedoCommand.push(command);
            }
        }
        else if (command.type === "table.sort") {
            const undoCommand = {
                type: "editor.loadJson",
                data: {
                    value: createJsonStringify(store),
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
    }
    function executeColumnCommand$1(store, command, batchUndoCommand, batchRedoCommand) {
        const { tables, indexes } = store.tableState;
        const { relationships } = store.relationshipState;
        if (command.type === "column.add" || command.type === "column.addOnly") {
            const data = command.data;
            data.forEach((addColumn) => batchUndoCommand.push(removeColumn(addColumn.tableId, [addColumn.id])));
            batchRedoCommand.push(command);
        }
        else if (command.type === "column.addCustom") {
            const data = command.data;
            data.forEach((addColumn) => batchUndoCommand.push(removeColumn(addColumn.tableId, [addColumn.id])));
            batchRedoCommand.push(command);
        }
        else if (command.type === "column.remove") {
            const data = command.data;
            const undoRelationships = [];
            const undoIndexes = [];
            const table = getData(tables, data.tableId);
            if (table) {
                relationships.forEach((relationship) => {
                    const { start, end } = relationship;
                    if ((data.tableId === start.tableId &&
                        data.columnIds.some((columnId) => start.columnIds.some((id) => id === columnId))) ||
                        (data.tableId === end.tableId &&
                            data.columnIds.some((columnId) => end.columnIds.some((id) => id === columnId)))) {
                        undoRelationships.push(cloneDeep(relationship));
                    }
                });
                const tableIndexes = indexes.filter((index) => index.tableId === table.id);
                tableIndexes.forEach((index) => {
                    undoIndexes.push(cloneDeep(index));
                });
                const columns = [];
                const indexList = [];
                data.columnIds.forEach((columnId) => {
                    const column = getData(table.columns, columnId);
                    const index = getIndex(table.columns, columnId);
                    if (column && index !== null) {
                        columns.push(cloneDeep(column));
                        indexList.push(index);
                    }
                });
                batchUndoCommand.push(loadColumn(data.tableId, columns, indexList));
                if (undoRelationships.length > 0) {
                    batchUndoCommand.push(removeRelationship(undoRelationships.map((relationship) => relationship.id)));
                    undoRelationships.forEach((relationship) => {
                        batchUndoCommand.push(loadRelationship(relationship));
                    });
                }
                if (undoIndexes.length > 0) {
                    batchUndoCommand.push(removeIndex(undoIndexes.map((index) => index.id)));
                    undoIndexes.forEach((index) => {
                        batchUndoCommand.push(loadIndex(index));
                    });
                }
                batchRedoCommand.push(command);
            }
        }
        else if (command.type === "column.changeName") {
            const data = command.data;
            const column = getColumn(tables, data.tableId, data.columnId);
            if (column) {
                const undoCommand = {
                    type: "column.changeName",
                    data: {
                        tableId: data.tableId,
                        columnId: data.columnId,
                        value: column.name,
                        width: column.ui.widthName,
                    },
                };
                batchUndoCommand.push(undoCommand);
                batchRedoCommand.push(command);
            }
        }
        else if (command.type === "column.changeComment") {
            const data = command.data;
            const column = getColumn(tables, data.tableId, data.columnId);
            if (column) {
                const undoCommand = {
                    type: "column.changeComment",
                    data: {
                        tableId: data.tableId,
                        columnId: data.columnId,
                        value: column.comment,
                        width: column.ui.widthComment,
                    },
                };
                batchUndoCommand.push(undoCommand);
                batchRedoCommand.push(command);
            }
        }
        else if (command.type === "column.changeDataType") {
            const data = command.data;
            const column = getColumn(tables, data.tableId, data.columnId);
            if (column) {
                const undoCommand = {
                    type: "column.changeDataType",
                    data: {
                        tableId: data.tableId,
                        columnId: data.columnId,
                        value: column.dataType,
                        width: column.ui.widthDataType,
                    },
                };
                batchUndoCommand.push(undoCommand);
                batchRedoCommand.push(command);
            }
        }
        else if (command.type === "column.changeDefault") {
            const data = command.data;
            const column = getColumn(tables, data.tableId, data.columnId);
            if (column) {
                const undoCommand = {
                    type: "column.changeDefault",
                    data: {
                        tableId: data.tableId,
                        columnId: data.columnId,
                        value: column.default,
                        width: column.ui.widthDefault,
                    },
                };
                batchUndoCommand.push(undoCommand);
                batchRedoCommand.push(command);
            }
        }
        else if (command.type === "column.changeAutoIncrement") {
            const data = command.data;
            const undoCommand = {
                type: "column.changeAutoIncrement",
                data: {
                    tableId: data.tableId,
                    columnId: data.columnId,
                    value: !data.value,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
        else if (command.type === "column.changePrimaryKey") {
            const data = command.data;
            const undoCommand = {
                type: "column.changePrimaryKey",
                data: {
                    tableId: data.tableId,
                    columnId: data.columnId,
                    value: !data.value,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
        else if (command.type === "column.changeUnique") {
            const data = command.data;
            const undoCommand = {
                type: "column.changeUnique",
                data: {
                    tableId: data.tableId,
                    columnId: data.columnId,
                    value: !data.value,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
        else if (command.type === "column.changeNotNull") {
            const data = command.data;
            const undoCommand = {
                type: "column.changeNotNull",
                data: {
                    tableId: data.tableId,
                    columnId: data.columnId,
                    value: !data.value,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
        else if (command.type === "column.move") {
            const data = command.data;
            const currentTable = getData(tables, data.tableId);
            const currentColumns = [];
            data.columnIds.forEach((columnId) => {
                const column = getColumn(tables, data.tableId, columnId);
                if (column) {
                    currentColumns.push(column);
                }
            });
            const targetTable = getData(tables, data.targetTableId);
            const targetColumn = getColumn(tables, data.targetTableId, data.targetColumnId);
            if (currentTable &&
                targetTable &&
                currentColumns.length !== 0 &&
                targetColumn) {
                if (data.tableId === data.targetTableId &&
                    !data.columnIds.some((columnId) => columnId === data.targetColumnId)) {
                    const columns = [];
                    const indexList = [];
                    data.columnIds.forEach((columnId) => {
                        const column = getData(currentTable.columns, columnId);
                        const index = getIndex(currentTable.columns, columnId);
                        if (column && index !== null) {
                            columns.push(cloneDeep(column));
                            indexList.push(index);
                        }
                    });
                    batchUndoCommand.push(removeOnlyColumn(data.tableId, data.columnIds), loadColumn(data.tableId, columns, indexList));
                    batchRedoCommand.push(command);
                }
                else if (data.tableId !== data.targetTableId &&
                    !data.columnIds.some((columnId) => columnId === data.targetColumnId)) {
                    const undoRelationships = [];
                    const undoIndexes = [];
                    const columns = [];
                    const indexList = [];
                    data.columnIds.forEach((columnId) => {
                        const column = getData(currentTable.columns, columnId);
                        const index = getIndex(currentTable.columns, columnId);
                        if (column && index !== null) {
                            columns.push(cloneDeep(column));
                            indexList.push(index);
                        }
                    });
                    batchUndoCommand.push(removeOnlyColumn(data.targetTableId, data.columnIds), loadColumn(data.tableId, columns, indexList));
                    relationships.forEach((relationship) => {
                        const { start, end } = relationship;
                        if ((data.tableId === start.tableId &&
                            data.columnIds.some((columnId) => start.columnIds.some((id) => id === columnId))) ||
                            (data.tableId === end.tableId &&
                                data.columnIds.some((columnId) => end.columnIds.some((id) => id === columnId)))) {
                            undoRelationships.push(cloneDeep(relationship));
                        }
                    });
                    const tableIndexes = indexes.filter((index) => index.tableId === data.tableId);
                    tableIndexes.forEach((index) => {
                        undoIndexes.push(cloneDeep(index));
                    });
                    if (undoRelationships.length > 0) {
                        batchUndoCommand.push(removeRelationship(undoRelationships.map((relationship) => relationship.id)));
                        undoRelationships.forEach((relationship) => {
                            batchUndoCommand.push(loadRelationship(relationship));
                        });
                    }
                    if (undoIndexes.length > 0) {
                        batchUndoCommand.push(removeIndex(undoIndexes.map((index) => index.id)));
                        undoIndexes.forEach((index) => {
                            batchUndoCommand.push(loadIndex(index));
                        });
                    }
                    batchRedoCommand.push(command);
                }
            }
        }
    }
    function executeRelationshipCommand$1(store, command, batchUndoCommand, batchRedoCommand) {
        const { relationships } = store.relationshipState;
        if (command.type === "relationship.add") {
            const data = command.data;
            batchUndoCommand.push(removeRelationship([data.id]));
            batchRedoCommand.push(command);
        }
        else if (command.type === "relationship.remove") {
            const data = command.data;
            data.relationshipIds.forEach((relationshipId) => {
                const relationship = getData(relationships, relationshipId);
                if (relationship) {
                    batchUndoCommand.push(loadRelationship(cloneDeep(relationship)));
                }
            });
            batchRedoCommand.push(command);
        }
        else if (command.type === "relationship.changeRelationshipType") {
            const data = command.data;
            const relationship = getData(relationships, data.relationshipId);
            if (relationship) {
                const undoCommand = {
                    type: "relationship.changeRelationshipType",
                    data: {
                        relationshipId: data.relationshipId,
                        relationshipType: relationship.relationshipType,
                    },
                };
                batchUndoCommand.push(undoCommand);
                batchRedoCommand.push(command);
            }
        }
        else if (command.type === "relationship.changeIdentification") {
            const data = command.data;
            const undoCommand = {
                type: "relationship.changeIdentification",
                data: {
                    relationshipId: data.relationshipId,
                    identification: !data.identification,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
    }
    function executeMemoCommand$1(store, command, batchUndoCommand, batchRedoCommand) {
        const { memos } = store.memoState;
        if (command.type === "memo.add" || command.type === "memo.addOnly") {
            const data = command.data;
            batchUndoCommand.push(removeMemo(store, data.id));
            batchRedoCommand.push(command);
        }
        else if (command.type === "memo.remove") {
            const data = command.data;
            data.memoIds.forEach((memoId) => {
                const memo = getData(memos, memoId);
                if (memo) {
                    batchUndoCommand.push(loadMemo(cloneDeep(memo)));
                }
            });
            batchRedoCommand.push(command);
        }
        else if (command.type === "memo.changeValue") {
            const data = command.data;
            const memo = getData(memos, data.memoId);
            if (memo) {
                const undoCommand = {
                    type: "memo.changeValue",
                    data: {
                        memoId: data.memoId,
                        value: memo.value,
                    },
                };
                batchUndoCommand.push(undoCommand);
                batchRedoCommand.push(command);
            }
        }
    }
    function executeCanvasCommand$1(store, command, batchUndoCommand, batchRedoCommand) {
        const { width, height, database, databaseName } = store.canvasState;
        if (command.type === "canvas.resize") {
            const undoCommand = {
                type: "canvas.resize",
                data: {
                    width,
                    height,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
        else if (command.type === "canvas.changeShow") {
            const data = command.data;
            const undoCommand = {
                type: "canvas.changeShow",
                data: {
                    showKey: data.showKey,
                    value: !data.value,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
        else if (command.type === "canvas.changeDatabase") {
            const undoCommand = {
                type: "canvas.changeDatabase",
                data: {
                    database,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
        else if (command.type === "canvas.changeDatabaseName") {
            const undoCommand = {
                type: "canvas.changeDatabaseName",
                data: {
                    value: databaseName,
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
    }
    function executeEditorCommand$1(store, command, batchUndoCommand, batchRedoCommand) {
        if (command.type === "editor.loadJson") {
            const undoCommand = {
                type: "editor.loadJson",
                data: {
                    value: createJsonStringify(store),
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
        else if (command.type === "editor.clear") {
            const undoCommand = {
                type: "editor.loadJson",
                data: {
                    value: createJsonStringify(store),
                },
            };
            batchUndoCommand.push(undoCommand);
            batchRedoCommand.push(command);
        }
    }

    function executeShareCommand$1(commands, user) {
        const shareCommands = [];
        commands.forEach((command) => {
            if (command.type === "table.add") {
                const data = cloneDeep(command.data);
                data.ui.active = false;
                shareCommands.push({
                    type: "table.addOnly",
                    data,
                    user: Object.assign({}, user),
                });
            }
            else if (command.type === "memo.add") {
                const data = cloneDeep(command.data);
                data.ui.active = false;
                shareCommands.push({
                    type: "memo.addOnly",
                    data,
                    user: Object.assign({}, user),
                });
            }
            else if (command.type === "column.add") {
                shareCommands.push({
                    type: "column.addOnly",
                    data: command.data,
                    user: Object.assign({}, user),
                });
            }
            else {
                shareCommands.push({
                    type: command.type,
                    data: command.data,
                    user: Object.assign({}, user),
                });
            }
        });
        return shareCommands;
    }

    class Store {
        constructor() {
            this.dispatch$ = new Subject();
            this.undo$ = new Subject();
            this.user = {
                id: uuid(),
                name: "user",
            };
            this.subscriptionList = [];
            this.excludeKeys = [
                "_store",
                "_subscriptionList",
                "_timeoutID",
                "_currentFocusColumn",
                "_currentFilterState",
                "focusColumns",
                "focusFilterStateList",
            ];
            this.hasUndoRedo = () => {
                this.dispatch(hasUndoRedo(this.undoManager.hasUndo, this.undoManager.hasRedo));
            };
            this.canvasState = createObservable(createCanvasState(), this.excludeKeys);
            this.tableState = createObservable(createTableState(), this.excludeKeys);
            this.memoState = createObservable(createMemoState(), this.excludeKeys);
            this.relationshipState = createObservable(createRelationshipState(), this.excludeKeys);
            this.editorState = createObservable(createEditorState(), this.excludeKeys);
            this.shareState = createObservable(createShareState(), this.excludeKeys);
            this.undoManager = new UndoManager(this.hasUndoRedo);
            this.subscriptionList.push(this.undo$.subscribe((commands) => executeCommand(this, commands)), this.dispatch$
                .pipe(filter((commands) => this.editorState.undoManager &&
                    commands.some((command) => undoCommandTypes.some((commandType) => commandType === command.type)) &&
                    (commands.some((command) => command.user === undefined) ||
                        commands.some((command) => { var _a; return ((_a = command.user) === null || _a === void 0 ? void 0 : _a.id) !== this.user.id; }))), groupBy((commands) => commands.some((command) => streamCommandTypes.some((commandType) => commandType === command.type))), mergeMap((group$) => group$.key
                    ? group$.pipe(buffer(group$.pipe(debounceTime(200))), map((buff) => buff.reduce((acc, current) => {
                        acc.push(...current);
                        return acc;
                    })))
                    : group$))
                .subscribe((commands) => executeUndoCommand(this, this.undoManager, commands)), this.dispatch$
                .pipe(filter((commands) => commands.some((command) => command.user === undefined) ||
                    commands.some((command) => { var _a; return ((_a = command.user) === null || _a === void 0 ? void 0 : _a.id) !== this.user.id; })))
                .subscribe((commands) => executeCommand(this, commands)));
            this.change$ = merge(this.undo$, this.dispatch$.pipe(filter((commands) => commands.some((command) => changeCommandTypes.some((commandType) => commandType === command.type))))).pipe(debounceTime(200));
            this.share$ = this.dispatch$.pipe(filter((commands) => commands.some((command) => command.user === undefined) &&
                commands.some((command) => shareCommandTypes.some((commandType) => commandType === command.type))), map((commands) => {
                const shareCommands = [];
                commands.forEach((command) => {
                    if (shareCommandTypes.some((commandType) => commandType === command.type)) {
                        shareCommands.push(command);
                    }
                });
                return shareCommands;
            }), map((commands) => executeShareCommand$1(commands, this.user)));
        }
        dispatch(...commands) {
            asapScheduler.schedule(() => this.dispatch$.next(commands));
        }
        destroy() {
            this.subscriptionList.forEach((sub) => sub.unsubscribe());
            this.undoManager.clear();
        }
        observe(proxy, observer) {
            return observeLegacy(proxy, observer);
        }
        undo() {
            if (this.undoManager.hasUndo && this.editorState.undoManager) {
                this.dispatch(focusTableEnd$1());
                this.undoManager.undo();
            }
        }
        redo() {
            if (this.undoManager.hasRedo && this.editorState.undoManager) {
                this.dispatch(focusTableEnd$1());
                this.undoManager.redo();
            }
        }
    }

    function createEditorContext() {
        return {
            windowEventObservable: createWindowEventObservable(),
            eventBus: new EventBus(),
            theme: createTheme(),
            keymap: createKeymap(),
            store: new Store(),
            helper: new Helper(),
        };
    }

    function formatNames(list, backtick, backtick2) {
        const buf = [];
        list.forEach((v, i) => {
            if (backtick) {
                if (backtick2) {
                    buf.push(`${backtick}${v.name}${backtick2}`);
                }
                else {
                    buf.push(`${backtick}${v.name}${backtick}`);
                }
            }
            else {
                buf.push(v.name);
            }
            if (list.length !== i + 1) {
                buf.push(", ");
            }
        });
        return buf.join("");
    }
    function formatSize(columns) {
        let name = 0;
        let dataType = 0;
        columns.forEach((column) => {
            if (name < column.name.length) {
                name = column.name.length;
            }
            if (dataType < column.dataType.length) {
                dataType = column.dataType.length;
            }
        });
        return {
            name,
            dataType,
        };
    }
    function formatSpace(size) {
        const buf = [];
        for (let i = 0; i < size; i++) {
            buf.push(" ");
        }
        return buf.join("");
    }
    function primaryKey(columns) {
        return columns.some((column) => column.option.primaryKey);
    }
    function primaryKeyColumns(columns) {
        return columns.filter((column) => column.option.primaryKey);
    }
    function unique(columns) {
        return columns.some((column) => column.option.unique);
    }
    function uniqueColumns(columns) {
        return columns.filter((column) => column.option.unique);
    }

    function createDDL(store) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [""];
        const tables = orderByNameASC(store.tableState.tables);
        const relationships = store.relationshipState.relationships;
        const indexes = store.tableState.indexes;
        tables.forEach((table) => {
            formatTable(table, stringBuffer);
            stringBuffer.push("");
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach((column) => {
                    stringBuffer.push(`ALTER TABLE ${table.name}`);
                    stringBuffer.push(`  ADD CONSTRAINT UQ_${column.name} UNIQUE (${column.name});`);
                    stringBuffer.push("");
                });
            }
        });
        relationships.forEach((relationship) => {
            formatRelation(tables, relationship, stringBuffer, fkNames);
            stringBuffer.push("");
        });
        indexes.forEach((index) => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex(table, index, stringBuffer, indexNames);
                stringBuffer.push("");
            }
        });
        return stringBuffer.join("\n");
    }
    function formatTable(table, buffer) {
        buffer.push(`CREATE TABLE ${table.name}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn(column, true, spaceSize, buffer);
            }
            else {
                formatColumn(column, table.columns.length !== i + 1, spaceSize, buffer);
            }
        });
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  PRIMARY KEY (${formatNames(pkColumns)})`);
        }
        if (table.comment.trim() === "") {
            buffer.push(`);`);
        }
        else {
            buffer.push(`) COMMENT '${table.comment}';`);
        }
    }
    function formatColumn(column, isComma, spaceSize, buffer) {
        const stringBuffer = [];
        stringBuffer.push(`  ${column.name}` + formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        stringBuffer.push(`${column.option.notNull ? "NOT NULL" : "NULL    "}`);
        if (column.option.autoIncrement) {
            stringBuffer.push(`AUTO_INCREMENT`);
        }
        else {
            if (column.default.trim() !== "") {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        if (column.comment.trim() !== "") {
            stringBuffer.push(`COMMENT '${column.comment}'`);
        }
        buffer.push(stringBuffer.join(" ") + `${isComma ? "," : ""}`);
    }
    function formatRelation(tables, relationship, buffer, fkNames) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${endTable.name}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, "", fkName);
            fkNames.push({
                id: uuid(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${fkName}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach((columnId) => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach((columnId) => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end)})`);
            buffer.push(`    REFERENCES ${startTable.name} (${formatNames(columns.start)});`);
        }
    }
    function formatIndex(table, index, buffer, indexNames) {
        const columnNames = index.columns
            .map((indexColumn) => {
                const column = getData(table.columns, indexColumn.id);
                if (column) {
                    return {
                        name: `${column.name} ${indexColumn.orderType}`,
                    };
                }
                return null;
            })
            .filter((columnName) => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === "") {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, "", indexName);
                indexNames.push({
                    id: uuid(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${indexName}`);
            }
            else {
                buffer.push(`CREATE INDEX ${indexName}`);
            }
            buffer.push(`  ON ${table.name} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$1(store) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [""];
        const tables = orderByNameASC(store.tableState.tables);
        const relationships = store.relationshipState.relationships;
        const indexes = store.tableState.indexes;
        tables.forEach((table) => {
            formatTable$1(table, stringBuffer);
            stringBuffer.push("");
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach((column) => {
                    stringBuffer.push(`ALTER TABLE ${table.name}`);
                    stringBuffer.push(`  ADD CONSTRAINT UQ_${column.name} UNIQUE (${column.name})\nGO`);
                    stringBuffer.push("");
                });
            }
            formatComment(table, stringBuffer);
        });
        relationships.forEach((relationship) => {
            formatRelation$1(tables, relationship, stringBuffer, fkNames);
            stringBuffer.push("");
        });
        indexes.forEach((index) => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$1(table, index, stringBuffer, indexNames);
                stringBuffer.push("");
            }
        });
        return stringBuffer.join("\n");
    }
    function formatTable$1(table, buffer) {
        buffer.push(`CREATE TABLE ${table.name}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$1(column, true, spaceSize, buffer);
            }
            else {
                formatColumn$1(column, table.columns.length !== i + 1, spaceSize, buffer);
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  CONSTRAINT PK_${table.name} PRIMARY KEY (${formatNames(pkColumns)})`);
        }
        buffer.push(`)\nGO`);
    }
    function formatColumn$1(column, isComma, spaceSize, buffer) {
        const stringBuffer = [];
        stringBuffer.push(`  ${column.name}` + formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        if (column.option.notNull) {
            stringBuffer.push(`NOT NULL`);
        }
        if (column.option.autoIncrement) {
            stringBuffer.push(`IDENTITY(1,1)`);
        }
        else {
            if (column.default.trim() !== "") {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        buffer.push(stringBuffer.join(" ") + `${isComma ? "," : ""}`);
    }
    function formatComment(table, buffer) {
        if (table.comment.trim() !== "") {
            buffer.push(`EXECUTE sys.sp_addextendedproperty 'MS_Description',`);
            buffer.push(`  '${table.comment}', 'user', dbo, 'table', '${table.name}'\nGO`);
            buffer.push("");
        }
        table.columns.forEach((column) => {
            if (column.comment.trim() !== "") {
                buffer.push(`EXECUTE sys.sp_addextendedproperty 'MS_Description',`);
                buffer.push(`  '${column.comment}', 'user', dbo, 'table', '${table.name}', 'column', '${column.name}'\nGO`);
                buffer.push("");
            }
        });
    }
    function formatRelation$1(tables, relationship, buffer, fkNames) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${endTable.name}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, "", fkName);
            fkNames.push({
                id: uuid(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${fkName}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach((columnId) => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach((columnId) => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end)})`);
            buffer.push(`    REFERENCES ${startTable.name} (${formatNames(columns.start)})\nGO`);
        }
    }
    function formatIndex$1(table, index, buffer, indexNames) {
        const columnNames = index.columns
            .map((indexColumn) => {
                const column = getData(table.columns, indexColumn.id);
                if (column) {
                    return {
                        name: `${column.name} ${indexColumn.orderType}`,
                    };
                }
                return null;
            })
            .filter((columnName) => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (indexName.trim() === "") {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, "", indexName);
                indexNames.push({
                    id: uuid(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${indexName}`);
            }
            else {
                buffer.push(`CREATE INDEX ${indexName}`);
            }
            buffer.push(`  ON ${table.name} (${formatNames(columnNames)})\nGO`);
        }
    }

    function createDDL$2(store) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [""];
        const tables = orderByNameASC(store.tableState.tables);
        const relationships = store.relationshipState.relationships;
        const indexes = store.tableState.indexes;
        tables.forEach((table) => {
            formatTable$2(table, stringBuffer);
            stringBuffer.push("");
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach((column) => {
                    stringBuffer.push(`ALTER TABLE ${table.name}`);
                    stringBuffer.push(`  ADD CONSTRAINT UQ_${column.name} UNIQUE (${column.name});`);
                    stringBuffer.push("");
                });
            }
        });
        relationships.forEach((relationship) => {
            formatRelation$2(tables, relationship, stringBuffer, fkNames);
            stringBuffer.push("");
        });
        indexes.forEach((index) => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$2(table, index, stringBuffer, indexNames);
                stringBuffer.push("");
            }
        });
        return stringBuffer.join("\n");
    }
    function formatTable$2(table, buffer) {
        buffer.push(`CREATE TABLE ${table.name}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$2(column, true, spaceSize, buffer);
            }
            else {
                formatColumn$2(column, table.columns.length !== i + 1, spaceSize, buffer);
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  PRIMARY KEY (${formatNames(pkColumns)})`);
        }
        if (table.comment.trim() === "") {
            buffer.push(`);`);
        }
        else {
            buffer.push(`) COMMENT '${table.comment}';`);
        }
    }
    function formatColumn$2(column, isComma, spaceSize, buffer) {
        const stringBuffer = [];
        stringBuffer.push(`  ${column.name}` + formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        stringBuffer.push(`${column.option.notNull ? "NOT NULL" : "NULL    "}`);
        if (column.option.autoIncrement) {
            stringBuffer.push(`AUTO_INCREMENT`);
        }
        else {
            if (column.default.trim() !== "") {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        if (column.comment.trim() !== "") {
            stringBuffer.push(`COMMENT '${column.comment}'`);
        }
        buffer.push(stringBuffer.join(" ") + `${isComma ? "," : ""}`);
    }
    function formatRelation$2(tables, relationship, buffer, fkNames) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${endTable.name}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, "", fkName);
            fkNames.push({
                id: uuid(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${fkName}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach((columnId) => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach((columnId) => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end)})`);
            buffer.push(`    REFERENCES ${startTable.name} (${formatNames(columns.start)});`);
        }
    }
    function formatIndex$2(table, index, buffer, indexNames) {
        const columnNames = index.columns
            .map((indexColumn) => {
                const column = getData(table.columns, indexColumn.id);
                if (column) {
                    return {
                        name: `${column.name} ${indexColumn.orderType}`,
                    };
                }
                return null;
            })
            .filter((columnName) => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === "") {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, "", indexName);
                indexNames.push({
                    id: uuid(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${indexName}`);
            }
            else {
                buffer.push(`CREATE INDEX ${indexName}`);
            }
            buffer.push(`  ON ${table.name} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$3(store) {
        const fkNames = [];
        const aiNames = [];
        const trgNames = [];
        const indexNames = [];
        const stringBuffer = [""];
        const tables = orderByNameASC(store.tableState.tables);
        const relationships = store.relationshipState.relationships;
        const indexes = store.tableState.indexes;
        tables.forEach((table) => {
            formatTable$3(table, stringBuffer);
            stringBuffer.push("");
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach((column) => {
                    stringBuffer.push(`ALTER TABLE ${table.name}`);
                    stringBuffer.push(`  ADD CONSTRAINT UQ_${column.name} UNIQUE (${column.name});`);
                    stringBuffer.push("");
                });
            }
            // Sequence
            table.columns.forEach((column) => {
                if (column.option.autoIncrement) {
                    let aiName = `SEQ_${table.name}`;
                    aiName = autoName(aiNames, "", aiName);
                    aiNames.push({
                        id: uuid(),
                        name: aiName,
                    });
                    stringBuffer.push(`CREATE SEQUENCE ${aiName}`);
                    stringBuffer.push(`START WITH 1`);
                    stringBuffer.push(`INCREMENT BY 1;`);
                    stringBuffer.push("");
                    let trgName = `SEQ_TRG_${table.name}`;
                    trgName = autoName(aiNames, "", trgName);
                    trgNames.push({
                        id: uuid(),
                        name: trgName,
                    });
                    stringBuffer.push(`CREATE OR REPLACE TRIGGER ${trgName}`);
                    stringBuffer.push(`BEFORE INSERT ON ${table.name}`);
                    stringBuffer.push(`REFERENCING NEW AS NEW FOR EACH ROW`);
                    stringBuffer.push(`BEGIN`);
                    stringBuffer.push(`  SELECT ${aiName}.NEXTVAL`);
                    stringBuffer.push(`  INTO: NEW.${column.name}`);
                    stringBuffer.push(`  FROM DUAL;`);
                    stringBuffer.push(`END;`);
                    stringBuffer.push("");
                }
            });
            formatComment$1(table, stringBuffer);
        });
        relationships.forEach((relationship) => {
            formatRelation$3(tables, relationship, stringBuffer, fkNames);
            stringBuffer.push("");
        });
        indexes.forEach((index) => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$3(table, index, stringBuffer, indexNames);
                stringBuffer.push("");
            }
        });
        return stringBuffer.join("\n");
    }
    function formatTable$3(table, buffer) {
        buffer.push(`CREATE TABLE ${table.name}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$3(column, true, spaceSize, buffer);
            }
            else {
                formatColumn$3(column, table.columns.length !== i + 1, spaceSize, buffer);
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  CONSTRAINT PK_${table.name} PRIMARY KEY (${formatNames(pkColumns)})`);
        }
        buffer.push(`);`);
    }
    function formatColumn$3(column, isComma, spaceSize, buffer) {
        const stringBuffer = [];
        stringBuffer.push(`  ${column.name}` + formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        if (column.default.trim() !== "") {
            stringBuffer.push(`DEFAULT ${column.default}`);
        }
        if (column.option.notNull) {
            stringBuffer.push(`NOT NULL`);
        }
        buffer.push(stringBuffer.join(" ") + `${isComma ? "," : ""}`);
    }
    function formatComment$1(table, buffer) {
        if (table.comment.trim() !== "") {
            buffer.push(`COMMENT ON TABLE ${table.name} IS '${table.comment}';`);
            buffer.push("");
        }
        table.columns.forEach((column) => {
            if (column.comment.trim() !== "") {
                buffer.push(`COMMENT ON COLUMN ${table.name}.${column.name} IS '${column.comment}';`);
                buffer.push("");
            }
        });
    }
    function formatRelation$3(tables, relationship, buffer, fkNames) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${endTable.name}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, "", fkName);
            fkNames.push({
                id: uuid(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${fkName}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach((columnId) => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach((columnId) => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end)})`);
            buffer.push(`    REFERENCES ${startTable.name} (${formatNames(columns.start)});`);
        }
    }
    function formatIndex$3(table, index, buffer, indexNames) {
        const columnNames = index.columns
            .map((indexColumn) => {
                const column = getData(table.columns, indexColumn.id);
                if (column) {
                    return {
                        name: `${column.name} ${indexColumn.orderType}`,
                    };
                }
                return null;
            })
            .filter((columnName) => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === "") {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, "", indexName);
                indexNames.push({
                    id: uuid(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${indexName}`);
            }
            else {
                buffer.push(`CREATE INDEX ${indexName}`);
            }
            buffer.push(`  ON ${table.name} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$4(store) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [""];
        const tables = orderByNameASC(store.tableState.tables);
        const relationships = store.relationshipState.relationships;
        const indexes = store.tableState.indexes;
        tables.forEach((table) => {
            formatTable$4(table, stringBuffer);
            stringBuffer.push("");
            formatComment$2(table, stringBuffer);
        });
        relationships.forEach((relationship) => {
            formatRelation$4(tables, relationship, stringBuffer, fkNames);
            stringBuffer.push("");
        });
        indexes.forEach((index) => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$4(table, index, stringBuffer, indexNames);
                stringBuffer.push("");
            }
        });
        return stringBuffer.join("\n");
    }
    function formatTable$4(table, buffer) {
        buffer.push(`CREATE TABLE ${table.name}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$4(column, true, spaceSize, buffer);
            }
            else {
                formatColumn$4(column, table.columns.length !== i + 1, spaceSize, buffer);
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  PRIMARY KEY (${formatNames(pkColumns)})`);
        }
        buffer.push(`);`);
    }
    function formatColumn$4(column, isComma, spaceSize, buffer) {
        const stringBuffer = [];
        stringBuffer.push(`  ${column.name}` + formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        if (column.option.notNull) {
            stringBuffer.push(`NOT NULL`);
        }
        if (column.option.unique) {
            stringBuffer.push(`UNIQUE`);
        }
        else {
            if (column.default.trim() !== "") {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        buffer.push(stringBuffer.join(" ") + `${isComma ? "," : ""}`);
    }
    function formatComment$2(table, buffer) {
        if (table.comment.trim() !== "") {
            buffer.push(`COMMENT ON TABLE ${table.name} IS '${table.comment}';`);
            buffer.push("");
        }
        table.columns.forEach((column) => {
            if (column.comment.trim() !== "") {
                buffer.push(`COMMENT ON COLUMN ${table.name}.${column.name} IS '${column.comment}';`);
                buffer.push("");
            }
        });
    }
    function formatRelation$4(tables, relationship, buffer, fkNames) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${endTable.name}`);
            // FK  
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, "", fkName);
            fkNames.push({
                id: uuid(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${fkName}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach((columnId) => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach((columnId) => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end)})`);
            buffer.push(`    REFERENCES ${startTable.name} (${formatNames(columns.start)});`);
        }
    }
    function formatIndex$4(table, index, buffer, indexNames) {
        const columnNames = index.columns
            .map((indexColumn) => {
                const column = getData(table.columns, indexColumn.id);
                if (column) {
                    return {
                        name: `${column.name} ${indexColumn.orderType}`,
                    };
                }
                return null;
            })
            .filter((columnName) => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === "") {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, "", indexName);
                indexNames.push({
                    id: uuid(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${indexName}`);
            }
            else {
                buffer.push(`CREATE INDEX ${indexName}`);
            }
            buffer.push(`  ON ${table.name} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$5(store) {
        const indexNames = [];
        const stringBuffer = [""];
        const relationships = store.relationshipState.relationships;
        const indexes = store.tableState.indexes;
        const tables = orderByRelationship(orderByNameASC(store.tableState.tables), relationships);
        tables.forEach((table) => {
            formatTable$5(table, tables, relationships.filter((relationship) => relationship.end.tableId === table.id), stringBuffer);
            stringBuffer.push("");
        });
        indexes.forEach((index) => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$5(table, index, stringBuffer, indexNames);
                stringBuffer.push("");
            }
        });
        return stringBuffer.join("\n");
    }
    function formatTable$5(table, tables, relationships, buffer) {
        if (table.comment.trim() !== "") {
            buffer.push(`-- ${table.comment}`);
        }
        buffer.push(`CREATE TABLE ${table.name}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk || relationships.length !== 0) {
                formatColumn$5(column, true, spaceSize, buffer);
            }
            else {
                formatColumn$5(column, table.columns.length !== i + 1, spaceSize, buffer);
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            if (relationships.length !== 0) {
                if (pkColumns.length === 1) {
                    const autoIncrement = pkColumns[0].option.autoIncrement
                        ? " AUTOINCREMENT"
                        : "";
                    buffer.push(`  PRIMARY KEY (${formatNames(pkColumns)}${autoIncrement}),`);
                }
                else {
                    buffer.push(`  PRIMARY KEY (${formatNames(pkColumns)}),`);
                }
            }
            else {
                if (pkColumns.length === 1) {
                    const autoIncrement = pkColumns[0].option.autoIncrement
                        ? " AUTOINCREMENT"
                        : "";
                    buffer.push(`  PRIMARY KEY (${formatNames(pkColumns)}${autoIncrement})`);
                }
                else {
                    buffer.push(`  PRIMARY KEY (${formatNames(pkColumns)})`);
                }
            }
        }
        relationships.forEach((relationship, i) => {
            const startTable = getData(tables, relationship.start.tableId);
            const endTable = getData(tables, relationship.end.tableId);
            if (startTable && endTable) {
                // key
                const columns = {
                    start: [],
                    end: [],
                };
                relationship.end.columnIds.forEach((columnId) => {
                    const column = getData(endTable.columns, columnId);
                    if (column) {
                        columns.end.push(column);
                    }
                });
                relationship.start.columnIds.forEach((columnId) => {
                    const column = getData(startTable.columns, columnId);
                    if (column) {
                        columns.start.push(column);
                    }
                });
                if (relationships.length - 1 > i) {
                    buffer.push(`  FOREIGN KEY (${formatNames(columns.end)}) REFERENCES ${startTable.name} (${formatNames(columns.start)}),`);
                }
                else {
                    buffer.push(`  FOREIGN KEY (${formatNames(columns.end)}) REFERENCES ${startTable.name} (${formatNames(columns.start)})`);
                }
            }
        });
        buffer.push(`);`);
    }
    function formatColumn$5(column, isComma, spaceSize, buffer) {
        if (column.comment.trim() !== "") {
            buffer.push(`  -- ${column.comment}`);
        }
        const stringBuffer = [];
        stringBuffer.push(`  ${column.name}` + formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        stringBuffer.push(`${column.option.notNull ? "NOT NULL" : "NULL    "}`);
        if (column.option.unique) {
            stringBuffer.push(`UNIQUE`);
        }
        if (!column.option.autoIncrement && column.default.trim() !== "") {
            stringBuffer.push(`DEFAULT ${column.default}`);
        }
        buffer.push(stringBuffer.join(" ") + `${isComma ? "," : ""}`);
    }
    function formatIndex$5(table, index, buffer, indexNames) {
        const columnNames = index.columns
            .map((indexColumn) => {
                const column = getData(table.columns, indexColumn.id);
                if (column) {
                    return {
                        name: `${column.name} ${indexColumn.orderType}`,
                    };
                }
                return null;
            })
            .filter((columnName) => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === "") {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, "", indexName);
                indexNames.push({
                    id: uuid(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${indexName}`);
            }
            else {
                buffer.push(`CREATE INDEX ${indexName}`);
            }
            buffer.push(`  ON ${table.name} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$6(store, database) {
        const currentDatabase = database ? database : store.canvasState.database;
        switch (currentDatabase) {
            case "MariaDB":
                return createDDL(store);
            case "MSSQL":
                return createDDL$1(store);
            case "MySQL":
                return createDDL$2(store);
            case "Oracle":
                return createDDL$3(store);
            case "PostgreSQL":
                return createDDL$4(store);
            case "SQLite":
                return createDDL$5(store);
        }
        return "";
    }
    function createDDLTable(store, table) {
        const stringBuffer = [""];
        const database = store.canvasState.database;
        const indexNames = [];
        const indexes = store.tableState.indexes.filter((index) => index.tableId === table.id);
        const relationships = store.relationshipState.relationships;
        const tables = store.tableState.tables;
        switch (database) {
            case "MariaDB":
                formatTable(table, stringBuffer);
                stringBuffer.push("");
                indexes.forEach((index) => {
                    formatIndex(table, index, stringBuffer, indexNames);
                    stringBuffer.push("");
                });
                break;
            case "MSSQL":
                formatTable$1(table, stringBuffer);
                stringBuffer.push("");
                indexes.forEach((index) => {
                    formatIndex$1(table, index, stringBuffer, indexNames);
                    stringBuffer.push("");
                });
                break;
            case "MySQL":
                formatTable$2(table, stringBuffer);
                stringBuffer.push("");
                indexes.forEach((index) => {
                    formatIndex$2(table, index, stringBuffer, indexNames);
                    stringBuffer.push("");
                });
                break;
            case "Oracle":
                formatTable$3(table, stringBuffer);
                stringBuffer.push("");
                indexes.forEach((index) => {
                    formatIndex$3(table, index, stringBuffer, indexNames);
                    stringBuffer.push("");
                });
                break;
            case "PostgreSQL":
                formatTable$4(table, stringBuffer);
                stringBuffer.push("");
                indexes.forEach((index) => {
                    formatIndex$4(table, index, stringBuffer, indexNames);
                    stringBuffer.push("");
                });
                break;
            case "SQLite":
                formatTable$5(table, tables, relationships.filter((relationship) => relationship.end.tableId === table.id), stringBuffer);
                stringBuffer.push("");
                indexes.forEach((index) => {
                    formatIndex$5(table, index, stringBuffer, indexNames);
                    stringBuffer.push("");
                });
                break;
        }
        return stringBuffer.join("\n");
    }

    /*!
     * Font Awesome Free 5.15.1 by @fontawesome - https://fontawesome.com
     * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
     */
    var faCheck = {
        prefix: 'fas',
        iconName: 'check',
        icon: [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"]
    };
    var faChevronRight = {
        prefix: 'fas',
        iconName: 'chevron-right',
        icon: [320, 512, [], "f054", "M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"]
    };
    var faCode = {
        prefix: 'fas',
        iconName: 'code',
        icon: [640, 512, [], "f121", "M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z"]
    };
    var faCog = {
        prefix: 'fas',
        iconName: 'cog',
        icon: [512, 512, [], "f013", "M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"]
    };
    var faDatabase = {
        prefix: 'fas',
        iconName: 'database',
        icon: [448, 512, [], "f1c0", "M448 73.143v45.714C448 159.143 347.667 192 224 192S0 159.143 0 118.857V73.143C0 32.857 100.333 0 224 0s224 32.857 224 73.143zM448 176v102.857C448 319.143 347.667 352 224 352S0 319.143 0 278.857V176c48.125 33.143 136.208 48.572 224 48.572S399.874 209.143 448 176zm0 160v102.857C448 479.143 347.667 512 224 512S0 479.143 0 438.857V336c48.125 33.143 136.208 48.572 224 48.572S399.874 369.143 448 336z"]
    };
    var faEye = {
        prefix: 'fas',
        iconName: 'eye',
        icon: [576, 512, [], "f06e", "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"]
    };
    var faFileCode = {
        prefix: 'fas',
        iconName: 'file-code',
        icon: [384, 512, [], "f1c9", "M384 121.941V128H256V0h6.059c6.365 0 12.47 2.529 16.971 7.029l97.941 97.941A24.005 24.005 0 0 1 384 121.941zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zM123.206 400.505a5.4 5.4 0 0 1-7.633.246l-64.866-60.812a5.4 5.4 0 0 1 0-7.879l64.866-60.812a5.4 5.4 0 0 1 7.633.246l19.579 20.885a5.4 5.4 0 0 1-.372 7.747L101.65 336l40.763 35.874a5.4 5.4 0 0 1 .372 7.747l-19.579 20.884zm51.295 50.479l-27.453-7.97a5.402 5.402 0 0 1-3.681-6.692l61.44-211.626a5.402 5.402 0 0 1 6.692-3.681l27.452 7.97a5.4 5.4 0 0 1 3.68 6.692l-61.44 211.626a5.397 5.397 0 0 1-6.69 3.681zm160.792-111.045l-64.866 60.812a5.4 5.4 0 0 1-7.633-.246l-19.58-20.885a5.4 5.4 0 0 1 .372-7.747L284.35 336l-40.763-35.874a5.4 5.4 0 0 1-.372-7.747l19.58-20.885a5.4 5.4 0 0 1 7.633-.246l64.866 60.812a5.4 5.4 0 0 1-.001 7.879z"]
    };
    var faFileExport = {
        prefix: 'fas',
        iconName: 'file-export',
        icon: [576, 512, [], "f56e", "M384 121.9c0-6.3-2.5-12.4-7-16.9L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128zM571 308l-95.7-96.4c-10.1-10.1-27.4-3-27.4 11.3V288h-64v64h64v65.2c0 14.3 17.3 21.4 27.4 11.3L571 332c6.6-6.6 6.6-17.4 0-24zm-379 28v-32c0-8.8 7.2-16 16-16h176V160H248c-13.2 0-24-10.8-24-24V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V352H208c-8.8 0-16-7.2-16-16z"]
    };
    var faFileImage = {
        prefix: 'fas',
        iconName: 'file-image',
        icon: [384, 512, [], "f1c5", "M384 121.941V128H256V0h6.059a24 24 0 0 1 16.97 7.029l97.941 97.941a24.002 24.002 0 0 1 7.03 16.971zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zm-135.455 16c26.51 0 48 21.49 48 48s-21.49 48-48 48-48-21.49-48-48 21.491-48 48-48zm208 240h-256l.485-48.485L104.545 328c4.686-4.686 11.799-4.201 16.485.485L160.545 368 264.06 264.485c4.686-4.686 12.284-4.686 16.971 0L320.545 304v112z"]
    };
    var faFileImport = {
        prefix: 'fas',
        iconName: 'file-import',
        icon: [512, 512, [], "f56f", "M16 288c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h112v-64zm489-183L407.1 7c-4.5-4.5-10.6-7-17-7H384v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-153 31V0H152c-13.3 0-24 10.7-24 24v264h128v-65.2c0-14.3 17.3-21.4 27.4-11.3L379 308c6.6 6.7 6.6 17.4 0 24l-95.7 96.4c-10.1 10.1-27.4 3-27.4-11.3V352H128v136c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H376c-13.2 0-24-10.8-24-24z"]
    };
    var faFilter = {
        prefix: 'fas',
        iconName: 'filter',
        icon: [512, 512, [], "f0b0", "M487.976 0H24.028C2.71 0-8.047 25.866 7.058 40.971L192 225.941V432c0 7.831 3.821 15.17 10.237 19.662l80 55.98C298.02 518.69 320 507.493 320 487.98V225.941l184.947-184.97C520.021 25.896 509.338 0 487.976 0z"]
    };
    var faKey = {
        prefix: 'fas',
        iconName: 'key',
        icon: [512, 512, [], "f084", "M512 176.001C512 273.203 433.202 352 336 352c-11.22 0-22.19-1.062-32.827-3.069l-24.012 27.014A23.999 23.999 0 0 1 261.223 384H224v40c0 13.255-10.745 24-24 24h-40v40c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24v-78.059c0-6.365 2.529-12.47 7.029-16.971l161.802-161.802C163.108 213.814 160 195.271 160 176 160 78.798 238.797.001 335.999 0 433.488-.001 512 78.511 512 176.001zM336 128c0 26.51 21.49 48 48 48s48-21.49 48-48-21.49-48-48-48-48 21.49-48 48z"]
    };
    var faList = {
        prefix: 'fas',
        iconName: 'list',
        icon: [512, 512, [], "f03a", "M80 368H16a16 16 0 0 0-16 16v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16v-64a16 16 0 0 0-16-16zm0-320H16A16 16 0 0 0 0 64v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16V64a16 16 0 0 0-16-16zm0 160H16a16 16 0 0 0-16 16v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16v-64a16 16 0 0 0-16-16zm416 176H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z"]
    };
    var faMousePointer = {
        prefix: 'fas',
        iconName: 'mouse-pointer',
        icon: [320, 512, [], "f245", "M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z"]
    };
    var faPlus = {
        prefix: 'fas',
        iconName: 'plus',
        icon: [448, 512, [], "f067", "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z"]
    };
    var faProjectDiagram = {
        prefix: 'fas',
        iconName: 'project-diagram',
        icon: [640, 512, [], "f542", "M384 320H256c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V352c0-17.67-14.33-32-32-32zM192 32c0-17.67-14.33-32-32-32H32C14.33 0 0 14.33 0 32v128c0 17.67 14.33 32 32 32h95.72l73.16 128.04C211.98 300.98 232.4 288 256 288h.28L192 175.51V128h224V64H192V32zM608 0H480c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V32c0-17.67-14.33-32-32-32z"]
    };
    var faQuestion = {
        prefix: 'fas',
        iconName: 'question',
        icon: [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"]
    };
    var faRedoAlt = {
        prefix: 'fas',
        iconName: 'redo-alt',
        icon: [512, 512, [], "f2f9", "M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z"]
    };
    var faSearch = {
        prefix: 'fas',
        iconName: 'search',
        icon: [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"]
    };
    var faSlidersH = {
        prefix: 'fas',
        iconName: 'sliders-h',
        icon: [512, 512, [], "f1de", "M496 384H160v-16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v16H16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h80v16c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16v-16h336c8.8 0 16-7.2 16-16v-32c0-8.8-7.2-16-16-16zm0-160h-80v-16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v16H16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h336v16c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16v-16h80c8.8 0 16-7.2 16-16v-32c0-8.8-7.2-16-16-16zm0-160H288V48c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v16H16C7.2 64 0 71.2 0 80v32c0 8.8 7.2 16 16 16h208v16c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16v-16h208c8.8 0 16-7.2 16-16V80c0-8.8-7.2-16-16-16z"]
    };
    var faStickyNote = {
        prefix: 'fas',
        iconName: 'sticky-note',
        icon: [448, 512, [], "f249", "M312 320h136V56c0-13.3-10.7-24-24-24H24C10.7 32 0 42.7 0 56v400c0 13.3 10.7 24 24 24h264V344c0-13.2 10.8-24 24-24zm129 55l-98 98c-4.5 4.5-10.6 7-17 7h-6V352h128v6.1c0 6.3-2.5 12.4-7 16.9z"]
    };
    var faTable = {
        prefix: 'fas',
        iconName: 'table',
        icon: [512, 512, [], "f0ce", "M464 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM224 416H64v-96h160v96zm0-160H64v-96h160v96zm224 160H288v-96h160v96zm0-160H288v-96h160v96z"]
    };
    var faTimes = {
        prefix: 'fas',
        iconName: 'times',
        icon: [352, 512, [], "f00d", "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"]
    };
    var faUndoAlt = {
        prefix: 'fas',
        iconName: 'undo-alt',
        icon: [512, 512, [], "f2ea", "M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z"]
    };

    // Material Design Icons v5.8.55
    var mdiChartBubble = "M7.2,11.2C8.97,11.2 10.4,12.63 10.4,14.4C10.4,16.17 8.97,17.6 7.2,17.6C5.43,17.6 4,16.17 4,14.4C4,12.63 5.43,11.2 7.2,11.2M14.8,16A2,2 0 0,1 16.8,18A2,2 0 0,1 14.8,20A2,2 0 0,1 12.8,18A2,2 0 0,1 14.8,16M15.2,4A4.8,4.8 0 0,1 20,8.8C20,11.45 17.85,13.6 15.2,13.6A4.8,4.8 0 0,1 10.4,8.8C10.4,6.15 12.55,4 15.2,4Z";

    const icons = [
        faKey,
        faTable,
        faStickyNote,
        faPlus,
        faTimes,
        faChevronRight,
        faCheck,
        faCode,
        faList,
        faRedoAlt,
        faUndoAlt,
        faSearch,
        faFilter,
        faQuestion,
        faProjectDiagram,
        faFileImage,
        faFileExport,
        faEye,
        faSlidersH,
        faDatabase,
        faFileImport,
        faFileCode,
        faCog,
        faMousePointer,
        {
            prefix: "mdi",
            iconName: "chart-bubble",
            icon: [24, 24, , , mdiChartBubble],
        },
    ];
    function getIcon(prefix, iconName) {
        let target = null;
        for (const icon of icons) {
            if (icon.prefix === prefix && icon.iconName === iconName) {
                target = icon;
                break;
            }
        }
        return target;
    }
    const base64Icons = {
        ZeroOneN: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Q0RFRDI1RjI0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Q0RFRDI1RjM0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCQTE2QzQzRDQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCQTE2QzQzRTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PnTT5ywAAAJMSURBVHja7Fc9T2JBFB3MZq1IqLSgsRM6G6TcAmK7VNoRK4yBxE6XP/CsNxBohc6G5w+AoCU0aEWpBfAD4AeM55AZMjvvg2dClsRwkxOeb+7ce+6dmTPPmJRSbNP2xJZtR2DrBH6k0+ndEkSxBHAD9AGpMAJc4Lfh1zDGn4GLgHglNb8kqANhSKVSTiaTkY7jyMFgILWNx2PZ7XZluVyW8BkBJWA1PhwO+f7ZinUO9DmH8xl3XfIGnefzuQwzBsvlcjKIAH4PWAh9zCLq9Xp48mq16knGwASTmkaShULBQ0B1ZlSr1TyFtFqtwOS3xWLxH2eyZctUUOKVFTGRtslk4iHAODZZ/k2yLDKIwLsZjJ2gM3Bo+V0wieu6vsvCCu0ucS+RPHC1vId8kp+YrWRwvHsIWaosO7Nun3DDqn1yD+zr+RQiz3WYz+dXz6iCP82g84lKB4jxF0Rv0G7P+Gw2E6ha9Ho9/eoPsRJAucbUzl53Wi79NmwU25QSJuLx+ObugkqlInD+l8+oTsAny1aHxDlKJpOBgzhBot1ui8Vi4R3cwCY8jbIJeap4JOHvAmd6flDQj+l06ncMD/yktdPp+AoW59nEeBqUnjjAzyACd7YQUcnUxL7CyJZWk7QWIs6xdcLQg6cvSzETEl+Q4iyXkAWZBHU3/stlpLvKpaWkm0sb5Tq+19exqfvWdbyU1gjX8SGLIlnKNJ9jPGYRP0gugQLwS717Az6AB+DJ+CC5Vs8vSkEffeIdK79mVALf95swtvvXbEdg2wQ+BRgAvLABcxKvek4AAAAASUVORK5CYII=",
        ZeroOne: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QkExNkM0M0I0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QkExNkM0M0M0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCQTE2QzQzOTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCQTE2QzQzQTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PomEhhsAAAKSSURBVHja7FexbhpBED0ipFRI7ixBQwlV0nCUWKJIydEkFSRpHCGQ0iXgBqfBbQrAShXzA4BLJJCdEip3UDoSUFvwAZv30B5a1ncHBiSk2CONdrU3O/N2dt6w+IQQxiHllXFgeQFwcAD+aDT6zDPwBNsjaAoaVtbuoNcee46hOSi5/hd6pRv41vUBXJFJJ4FA4FMymTRCodDy22g0Mnq93gOml8Ph8Mxhb71QKOQYYzqdGq1W6zPsVkHwo5tGIpFvsVhMNJtN4Saz2UwUi0UB299QU9u/tBsMBrS51WN4BrcsS4zHY7GJEKQOYmsAMIzz5GrwyWQiSqWSwDXQkchms6LRaCwyoIPYB4Ar3NdyM+cEhPXv0LC0OYH+ZJZUEASG9fdbA2AAnlI9uQwedwF7waC29Pt92t5sCoCN6FzSZCmsdluq1aoxn8+LqN6+E0uwXoKPKNiQ4j7TNA0w5gRLZRdWraz7QZOyTkU6saXb7XL4taZH3IGSKRs4asVA5s5Vg2AwaOTz+QSmCZ2GniLTuI6uFpyLbcRfq9UeHYcZwL0v5mw8SFsYqb73yMBb9Tel3W4zA4s5gC1G2Yget2Lc8Q99MZ1Ol20AmLMOTjE9c7nT1xgstW4qlQrrhn7LNgACgp8/mN56dkKk84hVb1OLo+T+qUv66wi4QlnSeNc+cAG0y81IvyDfZaf7CE1Av5JubE6qSLDxXQEc05ib9HbLvp/JZARPTc6rQjDMyL5+Cz7wKkDDjapZD74zAOngHbRN57wGJyFAmfa6w/71ndCruyBoB0MHlf4FxZUDJd+o7wF8Z7Vfy/dAx8HFJWies1ng+CABqqe8oMIOL6KHDV5ElPt9APj/HqW+l/+Gzx7APwEGACfjkeXK58xsAAAAAElFTkSuQmCC",
        ZeroN: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDc5MkNFMEM0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDc5MkNFMEQ0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NzkyQ0UwQTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0NzkyQ0UwQjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PpR0ImIAAALlSURBVHja7Fe/jxJBGF0MyVUk2HgJFJ6NQqUNWEoCkfKWxusozxBI7Eiw8ardKy/hxyVWQqcF8AdA9Eqg8DqwuwJI7Aj8AeN7OEuGhd09tCBRvuTLzA4z37z53rxvF58QQtunPdD2bAcA/mg0+p9nYMf5Qfhz5fnmbwH47iND0PQaTS4QCOiRSGQ1PhgMZmja8OvhcNi/z4aIdc5Ycs1HjQCcHJu9hH/KZrOi0+kIu83nc9FsNkUymRSYZ3jEegqv6bousLHI5/NcU3RbkIa3W62W8DICKZVKDFhziFWMxWKiXq+v1ozHY8Exv0OajpmmSqVyitOtxrvdrjYajZZ90KGlUiktFAot+4ZhcDiHtTOc8L1KHWLoAKiFw+FVrOl0+rvjgNjA5msnJA3MCPxC+hX8DhuvzZN0kDqDfTt1nCPT/w1+tm3zIFPDidYC8oZxc8vcI6ZdBUHKMPadY1YMy0gBY6uxfHhIMBEKAw+BvIUMLB+q1aqG/iXSWnKg6wjND9DzmHQsFgttMploqlpIm2maWr/fv8bj5zUZMrV2KWYymaXTyDMCPgGAOxdpXRQKhQ9I7cZv2FSzDrPVvG44TiLc5CWp0Mnrn5gfxWQDFG8r02nddpwwiAzMXOrLC6d3CtNPWhxLMSjYKKcYe0XZ0OLxOOVHOX1xA6Bybj8MKWg0GjdOFNjTeUL5WNbr9UjDV3jcIf3nVIllrHK8V2xVYxypphr8kbXeidO2ql+WWwnijQrU0rq6mdT4W/gta4ldiuVy2ZJi0Q1AmoHVxTyBDL50/m7XOkETvIxxTL1zHpSwBoJlWBa2mtvNNpky+wmcjJvIk6Vtcc5Y9QjeHovxveRlbiun9tLKVFul1S2W+kJiywx4fg9AXmm+UDD5lIqg3HizwftSYgBHmV1izhXGfnrEeobmHeLkuB7rIj4n+WyTGjwh2xP4rXR+kMx2/BBKyLWzXQD8mx+lvsNfswOAfQP4JcAAK/At0HQvwB8AAAAASUVORK5CYII=",
        OneOnly: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUJCNTBCRDA0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QkExNkM0MzQ0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBQkI1MEJDRTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBQkI1MEJDRjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pur5d4QAAAE1SURBVHjaYvz//z/DQAImhgEGow4YcAewaGpqjvAQoJI5CUAsD2VPB+JXULY4EGcCMSivPwTiBRgOuH79OkU2A6MwITAwcL6UlBSYP3XqVHGgmVlQufqcnJxMUFnz7NkzhvXr1zMA5VAdAZKkBGtoaBw4derUfxgA8v8jycHFQWpAatH1j2bDUQeACqIGaDahGgClfmLlWIDZpJ7SKhmWBUEgOzsbRDVgUwOUswcy7ZHFGf8PcIOABVhwUGwIsCBiQCqIUOSgIQIviNABI7BwaKDQfodFixbZm5qawuIYRDVC5ephJe3p06cZ4uLiDgKZB0ZLwtGCaNg1SBYAs5c9MJExIDVI4GxgtgQ1SBiePn3KgK1BAsqG1GoRKSA54CVaiwgEHtDSAUM3DTCO9g1HvAMAAgwAvvwYPnW1JuQAAAAASUVORK5CYII=",
        OneN: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QkExNkM0Mzc0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QkExNkM0Mzg0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCQTE2QzQzNTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCQTE2QzQzNjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pt+BFx8AAAIISURBVHja7Fc9TwJBEF0MLYkdBgot4QdwLSaQSAmNdkCrR61CI9Ud1oCUIB0NYElBtJU/QIkmQKIVgcpqfXPekQNBYu7WM4FJJvs1x87Ovnk7uDjnzEnZYw7LzgHHHXAFAoHtjoDbpt9JQw/1fgX6vsH+CDohdVnlgWAwmE4kElWfz6eNy+Vypd/vX6yx9aK58fv959PplM1mswNGDlhRYOip1+txQzDma+wuoYNSqaTZUYvxnXAHMJag1WQyyYfDITdLJBLhbpEAQ8gVj8eThTBc03weoWeqqrLRaFQREgHoKfQRG3Pc9cKpW60WD4VCZKPS90IiAJA1FEVhkiTN58bjMaNIwNl7yhQA9VlLQ4Qpj9a2J1GWZZbJZBbmkBkMoHtFt6pPxbBvTGNCHZWWNqX7xalXriHkdNfrqZg7XBC4KTxWhSJgENGy0Onb7faPj1He4v7H9Xo9DGRrg1QqpaWY2SEAj+Vyua+0W6ZpQWn4YjCeWYrFIq0NiBWN70U54CWajcfj3LxGQmxIrEjsSCwplIrRP6N1cMI3Qmo2mxohCa0HQDYNNCfASAG8z7rd7nwtGo3+TUECJz6gWfB/DAT1QCAlViSgYq5gBxXXQDZhQrqpIFnlSAdNBwx4BWwUsPk15m7tqgnTepVjOPC2wX5fr4hse4xqv7Sf/J+yfPffcOsd+BRgAOvawAWTC+PMAAAAAElFTkSuQmCC",
        One: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUJCNTBCQ0M0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QUJCNTBCQ0Q0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBQkI1MEJDQTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBQkI1MEJDQjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PnOhfCQAAADcSURBVHjaYvz//z/DQAImhgEGow4YcAewaGpqjvAQoJI5CUAsD2VPB+JXxGpkpLQcAEZhQmBg4HwpKSkwf+rUqdOvX7+eRbQBIAdQgjU0NA6cOnXqPwwA+f9J0T+aDUcdACqIGkBpkZqGAs2sJzobTpky5T+lWRGYDRmkpaXBbKB5JOll/D/ADQIWYMFBsSGgEEAqiEgLAWDB0UCh/Q6LFi2yNzU1hcU/iGocLQlHC6IR1SBZsH79entgQmRAapCQlA2p1SJSQHLAS3o3yRYM2TTAONo3HPEOAAgwAJh583IRUllDAAAAAElFTkSuQmCC",
        N: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDc5MkNFMDg0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDc5MkNFMDk0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozNDQwRjc3NTQ4M0MxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozNDQwRjc3NjQ4M0MxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PkbQDKwAAAGjSURBVHja7Jcxb4JQEMefLl272cjSUbYu0g+gSVemdpPZwKzRRSf4AGg70k8AfACTdqx+ibYJLp2MfoDr/wg0vJp2Al6TeskFeQ+4e/fufvdsEJFQKU2hWE4OKHeg0el0TlugQi6h5+kW1MkBXddbuMw0TRvu93txOBwumjUaH+Hy4jjOcLVaCcuyeHgmOAJVKpLcgAaDwYCSJKGi9Hq9yo273W6XwjCUDCP8NJlMCPP3VRm+hT6xETZWlCiKiJ3CvJfmX8mGW7wqDu16vZYMb7db4m3A/CP0On+HQTRHMpRVCiaS7Mq2bWlwuVyKxWLxjp/BEQkxQWWVYr/fF9/JipALrP5nFJPiA0EagbI+BsAI0zSlMV59HMe/NqN5mYg1DMPyPE+02+2vwc1mI6bTKTvzgNsP6Y0KSnAMfctySxLf97kKXqGj/PmqOJCWI7aDsHrJCaZhVo4BU7JqEt5Bn13XPQIS05GBVEcvOGPqsTE0IQnHtThQcOQGGnP4mYpZL/Bqc6CYpFkvGOcoVsEfPg3tVB7Jdn/nWH76b/jvHfgUYADeZNmzPgOYQQAAAABJRU5ErkJggg==",
    };
    function getBase64Icon(relationshipType) {
        return base64Icons[relationshipType];
    }

    const SIZE = 24;
    const SIZE_REM = 1.5;
    let Icon = class Icon extends EditorElement {
        constructor() {
            super(...arguments);
            this.prefix = "fas";
            this.icon = "";
            this.size = SIZE;
            this.color = "";
        }
        render() {
            const icon = getIcon(this.prefix, this.icon);
            if (icon) {
                const [width, height, , , d] = icon.icon;
                const rem = SIZE_REM * (this.size / SIZE);
                return svg `
        <svg
          class="vuerd-icon"
          style=${styleMap({
                    display: "inline-flex",
                    width: `${rem}rem`,
                    height: `${rem}rem`,
                })} 
          viewBox="0 0 ${width} ${height}"
        >
          ${this.color === ""
                    ? svg `<path d=${d}></path>`
                    : svg `<path d=${d} fill=${this.color}></path>`}
        </svg>
      `;
            }
            else {
                return svg ``;
            }
        }
    };
    __decorate([
        property({ type: String })
    ], Icon.prototype, "prefix", void 0);
    __decorate([
        property({ type: String })
    ], Icon.prototype, "icon", void 0);
    __decorate([
        property({ type: Number })
    ], Icon.prototype, "size", void 0);
    __decorate([
        property({ type: String })
    ], Icon.prototype, "color", void 0);
    Icon = __decorate([
        customElement("vuerd-icon")
    ], Icon);

    let Contextmenu = class Contextmenu extends EditorElement {
        constructor() {
            super(...arguments);
            this.x = 0;
            this.y = 0;
            this.currentMenu = null;
            this.menus = [];
            this.relationship = null;
        }
        get childrenX() {
            let x = this.x;
            const ul = this.renderRoot.querySelector(".vuerd-contextmenu");
            if (ul) {
                x = this.x + ul.clientWidth;
            }
            return x;
        }
        get childrenY() {
            let y = this.y;
            if (this.currentMenu) {
                y += this.menus.indexOf(this.currentMenu) * SIZE_CONTEXTMENU_HEIGHT;
            }
            return y;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(store.canvasState.show, () => this.requestUpdate()), store.observe(store.canvasState, (name) => {
                switch (name) {
                    case "database":
                    case "language":
                    case "tableCase":
                    case "columnCase":
                        this.requestUpdate();
                        break;
                }
            }));
            if (this.relationship) {
                this.subscriptionList.push(store.observe(this.relationship, (name) => {
                    if (name === "relationshipType") {
                        this.requestUpdate();
                    }
                }));
            }
        }
        disconnectedCallback() {
            this.currentMenu = null;
            super.disconnectedCallback();
        }
        render() {
            return html `
      <ul
        class="vuerd-contextmenu"
        style=${styleMap({
                left: `${this.x}px`,
                top: `${this.y}px`,
            })}
      >
        ${this.menus.map((menu) => {
                const icon = this.getIcon(menu);
                return html `
            <li
              @click=${() => this.onExecute(menu)}
              @mouseover=${() => this.onMouseover(menu)}
            >
              ${icon && menu.base64
                    ? html `
                    <span class="icon">
                      <img src=${icon} />
                    </span>
                  `
                    : icon
                        ? html `
                    <span class="icon">
                      <vuerd-icon size="14" icon=${icon}> </vuerd-icon>
                    </span>
                  `
                        : html `<span class="icon"></span>`}
              <span class="name">${menu.name}</span>
              <span class="keymap" title=${menu.keymap ? menu.keymap : ""}>
                ${menu.keymap}
              </span>
              ${menu.children
                    ? html `
                    <span class="arrow">
                      <vuerd-icon size="13" icon="chevron-right"> </vuerd-icon>
                    </span>
                  `
                    : ""}
            </li>
          `;
            })}
      </ul>
      ${this.currentMenu && this.currentMenu.children
                ? html `
            <vuerd-contextmenu
              .menus=${this.currentMenu.children}
              .x=${this.childrenX}
              .y=${this.childrenY}
              .relationship=${this.relationship}
            ></vuerd-contextmenu>
          `
                : ``}
    `;
        }
        onMouseover(menu) {
            this.currentMenu = menu;
        }
        onExecute(menu) {
            if (!menu.children && menu.execute && typeof menu.execute === "function") {
                menu.execute(this.getRootNode());
                if (!menu.option ||
                    menu.option.close ||
                    menu.option.close === undefined) {
                    this.context.eventBus.emit(Bus.ERD.contextmenuEnd);
                }
            }
        }
        getIcon(menu) {
            var _a, _b, _c, _d, _e, _f;
            const { canvasState } = this.context.store;
            if ((_a = menu.option) === null || _a === void 0 ? void 0 : _a.showKey) {
                const show = canvasState.show;
                return show[menu.option.showKey] ? "check" : undefined;
            }
            else if ((_b = menu.option) === null || _b === void 0 ? void 0 : _b.database) {
                const database = canvasState.database;
                return menu.option.database === database ? "check" : undefined;
            }
            else if ((_c = menu.option) === null || _c === void 0 ? void 0 : _c.language) {
                const language = canvasState.language;
                return menu.option.language === language ? "check" : undefined;
            }
            else if ((_d = menu.option) === null || _d === void 0 ? void 0 : _d.tableCase) {
                const tableCase = canvasState.tableCase;
                return menu.option.tableCase === tableCase ? "check" : undefined;
            }
            else if ((_e = menu.option) === null || _e === void 0 ? void 0 : _e.columnCase) {
                const columnCase = canvasState.columnCase;
                return menu.option.columnCase === columnCase ? "check" : undefined;
            }
            else if (this.relationship && ((_f = menu.option) === null || _f === void 0 ? void 0 : _f.relationshipType)) {
                return this.relationship.relationshipType === menu.option.relationshipType
                    ? "check"
                    : undefined;
            }
            return menu.icon;
        }
    };
    __decorate([
        property({ type: Number })
    ], Contextmenu.prototype, "x", void 0);
    __decorate([
        property({ type: Number })
    ], Contextmenu.prototype, "y", void 0);
    __decorate([
        property({ attribute: false })
    ], Contextmenu.prototype, "currentMenu", void 0);
    Contextmenu = __decorate([
        customElement("vuerd-contextmenu")
    ], Contextmenu);

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
        // IE11 doesn't support classList on SVG elements, so we emulate it with a Set
    class ClassList$1 {
        constructor(element) {
            this.classes = new Set();
            this.changed = false;
            this.element = element;
            const classList = (element.getAttribute('class') || '').split(/\s+/);
            for (const cls of classList) {
                this.classes.add(cls);
            }
        }
        add(cls) {
            this.classes.add(cls);
            this.changed = true;
        }
        remove(cls) {
            this.classes.delete(cls);
            this.changed = true;
        }
        commit() {
            if (this.changed) {
                let classString = '';
                this.classes.forEach((cls) => classString += cls + ' ');
                this.element.setAttribute('class', classString);
            }
        }
    }
    /**
     * Stores the ClassInfo object applied to a given AttributePart.
     * Used to unset existing values when a new ClassInfo object is applied.
     */
    const previousClassesCache = new WeakMap();
    /**
     * A directive that applies CSS classes. This must be used in the `class`
     * attribute and must be the only part used in the attribute. It takes each
     * property in the `classInfo` argument and adds the property name to the
     * element's `class` if the property value is truthy; if the property value is
     * falsey, the property name is removed from the element's `class`. For example
     * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.
     * @param classInfo {ClassInfo}
     */
    const classMap = directive((classInfo) => (part) => {
        if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||
            part.committer.name !== 'class' || part.committer.parts.length > 1) {
            throw new Error('The `classMap` directive must be used in the `class` attribute ' +
                'and must be the only part in the attribute.');
        }
        const { committer } = part;
        const { element } = committer;
        let previousClasses = previousClassesCache.get(part);
        if (previousClasses === undefined) {
            // Write static classes once
            // Use setAttribute() because className isn't a string on SVG elements
            element.setAttribute('class', committer.strings.join(' '));
            previousClassesCache.set(part, previousClasses = new Set());
        }
        const classList = (element.classList || new ClassList$1(element));
        // Remove old classes that no longer apply
        // We use forEach() instead of for-of so that re don't require down-level
        // iteration.
        previousClasses.forEach((name) => {
            if (!(name in classInfo)) {
                classList.remove(name);
                previousClasses.delete(name);
            }
        });
        // Add or remove classes based on their classMap value
        for (const name in classInfo) {
            const value = classInfo[name];
            if (value != previousClasses.has(name)) {
                // We explicitly want a loose truthy check of `value` because it seems
                // more convenient that '' and 0 are skipped.
                if (value) {
                    classList.add(name);
                    previousClasses.add(name);
                }
                else {
                    classList.remove(name);
                    previousClasses.delete(name);
                }
            }
        }
        if (typeof classList.commit === 'function') {
            classList.commit();
        }
    });

    let Sash = class Sash extends EditorElement {
        constructor() {
            super(...arguments);
            this.vertical = false;
            this.horizontal = false;
            this.edge = false;
            this.cursor = "default";
            this.top = 0;
            this.left = 0;
        }
        get classMap() {
            const classMap = {
                "vuerd-sash": true,
            };
            if (this.vertical) {
                classMap.vertical = true;
            }
            else if (this.horizontal) {
                classMap.horizontal = true;
            }
            else if (this.edge) {
                classMap.edge = true;
            }
            return classMap;
        }
        get styleMap() {
            const styleMap = {
                top: `${this.centerTop}px`,
                left: `${this.centerLeft}px`,
            };
            if (this.edge) {
                styleMap.cursor = this.cursor;
            }
            return styleMap;
        }
        get centerTop() {
            return this.top === 0 && !this.horizontal && !this.edge
                ? this.top
                : this.top - SIZE_SASH / 2;
        }
        get centerLeft() {
            return this.left === 0 && !this.vertical && !this.edge
                ? this.left
                : this.left - SIZE_SASH / 2;
        }
        render() {
            return html `
      <div
        class=${classMap(this.classMap)}
        style=${styleMap(this.styleMap)}
      ></div>
    `;
        }
    };
    __decorate([
        property({ type: Boolean })
    ], Sash.prototype, "vertical", void 0);
    __decorate([
        property({ type: Boolean })
    ], Sash.prototype, "horizontal", void 0);
    __decorate([
        property({ type: Boolean })
    ], Sash.prototype, "edge", void 0);
    __decorate([
        property({ type: String })
    ], Sash.prototype, "cursor", void 0);
    __decorate([
        property({ type: Number })
    ], Sash.prototype, "top", void 0);
    __decorate([
        property({ type: Number })
    ], Sash.prototype, "left", void 0);
    Sash = __decorate([
        customElement("vuerd-sash")
    ], Sash);

    const menus = [
        {
            title: "ERD ",
            canvasType: "ERD",
            prefix: "fas",
            icon: "project-diagram",
            size: 18,
        },
        // {
        //     title: "  ",
        //     canvasType: "Grid",
        //     prefix: "fas",
        //     icon: "list",
        //     size: 18,
        // },
        {
            title: " ",
            canvasType: "Visualization",
            prefix: "mdi",
            icon: "chart-bubble",
            size: 24,
        },
        {
            title: "DDL ",
            canvasType: "SQL",
            prefix: "fas",
            icon: "code",
            size: 18,
        },
        {
            title: " ",
            canvasType: "GeneratorCode",
            prefix: "fas",
            icon: "sliders-h",
            size: 18,
        },
    ];
    let Menubar$1 = class Menubar extends EditorElement {
        constructor() {
            super(...arguments);
            this.onFilter = () => {
                const { store } = this.context;
                store.dispatch(filterActive());
            };
            this.onFind = () => {
                const { store } = this.context;
                store.dispatch(findActive());
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus } = this.context;
            this.subscriptionList.push(store.observe(store.editorState.filterStateList, () => this.requestUpdate()), store.observe(store.canvasState, (name) => {
                switch (name) {
                    case "databaseName":
                    case "width":
                    case "height":
                    case "canvasType":
                        this.requestUpdate();
                        break;
                }
            }), store.observe(store.editorState, (name) => {
                switch (name) {
                    case "filterActive":
                    case "findActive":
                    case "hasUndo":
                    case "hasRedo":
                    case "undoManager":
                        this.requestUpdate();
                        break;
                }
            }), eventBus.on(Bus.Menubar.filter).subscribe(this.onFilter));
        }
        render() {
            const { keymap } = this.context;
            const { editorState } = this.context.store;
            const { databaseName, width, canvasType } = this.context.store.canvasState;
            return html `
      <ul class="vuerd-menubar" @mousedown=${this.onMousedown}>
        <li class="vuerd-menubar-input">
          <input
            style="width: 200px;"
            type="text"
            title=" "
            placeholder=" "
            spellcheck="false"
            .value=${databaseName}
            @input=${this.onChangeDatabaseName}
          />
        </li>
        <li class="vuerd-menubar-input">
          <input
            style="width: 65px;"
            type="text"
            title="  "
            spellcheck="false"
            placeholder="canvas size"
            .value=${width.toString()}
            @input=${this.onResizeValid}
            @change=${this.onResizeCanvas}
          />
        </li>
        ${menus.map((menu) => html `
            <li
              class=${classMap({
                "vuerd-menubar-menu": true,
                active: canvasType === menu.canvasType,
            })}
              title=${menu.title}
              @click=${() => this.onChangeCanvasType(menu.canvasType)}
            >
              <vuerd-icon
                .prefix=${menu.prefix}
                .icon=${menu.icon}
                .size=${menu.size}
              ></vuerd-icon>
            </li>
          `)}
        <li class="vuerd-menubar-menu-vertical"></li>
        <li
          class="vuerd-menubar-menu"
          title=""
          @click=${() => this.onEmit("help-start")}
        >
          <vuerd-icon icon="question" size="16"></vuerd-icon>
        </li>
        <li
          class="vuerd-menubar-menu"
          title=""
          @click=${() => this.onEmit("setting-start")}
        >
          <vuerd-icon icon="cog" size="16"></vuerd-icon>
        </li>
        <li class="vuerd-menubar-menu-vertical"></li>
        ${canvasType === "ERD"
                ? html `
              <li
                class="vuerd-menubar-menu"
                title=${` ${keymapOptionToString(keymap.find[0])}`}
                @click=${this.onFind}
              >
                <vuerd-icon icon="search" size="16"></vuerd-icon>
              </li>
              ${editorState.undoManager
                    ? html `
                    <li
                      class=${classMap({
                        "vuerd-menubar-menu": true,
                        "undo-redo": true,
                        active: editorState.hasUndo,
                    })}
                      title=${` ${keymapOptionToString(keymap.undo[0])}`}
                      @click=${this.onUndo}
                    >
                      <vuerd-icon icon="undo-alt" size="16"></vuerd-icon>
                    </li>
                    <li
                      class=${classMap({
                        "vuerd-menubar-menu": true,
                        "undo-redo": true,
                        active: editorState.hasRedo,
                    })}
                      title=${` ${keymapOptionToString(keymap.redo[0])}`}
                      @click=${this.onRedo}
                    >
                      <vuerd-icon icon="redo-alt" size="16"></vuerd-icon>
                    </li>
                  `
                    : ""}
            `
                : ""}
        ${canvasType === "Grid"
                ? html `
              <li
                class=${classMap({
                    "vuerd-menubar-menu": true,
                    active: editorState.filterStateList.length !== 0,
                })}
                title=${`Filter ${keymapOptionToString(keymap.find[0])}`}
                @click=${this.onFilter}
              >
                <vuerd-icon icon="filter" size="16"></vuerd-icon>
              </li>
            `
                : ""}
      </ul>
      ${editorState.findActive
                ? html `<vuerd-find @close=${this.onFindEnd}></vuerd-find>`
                : ""}
      ${editorState.filterActive
                ? html `
            <vuerd-grid-filter @close=${this.onFilterEnd}></vuerd-grid-filter>
          `
                : ""}
    `;
        }
        onFilterEnd() {
            const { store } = this.context;
            store.dispatch(filterActiveEnd());
        }
        onFindEnd() {
            const { store } = this.context;
            store.dispatch(findActiveEnd());
        }
        onMousedown(event) {
            const { eventBus } = this.context;
            eventBus.emit(Bus.ERD.contextmenuEnd);
        }
        onChangeDatabaseName(event) {
            const input = event.target;
            const { store } = this.context;
            store.dispatch(changeDatabaseName(input.value));
        }
        onResizeValid(event) {
            const input = event.target;
            input.value = input.value.replace(/[^0-9]/g, "");
        }
        onResizeCanvas(event) {
            const input = event.target;
            let size = Number(input.value.replace(/[^0-9]/g, ""));
            if (size < SIZE_CANVAS_MIN) {
                size = SIZE_CANVAS_MIN;
            }
            else if (size > SIZE_CANVAS_MAX) {
                size = SIZE_CANVAS_MAX;
            }
            input.value = size.toString();
            const { store } = this.context;
            store.dispatch(resizeCanvas(size, size));
        }
        onChangeCanvasType(canvasType) {
            const { store } = this.context;
            if (canvasType !== store.canvasState.canvasType) {
                store.dispatch(changeCanvasType(canvasType));
            }
        }
        onEmit(eventName) {
            this.dispatchEvent(new CustomEvent(eventName));
        }
        onUndo() {
            const { store } = this.context;
            store.undo();
        }
        onRedo() {
            const { store } = this.context;
            store.redo();
        }
    };
    Menubar$1 = __decorate([
        customElement("vuerd-menubar")
    ], Menubar$1);

    function createContextmenuERD(context) {
        const { store, keymap } = context;
        const { canvasState } = store;
        return [
            {
                icon: "table",
                name: " ",
                keymap: keymapOptionToString(keymap.addTable[0]),
                execute() {
                    store.dispatch(addTable(store));
                },
            },
            {
                icon: "sticky-note",
                name: " ",
                keymap: keymapOptionToString(keymap.addMemo[0]),
                execute() {
                    store.dispatch(addMemo(store));
                },
            },
            {
                name: "",
                children: createRelationshipMenus(store, keymap),
            },
            {
                icon: "eye",
                name: " ",
                children: createShowMenus(store),
            },
            {
                icon: "database",
                name: "",
                children: createDatabaseMenus(store),
            },
            {
                icon: "file-import",
                name: "",
                children: [
                    {
                        name: "json",
                        execute() {
                            importJSON(store);
                        },
                    },
                    {
                        name: "SQL DDL",
                        execute() {
                            importSQL(context);
                        },
                    },
                ],
            },
            {
                icon: "file-export",
                name: "",
                children: [
                    {
                        name: "json",
                        execute() {
                            exportJSON(createJsonStringify(store, 2), canvasState.databaseName);
                        },
                    },
                    {
                        name: "SQL DDL",
                        execute() {
                            exportSQLDDL(createDDL$6(store), canvasState.databaseName);
                        },
                    },
                    {
                        icon: "file-image",
                        name: "png",
                        execute(root) {
                            exportPNG(root, ".vuerd-canvas", canvasState.databaseName);
                        },
                    },
                ],
            },
        ];
    }
    const showMenus = [
        {
            name: " ",
            showKey: "tableComment",
        },
        {
            name: " ",
            showKey: "columnComment",
        },
        {
            name: " ",
            showKey: "columnDataType",
        },
        {
            name: "",
            showKey: "columnDefault",
        },
        {
            name: "Not Null",
            showKey: "columnNotNull",
        },
        {
            name: "Unique",
            showKey: "columnUnique",
        },
        {
            name: "Auto Increment",
            showKey: "columnAutoIncrement",
        },
        {
            name: "",
            showKey: "relationship",
        },
    ];
    function createShowMenus(store) {
        const { show } = store.canvasState;
        return showMenus.map((showMenu) => {
            return {
                icon: show[showMenu.showKey] ? "check" : undefined,
                name: showMenu.name,
                execute() {
                    store.dispatch(changeCanvasShow(store, showMenu.showKey));
                },
                option: {
                    close: false,
                    showKey: showMenu.showKey,
                },
            };
        });
    }
    const databaseKeys = [
        "MySQL",
        "MariaDB",
        "PostgreSQL",
        "SQLite",
        "Oracle",
        "MSSQL",
    ];
    function createDatabaseMenus(store) {
        const { canvasState } = store;
        return databaseKeys.map((databaseKey) => {
            return {
                icon: canvasState.database === databaseKey ? "check" : undefined,
                name: databaseKey,
                execute() {
                    store.dispatch(changeDatabase(databaseKey));
                },
                option: {
                    close: false,
                    database: databaseKey,
                },
            };
        });
    }
    const relationshipMenus = [
        {
            name: "Zero One N",
            relationshipType: "ZeroOneN",
            keymapName: "relationshipZeroOneN",
        },
        {
            name: "Zero One",
            relationshipType: "ZeroOne",
            keymapName: "relationshipZeroOne",
        },
        {
            name: "Zero N",
            relationshipType: "ZeroN",
            keymapName: "relationshipZeroN",
        },
        {
            name: "One Only",
            relationshipType: "OneOnly",
            keymapName: "relationshipOneOnly",
        },
        {
            name: "One N",
            relationshipType: "OneN",
            keymapName: "relationshipOneN",
        },
        {
            name: "One",
            relationshipType: "One",
            keymapName: "relationshipOne",
        },
        {
            name: "N",
            relationshipType: "N",
            keymapName: "relationshipN",
        },
    ];
    function createRelationshipMenus(store, keymap) {
        return relationshipMenus.map((relationshipMenu) => {
            return {
                icon: getBase64Icon(relationshipMenu.relationshipType),
                base64: true,
                name: relationshipMenu.name,
                keymap: keymapOptionToString(keymap[relationshipMenu.keymapName][0]),
                execute() {
                    store.dispatch(drawStartRelationship(relationshipMenu.relationshipType));
                },
            };
        });
    }
    function createContextmenuRelationship(store, relationship) {
        return [
            {
                name: "RelationshipType",
                children: createRelationshipSingleMenus(store, relationship),
            },
            {
                name: "Delete",
                execute() {
                    store.dispatch(removeRelationship([relationship.id]));
                },
            },
        ];
    }
    function createRelationshipSingleMenus(store, relationship) {
        return relationshipMenus.map((relationshipMenu) => {
            return {
                icon: relationship.relationshipType === relationshipMenu.relationshipType
                    ? "check"
                    : undefined,
                name: relationshipMenu.name,
                execute() {
                    store.dispatch(changeRelationshipType(relationship.id, relationshipMenu.relationshipType));
                },
                option: {
                    close: false,
                    relationshipType: relationshipMenu.relationshipType,
                },
            };
        });
    }
    function createContextmenuTable(context, tableId) {
        const { store, keymap, eventBus } = context;
        return [
            {
                icon: "key",
                name: " ",
                keymap: keymapOptionToString(keymap.primaryKey[0]),
                execute() {
                    const { focusTable } = store.editorState;
                    if (focusTable !== null) {
                        const currentFocus = focusTable.currentFocus;
                        if (currentFocus !== "tableName" && currentFocus !== "tableComment") {
                            const columnId = focusTable.currentFocusId;
                            store.dispatch(changeColumnPrimaryKey(store, focusTable.id, columnId));
                        }
                    }
                },
            },
            {
                name: " ",
                keymap: keymapOptionToString(keymap.tableProperties[0]),
                execute() {
                    eventBus.emit(Bus.Editor.tableProperties, {
                        tableId,
                    });
                },
            },
        ];
    }
    function createContextmenuGeneratorCode(store) {
        return [
            {
                icon: "code",
                name: " ",
                children: createLanguageMenus(store),
            },
            {
                name: "  ",
                children: createTableCaseMenus(store),
            },
            {
                name: "  ",
                children: createColumnCaseMenus(store),
            },
        ];
    }
    const languageKeys = [
        "GraphQL",
        "JPA",
        "Java",
        "Kotlin",
        "TypeScript",
        "C#",
        "Scala",
    ];
    function createLanguageMenus(store) {
        const { canvasState } = store;
        return languageKeys.map((languageKey) => {
            return {
                icon: canvasState.language === languageKey ? "check" : undefined,
                name: languageKey,
                execute() {
                    store.dispatch(changeLanguage(languageKey));
                },
                option: {
                    close: false,
                    language: languageKey,
                },
            };
        });
    }
    const nameCaseMenus = [
        {
            name: "Pascal",
            nameCase: "pascalCase",
        },
        {
            name: "Camel",
            nameCase: "camelCase",
        },
        {
            name: "Snake",
            nameCase: "snakeCase",
        },
        {
            name: "None",
            nameCase: "none",
        },
    ];
    function createTableCaseMenus(store) {
        const { canvasState } = store;
        return nameCaseMenus.map((nameCaseMenu) => {
            return {
                icon: canvasState.tableCase === nameCaseMenu.nameCase ? "check" : undefined,
                name: nameCaseMenu.name,
                execute() {
                    store.dispatch(changeTableCase(nameCaseMenu.nameCase));
                },
                option: {
                    close: false,
                    tableCase: nameCaseMenu.nameCase,
                },
            };
        });
    }
    function createColumnCaseMenus(store) {
        const { canvasState } = store;
        return nameCaseMenus.map((nameCaseMenu) => {
            return {
                icon: canvasState.columnCase === nameCaseMenu.nameCase ? "check" : undefined,
                name: nameCaseMenu.name,
                execute() {
                    store.dispatch(changeColumnCase(nameCaseMenu.nameCase));
                },
                option: {
                    close: false,
                    columnCase: nameCaseMenu.nameCase,
                },
            };
        });
    }

    let InputEdit = class InputEdit extends EditorElement {
        constructor() {
            super(...arguments);
            this.edit = false;
            this.focusState = false;
            this.select = false;
            this.active = false;
            this.width = SIZE_MIN_WIDTH;
            this.value = "";
            this.placeholder = "";
        }
        get classMap() {
            return {
                "vuerd-input-edit": true,
                placeholder: this.value.trim() === "" && !this.edit,
                focus: this.focusState && !this.edit,
                edit: this.edit,
                select: this.select,
                active: this.active,
            };
        }
        get placeholderValue() {
            if (this.value.trim() === "") {
                return this.placeholder;
            }
            return this.value;
        }
        updated(changedProperties) {
            changedProperties.forEach((oldValue, propName) => {
                switch (propName) {
                    case "edit":
                        if (this.edit) {
                            const input = this.renderRoot.querySelector("input");
                            if (input) {
                                const len = input.value.length;
                                input.selectionStart = len;
                                input.selectionEnd = len;
                                input.focus();
                            }
                        }
                        break;
                }
            });
        }
        render() {
            return this.edit
                ? html `
          <input
            class=${classMap(this.classMap)}
            style=${styleMap({
                    width: `${this.width}px`,
                })}
            type="text"
            spellcheck="false"
            .value=${this.value}
            placeholder=${this.placeholder}
            @blur=${this.onBlur}
          />
        `
                : html `
          <div
            class=${classMap(this.classMap)}
            style=${styleMap({
                    width: `${this.width}px`,
                })}
          >
            <span>${this.placeholderValue}</span>
          </div>
        `;
        }
        onBlur(event) {
            this.dispatchEvent(new Event("blur"));
        }
    };
    __decorate([
        property({ type: Boolean })
    ], InputEdit.prototype, "edit", void 0);
    __decorate([
        property({ type: Boolean })
    ], InputEdit.prototype, "focusState", void 0);
    __decorate([
        property({ type: Boolean })
    ], InputEdit.prototype, "select", void 0);
    __decorate([
        property({ type: Boolean })
    ], InputEdit.prototype, "active", void 0);
    __decorate([
        property({ type: Number })
    ], InputEdit.prototype, "width", void 0);
    __decorate([
        property({ type: String })
    ], InputEdit.prototype, "value", void 0);
    __decorate([
        property({ type: String })
    ], InputEdit.prototype, "placeholder", void 0);
    InputEdit = __decorate([
        customElement("vuerd-input-edit")
    ], InputEdit);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
        // Helper functions for manipulating parts
        // TODO(kschaaf): Refactor into Part API?
    const createAndInsertPart = (containerPart, beforePart) => {
            const container = containerPart.startNode.parentNode;
            const beforeNode = beforePart === undefined ? containerPart.endNode :
                beforePart.startNode;
            const startNode = container.insertBefore(createMarker(), beforeNode);
            container.insertBefore(createMarker(), beforeNode);
            const newPart = new NodePart(containerPart.options);
            newPart.insertAfterNode(startNode);
            return newPart;
        };
    const updatePart = (part, value) => {
        part.setValue(value);
        part.commit();
        return part;
    };
    const insertPartBefore = (containerPart, part, ref) => {
        const container = containerPart.startNode.parentNode;
        const beforeNode = ref ? ref.startNode : containerPart.endNode;
        const endNode = part.endNode.nextSibling;
        if (endNode !== beforeNode) {
            reparentNodes(container, part.startNode, endNode, beforeNode);
        }
    };
    const removePart = (part) => {
        removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);
    };
    // Helper for generating a map of array item to its index over a subset
    // of an array (used to lazily generate `newKeyToIndexMap` and
    // `oldKeyToIndexMap`)
    const generateMap = (list, start, end) => {
        const map = new Map();
        for (let i = start; i <= end; i++) {
            map.set(list[i], i);
        }
        return map;
    };
    // Stores previous ordered list of parts and map of key to index
    const partListCache = new WeakMap();
    const keyListCache = new WeakMap();
    /**
     * A directive that repeats a series of values (usually `TemplateResults`)
     * generated from an iterable, and updates those items efficiently when the
     * iterable changes based on user-provided `keys` associated with each item.
     *
     * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,
     * meaning previous DOM for a given key is moved into the new position if
     * needed, and DOM will never be reused with values for different keys (new DOM
     * will always be created for new keys). This is generally the most efficient
     * way to use `repeat` since it performs minimum unnecessary work for insertions
     * and removals.
     *
     * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a
     * given call to `repeat`. The behavior when two or more items have the same key
     * is undefined.
     *
     * If no `keyFn` is provided, this directive will perform similar to mapping
     * items to values, and DOM will be reused against potentially different items.
     */
    const repeat$1 = directive((items, keyFnOrTemplate, template) => {
        let keyFn;
        if (template === undefined) {
            template = keyFnOrTemplate;
        }
        else if (keyFnOrTemplate !== undefined) {
            keyFn = keyFnOrTemplate;
        }
        return (containerPart) => {
            if (!(containerPart instanceof NodePart)) {
                throw new Error('repeat can only be used in text bindings');
            }
            // Old part & key lists are retrieved from the last update
            // (associated with the part for this instance of the directive)
            const oldParts = partListCache.get(containerPart) || [];
            const oldKeys = keyListCache.get(containerPart) || [];
            // New part list will be built up as we go (either reused from
            // old parts or created for new keys in this update). This is
            // saved in the above cache at the end of the update.
            const newParts = [];
            // New value list is eagerly generated from items along with a
            // parallel array indicating its key.
            const newValues = [];
            const newKeys = [];
            let index = 0;
            for (const item of items) {
                newKeys[index] = keyFn ? keyFn(item, index) : index;
                newValues[index] = template(item, index);
                index++;
            }
            // Maps from key to index for current and previous update; these
            // are generated lazily only when needed as a performance
            // optimization, since they are only required for multiple
            // non-contiguous changes in the list, which are less common.
            let newKeyToIndexMap;
            let oldKeyToIndexMap;
            // Head and tail pointers to old parts and new values
            let oldHead = 0;
            let oldTail = oldParts.length - 1;
            let newHead = 0;
            let newTail = newValues.length - 1;
            // Overview of O(n) reconciliation algorithm (general approach
            // based on ideas found in ivi, vue, snabbdom, etc.):
            //
            // * We start with the list of old parts and new values (and
            //   arrays of their respective keys), head/tail pointers into
            //   each, and we build up the new list of parts by updating
            //   (and when needed, moving) old parts or creating new ones.
            //   The initial scenario might look like this (for brevity of
            //   the diagrams, the numbers in the array reflect keys
            //   associated with the old parts or new values, although keys
            //   and parts/values are actually stored in parallel arrays
            //   indexed using the same head/tail pointers):
            //
            //      oldHead v                 v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [ ,  ,  ,  ,  ,  ,  ]
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new
            //                                      item order
            //      newHead ^                 ^ newTail
            //
            // * Iterate old & new lists from both sides, updating,
            //   swapping, or removing parts at the head/tail locations
            //   until neither head nor tail can move.
            //
            // * Example below: keys at head pointers match, so update old
            //   part 0 in-place (no need to move it) and record part 0 in
            //   the `newParts` list. The last thing we do is advance the
            //   `oldHead` and `newHead` pointers (will be reflected in the
            //   next diagram).
            //
            //      oldHead v                 v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
            //                                      & newHead
            //      newHead ^                 ^ newTail
            //
            // * Example below: head pointers don't match, but tail
            //   pointers do, so update part 6 in place (no need to move
            //   it), and record part 6 in the `newParts` list. Last,
            //   advance the `oldTail` and `oldHead` pointers.
            //
            //         oldHead v              v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail
            //                                      & newTail
            //         newHead ^              ^ newTail
            //
            // * If neither head nor tail match; next check if one of the
            //   old head/tail items was removed. We first need to generate
            //   the reverse map of new keys to index (`newKeyToIndexMap`),
            //   which is done once lazily as a performance optimization,
            //   since we only hit this case if multiple non-contiguous
            //   changes were made. Note that for contiguous removal
            //   anywhere in the list, the head and tails would advance
            //   from either end and pass each other before we get to this
            //   case and removals would be handled in the final while loop
            //   without needing to generate the map.
            //
            // * Example below: The key at `oldTail` was removed (no longer
            //   in the `newKeyToIndexMap`), so remove that part from the
            //   DOM and advance just the `oldTail` pointer.
            //
            //         oldHead v           v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail
            //         newHead ^           ^ newTail
            //
            // * Once head and tail cannot move, any mismatches are due to
            //   either new or moved items; if a new key is in the previous
            //   "old key to old index" map, move the old part to the new
            //   location, otherwise create and insert a new part. Note
            //   that when moving an old part we null its position in the
            //   oldParts array if it lies between the head and tail so we
            //   know to skip it when the pointers get there.
            //
            // * Example below: neither head nor tail match, and neither
            //   were removed; so find the `newHead` key in the
            //   `oldKeyToIndexMap`, and move that old part's DOM into the
            //   next head position (before `oldParts[oldHead]`). Last,
            //   null the part in the `oldPart` array since it was
            //   somewhere in the remaining oldParts still to be scanned
            //   (between the head and tail pointers) so that we know to
            //   skip that old part on future iterations.
            //
            //         oldHead v        v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance
            //                                      newHead
            //         newHead ^           ^ newTail
            //
            // * Note that for moves/insertions like the one above, a part
            //   inserted at the head pointer is inserted before the
            //   current `oldParts[oldHead]`, and a part inserted at the
            //   tail pointer is inserted before `newParts[newTail+1]`. The
            //   seeming asymmetry lies in the fact that new parts are
            //   moved into place outside in, so to the right of the head
            //   pointer are old parts, and to the right of the tail
            //   pointer are new parts.
            //
            // * We always restart back from the top of the algorithm,
            //   allowing matching and simple updates in place to
            //   continue...
            //
            // * Example below: the head pointers once again match, so
            //   simply update part 1 and record it in the `newParts`
            //   array.  Last, advance both head pointers.
            //
            //         oldHead v        v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
            //                                      & newHead
            //            newHead ^        ^ newTail
            //
            // * As mentioned above, items that were moved as a result of
            //   being stuck (the final else clause in the code below) are
            //   marked with null, so we always advance old pointers over
            //   these so we're comparing the next actual old value on
            //   either end.
            //
            // * Example below: `oldHead` is null (already placed in
            //   newParts), so advance `oldHead`.
            //
            //            oldHead v     v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:
            //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
            //               newHead ^     ^ newTail
            //
            // * Note it's not critical to mark old parts as null when they
            //   are moved from head to tail or tail to head, since they
            //   will be outside the pointer range and never visited again.
            //
            // * Example below: Here the old tail key matches the new head
            //   key, so the part at the `oldTail` position and move its
            //   DOM to the new head position (before `oldParts[oldHead]`).
            //   Last, advance `oldTail` and `newHead` pointers.
            //
            //               oldHead v  v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,
            //                                     advance oldTail & newHead
            //               newHead ^     ^ newTail
            //
            // * Example below: Old and new head keys match, so update the
            //   old head part in place, and advance the `oldHead` and
            //   `newHead` pointers.
            //
            //               oldHead v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &
            //                                      newHead
            //                  newHead ^  ^ newTail
            //
            // * Once the new or old pointers move past each other then all
            //   we have left is additions (if old list exhausted) or
            //   removals (if new list exhausted). Those are handled in the
            //   final while loops at the end.
            //
            // * Example below: `oldHead` exceeded `oldTail`, so we're done
            //   with the main loop.  Create the remaining part and insert
            //   it at the new head position, and the update is complete.
            //
            //                   (oldHead > oldTail)
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
            //                     newHead ^ newTail
            //
            // * Note that the order of the if/else clauses is not
            //   important to the algorithm, as long as the null checks
            //   come first (to ensure we're always working on valid old
            //   parts) and that the final else clause comes last (since
            //   that's where the expensive moves occur). The order of
            //   remaining clauses is is just a simple guess at which cases
            //   will be most common.
            //
            // * TODO(kschaaf) Note, we could calculate the longest
            //   increasing subsequence (LIS) of old items in new position,
            //   and only move those not in the LIS set. However that costs
            //   O(nlogn) time and adds a bit more code, and only helps
            //   make rare types of mutations require fewer moves. The
            //   above handles removes, adds, reversal, swaps, and single
            //   moves of contiguous items in linear time, in the minimum
            //   number of moves. As the number of multiple moves where LIS
            //   might help approaches a random shuffle, the LIS
            //   optimization becomes less helpful, so it seems not worth
            //   the code at this point. Could reconsider if a compelling
            //   case arises.
            while (oldHead <= oldTail && newHead <= newTail) {
                if (oldParts[oldHead] === null) {
                    // `null` means old part at head has already been used
                    // below; skip
                    oldHead++;
                }
                else if (oldParts[oldTail] === null) {
                    // `null` means old part at tail has already been used
                    // below; skip
                    oldTail--;
                }
                else if (oldKeys[oldHead] === newKeys[newHead]) {
                    // Old head matches new head; update in place
                    newParts[newHead] =
                        updatePart(oldParts[oldHead], newValues[newHead]);
                    oldHead++;
                    newHead++;
                }
                else if (oldKeys[oldTail] === newKeys[newTail]) {
                    // Old tail matches new tail; update in place
                    newParts[newTail] =
                        updatePart(oldParts[oldTail], newValues[newTail]);
                    oldTail--;
                    newTail--;
                }
                else if (oldKeys[oldHead] === newKeys[newTail]) {
                    // Old head matches new tail; update and move to new tail
                    newParts[newTail] =
                        updatePart(oldParts[oldHead], newValues[newTail]);
                    insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);
                    oldHead++;
                    newTail--;
                }
                else if (oldKeys[oldTail] === newKeys[newHead]) {
                    // Old tail matches new head; update and move to new head
                    newParts[newHead] =
                        updatePart(oldParts[oldTail], newValues[newHead]);
                    insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);
                    oldTail--;
                    newHead++;
                }
                else {
                    if (newKeyToIndexMap === undefined) {
                        // Lazily generate key-to-index maps, used for removals &
                        // moves below
                        newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
                        oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
                    }
                    if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
                        // Old head is no longer in new list; remove
                        removePart(oldParts[oldHead]);
                        oldHead++;
                    }
                    else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
                        // Old tail is no longer in new list; remove
                        removePart(oldParts[oldTail]);
                        oldTail--;
                    }
                    else {
                        // Any mismatches at this point are due to additions or
                        // moves; see if we have an old part we can reuse and move
                        // into place
                        const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
                        const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;
                        if (oldPart === null) {
                            // No old part for this value; create a new one and
                            // insert it
                            const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);
                            updatePart(newPart, newValues[newHead]);
                            newParts[newHead] = newPart;
                        }
                        else {
                            // Reuse old part
                            newParts[newHead] =
                                updatePart(oldPart, newValues[newHead]);
                            insertPartBefore(containerPart, oldPart, oldParts[oldHead]);
                            // This marks the old part as having been used, so that
                            // it will be skipped in the first two checks above
                            oldParts[oldIndex] = null;
                        }
                        newHead++;
                    }
                }
            }
            // Add parts for any remaining new values
            while (newHead <= newTail) {
                // For all remaining additions, we insert before last new
                // tail, since old pointers are no longer valid
                const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);
                updatePart(newPart, newValues[newHead]);
                newParts[newHead++] = newPart;
            }
            // Remove any remaining unused old parts
            while (oldHead <= oldTail) {
                const oldPart = oldParts[oldHead++];
                if (oldPart !== null) {
                    removePart(oldPart);
                }
            }
            // Save order of new parts for next round
            partListCache.set(containerPart, newParts);
            keyListCache.set(containerPart, newKeys);
        };
    });

    let Canvas = class Canvas extends EditorElement {
        constructor() {
            super(...arguments);
            this.tables = [];
            this.memos = [];
            this.userMouseList = [];
        }
        get virtualTables() {
            const { width, height, scrollLeft, scrollTop, } = this.context.store.canvasState;
            const minX = scrollLeft;
            const minY = scrollTop;
            const maxX = minX + width;
            const maxY = minY + height;
            return this.tables.filter((table) => virtualTable({
                minX,
                minY,
                maxX,
                maxY,
            }, table));
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.tables = store.tableState.tables;
            this.memos = store.memoState.memos;
            this.userMouseList = store.shareState.userMouseList;
            this.subscriptionList.push(store.observe(this.tables, () => this.requestUpdate()), store.observe(this.memos, () => this.requestUpdate()), store.observe(this.userMouseList, () => this.requestUpdate()), store.observe(store.canvasState, (name) => {
                switch (name) {
                    case "width":
                    case "height":
                        this.requestUpdate();
                        break;
                }
            }), store.observe(store.canvasState.show, (name) => {
                if (name === "relationship") {
                    this.requestUpdate();
                }
            }));
        }
        render() {
            const { width, height } = this.context.store.canvasState;
            const { show } = this.context.store.canvasState;
            return html `
      <div
        class="vuerd-canvas"
        style=${styleMap({
                width: `${width}px`,
                height: `${height}px`,
            })}
      >
        ${repeat$1(this.tables, (table) => table.id, (table) => html `<vuerd-table .table=${table}></vuerd-table>`)}
        ${repeat$1(this.memos, (memo) => memo.id, (memo) => html `<vuerd-memo .memo=${memo}></vuerd-memo>`)}
        ${show.relationship ? html `<vuerd-canvas-svg></vuerd-canvas-svg>` : ""}
        ${repeat$1(this.userMouseList, (userMouse) => userMouse.id, (userMouse) => html `
              <vuerd-share-mouse .userMouse=${userMouse}></vuerd-share-mouse>
            `)}
      </div>
    `;
        }
    };
    Canvas = __decorate([
        customElement("vuerd-canvas")
    ], Canvas);

    function createRelationship$1(relationship, strokeWidth = 3) {
        let shape = svg ``;
        const relationshipPath = getRelationshipPath(relationship);
        const { path, line } = relationshipPath;
        switch (relationship.relationshipType) {
            case "ZeroOneN":
                shape = relationshipZeroOneN(relationshipPath);
                break;
            case "ZeroOne":
                shape = relationshipZeroOne(relationshipPath);
                break;
            case "ZeroN":
                shape = relationshipZeroN(relationshipPath);
                break;
            case "OneOnly":
                shape = relationshipOneOnly(relationshipPath);
                break;
            case "OneN":
                shape = relationshipOneN(relationshipPath);
                break;
            case "One":
                shape = relationshipOne(relationshipPath);
                break;
            case "N":
                shape = relationshipN(relationshipPath);
                break;
        }
        return svg `
    <!-- start -->
    <line
      x1=${path.line.start.x1} y1=${path.line.start.y1}
      x2=${path.line.start.x2} y2=${path.line.start.y2}
      stroke-width="3"
    ></line>
    <path
      d=${path.path.d()}
      stroke-dasharray=${relationship.identification ? 0 : 10}
      stroke-width=${strokeWidth}
      fill="transparent"
    ></path>
    <line
      x1=${line.line.start.x1} y1=${line.line.start.y1}
      x2=${line.line.start.x2} y2=${line.line.start.y2}
      stroke-width="3"
    ></line>
    <!-- end -->
    ${shape}
  `;
    }
    function relationshipZeroOneN({ path, line }) {
        return svg `
    <!-- end -->
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <circle
      cx=${line.circle.cx} cy=${line.circle.cy} r="8"
      fill-opacity="0.0"
      stroke-width="3"
    ></circle>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center.x1} y1=${line.line.end.center.y1}
      x2=${line.line.end.center.x2} y2=${line.line.end.center.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="3"
    ></line>
  `;
    }
    function relationshipZeroOne({ path, line }) {
        return svg `
    <!-- end -->
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <circle
      cx=${line.circle.cx} cy=${line.circle.cy} r="8"
      fill-opacity="0.0"
      stroke-width="3"
    ></circle>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center.x1} y1=${line.line.end.center.y1}
      x2=${line.line.end.center.x2} y2=${line.line.end.center.y2}
      stroke-width="3"
    ></line>
  `;
    }
    function relationshipZeroN({ path, line }) {
        return svg `
    <!-- end -->
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <circle
      cx=${line.circle.cx} cy=${line.circle.cy} r="8"
      fill-opacity="0.0"
      stroke-width="3"
    ></circle>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center.x1} y1=${line.line.end.center.y1}
      x2=${line.line.end.center.x2} y2=${line.line.end.center.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="3"
    ></line>
  `;
    }
    function relationshipOneOnly({ path, line }) {
        return svg `
    <!-- end -->
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.base2.x1} y1=${line.line.end.base2.y1}
      x2=${line.line.end.base2.x2} y2=${line.line.end.base2.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="3"
    ></line>
  `;
    }
    function relationshipOneN({ path, line }) {
        return svg `
    <!-- end -->
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="3"
    ></line>
  `;
    }
    function relationshipOne({ path, line }) {
        return svg `
    <!-- end -->
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="3"
    ></line>
  `;
    }
    function relationshipN({ path, line }) {
        return svg `
    <!-- end -->
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="3"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="3"
    ></line>
  `;
    }

    let CanvasSVG = class CanvasSVG extends EditorElement {
        constructor() {
            super(...arguments);
            this.activeId = "";
            this.relationships = [];
            this.subRelationships = [];
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.relationships = store.relationshipState.relationships;
            this.subscriptionList.push(store.observe(store.canvasState.show, () => this.requestUpdate()), store.observe(this.relationships, () => {
                this.unsubscribeRelationships();
                this.observeRelationships();
                this.requestUpdate();
            }), store.observe(store.canvasState, (name) => {
                switch (name) {
                    case "width":
                    case "height":
                        this.requestUpdate();
                        break;
                }
            }));
            this.observeRelationships();
        }
        disconnectedCallback() {
            this.unsubscribeRelationships();
            super.disconnectedCallback();
        }
        render() {
            const { width, height } = this.context.store.canvasState;
            return svg `
      <svg 
        class="vuerd-canvas-svg"
        style=${styleMap({
                width: `${width}px`,
                height: `${height}px`,
            })}
      >
      ${repeat$1(this.relationships, (relationship) => relationship.id, (relationship) => {
                const shape = createRelationship$1(relationship);
                return svg `
            <g
              class=${classMap({
                    "vuerd-relationship": true,
                    identification: relationship.identification &&
                        this.activeId !== relationship.id,
                    active: this.activeId === relationship.id,
                })}
              data-id=${relationship.id}
              @mouseover=${() => this.onMouseover(relationship)}
              @mouseleave=${() => this.onMouseleave(relationship)}
            >
              ${shape}
            </g>
          `;
            })}
      </svg>
    `;
        }
        onMouseover(relationship) {
            const { store } = this.context;
            store.dispatch(activeColumn(relationship));
            this.activeId = relationship.id;
        }
        onMouseleave(relationship) {
            const { store } = this.context;
            store.dispatch(activeEndColumn(relationship));
            this.activeId = "";
        }
        observeRelationships() {
            const { store } = this.context;
            this.relationships.forEach((relationship) => {
                this.subRelationships.push(store.observe(relationship, () => this.requestUpdate()), store.observe(relationship.start, () => this.requestUpdate()), store.observe(relationship.end, () => this.requestUpdate()));
            });
        }
        unsubscribeRelationships() {
            this.subRelationships.forEach((sub) => sub.unsubscribe());
            this.subRelationships = [];
        }
    };
    __decorate([
        property({ type: String })
    ], CanvasSVG.prototype, "activeId", void 0);
    CanvasSVG = __decorate([
        customElement("vuerd-canvas-svg")
    ], CanvasSVG);

    class FlipAnimation {
        constructor(root, selector, animationName) {
            this.flipSnapshots = [];
            this.root = root;
            this.selector = selector;
            this.animationName = animationName;
        }
        snapshot() {
            this.flipSnapshots = [];
            this.root.querySelectorAll(this.selector).forEach((el) => {
                // first
                const { top, left } = el.getBoundingClientRect();
                this.flipSnapshots.push({ el, top, left });
            });
        }
        play() {
            if (this.flipSnapshots.length !== 0) {
                this.flipSnapshots.forEach((snapshot) => {
                    // last
                    const el = snapshot.el;
                    const { top, left } = el.getBoundingClientRect();
                    const dx = snapshot.left - left;
                    const dy = snapshot.top - top;
                    if (dx || dy) {
                        // invert
                        el.style.transform = `translate(${dx}px,${dy}px)`;
                        el.style.transitionDuration = "0s";
                        // play
                        requestAnimationFrame(() => {
                            el.classList.add(this.animationName);
                            el.style.transform = "";
                            el.style.transitionDuration = "";
                            const onTransitionend = () => {
                                el.classList.remove(this.animationName);
                                el.removeEventListener("transitionend", onTransitionend);
                            };
                            el.addEventListener("transitionend", onTransitionend);
                        });
                    }
                });
                this.flipSnapshots = [];
            }
        }
    }
    class AnimationFrame {
        constructor(millisecond) {
            this.subAnimationFrame = null;
            this.onUpdate = () => { };
            this.onComplete = () => { };
            this.update = (effect) => {
                this.onUpdate = effect;
                return this;
            };
            this.complete = (effect) => {
                this.onComplete = effect;
                return this;
            };
            this.start = () => {
                this.stop();
                if (this.from && this.to) {
                    this.subAnimationFrame = of(animationFrameScheduler.now(), animationFrameScheduler)
                        .pipe(repeat(), takeUntil(timer(this.millisecond)), map((start) => animationFrameScheduler.now() - start))
                        .subscribe({
                            next: (current) => {
                                const progressRate = current / this.millisecond;
                                const from = this.from;
                                const to = this.to;
                                const currentValue = {};
                                Object.keys(from).forEach((key) => {
                                    if (typeof from[key] === "number" &&
                                        typeof to[key] === "number") {
                                        const start = from[key];
                                        const end = to[key];
                                        const range = Math.abs(end - start);
                                        if (start < end) {
                                            currentValue[key] = range * progressRate + start;
                                            if (currentValue[key] > end) {
                                                currentValue[key] = end;
                                            }
                                        }
                                        else {
                                            currentValue[key] = (range * progressRate - start) * -1;
                                            if (currentValue[key] < end) {
                                                currentValue[key] = end;
                                            }
                                        }
                                    }
                                });
                                this.onUpdate(currentValue);
                            },
                            complete: () => {
                                this.onUpdate(this.to);
                                this.onComplete();
                            },
                        });
                }
                return this;
            };
            this.millisecond = millisecond;
        }
        play(from, to, millisecond) {
            const { update, start, complete } = this;
            this.stop();
            this.from = from;
            this.to = to;
            if (millisecond !== undefined) {
                this.millisecond = millisecond;
            }
            return {
                update(effect) {
                    update(effect);
                    return this;
                },
                complete(effect) {
                    complete(effect);
                    return this;
                },
                start() {
                    return start();
                },
            };
        }
        stop() {
            var _a;
            (_a = this.subAnimationFrame) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this.subAnimationFrame = null;
            return this;
        }
    }

    const MEMO_PADDING$1 = SIZE_MEMO_PADDING * 2;
    const MEMO_HEADER = 17 + SIZE_MEMO_PADDING;
    let Memo$1 = class Memo extends EditorElement {
        constructor() {
            super(...arguments);
            this.subMoveEnd = null;
            this.subMove = null;
            this.x = 0;
            this.y = 0;
            this.animationFrameX = new AnimationFrame(200);
            this.animationFrameY = new AnimationFrame(200);
            this.onMoveEnd = (event) => {
                var _a, _b;
                const { eventBus } = this.context;
                (_a = this.subMoveEnd) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                (_b = this.subMove) === null || _b === void 0 ? void 0 : _b.unsubscribe();
                this.subMoveEnd = null;
                this.subMove = null;
                eventBus.emit(Bus.Table.moveValid);
                eventBus.emit(Bus.Memo.moveValid);
            };
            this.onMove = ({ event, movementX, movementY }) => {
                if (event.type === "mousemove") {
                    event.preventDefault();
                }
                const { store } = this.context;
                store.dispatch(moveMemo(store, event.ctrlKey || event.metaKey, movementX, movementY, this.memo.id));
            };
            this.onMoveValid = () => {
                const { width, height } = this.context.store.canvasState;
                let x = 0;
                let y = SIZE_MENUBAR_HEIGHT;
                const minWidth = width - (this.memo.ui.width + MEMO_PADDING$1);
                const minHeight = height - (this.memo.ui.height + MEMO_PADDING$1 + MEMO_HEADER);
                if (this.memo.ui.left > minWidth) {
                    x = minWidth;
                }
                if (this.memo.ui.top > minHeight) {
                    y = minHeight;
                }
                if (this.memo.ui.left < 0 || this.memo.ui.left > minWidth) {
                    this.animationFrameX
                        .play({ x: this.memo.ui.left }, { x })
                        .update((value) => (this.memo.ui.left = value.x))
                        .start();
                }
                if (this.memo.ui.top < SIZE_MENUBAR_HEIGHT ||
                    this.memo.ui.top > minHeight) {
                    this.animationFrameY
                        .play({ y: this.memo.ui.top }, { y })
                        .update((value) => (this.memo.ui.top = value.y))
                        .start();
                }
            };
        }
        get width() {
            const { ui } = this.memo;
            return ui.width + MEMO_PADDING$1;
        }
        get height() {
            const { ui } = this.memo;
            return ui.height + MEMO_PADDING$1 + MEMO_HEADER;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus } = this.context;
            this.subscriptionList.push(store.observe(this.memo.ui, () => this.requestUpdate()), store.observe(this.memo, () => this.requestUpdate()), eventBus.on(Bus.Memo.moveValid).subscribe(this.onMoveValid));
        }
        firstUpdated() {
            const { store } = this.context;
            const textarea = this.renderRoot.querySelector("textarea");
            if (store.editorState.focus) {
                textarea.focus();
            }
        }
        disconnectedCallback() {
            this.onMoveEnd();
            super.disconnectedCallback();
        }
        render() {
            const { ui } = this.memo;
            const { keymap } = this.context;
            const keymapRemoveTable = keymapOptionToString(keymap.removeTable[0]);
            return html `
      <div
        class=${classMap({
                "vuerd-memo": true,
                active: ui.active,
            })}
        style=${styleMap({
                top: `${ui.top}px`,
                left: `${ui.left}px`,
                zIndex: `${ui.zIndex}`,
                width: `${this.width}px`,
                height: `${this.height}px`,
            })}
        @mousedown=${this.onMoveStart}
        @touchstart=${this.onMoveStart}
      >
        <div class="vuerd-memo-header">
          <vuerd-icon
            class="vuerd-button"
            title=${keymapRemoveTable}
            icon="times"
            size="12"
            @click=${this.onRemoveMemo}
          ></vuerd-icon>
        </div>
        <div class="vuerd-memo-body">
          <textarea
            class="vuerd-memo-textarea vuerd-scrollbar"
            style=${styleMap({
                width: `${ui.width}px`,
                height: `${ui.height}px`,
            })}
            spellcheck="false"
            .value=${this.memo.value}
            @input=${this.onInput}
          ></textarea>
        </div>
        <vuerd-sash
          vertical
          @mousedown=${(event) => this.onMousedownSash(event, "left")}
        ></vuerd-sash>
        <vuerd-sash
          vertical
          .left=${this.width}
          @mousedown=${(event) => this.onMousedownSash(event, "right")}
        ></vuerd-sash>
        <vuerd-sash
          horizontal
          @mousedown=${(event) => this.onMousedownSash(event, "top")}
        ></vuerd-sash>
        <vuerd-sash
          horizontal
          .top=${this.height}
          @mousedown=${(event) => this.onMousedownSash(event, "bottom")}
        ></vuerd-sash>
        <vuerd-sash
          edge
          cursor="nw-resize"
          @mousedown=${(event) => this.onMousedownSash(event, "lt")}
        ></vuerd-sash>
        <vuerd-sash
          edge
          cursor="ne-resize"
          .left=${this.width}
          @mousedown=${(event) => this.onMousedownSash(event, "rt")}
        ></vuerd-sash>
        <vuerd-sash
          edge
          cursor="ne-resize"
          .top=${this.height}
          @mousedown=${(event) => this.onMousedownSash(event, "lb")}
        ></vuerd-sash>
        <vuerd-sash
          edge
          cursor="nw-resize"
          .left=${this.width}
          .top=${this.height}
          @mousedown=${(event) => this.onMousedownSash(event, "rb")}
        ></vuerd-sash>
      </div>
    `;
        }
        onMoveStart(event) {
            const el = event.target;
            if (!el.closest(".vuerd-button") &&
                !el.closest(".vuerd-sash") &&
                !el.closest(".vuerd-memo-textarea")) {
                const { moveEnd$, move$ } = this.context.windowEventObservable;
                this.onMoveEnd();
                this.subMoveEnd = moveEnd$.subscribe(this.onMoveEnd);
                this.subMove = move$.subscribe(this.onMove);
            }
            const { store } = this.context;
            store.dispatch(selectMemo(store, event.ctrlKey || event.metaKey, this.memo.id));
        }
        onRemoveMemo(event) {
            const { store } = this.context;
            store.dispatch(removeMemo(store, this.memo.id));
        }
        onInput(event) {
            const { store } = this.context;
            const textarea = event.target;
            store.dispatch(changeMemoValue(this.memo.id, textarea.value));
        }
        onMousedownSash(event, position) {
            this.x = event.clientX;
            this.y = event.clientY;
            const { moveEnd$, move$ } = this.context.windowEventObservable;
            this.onMoveEnd();
            this.subMoveEnd = moveEnd$.subscribe(this.onMoveEnd);
            this.subMove = move$.subscribe((move) => {
                this.onMousemoveSash(move, position);
            });
        }
        onMousemoveSash(move, position) {
            move.event.preventDefault();
            const { store } = this.context;
            let verticalUI = null;
            let horizontalUI = null;
            switch (position) {
                case "left":
                case "right":
                    verticalUI = this.resizeWidth(move, position);
                    break;
                case "top":
                case "bottom":
                    horizontalUI = this.resizeHeight(move, position);
                    break;
                case "lt":
                    verticalUI = this.resizeWidth(move, "left");
                    horizontalUI = this.resizeHeight(move, "top");
                    break;
                case "rt":
                    verticalUI = this.resizeWidth(move, "right");
                    horizontalUI = this.resizeHeight(move, "top");
                    break;
                case "lb":
                    verticalUI = this.resizeWidth(move, "left");
                    horizontalUI = this.resizeHeight(move, "bottom");
                    break;
                case "rb":
                    verticalUI = this.resizeWidth(move, "right");
                    horizontalUI = this.resizeHeight(move, "bottom");
                    break;
            }
            if ((verticalUI === null || verticalUI === void 0 ? void 0 : verticalUI.change) && (horizontalUI === null || horizontalUI === void 0 ? void 0 : horizontalUI.change)) {
                store.dispatch(resizeMemo(this.memo.id, horizontalUI.top, verticalUI.left, verticalUI.width, horizontalUI.height));
            }
            else if (verticalUI === null || verticalUI === void 0 ? void 0 : verticalUI.change) {
                store.dispatch(resizeMemo(this.memo.id, verticalUI.top, verticalUI.left, verticalUI.width, verticalUI.height));
            }
            else if (horizontalUI === null || horizontalUI === void 0 ? void 0 : horizontalUI.change) {
                store.dispatch(resizeMemo(this.memo.id, horizontalUI.top, horizontalUI.left, horizontalUI.width, horizontalUI.height));
            }
        }
        resizeWidth({ movementX, x }, direction) {
            const ui = Object.assign({ change: false }, this.memo.ui);
            const mouseDirection = movementX < 0 ? "left" : "right";
            const width = direction === "left" ? ui.width - movementX : ui.width + movementX;
            switch (mouseDirection) {
                case "left":
                    if (SIZE_MEMO_WIDTH < width && x < this.x) {
                        ui.width = width;
                        if (direction === "left") {
                            ui.left += movementX;
                        }
                        this.x += movementX;
                        ui.change = true;
                    }
                    break;
                case "right":
                    if (SIZE_MEMO_WIDTH < width && x > this.x) {
                        ui.width = width;
                        if (direction === "left") {
                            ui.left += movementX;
                        }
                        this.x += movementX;
                        ui.change = true;
                    }
                    break;
            }
            return ui;
        }
        resizeHeight({ movementY, y }, direction) {
            const ui = Object.assign({ change: false }, this.memo.ui);
            const mouseDirection = movementY < 0 ? "top" : "bottom";
            const height = direction === "top" ? ui.height - movementY : ui.height + movementY;
            switch (mouseDirection) {
                case "top":
                    if (SIZE_MEMO_HEIGHT < height && y < this.y) {
                        ui.height = height;
                        if (direction === "top") {
                            ui.top += movementY;
                        }
                        this.y += movementY;
                        ui.change = true;
                    }
                    break;
                case "bottom":
                    if (SIZE_MEMO_HEIGHT < height && y > this.y) {
                        ui.height = height;
                        if (direction === "top") {
                            ui.top += movementY;
                        }
                        this.y += movementY;
                        ui.change = true;
                    }
                    break;
            }
            return ui;
        }
    };
    Memo$1 = __decorate([
        customElement("vuerd-memo")
    ], Memo$1);

    const TABLE_PADDING$2 = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    let Table$1 = class Table extends EditorElement {
        constructor() {
            super(...arguments);
            this.draggable$ = new Subject();
            this.subMoveEnd = null;
            this.subMove = null;
            this.subFocusTable = null;
            this.subDraggableColumns = [];
            this.flipAnimation = new FlipAnimation(this.renderRoot, ".vuerd-column", "vuerd-column-move");
            this.animationFrameX = new AnimationFrame(200);
            this.animationFrameY = new AnimationFrame(200);
            this.onMoveEnd = (event) => {
                var _a, _b;
                const { eventBus } = this.context;
                (_a = this.subMoveEnd) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                (_b = this.subMove) === null || _b === void 0 ? void 0 : _b.unsubscribe();
                this.subMoveEnd = null;
                this.subMove = null;
                eventBus.emit(Bus.Table.moveValid);
                eventBus.emit(Bus.Memo.moveValid);
            };
            this.onMove = ({ event, movementX, movementY }) => {
                if (event.type === "mousemove") {
                    event.preventDefault();
                }
                const { store } = this.context;
                store.dispatch(moveTable(store, event.ctrlKey || event.metaKey, movementX, movementY, this.table.id));
            };
            this.onDragoverGroupColumn = (event) => {
                this.draggable$.next(event);
            };
            this.onDragoverColumn = (event) => {
                const { store } = this.context;
                const { draggableColumn } = store.editorState;
                const { tableId, columnId } = event.detail;
                if (draggableColumn &&
                    !draggableColumn.columnIds.some((id) => id === columnId)) {
                    this.flipAnimation.snapshot();
                    store.dispatch(moveColumn(draggableColumn.tableId, draggableColumn.columnIds, tableId, columnId));
                }
            };
            this.onMoveValid = () => {
                const { tables } = this.context.store.tableState;
                const { relationships } = this.context.store.relationshipState;
                const { width, height } = this.context.store.canvasState;
                let x = 0;
                let y = SIZE_MENUBAR_HEIGHT;
                const minWidth = width - (this.table.width() + TABLE_PADDING$2);
                const minHeight = height - (this.table.height() + TABLE_PADDING$2);
                if (this.table.ui.left > minWidth) {
                    x = minWidth;
                }
                if (this.table.ui.top > minHeight) {
                    y = minHeight;
                }
                if (this.table.ui.left < 0 || this.table.ui.left > minWidth) {
                    this.animationFrameX
                        .play({ x: this.table.ui.left }, { x })
                        .update((value) => {
                            this.table.ui.left = value.x;
                            relationshipSort(tables, relationships);
                        })
                        .start();
                }
                if (this.table.ui.top < SIZE_MENUBAR_HEIGHT ||
                    this.table.ui.top > minHeight) {
                    this.animationFrameY
                        .play({ y: this.table.ui.top }, { y })
                        .update((value) => {
                            this.table.ui.top = value.y;
                            relationshipSort(tables, relationships);
                        })
                        .start();
                }
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus } = this.context;
            this.subscriptionList.push(this.draggable$.pipe(debounceTime(50)).subscribe(this.onDragoverColumn), store.observe(this.table.ui, () => this.requestUpdate()), store.observe(this.table.columns, () => this.requestUpdate()), store.observe(store.canvasState.show, () => this.requestUpdate()), store.observe(store.editorState, (name) => {
                const { focusTable, draggableColumn } = store.editorState;
                switch (name) {
                    case "focusTable":
                        if (focusTable === null || focusTable.id !== this.table.id) {
                            this.unsubscribeFocusTable();
                        }
                        else if (this.subFocusTable === null &&
                            (focusTable === null || focusTable === void 0 ? void 0 : focusTable.id) === this.table.id) {
                            this.observeFocusTable();
                        }
                        this.requestUpdate();
                        break;
                    case "editTable":
                        if ((focusTable === null || focusTable === void 0 ? void 0 : focusTable.id) === this.table.id) {
                            this.requestUpdate();
                        }
                        break;
                    case "draggableColumn":
                        if (draggableColumn) {
                            if (this.subDraggableColumns.length === 0) {
                                this.onDraggableColumn();
                            }
                        }
                        else {
                            this.onDraggableEndColumn();
                            this.requestUpdate();
                        }
                        break;
                }
            }), eventBus.on(Bus.Table.moveValid).subscribe(this.onMoveValid));
            this.observeFocusTable();
        }
        updated(changedProperties) {
            this.flipAnimation.play();
        }
        disconnectedCallback() {
            this.onMoveEnd();
            this.unsubscribeFocusTable();
            super.disconnectedCallback();
        }
        render() {
            const { ui } = this.table;
            const { keymap } = this.context;
            const { show } = this.context.store.canvasState;
            const keymapAddColumn = keymapOptionToString(keymap.addColumn[0]);
            const keymapRemoveTable = keymapOptionToString(keymap.removeTable[0]);
            const widthColumn = this.table.maxWidthColumn();
            return html `
      <div
        class=${classMap({
                "vuerd-table": true,
                active: ui.active,
            })}
        style=${styleMap({
                top: `${ui.top}px`,
                left: `${ui.left}px`,
                zIndex: `${ui.zIndex}`,
                width: `${this.table.width()}px`,
                height: `${this.table.height()}px`,
            })}
        data-id=${this.table.id}
        @mousedown=${this.onMoveStart}
        @touchstart=${this.onMoveStart}
      >
        <div class="vuerd-table-header">
          <div class="vuerd-table-header-top">
            <vuerd-icon
              class="vuerd-button"
              title=${keymapRemoveTable}
              icon="times"
              size="12"
              @click=${this.onRemoveTable}
            ></vuerd-icon>
            <vuerd-icon
              class="vuerd-button"
              title=${keymapAddColumn}
              icon="plus"
              size="12"
              @click=${this.onAddColumn}
            ></vuerd-icon>
          </div>
          <div class="vuerd-table-header-body">
            <vuerd-input-edit
              class="vuerd-table-name"
              .width=${this.table.ui.widthName}
              .value=${this.table.name}
              .focusState=${this.focusTable("focusName")}
              .edit=${this.editTable("tableName")}
              placeholder="table"
              @blur=${this.onBlur}
              @input=${(event) => this.onInput(event, "tableName")}
              @mousedown=${(event) => this.onFocus(event, "tableName")}
              @dblclick=${(event) => this.onEdit(event, "tableName")}
            ></vuerd-input-edit>
            ${show.tableComment
                ? html `
                  <vuerd-input-edit
                    class="vuerd-table-comment"
                    .width=${this.table.ui.widthComment}
                    .value=${this.table.comment}
                    .focusState=${this.focusTable("focusComment")}
                    .edit=${this.editTable("tableComment")}
                    placeholder=""
                    @blur=${this.onBlur}
                    @input=${(event) => this.onInput(event, "tableComment")}
                    @mousedown=${(event) => this.onFocus(event, "tableComment")}
                    @dblclick=${(event) => this.onEdit(event, "tableComment")}
                  ></vuerd-input-edit>
                `
                : ""}
          </div>
        </div>
        <div class="vuerd-table-body">
          ${repeat$1(this.table.columns, (column) => column.id, (column) => html `
                <vuerd-column
                  .tableId=${this.table.id}
                  .column=${column}
                  .select=${this.selectColumn(column)}
                  .draggable=${this.draggableColumn(column)}
                  .focusName=${this.focusColumn(column, "columnName")}
                  .focusDataType=${this.focusColumn(column, "columnDataType")}
                  .focusNotNull=${this.focusColumn(column, "columnNotNull")}
                  .focusDefault=${this.focusColumn(column, "columnDefault")}
                  .focusComment=${this.focusColumn(column, "columnComment")}
                  .focusUnique=${this.focusColumn(column, "columnUnique")}
                  .focusAutoIncrement=${this.focusColumn(column, "columnAutoIncrement")}
                  .editName=${this.editColumn(column, "columnName")}
                  .editDataType=${this.editColumn(column, "columnDataType")}
                  .editDefault=${this.editColumn(column, "columnDefault")}
                  .editComment=${this.editColumn(column, "columnComment")}
                  .widthName=${widthColumn.name}
                  .widthDataType=${widthColumn.dataType}
                  .widthNotNull=${widthColumn.notNull}
                  .widthDefault=${widthColumn.default}
                  .widthComment=${widthColumn.comment}
                  @request-update=${() => this.requestUpdate()}
                ></vuerd-column>
              `)}
        </div>
      </div>
    `;
        }
        onMoveStart(event) {
            const el = event.target;
            if (!el.closest(".vuerd-button") && !el.closest("vuerd-input-edit")) {
                const { moveEnd$, move$ } = this.context.windowEventObservable;
                this.onMoveEnd();
                this.subMoveEnd = moveEnd$.subscribe(this.onMoveEnd);
                this.subMove = move$.subscribe(this.onMove);
            }
            if (!el.closest("vuerd-input-edit")) {
                const { store } = this.context;
                store.dispatch(selectTable(store, event.ctrlKey || event.metaKey, this.table.id));
            }
        }
        onDraggableColumn() {
            const nodeList = this.renderRoot.querySelectorAll("vuerd-column");
            nodeList.forEach((node) => {
                this.subDraggableColumns.push(fromEvent(node, "dragover")
                    .pipe(throttleTime(300))
                    .subscribe(this.onDragoverGroupColumn));
            });
        }
        onDraggableEndColumn() {
            this.subDraggableColumns.forEach((sub) => sub.unsubscribe());
            this.subDraggableColumns = [];
        }
        onAddColumn(event) {
            const selection = window.getSelection();
            if (selection) {
                selection.removeAllRanges();
            }
            const { store } = this.context;
            store.dispatch(addColumn(store, this.table.id));
        }
        onRemoveTable(event) {
            const { store } = this.context;
            store.dispatch(removeTable(store, this.table.id));
        }
        onInput(event, focusType) {
            const { store, helper } = this.context;
            const input = event.target;
            switch (focusType) {
                case "tableName":
                    store.dispatch(changeTableName(helper, this.table.id, input.value));
                    break;
                case "tableComment":
                    store.dispatch(changeTableComment(helper, this.table.id, input.value));
                    break;
            }
        }
        onBlur(event) {
            const { store } = this.context;
            store.dispatch(editTableEnd());
        }
        onFocus(event, focusType) {
            const { store } = this.context;
            const { editTable, focusTable } = store.editorState;
            if (editTable === null ||
                editTable.focusType !== focusType ||
                focusTable === null ||
                focusTable.id !== this.table.id) {
                store.dispatch(selectTable(store, event.ctrlKey || event.metaKey, this.table.id), focusTargetTable(focusType));
            }
        }
        onEdit(event, focusType) {
            const { store } = this.context;
            const { editTable: editTable$1, focusTable } = store.editorState;
            if (focusTable !== null && editTable$1 === null) {
                store.dispatch(editTable(this.table.id, focusType));
            }
        }
        observeFocusTable() {
            var _a;
            const { store } = this.context;
            if (((_a = store.editorState.focusTable) === null || _a === void 0 ? void 0 : _a.id) === this.table.id) {
                this.subFocusTable = store.observe(store.editorState.focusTable, () => this.requestUpdate());
            }
        }
        unsubscribeFocusTable() {
            var _a;
            (_a = this.subFocusTable) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this.subFocusTable = null;
        }
        focusTable(focusTableKey) {
            const { focusTable } = this.context.store.editorState;
            return (focusTable === null || focusTable === void 0 ? void 0 : focusTable.id) === this.table.id && focusTable[focusTableKey];
        }
        editTable(focusType) {
            const { editTable } = this.context.store.editorState;
            return (editTable === null || editTable === void 0 ? void 0 : editTable.id) === this.table.id && editTable.focusType === focusType;
        }
        focusColumn(column, focusType) {
            const { focusTable } = this.context.store.editorState;
            return ((focusTable === null || focusTable === void 0 ? void 0 : focusTable.id) === this.table.id &&
                focusTable.currentFocusId === column.id &&
                focusTable.currentFocus === focusType);
        }
        selectColumn(column) {
            var _a;
            const { focusTable } = this.context.store.editorState;
            return ((focusTable === null || focusTable === void 0 ? void 0 : focusTable.id) === this.table.id &&
                ((_a = getData(focusTable.focusColumns, column.id)) === null || _a === void 0 ? void 0 : _a.select) === true);
        }
        editColumn(column, focusType) {
            const { editTable } = this.context.store.editorState;
            return (editTable === null || editTable === void 0 ? void 0 : editTable.id) === column.id && editTable.focusType === focusType;
        }
        draggableColumn(column) {
            const { draggableColumn } = this.context.store.editorState;
            return ((draggableColumn === null || draggableColumn === void 0 ? void 0 : draggableColumn.tableId) === this.table.id &&
                draggableColumn.columnIds.some((id) => id === column.id));
        }
    };
    Table$1 = __decorate([
        customElement("vuerd-table")
    ], Table$1);

    let Column = class Column extends EditorElement {
        constructor() {
            super(...arguments);
            this.select = false;
            this.draggable = false;
            this.focusName = false;
            this.focusDataType = false;
            this.focusNotNull = false;
            this.focusDefault = false;
            this.focusComment = false;
            this.focusUnique = false;
            this.focusAutoIncrement = false;
            this.editName = false;
            this.editDataType = false;
            this.editDefault = false;
            this.editComment = false;
            this.widthName = SIZE_MIN_WIDTH;
            this.widthDataType = SIZE_MIN_WIDTH;
            this.widthNotNull = SIZE_MIN_WIDTH;
            this.widthDefault = SIZE_MIN_WIDTH;
            this.widthComment = SIZE_MIN_WIDTH;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            const { columnOrder } = store.canvasState.setting;
            this.subscriptionList.push(store.observe(store.canvasState.show, () => this.requestUpdate()), store.observe(columnOrder, () => this.requestUpdate()), store.observe(this.column, () => this.requestUpdate()), store.observe(this.column.ui, (name) => {
                switch (name) {
                    case "widthName":
                    case "widthComment":
                    case "widthDataType":
                    case "widthDefault":
                        this.dispatchEvent(new CustomEvent("request-update"));
                        break;
                    case "active":
                        this.requestUpdate();
                        break;
                }
            }));
        }
        render() {
            const { keymap } = this.context;
            const { show, setting } = this.context.store.canvasState;
            const { ui, option } = this.column;
            const keymapRemoveColumn = keymapOptionToString(keymap.removeColumn[0]);
            const columns = [];
            setting.columnOrder.forEach((columnType) => {
                switch (columnType) {
                    case "columnName":
                        columns.push(html `
            <vuerd-input-edit
              .width=${this.widthName}
              .value=${this.column.name}
              .focusState=${this.focusName}
              .edit=${this.editName}
              .select=${this.select}
              .active=${ui.active}
              placeholder="column"
              @blur=${this.onBlur}
              @input=${(event) => this.onInput(event, "columnName")}
              @mousedown=${(event) => this.onFocus(event, "columnName")}
              @dblclick=${(event) => this.onEdit(event, "columnName")}
            ></vuerd-input-edit>
          `);
                        break;
                    case "columnDataType":
                        if (show.columnDataType) {
                            columns.push(html `
              <vuerd-column-data-type
                .width=${this.widthDataType}
                .value=${this.column.dataType}
                .focusState=${this.focusDataType}
                .edit=${this.editDataType}
                .select=${this.select}
                .active=${ui.active}
                .tableId=${this.tableId}
                .columnId=${this.column.id}
                @blur=${this.onBlur}
                @input=${(event) => this.onInput(event, "columnDataType")}
                @mousedown=${(event) => this.onFocus(event, "columnDataType")}
                @dblclick=${(event) => this.onEdit(event, "columnDataType")}
              ></vuerd-column-data-type>
            `);
                        }
                        break;
                    case "columnNotNull":
                        if (show.columnNotNull) {
                            columns.push(html `
              <vuerd-column-not-null
                .columnOption=${this.column.option}
                .focusState=${this.focusNotNull}
                @mousedown=${(event) => this.onFocus(event, "columnNotNull")}
                @dblclick=${(event) => this.onEdit(event, "columnNotNull")}
              ></vuerd-column-not-null>
            `);
                        }
                        break;
                    case "columnDefault":
                        if (show.columnDefault) {
                            columns.push(html `
              <vuerd-input-edit
                .width=${this.widthDefault}
                .value=${this.column.default}
                .focusState=${this.focusDefault}
                .edit=${this.editDefault}
                .select=${this.select}
                .active=${ui.active}
                placeholder="default"
                @blur=${this.onBlur}
                @input=${(event) => this.onInput(event, "columnDefault")}
                @mousedown=${(event) => this.onFocus(event, "columnDefault")}
                @dblclick=${(event) => this.onEdit(event, "columnDefault")}
              ></vuerd-input-edit>
            `);
                        }
                        break;
                    case "columnComment":
                        if (show.columnComment) {
                            columns.push(html `
              <vuerd-input-edit
                .width=${this.widthComment}
                .value=${this.column.comment}
                .focusState=${this.focusComment}
                .edit=${this.editComment}
                .select=${this.select}
                .active=${ui.active}
                placeholder=""
                @blur=${this.onBlur}
                @input=${(event) => this.onInput(event, "columnComment")}
                @mousedown=${(event) => this.onFocus(event, "columnComment")}
                @dblclick=${(event) => this.onEdit(event, "columnComment")}
              ></vuerd-input-edit>
            `);
                        }
                        break;
                    case "columnUnique":
                        if (show.columnUnique) {
                            columns.push(html `
              <vuerd-column-unique
                .columnOption=${option}
                .focusState=${this.focusUnique}
                @mousedown=${(event) => this.onFocus(event, "columnUnique")}
                @dblclick=${(event) => this.onEdit(event, "columnUnique")}
              ></vuerd-column-unique>
            `);
                        }
                        break;
                    case "columnAutoIncrement":
                        if (show.columnAutoIncrement) {
                            columns.push(html `
              <vuerd-column-auto-increment
                .columnOption=${option}
                .focusState=${this.focusAutoIncrement}
                @mousedown=${(event) => this.onFocus(event, "columnAutoIncrement")}
                @dblclick=${(event) => this.onEdit(event, "columnAutoIncrement")}
              ></vuerd-column-auto-increment>
            `);
                        }
                        break;
                }
            });
            return html `
      <div
        class=${classMap({
                "vuerd-column": true,
                select: this.select,
                draggable: this.draggable,
                active: ui.active,
            })}
        data-id=${this.column.id}
        draggable="true"
        @dragstart=${this.onDragstart}
        @dragend=${this.onDragend}
        @dragover=${this.onDragover}
      >
        <vuerd-column-key .columnUI=${ui}></vuerd-column-key>
        ${columns}
        <vuerd-icon
          class="vuerd-button"
          title=${keymapRemoveColumn}
          icon="times"
          size="9"
          @click=${this.onRemoveColumn}
        ></vuerd-icon>
      </div>
    `;
        }
        onInput(event, focusType) {
            const { store, helper } = this.context;
            const input = event.target;
            switch (focusType) {
                case "columnName":
                    store.dispatch(changeColumnName(helper, this.tableId, this.column.id, input.value));
                    break;
                case "columnComment":
                    store.dispatch(changeColumnComment(helper, this.tableId, this.column.id, input.value));
                    break;
                case "columnDataType":
                    store.dispatch(changeColumnDataType(helper, this.tableId, this.column.id, input.value));
                    break;
                case "columnDefault":
                    store.dispatch(changeColumnDefault(helper, this.tableId, this.column.id, input.value));
                    break;
            }
        }
        onBlur(event) {
            const { store } = this.context;
            store.dispatch(editTableEnd());
        }
        onFocus(event, focusType) {
            const { store } = this.context;
            const { editTable, focusTable } = store.editorState;
            if (editTable === null ||
                editTable.focusType !== focusType ||
                focusTable === null ||
                focusTable.currentFocusId !== this.column.id) {
                store.dispatch(selectTable(store, event.ctrlKey || event.metaKey, this.tableId), focusTargetColumn(this.column.id, focusType, event.ctrlKey || event.metaKey, event.shiftKey));
            }
        }
        onEdit(event, focusType) {
            const { store } = this.context;
            const { editTable: editTable$1, focusTable } = store.editorState;
            if (focusTable !== null && editTable$1 === null) {
                if (focusType === "columnNotNull") {
                    store.dispatch(changeColumnNotNull(store, this.tableId, this.column.id));
                }
                else if (focusType === "columnUnique") {
                    store.dispatch(changeColumnUnique(store, this.tableId, this.column.id));
                }
                else if (focusType === "columnAutoIncrement") {
                    store.dispatch(changeColumnAutoIncrement(store, this.tableId, this.column.id));
                }
                else {
                    store.dispatch(editTable(this.column.id, focusType));
                }
            }
        }
        onRemoveColumn(event) {
            const { store } = this.context;
            store.dispatch(removeColumn(this.tableId, [this.column.id]));
        }
        onDragstart(event) {
            const { store } = this.context;
            store.dispatch(draggableColumn(store, this.tableId, this.column.id, event.ctrlKey || event.metaKey));
        }
        onDragend(event) {
            const { store } = this.context;
            store.dispatch(draggableColumnEnd());
        }
        onDragover(event) {
            this.dispatchEvent(new CustomEvent("dragover", {
                detail: {
                    tableId: this.tableId,
                    columnId: this.column.id,
                },
            }));
        }
    };
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "select", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "draggable", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "focusName", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "focusDataType", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "focusNotNull", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "focusDefault", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "focusComment", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "focusUnique", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "focusAutoIncrement", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "editName", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "editDataType", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "editDefault", void 0);
    __decorate([
        property({ type: Boolean })
    ], Column.prototype, "editComment", void 0);
    __decorate([
        property({ type: Number })
    ], Column.prototype, "widthName", void 0);
    __decorate([
        property({ type: Number })
    ], Column.prototype, "widthDataType", void 0);
    __decorate([
        property({ type: Number })
    ], Column.prototype, "widthNotNull", void 0);
    __decorate([
        property({ type: Number })
    ], Column.prototype, "widthDefault", void 0);
    __decorate([
        property({ type: Number })
    ], Column.prototype, "widthComment", void 0);
    Column = __decorate([
        customElement("vuerd-column")
    ], Column);

    let ColumnKey = class ColumnKey extends EditorElement {
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(this.columnUI, (name) => {
                switch (name) {
                    case "pk":
                    case "fk":
                    case "pfk":
                        this.requestUpdate();
                        break;
                }
            }));
        }
        render() {
            const { pk, fk, pfk } = this.columnUI;
            return html `
      <div
        class=${classMap({
                "vuerd-column-key": true,
                pk,
                fk,
                pfk,
            })}
      >
        <vuerd-icon size="12" icon="key"></vuerd-icon>
      </div>
    `;
        }
    };
    ColumnKey = __decorate([
        customElement("vuerd-column-key")
    ], ColumnKey);

    let ColumnNotNull = class ColumnNotNull extends EditorElement {
        constructor() {
            super(...arguments);
            this.focusState = false;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(this.columnOption, (name) => {
                if (name === "notNull") {
                    this.requestUpdate();
                }
            }));
        }
        render() {
            return html `
      <div
        class=${classMap({
                "vuerd-column-not-null": true,
                focus: this.focusState,
            })}
        style=${styleMap({
                width: `${SIZE_COLUMN_OPTION_NN}px`,
            })}
      >
        ${this.columnOption.notNull ? "N-N" : "NULL"}
      </div>
    `;
        }
    };
    __decorate([
        property({ type: Boolean })
    ], ColumnNotNull.prototype, "focusState", void 0);
    ColumnNotNull = __decorate([
        customElement("vuerd-column-not-null")
    ], ColumnNotNull);

    let ColumnDataType = class ColumnDataType extends EditorElement {
        constructor() {
            super(...arguments);
            this.edit = false;
            this.focusState = false;
            this.select = false;
            this.active = false;
            this.width = SIZE_MIN_WIDTH;
            this.value = "";
        }
        render() {
            return html `
      <div class="vuerd-column-data-type">
        <vuerd-input-edit
          .width=${this.width}
          .value=${this.value}
          .focusState=${this.focusState}
          .edit=${this.edit}
          .select=${this.select}
          .active=${this.active}
          placeholder="dataType"
          @keydown=${this.onKeydown}
          @blur=${this.onBlur}
          @input=${this.onInput}
        ></vuerd-input-edit>
        ${this.edit
                ? html `
              <vuerd-column-data-type-hint
                .value=${this.value}
                .tableId=${this.tableId}
                .columnId=${this.columnId}
                @blur=${this.onBlurHint}
              ></vuerd-column-data-type-hint>
            `
                : ""}
      </div>
    `;
        }
        onKeydown(event) {
            const { eventBus } = this.context;
            switch (event.key) {
                case "ArrowUp":
                    eventBus.emit(Bus.ColumnDataTypeHint.arrowUp, event);
                    break;
                case "ArrowDown":
                    eventBus.emit(Bus.ColumnDataTypeHint.arrowDown, event);
                    break;
                case "ArrowLeft":
                    eventBus.emit(Bus.ColumnDataTypeHint.arrowLeft, event);
                    break;
                case "ArrowRight":
                    eventBus.emit(Bus.ColumnDataTypeHint.arrowRight, event);
                    break;
            }
        }
        onInput(event) {
            const { eventBus } = this.context;
            eventBus.emit(Bus.ColumnDataTypeHint.startFilter);
        }
        onBlurHint() {
            this.dispatchEvent(new Event("blur"));
        }
        onBlur() {
            const { helper } = this.context;
            const input = this.renderRoot.querySelector("input");
            if (input && this.edit) {
                const len = input.value.length;
                input.selectionStart = len;
                input.selectionEnd = len;
                input.focus();
            }
            else {
                helper.focus();
            }
        }
    };
    __decorate([
        property({ type: Boolean })
    ], ColumnDataType.prototype, "edit", void 0);
    __decorate([
        property({ type: Boolean })
    ], ColumnDataType.prototype, "focusState", void 0);
    __decorate([
        property({ type: Boolean })
    ], ColumnDataType.prototype, "select", void 0);
    __decorate([
        property({ type: Boolean })
    ], ColumnDataType.prototype, "active", void 0);
    __decorate([
        property({ type: Number })
    ], ColumnDataType.prototype, "width", void 0);
    __decorate([
        property({ type: String })
    ], ColumnDataType.prototype, "value", void 0);
    ColumnDataType = __decorate([
        customElement("vuerd-column-data-type")
    ], ColumnDataType);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
        // For each part, remember the value that was last rendered to the part by the
        // unsafeHTML directive, and the DocumentFragment that was last set as a value.
        // The DocumentFragment is used as a unique key to check if the last value
        // rendered to the part was with unsafeHTML. If not, we'll always re-render the
        // value passed to unsafeHTML.
    const previousValues = new WeakMap();
    /**
     * Renders the result as HTML, rather than text.
     *
     * Note, this is unsafe to use with any user-provided input that hasn't been
     * sanitized or escaped, as it may lead to cross-site-scripting
     * vulnerabilities.
     */
    const unsafeHTML = directive((value) => (part) => {
        if (!(part instanceof NodePart)) {
            throw new Error('unsafeHTML can only be used in text bindings');
        }
        const previousValue = previousValues.get(part);
        if (previousValue !== undefined && isPrimitive(value) &&
            value === previousValue.value && part.value === previousValue.fragment) {
            return;
        }
        const template = document.createElement('template');
        template.innerHTML = value; // innerHTML casts to string internally
        const fragment = document.importNode(template.content, true);
        part.setValue(fragment);
        previousValues.set(part, { value, fragment });
    });

    /**
     * https://mariadb.com/kb/en/data-types/
     */
    const MariaDBTypes$1 = [
        { name: "BIGINT", primitiveType: "long" },
        { name: "BINARY", primitiveType: "string" },
        { name: "BIT", primitiveType: "int" },
        { name: "BLOB", primitiveType: "lob" },
        { name: "BOOL", primitiveType: "boolean" },
        { name: "BOOLEAN", primitiveType: "boolean" },
        { name: "CHAR", primitiveType: "string" },
        { name: "DATE", primitiveType: "date" },
        { name: "DATETIME", primitiveType: "dateTime" },
        { name: "DEC", primitiveType: "decimal" },
        { name: "DECIMAL", primitiveType: "decimal" },
        { name: "DOUBLE PRECISION", primitiveType: "double" },
        { name: "DOUBLE", primitiveType: "double" },
        { name: "ENUM", primitiveType: "string" },
        { name: "FIXED", primitiveType: "decimal" },
        { name: "FLOAT", primitiveType: "float" },
        { name: "GEOMETRY", primitiveType: "string" },
        { name: "GEOMETRYCOLLECTION", primitiveType: "string" },
        { name: "INT", primitiveType: "int" },
        { name: "INTEGER", primitiveType: "int" },
        { name: "JSON", primitiveType: "lob" },
        { name: "LINESTRING", primitiveType: "string" },
        { name: "LONGBLOB", primitiveType: "lob" },
        { name: "LONGTEXT", primitiveType: "lob" },
        { name: "MEDIUMBLOB", primitiveType: "lob" },
        { name: "MEDIUMINT", primitiveType: "int" },
        { name: "MEDIUMTEXT", primitiveType: "lob" },
        { name: "MULTILINESTRING", primitiveType: "string" },
        { name: "MULTIPOINT", primitiveType: "string" },
        { name: "MULTIPOLYGON", primitiveType: "string" },
        { name: "NUMERIC", primitiveType: "decimal" },
        { name: "POINT", primitiveType: "string" },
        { name: "POLYGON", primitiveType: "string" },
        { name: "REAL", primitiveType: "double" },
        { name: "SET", primitiveType: "string" },
        { name: "SMALLINT", primitiveType: "int" },
        { name: "TEXT", primitiveType: "lob" },
        { name: "TIME", primitiveType: "time" },
        { name: "TIMESTAMP", primitiveType: "dateTime" },
        { name: "TINYBLOB", primitiveType: "lob" },
        { name: "TINYINT", primitiveType: "int" },
        { name: "TINYTEXT", primitiveType: "lob" },
        { name: "VARBINARY", primitiveType: "string" },
        { name: "VARCHAR", primitiveType: "string" },
        { name: "YEAR", primitiveType: "int" },
    ];

    /**
     * https://docs.microsoft.com/ko-kr/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver15
     */
    const MSSQLTypes$1 = [
        { name: "bigint", primitiveType: "long" },
        { name: "binary", primitiveType: "lob" },
        { name: "bit", primitiveType: "int" },
        { name: "char", primitiveType: "string" },
        { name: "date", primitiveType: "date" },
        { name: "datetime", primitiveType: "dateTime" },
        { name: "datetime2", primitiveType: "dateTime" },
        { name: "datetimeoffset", primitiveType: "dateTime" },
        { name: "decimal", primitiveType: "decimal" },
        { name: "float", primitiveType: "double" },
        { name: "geography", primitiveType: "string" },
        { name: "geometry", primitiveType: "string" },
        { name: "image", primitiveType: "lob" },
        { name: "int", primitiveType: "int" },
        { name: "money", primitiveType: "double" },
        { name: "nchar", primitiveType: "string" },
        { name: "ntext", primitiveType: "lob" },
        { name: "numeric", primitiveType: "float" },
        { name: "nvarchar", primitiveType: "string" },
        { name: "real", primitiveType: "float" },
        { name: "smalldatetime", primitiveType: "dateTime" },
        { name: "smallint", primitiveType: "int" },
        { name: "smallmoney", primitiveType: "float" },
        { name: "sql_variant", primitiveType: "string" },
        { name: "text", primitiveType: "lob" },
        { name: "time", primitiveType: "time" },
        { name: "tinyint", primitiveType: "int" },
        { name: "uniqueidentifier", primitiveType: "string" },
        { name: "varbinary", primitiveType: "string" },
        { name: "varchar", primitiveType: "string" },
        { name: "xml", primitiveType: "lob" },
    ];

    /**
     * https://dev.mysql.com/doc/refman/8.0/en/data-types.html
     */
    const MySQLTypes$1 = [
        { name: "BIGINT", primitiveType: "long" },
        { name: "BINARY", primitiveType: "string" },
        { name: "BIT", primitiveType: "int" },
        { name: "BLOB", primitiveType: "lob" },
        { name: "BOOL", primitiveType: "boolean" },
        { name: "BOOLEAN", primitiveType: "boolean" },
        { name: "CHAR", primitiveType: "string" },
        { name: "DATE", primitiveType: "date" },
        { name: "DATETIME", primitiveType: "dateTime" },
        { name: "DEC", primitiveType: "decimal" },
        { name: "DECIMAL", primitiveType: "decimal" },
        { name: "DOUBLE PRECISION", primitiveType: "double" },
        { name: "DOUBLE", primitiveType: "double" },
        { name: "ENUM", primitiveType: "string" },
        { name: "FLOAT", primitiveType: "float" },
        { name: "GEOMETRY", primitiveType: "string" },
        { name: "GEOMETRYCOLLECTION", primitiveType: "string" },
        { name: "INT", primitiveType: "int" },
        { name: "INTEGER", primitiveType: "int" },
        { name: "JSON", primitiveType: "lob" },
        { name: "LINESTRING", primitiveType: "string" },
        { name: "LONGBLOB", primitiveType: "lob" },
        { name: "LONGTEXT", primitiveType: "lob" },
        { name: "MEDIUMBLOB", primitiveType: "lob" },
        { name: "MEDIUMINT", primitiveType: "int" },
        { name: "MEDIUMTEXT", primitiveType: "lob" },
        { name: "MULTILINESTRING", primitiveType: "string" },
        { name: "MULTIPOINT", primitiveType: "string" },
        { name: "MULTIPOLYGON", primitiveType: "string" },
        { name: "NUMERIC", primitiveType: "decimal" },
        { name: "POINT", primitiveType: "string" },
        { name: "POLYGON", primitiveType: "string" },
        { name: "SET", primitiveType: "string" },
        { name: "SMALLINT", primitiveType: "int" },
        { name: "TEXT", primitiveType: "lob" },
        { name: "TIME", primitiveType: "time" },
        { name: "TIMESTAMP", primitiveType: "dateTime" },
        { name: "TINYBLOB", primitiveType: "lob" },
        { name: "TINYINT", primitiveType: "int" },
        { name: "TINYTEXT", primitiveType: "lob" },
        { name: "VARBINARY", primitiveType: "string" },
        { name: "VARCHAR", primitiveType: "string" },
        { name: "YEAR", primitiveType: "int" },
    ];

    /**
     * https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT012
     */
    const OracleTypes$1 = [
        { name: "BFILE", primitiveType: "lob" },
        { name: "BINARY_DOUBLE", primitiveType: "double" },
        { name: "BINARY_FLOAT", primitiveType: "float" },
        { name: "BLOB", primitiveType: "lob" },
        { name: "CHAR", primitiveType: "string" },
        { name: "CLOB", primitiveType: "lob" },
        { name: "DATE", primitiveType: "date" },
        { name: "DATETIME", primitiveType: "dateTime" },
        { name: "LONG RAW", primitiveType: "lob" },
        { name: "LONG", primitiveType: "lob" },
        { name: "NCHAR", primitiveType: "string" },
        { name: "NCLOB", primitiveType: "lob" },
        { name: "NUMBER", primitiveType: "long" },
        { name: "NVARCHAR2", primitiveType: "string" },
        { name: "RAW", primitiveType: "lob" },
        { name: "TIMESTAMP WITH LOCAL TIME ZONE", primitiveType: "dateTime" },
        { name: "TIMESTAMP WITH TIME ZONE", primitiveType: "dateTime" },
        { name: "TIMESTAMP", primitiveType: "dateTime" },
        { name: "UriType", primitiveType: "string" },
        { name: "VARCHAR", primitiveType: "string" },
        { name: "VARCHAR2", primitiveType: "string" },
        { name: "XMLType", primitiveType: "string" },
    ];

    /**
     * https://www.postgresql.org/docs/current/datatype.html
     */
    const PostgreSQLTypes$1 = [
        { name: "bigint", primitiveType: "long" },
        { name: "bigserial", primitiveType: "long" },
        { name: "bit varying", primitiveType: "int" },
        { name: "bit", primitiveType: "int" },
        { name: "bool", primitiveType: "boolean" },
        { name: "boolean", primitiveType: "boolean" },
        { name: "box", primitiveType: "string" },
        { name: "bytea", primitiveType: "string" },
        { name: "char", primitiveType: "string" },
        { name: "character varying", primitiveType: "string" },
        { name: "character", primitiveType: "string" },
        { name: "cidr", primitiveType: "string" },
        { name: "circle", primitiveType: "string" },
        { name: "date", primitiveType: "date" },
        { name: "decimal", primitiveType: "decimal" },
        { name: "double precision", primitiveType: "double" },
        { name: "float4", primitiveType: "float" },
        { name: "float8", primitiveType: "double" },
        { name: "inet", primitiveType: "string" },
        { name: "int", primitiveType: "int" },
        { name: "int2", primitiveType: "int" },
        { name: "int4", primitiveType: "int" },
        { name: "int8", primitiveType: "long" },
        { name: "integer", primitiveType: "int" },
        { name: "interval", primitiveType: "time" },
        { name: "json", primitiveType: "lob" },
        { name: "jsonb", primitiveType: "lob" },
        { name: "line", primitiveType: "string" },
        { name: "lseg", primitiveType: "string" },
        { name: "macaddr", primitiveType: "string" },
        { name: "macaddr8", primitiveType: "string" },
        { name: "money", primitiveType: "double" },
        { name: "numeric", primitiveType: "decimal" },
        { name: "path", primitiveType: "string" },
        { name: "pg_lsn", primitiveType: "int" },
        { name: "point", primitiveType: "string" },
        { name: "polygon", primitiveType: "string" },
        { name: "real", primitiveType: "float" },
        { name: "serial", primitiveType: "int" },
        { name: "serial2", primitiveType: "int" },
        { name: "serial4", primitiveType: "int" },
        { name: "serial8", primitiveType: "long" },
        { name: "smallint", primitiveType: "int" },
        { name: "smallserial", primitiveType: "int" },
        { name: "text", primitiveType: "string" },
        { name: "time with time zone", primitiveType: "time" },
        { name: "time", primitiveType: "time" },
        { name: "timestamp with time zone", primitiveType: "dateTime" },
        { name: "timestamp", primitiveType: "dateTime" },
        { name: "timestamptz", primitiveType: "dateTime" },
        { name: "timetz", primitiveType: "time" },
        { name: "tsquery", primitiveType: "string" },
        { name: "tsvector", primitiveType: "string" },
        { name: "txid_snapshot", primitiveType: "string" },
        { name: "uuid", primitiveType: "string" },
        { name: "varbit", primitiveType: "int" },
        { name: "varchar", primitiveType: "string" },
        { name: "xml", primitiveType: "lob" },
    ];

    /**
     * https://www.sqlite.org/datatype3.html
     */
    const SQLiteTypes$1 = [
        { name: "BLOB", primitiveType: "lob" },
        { name: "INTEGER", primitiveType: "int" },
        { name: "NUMERIC", primitiveType: "decimal" },
        { name: "REAL", primitiveType: "double" },
        { name: "TEXT", primitiveType: "string" },
    ];

    const databaseHints = [
        {
            database: "MariaDB",
            dataTypeHints: MariaDBTypes$1,
        },
        {
            database: "MSSQL",
            dataTypeHints: MSSQLTypes$1,
        },
        {
            database: "MySQL",
            dataTypeHints: MySQLTypes$1,
        },
        {
            database: "Oracle",
            dataTypeHints: OracleTypes$1,
        },
        {
            database: "PostgreSQL",
            dataTypeHints: PostgreSQLTypes$1,
        },
        {
            database: "SQLite",
            dataTypeHints: SQLiteTypes$1,
        },
    ];

    let ColumnDataTypeHint$1 = class ColumnDataTypeHint extends EditorElement {
        constructor() {
            super(...arguments);
            this.value = "";
            this.hints = [];
            this.startFilter = true;
            this.flipAnimation = new FlipAnimation(this.renderRoot, ".vuerd-data-type-hint", "vuerd-data-type-hint-move");
            this.onArrowUp = (event) => {
                if (this.hints.length !== 0) {
                    event.detail.preventDefault();
                }
                const index = this.activeIndex;
                if (index !== null && index !== 0) {
                    this.hints[index].active = false;
                    this.hints[index - 1].active = true;
                    this.requestUpdate();
                }
                else if (this.hints.length !== 0) {
                    if (index === 0) {
                        this.hints[index].active = false;
                    }
                    this.hints[this.hints.length - 1].active = true;
                    this.requestUpdate();
                }
            };
            this.onArrowDown = (event) => {
                if (this.hints.length !== 0) {
                    event.detail.preventDefault();
                }
                const index = this.activeIndex;
                if (index !== null && index !== this.hints.length - 1) {
                    this.hints[index].active = false;
                    this.hints[index + 1].active = true;
                    this.requestUpdate();
                }
                else if (this.hints.length !== 0) {
                    if (index === this.hints.length - 1) {
                        this.hints[index].active = false;
                    }
                    this.hints[0].active = true;
                    this.requestUpdate();
                }
            };
            this.onArrowLeft = (event) => {
                this.activeEnd();
                this.requestUpdate();
            };
            this.onArrowRight = (event) => {
                const index = this.activeIndex;
                if (index !== null) {
                    event.detail.preventDefault();
                    this.startFilter = false;
                    const { store, helper } = this.context;
                    store.dispatch(changeColumnDataType(helper, this.tableId, this.columnId, this.hints[index].name));
                }
            };
            this.onStartFilter = (event) => {
                this.startFilter = true;
            };
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-column-data-type")) {
                    this.dispatchEvent(new Event("blur"));
                }
            };
        }
        get dataTypeHints() {
            const { canvasState } = this.context.store;
            let dataTypeHints = [];
            for (const databaseHint of databaseHints) {
                if (databaseHint.database === canvasState.database) {
                    dataTypeHints = databaseHint.dataTypeHints;
                    break;
                }
            }
            return dataTypeHints;
        }
        get activeIndex() {
            let index = null;
            for (let i = 0; i < this.hints.length; i++) {
                if (this.hints[i].active) {
                    index = i;
                    break;
                }
            }
            return index;
        }
        connectedCallback() {
            super.connectedCallback();
            const { eventBus } = this.context;
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.hintFilter();
            this.subscriptionList.push(fromEvent(editor, "mousedown").subscribe(this.onMousedown), eventBus.on(Bus.ColumnDataTypeHint.arrowUp).subscribe(this.onArrowUp), eventBus.on(Bus.ColumnDataTypeHint.arrowDown).subscribe(this.onArrowDown), eventBus.on(Bus.ColumnDataTypeHint.arrowLeft).subscribe(this.onArrowLeft), eventBus
                .on(Bus.ColumnDataTypeHint.arrowRight)
                .subscribe(this.onArrowRight), eventBus
                .on(Bus.ColumnDataTypeHint.startFilter)
                .subscribe(this.onStartFilter));
        }
        updated(changedProperties) {
            changedProperties.forEach((oldValue, propName) => {
                switch (propName) {
                    case "value":
                        this.flipAnimation.snapshot();
                        this.hintFilter();
                        break;
                    case "hints":
                        this.flipAnimation.play();
                        break;
                }
            });
        }
        render() {
            return html `
      <ul class="vuerd-column-data-type-hint">
        ${repeat$1(this.hints, (hint) => hint.name, (hint) => {
                return html `
              <li
                class=${classMap({
                    "vuerd-data-type-hint": true,
                    active: hint.active,
                })}
                @click=${() => this.onSelectHint(hint)}
              >
                ${unsafeHTML(hint.html)}
              </li>
            `;
            })}
      </ul>
    `;
        }
        onSelectHint(hint) {
            const { store, helper } = this.context;
            this.startFilter = false;
            this.activeEnd();
            store.dispatch(changeColumnDataType(helper, this.tableId, this.columnId, hint.name));
        }
        hintFilter() {
            if (this.startFilter) {
                if (this.value.trim() === "") {
                    this.hints = this.dataTypeHints.map((dataTypeHint) => {
                        return {
                            name: dataTypeHint.name,
                            html: dataTypeHint.name,
                            active: false,
                        };
                    });
                }
                else {
                    this.hints = this.dataTypeHints
                        .filter((dataTypeHint) => dataTypeHint.name
                            .toLowerCase()
                            .indexOf(this.value.toLowerCase()) !== -1)
                        .map((dataTypeHint) => {
                            return {
                                name: dataTypeHint.name,
                                html: markToHTML("vuerd-mark", dataTypeHint.name, this.value),
                                active: false,
                            };
                        });
                }
            }
        }
        activeEnd() {
            this.hints.forEach((hint) => (hint.active = false));
        }
    };
    __decorate([
        property({ type: String })
    ], ColumnDataTypeHint$1.prototype, "value", void 0);
    __decorate([
        property({ type: Array })
    ], ColumnDataTypeHint$1.prototype, "hints", void 0);
    ColumnDataTypeHint$1 = __decorate([
        customElement("vuerd-column-data-type-hint")
    ], ColumnDataTypeHint$1);

    let ColumnUnique = class ColumnUnique extends EditorElement {
        constructor() {
            super(...arguments);
            this.focusState = false;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(this.columnOption, (name) => {
                if (name === "unique") {
                    this.requestUpdate();
                }
            }));
        }
        render() {
            return html `
      <div
        class=${classMap({
                "vuerd-column-unique": true,
                focus: this.focusState,
                checked: this.columnOption.unique,
            })}
        style=${styleMap({
                width: `${SIZE_COLUMN_OPTION_QU}px`,
            })}
        title="Unique"
      >
        UQ
      </div>
    `;
        }
    };
    __decorate([
        property({ type: Boolean })
    ], ColumnUnique.prototype, "focusState", void 0);
    ColumnUnique = __decorate([
        customElement("vuerd-column-unique")
    ], ColumnUnique);

    let ColumnAutoIncrement = class ColumnAutoIncrement extends EditorElement {
        constructor() {
            super(...arguments);
            this.focusState = false;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(this.columnOption, (name) => {
                if (name === "autoIncrement") {
                    this.requestUpdate();
                }
            }));
        }
        render() {
            return html `
      <div
        class=${classMap({
                "vuerd-column-auto-increment": true,
                focus: this.focusState,
                checked: this.columnOption.autoIncrement,
            })}
        style=${styleMap({
                width: `${SIZE_COLUMN_OPTION_AI}px`,
            })}
        title="Auto Increment"
      >
        AI
      </div>
    `;
        }
    };
    __decorate([
        property({ type: Boolean })
    ], ColumnAutoIncrement.prototype, "focusState", void 0);
    ColumnAutoIncrement = __decorate([
        customElement("vuerd-column-auto-increment")
    ], ColumnAutoIncrement);

    const MARGIN_TOP = SIZE_MENUBAR_HEIGHT + SIZE_MINIMAP_MARGIN;
    let Minimap = class Minimap extends EditorElement {
        constructor() {
            super(...arguments);
            this.width = defaultWidth;
            this.height = defaultHeight;
            this.tables = [];
            this.memos = [];
            this.relationships = [];
            this.subRelationships = [];
        }
        get styleMap() {
            const { width, height, scrollLeft, scrollTop, } = this.context.store.canvasState;
            const ratio = SIZE_MINIMAP_WIDTH / width;
            const x = (-1 * width) / 2 + SIZE_MINIMAP_WIDTH / 2;
            const y = (-1 * height) / 2 + (height * ratio) / 2;
            const left = x - SIZE_MINIMAP_WIDTH - SIZE_MINIMAP_MARGIN + this.width + scrollLeft;
            const top = y + MARGIN_TOP + scrollTop;
            return {
                transform: `scale(${ratio}, ${ratio})`,
                width: `${width}px`,
                height: `${height}px`,
                left: `${left}px`,
                top: `${top}px`,
            };
        }
        get shadowStyle() {
            const { scrollLeft, scrollTop } = this.context.store.canvasState;
            const left = this.width + scrollLeft - SIZE_MINIMAP_WIDTH - SIZE_MINIMAP_MARGIN;
            const top = MARGIN_TOP + scrollTop;
            return {
                width: `${SIZE_MINIMAP_WIDTH}px`,
                height: `${SIZE_MINIMAP_WIDTH}px`,
                left: `${left}px`,
                top: `${top}px`,
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.tables = store.tableState.tables;
            this.memos = store.memoState.memos;
            this.relationships = store.relationshipState.relationships;
            this.subscriptionList.push(store.observe(this.tables, () => this.requestUpdate()), store.observe(this.memos, () => this.requestUpdate()), store.observe(store.canvasState.show, () => this.requestUpdate()), store.observe(store.canvasState, (name) => {
                switch (name) {
                    case "width":
                    case "height":
                    case "scrollTop":
                    case "scrollLeft":
                        this.requestUpdate();
                        break;
                }
            }), store.observe(this.relationships, () => {
                this.unsubscribeRelationships();
                this.observeRelationships();
                this.requestUpdate();
            }));
            this.observeRelationships();
        }
        disconnectedCallback() {
            this.unsubscribeRelationships();
            super.disconnectedCallback();
        }
        render() {
            const { width, height } = this.context.store.canvasState;
            const { show } = this.context.store.canvasState;
            return html `
      <div class="vuerd-minimap" style=${styleMap(this.styleMap)}>
        <div class="vuerd-minimap-canvas">
          ${repeat$1(this.tables, (table) => table.id, (table) => html `
                <vuerd-minimap-table .table=${table}></vuerd-minimap-table>
              `)}
          ${repeat$1(this.memos, (memo) => memo.id, (memo) => html ` <vuerd-minimap-memo .memo=${memo}></vuerd-minimap-memo> `)}
          ${show.relationship
                ? svg `
            <svg
              class="vuerd-minimap-canvas-svg"
              style=${styleMap({
                    width: `${width}px`,
                    height: `${height}px`,
                })}
            >
            ${repeat$1(this.relationships, (relationship) => relationship.id, (relationship) => {
                    const shape = createRelationship$1(relationship, 12);
                    return svg `
                  <g
                    class=${classMap({
                        "vuerd-relationship": true,
                        identification: relationship.identification,
                    })}
                  >
                    ${shape}
                  </g>
                `;
                })}
            </svg>
          `
                : ""}
        </div>
      </div>
      <div
        class="vuerd-minimap-shadow"
        style=${styleMap(this.shadowStyle)}
      ></div>
      <vuerd-minimap-handle
        .width=${this.width}
        .height=${this.height}
      ></vuerd-minimap-handle>
    `;
        }
        observeRelationships() {
            const { store } = this.context;
            this.relationships.forEach((relationship) => {
                this.subRelationships.push(store.observe(relationship, () => this.requestUpdate()), store.observe(relationship.start, () => this.requestUpdate()), store.observe(relationship.end, () => this.requestUpdate()));
            });
        }
        unsubscribeRelationships() {
            this.subRelationships.forEach((sub) => sub.unsubscribe());
            this.subRelationships = [];
        }
    };
    __decorate([
        property({ type: Number })
    ], Minimap.prototype, "width", void 0);
    __decorate([
        property({ type: Number })
    ], Minimap.prototype, "height", void 0);
    Minimap = __decorate([
        customElement("vuerd-minimap")
    ], Minimap);

    const MARGIN_TOP$1 = SIZE_MENUBAR_HEIGHT + SIZE_MINIMAP_MARGIN;
    let MinimapHandle = class MinimapHandle extends EditorElement {
        constructor() {
            super(...arguments);
            this.width = defaultWidth;
            this.height = defaultHeight;
            this.subMoveEnd = null;
            this.subMove = null;
            this.onMoveEnd = (event) => {
                var _a, _b;
                (_a = this.subMoveEnd) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                (_b = this.subMove) === null || _b === void 0 ? void 0 : _b.unsubscribe();
                this.subMoveEnd = null;
                this.subMove = null;
            };
            this.onMove = ({ event, movementX, movementY }) => {
                if (event.type === "mousemove") {
                    event.preventDefault();
                }
                const ratio = this.ratio;
                const root = this.getRootNode();
                const erd = root.querySelector(".vuerd-erd");
                erd.scrollTop += movementY / ratio;
                erd.scrollLeft += movementX / ratio;
                const { store } = this.context;
                store.dispatch(moveCanvas(erd.scrollTop, erd.scrollLeft));
            };
        }
        get styleMap() {
            const { scrollLeft, scrollTop } = this.context.store.canvasState;
            const ratio = this.ratio;
            const x = scrollLeft * ratio;
            const y = scrollTop * ratio;
            const left = this.width - SIZE_MINIMAP_WIDTH - SIZE_MINIMAP_MARGIN + scrollLeft + x;
            const top = MARGIN_TOP$1 + scrollTop + y;
            return {
                width: `${this.width * ratio}px`,
                height: `${this.height * ratio}px`,
                left: `${left}px`,
                top: `${top}px`,
            };
        }
        get ratio() {
            const { width } = this.context.store.canvasState;
            return SIZE_MINIMAP_WIDTH / width;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(store.canvasState, (name) => {
                switch (name) {
                    case "width":
                    case "height":
                    case "scrollLeft":
                    case "scrollTop":
                        this.requestUpdate();
                        break;
                }
            }));
        }
        disconnectedCallback() {
            this.onMoveEnd();
            super.disconnectedCallback();
        }
        render() {
            return html `
      <div
        class="vuerd-minimap-handle"
        style=${styleMap(this.styleMap)}
        @mousedown=${this.onMoveStart}
        @touchstart=${this.onMoveStart}
      ></div>
    `;
        }
        onMoveStart() {
            const { moveEnd$, move$ } = this.context.windowEventObservable;
            this.onMoveEnd();
            this.subMoveEnd = moveEnd$.subscribe(this.onMoveEnd);
            this.subMove = move$.subscribe(this.onMove);
        }
    };
    __decorate([
        property({ type: Number })
    ], MinimapHandle.prototype, "width", void 0);
    __decorate([
        property({ type: Number })
    ], MinimapHandle.prototype, "height", void 0);
    MinimapHandle = __decorate([
        customElement("vuerd-minimap-handle")
    ], MinimapHandle);

    let Table$2 = class Table extends EditorElement {
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(this.table.ui, () => this.requestUpdate()), store.observe(this.table.columns, () => this.requestUpdate()), store.observe(store.canvasState.show, () => this.requestUpdate()));
        }
        render() {
            const { ui } = this.table;
            return html `
      <div
        class=${classMap({
                "vuerd-table": true,
                active: ui.active,
            })}
        style=${styleMap({
                top: `${ui.top}px`,
                left: `${ui.left}px`,
                zIndex: `${ui.zIndex}`,
                width: `${this.table.width()}px`,
                height: `${this.table.height()}px`,
            })}
      >
        ${repeat$1(this.table.columns, (column) => column.id, (column) => html `
              <vuerd-minimap-column
                .column=${column}
                @request-update=${() => this.requestUpdate()}
              ></vuerd-minimap-column>
            `)}
      </div>
    `;
        }
    };
    Table$2 = __decorate([
        customElement("vuerd-minimap-table")
    ], Table$2);

    let Column$1 = class Column extends EditorElement {
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(this.column.ui, (name) => {
                switch (name) {
                    case "widthName":
                    case "widthComment":
                    case "widthDataType":
                    case "widthDefault":
                        this.dispatchEvent(new CustomEvent("request-update"));
                        break;
                }
            }));
        }
        render() {
            return html ``;
        }
    };
    Column$1 = __decorate([
        customElement("vuerd-minimap-column")
    ], Column$1);

    const MEMO_PADDING$2 = SIZE_MEMO_PADDING * 2;
    const MEMO_HEADER$1 = 17 + SIZE_MEMO_PADDING;
    let Memo$2 = class Memo extends EditorElement {
        get width() {
            const { ui } = this.memo;
            return ui.width + MEMO_PADDING$2;
        }
        get height() {
            const { ui } = this.memo;
            return ui.height + MEMO_PADDING$2 + MEMO_HEADER$1;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(this.memo.ui, () => this.requestUpdate()));
        }
        render() {
            const { ui } = this.memo;
            return html `
      <div
        class=${classMap({
                "vuerd-memo": true,
                active: ui.active,
            })}
        style=${styleMap({
                top: `${ui.top}px`,
                left: `${ui.left}px`,
                zIndex: `${ui.zIndex}`,
                width: `${this.width}px`,
                height: `${this.height}px`,
            })}
      ></div>
    `;
        }
    };
    Memo$2 = __decorate([
        customElement("vuerd-minimap-memo")
    ], Memo$2);

    const MARGIN = 4;
    let DargSelect = class DargSelect extends EditorElement {
        constructor() {
            super(...arguments);
            this.x = 0;
            this.y = 0;
            this.ghostX = 0;
            this.ghostY = 0;
            this.top = 0;
            this.left = 0;
            this.width = 0;
            this.height = 0;
            this.onMouseup = (event) => {
                this.dispatchEvent(new CustomEvent("select-end"));
            };
            this.onMousemove = (event) => {
                event.preventDefault();
                if (!event.ctrlKey && !event.metaKey) {
                    this.dispatchEvent(new CustomEvent("select-end"));
                }
            };
            this.onMousemoveERD = (event) => {
                event.preventDefault();
                const currentX = event.x;
                const currentY = event.y;
                const currentMinX = this.x > currentX;
                const currentMinY = this.y > currentY;
                const min = {
                    x: this.x < currentX ? this.x : currentX,
                    y: this.y < currentY ? this.y : currentY,
                };
                const max = {
                    x: this.x > currentX ? this.x : currentX,
                    y: this.y > currentY ? this.y : currentY,
                };
                if (currentMinX) {
                    this.left = min.x + MARGIN;
                    this.width = max.x - min.x;
                }
                else {
                    this.left = min.x;
                    this.width = max.x - min.x - MARGIN;
                    if (this.width < 0) {
                        this.width = 0;
                    }
                }
                if (currentMinY) {
                    this.top = min.y + MARGIN;
                    this.height = max.y - min.y;
                }
                else {
                    this.top = min.y;
                    this.height = max.y - min.y - MARGIN;
                    if (this.height < 0) {
                        this.height = 0;
                    }
                }
                const el = event.target;
                if (!el.closest(".vuerd-table") &&
                    !el.closest(".vuerd-memo") &&
                    !el.closest(".vuerd-contextmenu") &&
                    !el.closest(".vuerd-minimap") &&
                    !el.closest(".vuerd-minimap-handle")) {
                    const ghostCurrentX = event.offsetX;
                    const ghostCurrentY = event.offsetY;
                    const ghostMin = {
                        x: this.ghostX < ghostCurrentX ? this.ghostX : ghostCurrentX,
                        y: this.ghostY < ghostCurrentY ? this.ghostY : ghostCurrentY,
                    };
                    const ghostMax = {
                        x: this.ghostX > ghostCurrentX ? this.ghostX : ghostCurrentX,
                        y: this.ghostY > ghostCurrentY ? this.ghostY : ghostCurrentY,
                    };
                    const { store } = this.context;
                    store.dispatch(dragSelectTable(ghostMin, ghostMax), dragSelectMemo(ghostMin, ghostMax));
                }
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { mouseup$, mousemove$ } = this.context.windowEventObservable;
            const root = this.getRootNode();
            const erd = root.querySelector(".vuerd-erd");
            this.subscriptionList.push(mouseup$.subscribe(this.onMouseup), mousemove$.subscribe(this.onMousemove), fromEvent(erd, "mousemove").subscribe(this.onMousemoveERD));
        }
        render() {
            return svg `
      <svg 
        class="vuerd-drag-select" 
        style=${styleMap({
                top: `${this.top}px`,
                left: `${this.left}px`,
                width: `${this.width}px`,
                height: `${this.height}px`,
            })}
      >
        <rect
          width=${this.width}
          height=${this.height}
          stroke-width="1"
          stroke-opacity="0.9"
          stroke-dasharray="3"
          fill-opacity="0.3"
        >
        </rect>
      </svg>
    `;
        }
    };
    __decorate([
        property({ type: Number })
    ], DargSelect.prototype, "x", void 0);
    __decorate([
        property({ type: Number })
    ], DargSelect.prototype, "y", void 0);
    __decorate([
        property({ type: Number })
    ], DargSelect.prototype, "ghostX", void 0);
    __decorate([
        property({ type: Number })
    ], DargSelect.prototype, "ghostY", void 0);
    __decorate([
        property({ type: Number })
    ], DargSelect.prototype, "top", void 0);
    __decorate([
        property({ type: Number })
    ], DargSelect.prototype, "left", void 0);
    __decorate([
        property({ type: Number })
    ], DargSelect.prototype, "width", void 0);
    __decorate([
        property({ type: Number })
    ], DargSelect.prototype, "height", void 0);
    DargSelect = __decorate([
        customElement("vuerd-drag-select")
    ], DargSelect);

    let DrawRelationship = class DrawRelationship extends EditorElement {
        constructor() {
            super(...arguments);
            this.subDrawRelationship = null;
            this.onMousemoveERD = (event) => {
                event.preventDefault();
                const el = event.target;
                if (!el.closest(".vuerd-table") &&
                    !el.closest(".vuerd-memo") &&
                    !el.closest(".vuerd-contextmenu") &&
                    !el.closest(".vuerd-minimap") &&
                    !el.closest(".vuerd-minimap-handle")) {
                    const { store } = this.context;
                    store.dispatch(drawRelationship$1(event.offsetX, event.offsetY));
                }
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            const root = this.getRootNode();
            const erd = root.querySelector(".vuerd-erd");
            this.subscriptionList.push(fromEvent(erd, "mousemove").subscribe(this.onMousemoveERD), store.observe(store.canvasState, (name) => {
                switch (name) {
                    case "width":
                    case "height":
                        this.requestUpdate();
                        break;
                }
            }), store.observe(store.editorState, (name) => {
                const { drawRelationship } = store.editorState;
                if (name === "drawRelationship") {
                    this.unsubscribeDrawRelationship();
                    if (drawRelationship !== null) {
                        this.observeDrawRelationship();
                    }
                }
            }));
            this.observeDrawRelationship();
        }
        disconnectedCallback() {
            this.unsubscribeDrawRelationship();
            super.disconnectedCallback();
        }
        render() {
            const { width, height } = this.context.store.canvasState;
            const { path, line } = getDraw(this.draw);
            return svg `
      <svg
        class="vuerd-draw-relationship"
        style=${styleMap({
                width: `${width}px`,
                height: `${height}px`,
            })}
      >
        <g>
          <line
            x1=${path.line.start.x1} y1=${path.line.start.y1}
            x2=${path.line.start.x2} y2=${path.line.start.y2}
            stroke-width="3"
          ></line>
          <path
            d=${path.path.d()}
            stroke-dasharray="10"
            stroke-width="3" fill="transparent"
          ></path>
          <line
            x1=${line.start.x1} y1=${line.start.y1}
            x2=${line.start.x2} y2=${line.start.y2}
            stroke-width="3"
          ></line>
        </g>
      </svg>
    `;
        }
        observeDrawRelationship() {
            const { store } = this.context;
            const { drawRelationship } = this.context.store.editorState;
            if (drawRelationship) {
                store.observe(drawRelationship.end, () => this.requestUpdate());
            }
        }
        unsubscribeDrawRelationship() {
            var _a;
            (_a = this.subDrawRelationship) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this.subDrawRelationship = null;
        }
    };
    DrawRelationship = __decorate([
        customElement("vuerd-draw-relationship")
    ], DrawRelationship);

    const PADDING = 10 * 2;
    const HEIGHT = 30 + PADDING;
    let Find$1 = class Find extends EditorElement {
        constructor() {
            super(...arguments);
            this.animation = true;
            this.top = 0;
            this.animationFrame = new AnimationFrame(200);
            this.onClose = () => {
                this.animation = true;
                this.animationFrame
                    .play({ top: this.top }, { top: -1 * HEIGHT })
                    .update((value) => {
                        this.top = value.top;
                    })
                    .complete(() => {
                        this.dispatchEvent(new CustomEvent("close"));
                    })
                    .start();
            };
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-find")) {
                    this.onClose();
                }
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { eventBus } = this.context;
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.subscriptionList.push(fromEvent(editor, "mousedown").subscribe(this.onMousedown), eventBus.on(Bus.Find.close).subscribe(this.onClose));
            this.top = -1 * HEIGHT;
        }
        firstUpdated() {
            this.animationFrame
                .play({ top: -1 * HEIGHT }, { top: SIZE_MENUBAR_HEIGHT })
                .update((value) => {
                    this.top = value.top;
                })
                .complete(() => {
                    this.animation = false;
                })
                .start();
        }
        render() {
            const { keymap } = this.context;
            const keymapStop = keymapOptionToString(keymap.stop[0]);
            return html `
      <div
        class="vuerd-find"
        style=${styleMap({
                top: `${this.top}px`,
                height: `${HEIGHT}px`,
            })}
      >
        <div class="vuerd-find-header">
          <h3>Find</h3>
          <vuerd-find-table @blur=${this.onClose}></vuerd-find-table>
          <vuerd-icon
            class="vuerd-button"
            title=${keymapStop}
            icon="times"
            size="12"
            @click=${this.onClose}
          ></vuerd-icon>
        </div>
      </div>
    `;
        }
    };
    __decorate([
        property({ type: Boolean })
    ], Find$1.prototype, "animation", void 0);
    __decorate([
        property({ type: Number })
    ], Find$1.prototype, "top", void 0);
    Find$1 = __decorate([
        customElement("vuerd-find")
    ], Find$1);

    let FindTable = class FindTable extends EditorElement {
        constructor() {
            super(...arguments);
            this.value = "";
            this.hints = [];
            this.startFilter = true;
            this.flipAnimation = new FlipAnimation(this.renderRoot, ".vuerd-find-table-hint", "vuerd-find-table-hint-move");
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-find-table")) {
                    this.dispatchEvent(new Event("blur"));
                }
            };
        }
        get activeIndex() {
            let index = null;
            for (let i = 0; i < this.hints.length; i++) {
                if (this.hints[i].active) {
                    index = i;
                    break;
                }
            }
            return index;
        }
        connectedCallback() {
            super.connectedCallback();
            const { eventBus } = this.context;
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.hintFilter();
            this.subscriptionList.push(fromEvent(editor, "mousedown").subscribe(this.onMousedown));
            eventBus.emit(Bus.TableProperties.closeOnly);
        }
        firstUpdated() {
            const input = this.renderRoot.querySelector("input");
            input === null || input === void 0 ? void 0 : input.focus();
        }
        updated(changedProperties) {
            changedProperties.forEach((oldValue, propName) => {
                switch (propName) {
                    case "value":
                        this.flipAnimation.snapshot();
                        this.hintFilter();
                        break;
                    case "hints":
                        this.flipAnimation.play();
                        break;
                }
            });
        }
        render() {
            return html `
      <div class="vuerd-find-table">
        <input
          type="text"
          spellcheck="false"
          .value=${this.value}
          placeholder="table"
          @keydown=${this.onKeydown}
          @input=${this.onInput}
        />
        <ul class="vuerd-find-table-list">
          ${repeat$1(this.hints, (hint) => hint.id, (hint) => {
                return html `
                <li
                  class=${classMap({
                    "vuerd-find-table-hint": true,
                    active: hint.active,
                })}
                  @click=${() => this.onSelectHint(hint)}
                >
                  ${unsafeHTML(hint.html)}
                </li>
              `;
            })}
        </ul>
      </div>
    `;
        }
        onInput(event) {
            const input = event.target;
            this.value = input.value;
            this.onStartFilter();
        }
        onKeydown(event) {
            switch (event.key) {
                case "ArrowUp":
                    this.onArrowUp(event);
                    break;
                case "ArrowDown":
                    this.onArrowDown(event);
                    break;
                case "ArrowLeft":
                    this.onArrowLeft(event);
                    break;
                case "Enter":
                case "ArrowRight":
                    this.onArrowRight(event);
                    break;
            }
        }
        onArrowUp(event) {
            if (this.hints.length !== 0) {
                event.preventDefault();
            }
            const index = this.activeIndex;
            if (index !== null && index !== 0) {
                this.hints[index].active = false;
                this.hints[index - 1].active = true;
                this.requestUpdate();
            }
            else if (this.hints.length !== 0) {
                if (index === 0) {
                    this.hints[index].active = false;
                }
                this.hints[this.hints.length - 1].active = true;
                this.requestUpdate();
            }
        }
        onArrowDown(event) {
            if (this.hints.length !== 0) {
                event.preventDefault();
            }
            const index = this.activeIndex;
            if (index !== null && index !== this.hints.length - 1) {
                this.hints[index].active = false;
                this.hints[index + 1].active = true;
                this.requestUpdate();
            }
            else if (this.hints.length !== 0) {
                if (index === this.hints.length - 1) {
                    this.hints[index].active = false;
                }
                this.hints[0].active = true;
                this.requestUpdate();
            }
        }
        onArrowLeft(event) {
            this.activeEnd();
            this.requestUpdate();
        }
        onArrowRight(event) {
            const { tables } = this.context.store.tableState;
            const index = this.activeIndex;
            if (index !== null) {
                event.preventDefault();
                this.startFilter = false;
                const table = getData(tables, this.hints[index].id);
                if (table) {
                    this.moveCanvasFindTable(table);
                }
            }
        }
        onStartFilter() {
            this.startFilter = true;
        }
        onSelectHint(hint) {
            const { tables } = this.context.store.tableState;
            this.startFilter = false;
            this.activeEnd();
            const input = this.renderRoot.querySelector("input");
            if (input) {
                const len = input.value.length;
                input.selectionStart = len;
                input.selectionEnd = len;
                input.focus();
            }
            const table = getData(tables, hint.id);
            if (table) {
                this.moveCanvasFindTable(table);
            }
        }
        hintFilter() {
            const { tables } = this.context.store.tableState;
            if (this.startFilter) {
                if (this.value.trim().length < 1) {
                    this.hints = [];
                }
                else {
                    this.hints = tables
                        .filter((table) => table.name.toLowerCase().indexOf(this.value.toLowerCase()) !== -1)
                        .map((table) => {
                            return {
                                id: table.id,
                                name: table.name,
                                html: markToHTML("vuerd-mark", table.name, this.value),
                                active: false,
                            };
                        });
                }
            }
        }
        activeEnd() {
            this.hints.forEach((hint) => (hint.active = false));
        }
        moveCanvasFindTable(table) {
            const { store } = this.context;
            store.dispatch(moveCanvas(table.ui.top - SIZE_START_Y, table.ui.left - SIZE_START_X), selectOnlyTable(store, table.id));
        }
    };
    __decorate([
        property({ type: String })
    ], FindTable.prototype, "value", void 0);
    __decorate([
        property({ type: Array })
    ], FindTable.prototype, "hints", void 0);
    FindTable = __decorate([
        customElement("vuerd-find-table")
    ], FindTable);

    let ShareMouse = class ShareMouse extends EditorElement {
        constructor() {
            super(...arguments);
            this.x = 0;
            this.y = 0;
            this.subLerp = null;
        }
        connectedCallback() {
            super.connectedCallback();
            const { requestAnimationFrame$ } = this.context.windowEventObservable;
            this.x = this.userMouse.x;
            this.y = this.userMouse.y;
            this.subLerp = requestAnimationFrame$.subscribe(() => {
                this.x += (this.userMouse.x - this.x) * 0.2;
                this.y += (this.userMouse.y - this.y) * 0.2;
                this.requestUpdate();
            });
        }
        disconnectedCallback() {
            var _a;
            (_a = this.subLerp) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            super.disconnectedCallback();
        }
        render() {
            return html `
      <div
        class="vuerd-share-mouse"
        style=${styleMap({
                top: `${this.y}px`,
                left: `${this.x}px`,
            })}
      >
        <vuerd-icon
          icon="mouse-pointer"
          size="18"
          color=${this.userMouse.color}
        ></vuerd-icon>
        <span>${this.userMouse.name}</span>
      </div>
    `;
        }
    };
    ShareMouse = __decorate([
        customElement("vuerd-share-mouse")
    ], ShareMouse);

    let ERD$1 = class ERD extends EditorElement {
        constructor() {
            super(...arguments);
            this.width = defaultWidth;
            this.height = defaultHeight;
            this.contextmenu = false;
            this.select = false;
            this.selectX = 0;
            this.selectY = 0;
            this.selectGhostX = 0;
            this.selectGhostY = 0;
            this.contextmenuX = 0;
            this.contextmenuY = 0;
            this.contextmenuRelationship = null;
            this.subMoveEnd = null;
            this.subMove = null;
            this.subDrawRelationship = null;
            this.menus = [];
            this.onContextmenuEnd = (event) => {
                this.contextmenu = false;
                this.contextmenuRelationship = null;
            };
            this.onMoveEnd = (event) => {
                var _a, _b;
                (_a = this.subMoveEnd) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                (_b = this.subMove) === null || _b === void 0 ? void 0 : _b.unsubscribe();
                this.subMoveEnd = null;
                this.subMove = null;
            };
            this.onMove = ({ event, movementX, movementY }) => {
                if (event.type === "mousemove") {
                    event.preventDefault();
                }
                const erd = this.erd;
                if (erd) {
                    erd.scrollTop -= movementY;
                    erd.scrollLeft -= movementX;
                    const { store } = this.context;
                    store.dispatch(moveCanvas(erd.scrollTop, erd.scrollLeft));
                }
            };
        }
        get styleMap() {
            const { drawRelationship } = this.context.store.editorState;
            const styleMap = {
                width: `${this.width}px`,
                height: `${this.height}px`,
            };
            if (drawRelationship) {
                styleMap.cursor = `url("${getBase64Icon(drawRelationship.relationshipType)}") 16 16, auto`;
            }
            return styleMap;
        }
        get erd() {
            return this.renderRoot.querySelector(".vuerd-erd");
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus, keymap, helper } = this.context;
            this.subscriptionList.push(eventBus.on(Bus.ERD.contextmenuEnd).subscribe(this.onContextmenuEnd), store.observe(store.canvasState, (name) => {
                if (name === "scrollTop" || name === "scrollLeft") {
                    const erd = this.erd;
                    if (erd) {
                        erd.scrollTop = store.canvasState.scrollTop;
                        erd.scrollLeft = store.canvasState.scrollLeft;
                        this.onScrollValid();
                    }
                }
            }), store.observe(store.editorState, (name) => {
                const { drawRelationship } = store.editorState;
                if (name === "drawRelationship") {
                    this.unsubscribeDrawRelationship();
                    if (drawRelationship !== null) {
                        this.observeDrawRelationship();
                    }
                    this.requestUpdate();
                }
            }), helper.keydown$.subscribe((event) => {
                const { editTable: editTable$1, focusTable, copyColumns, findActive: findActive$1, } = store.editorState;
                if (keymapMatch(event, keymap.addTable)) {
                    store.dispatch(addTable(store));
                }
                if (keymapMatch(event, keymap.addColumn) &&
                    store.tableState.tables.some((table) => table.ui.active)) {
                    store.dispatch(addColumn(store), findActiveEnd());
                }
                if (keymapMatch(event, keymap.addMemo)) {
                    store.dispatch(addMemo(store));
                }
                if (keymapMatch(event, keymap.removeTable) &&
                    (store.tableState.tables.some((table) => table.ui.active) ||
                        store.memoState.memos.some((memo) => memo.ui.active))) {
                    const batchCommand = [];
                    if (store.tableState.tables.some((table) => table.ui.active)) {
                        batchCommand.push(removeTable(store));
                    }
                    if (store.memoState.memos.some((memo) => memo.ui.active)) {
                        batchCommand.push(removeMemo(store));
                    }
                    store.dispatch(...batchCommand);
                }
                if (focusTable !== null && keymapMatch(event, keymap.removeColumn)) {
                    const columns = focusTable.selectColumns;
                    if (columns.length !== 0) {
                        store.dispatch(removeColumn(focusTable.id, columns.map((column) => column.id)));
                    }
                }
                if (focusTable !== null && keymapMatch(event, keymap.primaryKey)) {
                    const currentFocus = focusTable.currentFocus;
                    if (currentFocus !== "tableName" && currentFocus !== "tableComment") {
                        const columnId = focusTable.currentFocusId;
                        store.dispatch(changeColumnPrimaryKey(store, focusTable.id, columnId));
                    }
                }
                if (editTable$1 === null && keymapMatch(event, keymap.selectAllTable)) {
                    store.dispatch(selectAllTable(), selectAllMemo());
                }
                if (editTable$1 === null && keymapMatch(event, keymap.selectAllColumn)) {
                    store.dispatch(selectAllColumn$1());
                }
                if (focusTable !== null &&
                    editTable$1 === null &&
                    moveKeys.some((moveKey) => moveKey === event.key)) {
                    store.dispatch(focusMoveTable(event.key, event.shiftKey));
                }
                if (focusTable !== null && event.key === "Tab") {
                    event.preventDefault();
                    store.dispatch(focusMoveTable("Tab", event.shiftKey));
                    // TODO: Refactoring edit
                    setTimeout(() => {
                        if (![
                            "columnUnique",
                            "columnAutoIncrement",
                            "columnNotNull",
                        ].includes(focusTable.currentFocus)) {
                            store.dispatch(editTable(focusTable.currentFocusId, focusTable.currentFocus));
                        }
                    }, 0);
                }
                if (focusTable !== null && keymapMatch(event, keymap.edit)) {
                    if (editTable$1 === null) {
                        const currentFocus = focusTable.currentFocus;
                        if (currentFocus === "columnNotNull") {
                            const columnId = focusTable.currentFocusId;
                            store.dispatch(changeColumnNotNull(store, focusTable.id, columnId));
                        }
                        else if (currentFocus === "columnUnique") {
                            const columnId = focusTable.currentFocusId;
                            store.dispatch(changeColumnUnique(store, focusTable.id, columnId));
                        }
                        else if (currentFocus === "columnAutoIncrement") {
                            const columnId = focusTable.currentFocusId;
                            store.dispatch(changeColumnAutoIncrement(store, focusTable.id, columnId));
                        }
                        else {
                            store.dispatch(editTable(focusTable.currentFocusId, focusTable.currentFocus));
                        }
                    }
                    else {
                        store.dispatch(editTableEnd());
                    }
                }
                relationshipMenus.forEach((relationshipMenu) => {
                    if (keymapMatch(event, keymap[relationshipMenu.keymapName])) {
                        store.dispatch(drawStartRelationship(relationshipMenu.relationshipType));
                    }
                });
                if (focusTable !== null &&
                    editTable$1 === null &&
                    keymapMatch(event, keymap.copyColumn)) {
                    const columns = focusTable.selectColumns;
                    if (columns.length !== 0) {
                        store.dispatch(copyColumn(focusTable.id, columns.map((column) => column.id)));
                    }
                }
                if (editTable$1 === null &&
                    copyColumns.length !== 0 &&
                    keymapMatch(event, keymap.pasteColumn) &&
                    store.tableState.tables.some((table) => table.ui.active)) {
                    store.dispatch(pasteColumn(store));
                }
                if (keymapMatch(event, keymap.find)) {
                    event.preventDefault();
                    store.dispatch(findActive());
                }
                if (keymapMatch(event, keymap.stop)) {
                    const batchCommand = [
                        selectEndMemo(),
                        drawEndRelationship(),
                    ];
                    if (findActive$1) {
                        const table = store.tableState.tables.find((table) => table.ui.active);
                        if (table) {
                            batchCommand.push(selectTable(store, false, table.id));
                        }
                    }
                    else {
                        batchCommand.push(selectEndTable());
                    }
                    store.dispatch(...batchCommand);
                }
                if (keymapMatch(event, keymap.undo)) {
                    event.preventDefault();
                    store.undo();
                }
                if (keymapMatch(event, keymap.redo)) {
                    event.preventDefault();
                    store.redo();
                }
                if (keymapMatch(event, keymap.tableProperties) &&
                    store.tableState.tables.some((table) => table.ui.active)) {
                    const table = store.tableState.tables.find((table) => table.ui.active);
                    if (table) {
                        eventBus.emit(Bus.Editor.tableProperties, {
                            tableId: table.id,
                        });
                    }
                }
            }));
            const erd = this.erd;
            if (erd) {
                requestAnimationFrame(() => {
                    erd.scrollTop = store.canvasState.scrollTop;
                    erd.scrollLeft = store.canvasState.scrollLeft;
                    this.onScrollValid();
                });
            }
        }
        firstUpdated() {
            const { store } = this.context;
            requestAnimationFrame(() => {
                const erd = this.erd;
                if (erd) {
                    erd.scrollTop = store.canvasState.scrollTop;
                    erd.scrollLeft = store.canvasState.scrollLeft;
                    this.onScrollValid();
                }
            });
        }
        disconnectedCallback() {
            this.onMoveEnd();
            this.unsubscribeDrawRelationship();
            super.disconnectedCallback();
        }
        render() {
            const { drawRelationship } = this.context.store.editorState;
            return html `
      <div
        class="vuerd-erd"
        style=${styleMap(this.styleMap)}
        @mousemove=${this.onTrack}
        @mousedown=${this.onMousedown}
        @touchstart=${this.onTouchstart}
        @contextmenu=${this.onContextmenu}
      >
        <vuerd-canvas></vuerd-canvas>
        <vuerd-minimap
          .width=${this.width}
          .height=${this.height}
        ></vuerd-minimap>
        ${this.contextmenu
                ? html `
              <vuerd-contextmenu
                .menus=${this.menus}
                .x=${this.contextmenuX}
                .y=${this.contextmenuY}
                .relationship=${this.contextmenuRelationship}
              ></vuerd-contextmenu>
            `
                : ""}
        ${this.select
                ? html `
              <vuerd-drag-select
                .x=${this.selectX}
                .y=${this.selectY}
                .ghostX=${this.selectGhostX}
                .ghostY=${this.selectGhostY}
                @select-end=${this.onSelectEnd}
              ></vuerd-drag-select>
            `
                : ""}
        ${(drawRelationship === null || drawRelationship === void 0 ? void 0 : drawRelationship.start) ? html `
              <vuerd-draw-relationship
                .draw=${drawRelationship}
              ></vuerd-draw-relationship>
            `
                : ""}
      </div>
    `;
        }
        onContextmenu(event) {
            event.preventDefault();
            const el = event.target;
            const { store } = this.context;
            this.contextmenuX = event.x;
            this.contextmenuY = event.y;
            const tableTag = el.closest(".vuerd-table");
            const relationshipTag = el.closest(".vuerd-relationship");
            if (!relationshipTag && !tableTag) {
                this.menus = createContextmenuERD(this.context);
                this.contextmenu = true;
            }
            else if (relationshipTag) {
                const id = relationshipTag.dataset.id;
                const { relationships } = this.context.store.relationshipState;
                const relationship = getData(relationships, id);
                if (relationship) {
                    this.menus = createContextmenuRelationship(store, relationship);
                    this.contextmenuRelationship = relationship;
                    this.contextmenu = true;
                }
            }
            else if (tableTag) {
                const id = tableTag.dataset.id;
                this.menus = createContextmenuTable(this.context, id);
                this.contextmenu = true;
            }
        }
        onMousedown(event) {
            const el = event.target;
            if (!el.closest(".vuerd-contextmenu")) {
                this.contextmenu = false;
            }
            if (!el.closest(".vuerd-contextmenu") &&
                !el.closest(".vuerd-table") &&
                !el.closest(".vuerd-memo") &&
                !el.closest(".vuerd-minimap") &&
                !el.closest(".vuerd-minimap-handle")) {
                const { store } = this.context;
                const { moveEnd$, move$ } = this.context.windowEventObservable;
                store.dispatch(selectEndTable(), selectEndMemo());
                if (event.ctrlKey || event.metaKey) {
                    this.selectX = event.x;
                    this.selectY = event.y;
                    this.selectGhostX = event.offsetX;
                    this.selectGhostY = event.offsetY;
                    this.select = true;
                }
                else {
                    this.onMoveEnd();
                    this.subMoveEnd = moveEnd$.subscribe(this.onMoveEnd);
                    this.subMove = move$.subscribe(this.onMove);
                }
            }
        }
        onTouchstart(event) {
            const el = event.target;
            if (!el.closest(".vuerd-contextmenu")) {
                this.contextmenu = false;
            }
            if (!el.closest(".vuerd-contextmenu") &&
                !el.closest(".vuerd-table") &&
                !el.closest(".vuerd-memo") &&
                !el.closest(".vuerd-minimap") &&
                !el.closest(".vuerd-minimap-handle")) {
                const { store } = this.context;
                const { moveEnd$, move$ } = this.context.windowEventObservable;
                store.dispatch(selectEndTable(), selectEndMemo());
                this.onMoveEnd();
                this.subMoveEnd = moveEnd$.subscribe(this.onMoveEnd);
                this.subMove = move$.subscribe(this.onMove);
            }
        }
        onSelectEnd() {
            this.select = false;
        }
        onScrollValid() {
            const { store } = this.context;
            const { canvasState } = store;
            const erd = this.erd;
            if (erd &&
                (erd.scrollTop !== canvasState.scrollTop ||
                    erd.scrollLeft !== canvasState.scrollLeft)) {
                canvasState.scrollTop = erd.scrollTop;
                canvasState.scrollLeft = erd.scrollLeft;
                // store.dispatch(moveCanvas(erd.scrollTop, erd.scrollLeft));
            }
        }
        onTrack(event) {
            const el = event.target;
            if (!el.closest(".vuerd-table") &&
                !el.closest(".vuerd-memo") &&
                !el.closest(".vuerd-contextmenu") &&
                !el.closest(".vuerd-minimap") &&
                !el.closest(".vuerd-minimap-handle") &&
                !el.closest(".vuerd-share-mouse")) {
                const { store } = this.context;
                store.dispatch(shareMouse$1(event.offsetX, event.offsetY));
            }
        }
        observeDrawRelationship() {
            const { store } = this.context;
            const { drawRelationship } = this.context.store.editorState;
            if (drawRelationship) {
                store.observe(drawRelationship, () => this.requestUpdate());
            }
        }
        unsubscribeDrawRelationship() {
            var _a;
            (_a = this.subDrawRelationship) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this.subDrawRelationship = null;
        }
    };
    __decorate([
        property({ type: Number })
    ], ERD$1.prototype, "width", void 0);
    __decorate([
        property({ type: Number })
    ], ERD$1.prototype, "height", void 0);
    __decorate([
        property({ type: Boolean })
    ], ERD$1.prototype, "contextmenu", void 0);
    __decorate([
        property({ type: Boolean })
    ], ERD$1.prototype, "select", void 0);
    ERD$1 = __decorate([
        customElement("vuerd-erd")
    ], ERD$1);

    var jquery = createCommonjsModule(function (module) {
        /*!
     * jQuery JavaScript Library v1.12.4
     * http://jquery.com/
     *
     * Includes Sizzle.js
     * http://sizzlejs.com/
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2016-05-20T17:17Z
     */

        (function( global, factory ) {

            {
                // For CommonJS and CommonJS-like environments where a proper `window`
                // is present, execute the factory and get jQuery.
                // For environments that do not have a `window` with a `document`
                // (such as Node.js), expose a factory as module.exports.
                // This accentuates the need for the creation of a real `window`.
                // e.g. var jQuery = require("jquery")(window);
                // See ticket #14549 for more info.
                module.exports = global.document ?
                    factory( global, true ) :
                    function( w ) {
                        if ( !w.document ) {
                            throw new Error( "jQuery requires a window with a document" );
                        }
                        return factory( w );
                    };
            }

            // Pass this if window is not defined yet
        }(typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

            // Support: Firefox 18+
            // Can't be in strict mode, several libs including ASP.NET trace
            // the stack via arguments.caller.callee and Firefox dies if
            // you try to trace through "use strict" call chains. (#13335)
            //"use strict";
            var deletedIds = [];

            var document = window.document;

            var slice = deletedIds.slice;

            var concat = deletedIds.concat;

            var push = deletedIds.push;

            var indexOf = deletedIds.indexOf;

            var class2type = {};

            var toString = class2type.toString;

            var hasOwn = class2type.hasOwnProperty;

            var support = {};



            var
                version = "1.12.4",

                // Define a local copy of jQuery
                jQuery = function( selector, context ) {

                    // The jQuery object is actually just the init constructor 'enhanced'
                    // Need init if jQuery is called (just allow error to be thrown if not included)
                    return new jQuery.fn.init( selector, context );
                },

                // Support: Android<4.1, IE<9
                // Make sure we trim BOM and NBSP
                rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

                // Matches dashed string for camelizing
                rmsPrefix = /^-ms-/,
                rdashAlpha = /-([\da-z])/gi,

                // Used by jQuery.camelCase as callback to replace()
                fcamelCase = function( all, letter ) {
                    return letter.toUpperCase();
                };

            jQuery.fn = jQuery.prototype = {

                // The current version of jQuery being used
                jquery: version,

                constructor: jQuery,

                // Start with an empty selector
                selector: "",

                // The default length of a jQuery object is 0
                length: 0,

                toArray: function() {
                    return slice.call( this );
                },

                // Get the Nth element in the matched element set OR
                // Get the whole matched element set as a clean array
                get: function( num ) {
                    return num != null ?

                        // Return just the one element from the set
                        ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

                        // Return all the elements in a clean array
                        slice.call( this );
                },

                // Take an array of elements and push it onto the stack
                // (returning the new matched element set)
                pushStack: function( elems ) {

                    // Build a new jQuery matched element set
                    var ret = jQuery.merge( this.constructor(), elems );

                    // Add the old object onto the stack (as a reference)
                    ret.prevObject = this;
                    ret.context = this.context;

                    // Return the newly-formed element set
                    return ret;
                },

                // Execute a callback for every element in the matched set.
                each: function( callback ) {
                    return jQuery.each( this, callback );
                },

                map: function( callback ) {
                    return this.pushStack( jQuery.map( this, function( elem, i ) {
                        return callback.call( elem, i, elem );
                    } ) );
                },

                slice: function() {
                    return this.pushStack( slice.apply( this, arguments ) );
                },

                first: function() {
                    return this.eq( 0 );
                },

                last: function() {
                    return this.eq( -1 );
                },

                eq: function( i ) {
                    var len = this.length,
                        j = +i + ( i < 0 ? len : 0 );
                    return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
                },

                end: function() {
                    return this.prevObject || this.constructor();
                },

                // For internal use only.
                // Behaves like an Array's method, not like a jQuery method.
                push: push,
                sort: deletedIds.sort,
                splice: deletedIds.splice
            };

            jQuery.extend = jQuery.fn.extend = function() {
                var src, copyIsArray, copy, name, options, clone,
                    target = arguments[ 0 ] || {},
                    i = 1,
                    length = arguments.length,
                    deep = false;

                // Handle a deep copy situation
                if ( typeof target === "boolean" ) {
                    deep = target;

                    // skip the boolean and the target
                    target = arguments[ i ] || {};
                    i++;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
                    target = {};
                }

                // extend jQuery itself if only one argument is passed
                if ( i === length ) {
                    target = this;
                    i--;
                }

                for ( ; i < length; i++ ) {

                    // Only deal with non-null/undefined values
                    if ( ( options = arguments[ i ] ) != null ) {

                        // Extend the base object
                        for ( name in options ) {
                            src = target[ name ];
                            copy = options[ name ];

                            // Prevent never-ending loop
                            if ( target === copy ) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
                                ( copyIsArray = jQuery.isArray( copy ) ) ) ) {

                                if ( copyIsArray ) {
                                    copyIsArray = false;
                                    clone = src && jQuery.isArray( src ) ? src : [];

                                } else {
                                    clone = src && jQuery.isPlainObject( src ) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[ name ] = jQuery.extend( deep, clone, copy );

                                // Don't bring in undefined values
                            } else if ( copy !== undefined ) {
                                target[ name ] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            };

            jQuery.extend( {

                // Unique for each copy of jQuery on the page
                expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

                // Assume jQuery is ready without the ready module
                isReady: true,

                error: function( msg ) {
                    throw new Error( msg );
                },

                noop: function() {},

                // See test/unit/core.js for details concerning isFunction.
                // Since version 1.3, DOM methods and functions like alert
                // aren't supported. They return false on IE (#2968).
                isFunction: function( obj ) {
                    return jQuery.type( obj ) === "function";
                },

                isArray: Array.isArray || function( obj ) {
                    return jQuery.type( obj ) === "array";
                },

                isWindow: function( obj ) {
                    /* jshint eqeqeq: false */
                    return obj != null && obj == obj.window;
                },

                isNumeric: function( obj ) {

                    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
                    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                    // subtraction forces infinities to NaN
                    // adding 1 corrects loss of precision from parseFloat (#15100)
                    var realStringObj = obj && obj.toString();
                    return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
                },

                isEmptyObject: function( obj ) {
                    var name;
                    for ( name in obj ) {
                        return false;
                    }
                    return true;
                },

                isPlainObject: function( obj ) {
                    var key;

                    // Must be an Object.
                    // Because of IE, we also have to check the presence of the constructor property.
                    // Make sure that DOM nodes and window objects don't pass through, as well
                    if ( !obj || jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                        return false;
                    }

                    try {

                        // Not own constructor property must be Object
                        if ( obj.constructor &&
                            !hasOwn.call( obj, "constructor" ) &&
                            !hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
                            return false;
                        }
                    } catch ( e ) {

                        // IE8,9 Will throw exceptions on certain host objects #9897
                        return false;
                    }

                    // Support: IE<9
                    // Handle iteration over inherited properties before own properties.
                    if ( !support.ownFirst ) {
                        for ( key in obj ) {
                            return hasOwn.call( obj, key );
                        }
                    }

                    // Own properties are enumerated firstly, so to speed up,
                    // if last one is own, then all properties are own.
                    for ( key in obj ) {}

                    return key === undefined || hasOwn.call( obj, key );
                },

                type: function( obj ) {
                    if ( obj == null ) {
                        return obj + "";
                    }
                    return typeof obj === "object" || typeof obj === "function" ?
                        class2type[ toString.call( obj ) ] || "object" :
                        typeof obj;
                },

                // Workarounds based on findings by Jim Driscoll
                // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
                globalEval: function( data ) {
                    if ( data && jQuery.trim( data ) ) {

                        // We use execScript on Internet Explorer
                        // We use an anonymous function so that context is window
                        // rather than jQuery in Firefox
                        ( window.execScript || function( data ) {
                            window[ "eval" ].call( window, data ); // jscs:ignore requireDotNotation
                        } )( data );
                    }
                },

                // Convert dashed to camelCase; used by the css and data modules
                // Microsoft forgot to hump their vendor prefix (#9572)
                camelCase: function( string ) {
                    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
                },

                nodeName: function( elem, name ) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                },

                each: function( obj, callback ) {
                    var length, i = 0;

                    if ( isArrayLike( obj ) ) {
                        length = obj.length;
                        for ( ; i < length; i++ ) {
                            if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                                break;
                            }
                        }
                    } else {
                        for ( i in obj ) {
                            if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                                break;
                            }
                        }
                    }

                    return obj;
                },

                // Support: Android<4.1, IE<9
                trim: function( text ) {
                    return text == null ?
                        "" :
                        ( text + "" ).replace( rtrim, "" );
                },

                // results is for internal usage only
                makeArray: function( arr, results ) {
                    var ret = results || [];

                    if ( arr != null ) {
                        if ( isArrayLike( Object( arr ) ) ) {
                            jQuery.merge( ret,
                                typeof arr === "string" ?
                                    [ arr ] : arr
                            );
                        } else {
                            push.call( ret, arr );
                        }
                    }

                    return ret;
                },

                inArray: function( elem, arr, i ) {
                    var len;

                    if ( arr ) {
                        if ( indexOf ) {
                            return indexOf.call( arr, elem, i );
                        }

                        len = arr.length;
                        i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

                        for ( ; i < len; i++ ) {

                            // Skip accessing in sparse arrays
                            if ( i in arr && arr[ i ] === elem ) {
                                return i;
                            }
                        }
                    }

                    return -1;
                },

                merge: function( first, second ) {
                    var len = +second.length,
                        j = 0,
                        i = first.length;

                    while ( j < len ) {
                        first[ i++ ] = second[ j++ ];
                    }

                    // Support: IE<9
                    // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
                    if ( len !== len ) {
                        while ( second[ j ] !== undefined ) {
                            first[ i++ ] = second[ j++ ];
                        }
                    }

                    first.length = i;

                    return first;
                },

                grep: function( elems, callback, invert ) {
                    var callbackInverse,
                        matches = [],
                        i = 0,
                        length = elems.length,
                        callbackExpect = !invert;

                    // Go through the array, only saving the items
                    // that pass the validator function
                    for ( ; i < length; i++ ) {
                        callbackInverse = !callback( elems[ i ], i );
                        if ( callbackInverse !== callbackExpect ) {
                            matches.push( elems[ i ] );
                        }
                    }

                    return matches;
                },

                // arg is for internal usage only
                map: function( elems, callback, arg ) {
                    var length, value,
                        i = 0,
                        ret = [];

                    // Go through the array, translating each of the items to their new values
                    if ( isArrayLike( elems ) ) {
                        length = elems.length;
                        for ( ; i < length; i++ ) {
                            value = callback( elems[ i ], i, arg );

                            if ( value != null ) {
                                ret.push( value );
                            }
                        }

                        // Go through every key on the object,
                    } else {
                        for ( i in elems ) {
                            value = callback( elems[ i ], i, arg );

                            if ( value != null ) {
                                ret.push( value );
                            }
                        }
                    }

                    // Flatten any nested arrays
                    return concat.apply( [], ret );
                },

                // A global GUID counter for objects
                guid: 1,

                // Bind a function to a context, optionally partially applying any
                // arguments.
                proxy: function( fn, context ) {
                    var args, proxy, tmp;

                    if ( typeof context === "string" ) {
                        tmp = fn[ context ];
                        context = fn;
                        fn = tmp;
                    }

                    // Quick check to determine if target is callable, in the spec
                    // this throws a TypeError, but we will just return undefined.
                    if ( !jQuery.isFunction( fn ) ) {
                        return undefined;
                    }

                    // Simulated bind
                    args = slice.call( arguments, 2 );
                    proxy = function() {
                        return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
                    };

                    // Set the guid of unique handler to the same of original handler, so it can be removed
                    proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                    return proxy;
                },

                now: function() {
                    return +( new Date() );
                },

                // jQuery.support is not used in Core but other projects attach their
                // properties to it so it needs to exist.
                support: support
            } );

            // JSHint would error on this code due to the Symbol not being defined in ES5.
            // Defining this global in .jshintrc would create a danger of using the global
            // unguarded in another place, it seems safer to just disable JSHint for these
            // three lines.
            /* jshint ignore: start */
            if ( typeof Symbol === "function" ) {
                jQuery.fn[ Symbol.iterator ] = deletedIds[ Symbol.iterator ];
            }
            /* jshint ignore: end */

            // Populate the class2type map
            jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
                function( i, name ) {
                    class2type[ "[object " + name + "]" ] = name.toLowerCase();
                } );

            function isArrayLike( obj ) {

                // Support: iOS 8.2 (not reproducible in simulator)
                // `in` check used to prevent JIT error (gh-2145)
                // hasOwn isn't used here due to false negatives
                // regarding Nodelist length in IE
                var length = !!obj && "length" in obj && obj.length,
                    type = jQuery.type( obj );

                if ( type === "function" || jQuery.isWindow( obj ) ) {
                    return false;
                }

                return type === "array" || length === 0 ||
                    typeof length === "number" && length > 0 && ( length - 1 ) in obj;
            }
            var Sizzle =
                /*!
     * Sizzle CSS Selector Engine v2.2.1
     * http://sizzlejs.com/
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2015-10-17
     */
                (function( window ) {

                    var i,
                        support,
                        Expr,
                        getText,
                        isXML,
                        tokenize,
                        compile,
                        select,
                        outermostContext,
                        sortInput,
                        hasDuplicate,

                        // Local document vars
                        setDocument,
                        document,
                        docElem,
                        documentIsHTML,
                        rbuggyQSA,
                        rbuggyMatches,
                        matches,
                        contains,

                        // Instance-specific data
                        expando = "sizzle" + 1 * new Date(),
                        preferredDoc = window.document,
                        dirruns = 0,
                        done = 0,
                        classCache = createCache(),
                        tokenCache = createCache(),
                        compilerCache = createCache(),
                        sortOrder = function( a, b ) {
                            if ( a === b ) {
                                hasDuplicate = true;
                            }
                            return 0;
                        },

                        // General-purpose constants
                        MAX_NEGATIVE = 1 << 31,

                        // Instance methods
                        hasOwn = ({}).hasOwnProperty,
                        arr = [],
                        pop = arr.pop,
                        push_native = arr.push,
                        push = arr.push,
                        slice = arr.slice,
                        // Use a stripped-down indexOf as it's faster than native
                        // http://jsperf.com/thor-indexof-vs-for/5
                        indexOf = function( list, elem ) {
                            var i = 0,
                                len = list.length;
                            for ( ; i < len; i++ ) {
                                if ( list[i] === elem ) {
                                    return i;
                                }
                            }
                            return -1;
                        },

                        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                        // Regular expressions

                        // http://www.w3.org/TR/css3-selectors/#whitespace
                        whitespace = "[\\x20\\t\\r\\n\\f]",

                        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                        identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

                        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
                            // Operator (capture 2)
                            "*([*^$|!~]?=)" + whitespace +
                            // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                            "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                            "*\\]",

                        pseudos = ":(" + identifier + ")(?:\\((" +
                            // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                            // 1. quoted (capture 3; capture 4 or capture 5)
                            "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                            // 2. simple (capture 6)
                            "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                            // 3. anything else (capture 2)
                            ".*" +
                            ")\\)|)",

                        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                        rwhitespace = new RegExp( whitespace + "+", "g" ),
                        rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

                        rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
                        rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

                        rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

                        rpseudo = new RegExp( pseudos ),
                        ridentifier = new RegExp( "^" + identifier + "$" ),

                        matchExpr = {
                            "ID": new RegExp( "^#(" + identifier + ")" ),
                            "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
                            "TAG": new RegExp( "^(" + identifier + "|[*])" ),
                            "ATTR": new RegExp( "^" + attributes ),
                            "PSEUDO": new RegExp( "^" + pseudos ),
                            "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                                "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                                "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
                            "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
                            // For use in libraries implementing .is()
                            // We use this for POS matching in `select`
                            "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                                whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
                        },

                        rinputs = /^(?:input|select|textarea|button)$/i,
                        rheader = /^h\d$/i,

                        rnative = /^[^{]+\{\s*\[native \w/,

                        // Easily-parseable/retrievable ID or TAG or CLASS selectors
                        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                        rsibling = /[+~]/,
                        rescape = /'|\\/g,

                        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                        runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
                        funescape = function( _, escaped, escapedWhitespace ) {
                            var high = "0x" + escaped - 0x10000;
                            // NaN means non-codepoint
                            // Support: Firefox<24
                            // Workaround erroneous numeric interpretation of +"0x"
                            return high !== high || escapedWhitespace ?
                                escaped :
                                high < 0 ?
                                    // BMP codepoint
                                    String.fromCharCode( high + 0x10000 ) :
                                    // Supplemental Plane codepoint (surrogate pair)
                                    String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
                        },

                        // Used for iframes
                        // See setDocument()
                        // Removing the function wrapper causes a "Permission Denied"
                        // error in IE
                        unloadHandler = function() {
                            setDocument();
                        };

                    // Optimize for push.apply( _, NodeList )
                    try {
                        push.apply(
                            (arr = slice.call( preferredDoc.childNodes )),
                            preferredDoc.childNodes
                        );
                        // Support: Android<4.0
                        // Detect silently failing push.apply
                        arr[ preferredDoc.childNodes.length ].nodeType;
                    } catch ( e ) {
                        push = { apply: arr.length ?

                                // Leverage slice if possible
                                function( target, els ) {
                                    push_native.apply( target, slice.call(els) );
                                } :

                                // Support: IE<9
                                // Otherwise append directly
                                function( target, els ) {
                                    var j = target.length,
                                        i = 0;
                                    // Can't trust NodeList.length
                                    while ( (target[j++] = els[i++]) ) {}
                                    target.length = j - 1;
                                }
                        };
                    }

                    function Sizzle( selector, context, results, seed ) {
                        var m, i, elem, nid, nidselect, match, groups, newSelector,
                            newContext = context && context.ownerDocument,

                            // nodeType defaults to 9, since context defaults to document
                            nodeType = context ? context.nodeType : 9;

                        results = results || [];

                        // Return early from calls with invalid selector or context
                        if ( typeof selector !== "string" || !selector ||
                            nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

                            return results;
                        }

                        // Try to shortcut find operations (as opposed to filters) in HTML documents
                        if ( !seed ) {

                            if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
                                setDocument( context );
                            }
                            context = context || document;

                            if ( documentIsHTML ) {

                                // If the selector is sufficiently simple, try using a "get*By*" DOM method
                                // (excepting DocumentFragment context, where the methods don't exist)
                                if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

                                    // ID selector
                                    if ( (m = match[1]) ) {

                                        // Document context
                                        if ( nodeType === 9 ) {
                                            if ( (elem = context.getElementById( m )) ) {

                                                // Support: IE, Opera, Webkit
                                                // TODO: identify versions
                                                // getElementById can match elements by name instead of ID
                                                if ( elem.id === m ) {
                                                    results.push( elem );
                                                    return results;
                                                }
                                            } else {
                                                return results;
                                            }

                                            // Element context
                                        } else {

                                            // Support: IE, Opera, Webkit
                                            // TODO: identify versions
                                            // getElementById can match elements by name instead of ID
                                            if ( newContext && (elem = newContext.getElementById( m )) &&
                                                contains( context, elem ) &&
                                                elem.id === m ) {

                                                results.push( elem );
                                                return results;
                                            }
                                        }

                                        // Type selector
                                    } else if ( match[2] ) {
                                        push.apply( results, context.getElementsByTagName( selector ) );
                                        return results;

                                        // Class selector
                                    } else if ( (m = match[3]) && support.getElementsByClassName &&
                                        context.getElementsByClassName ) {

                                        push.apply( results, context.getElementsByClassName( m ) );
                                        return results;
                                    }
                                }

                                // Take advantage of querySelectorAll
                                if ( support.qsa &&
                                    !compilerCache[ selector + " " ] &&
                                    (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

                                    if ( nodeType !== 1 ) {
                                        newContext = context;
                                        newSelector = selector;

                                        // qSA looks outside Element context, which is not what we want
                                        // Thanks to Andrew Dupont for this workaround technique
                                        // Support: IE <=8
                                        // Exclude object elements
                                    } else if ( context.nodeName.toLowerCase() !== "object" ) {

                                        // Capture the context ID, setting it first if necessary
                                        if ( (nid = context.getAttribute( "id" )) ) {
                                            nid = nid.replace( rescape, "\\$&" );
                                        } else {
                                            context.setAttribute( "id", (nid = expando) );
                                        }

                                        // Prefix every selector in the list
                                        groups = tokenize( selector );
                                        i = groups.length;
                                        nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
                                        while ( i-- ) {
                                            groups[i] = nidselect + " " + toSelector( groups[i] );
                                        }
                                        newSelector = groups.join( "," );

                                        // Expand context for sibling selectors
                                        newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
                                            context;
                                    }

                                    if ( newSelector ) {
                                        try {
                                            push.apply( results,
                                                newContext.querySelectorAll( newSelector )
                                            );
                                            return results;
                                        } catch ( qsaError ) {
                                        } finally {
                                            if ( nid === expando ) {
                                                context.removeAttribute( "id" );
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // All others
                        return select( selector.replace( rtrim, "$1" ), context, results, seed );
                    }

                    /**
                     * Create key-value caches of limited size
                     * @returns {function(string, object)} Returns the Object data after storing it on itself with
                     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                     *	deleting the oldest entry
                     */
                    function createCache() {
                        var keys = [];

                        function cache( key, value ) {
                            // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                            if ( keys.push( key + " " ) > Expr.cacheLength ) {
                                // Only keep the most recent entries
                                delete cache[ keys.shift() ];
                            }
                            return (cache[ key + " " ] = value);
                        }
                        return cache;
                    }

                    /**
                     * Mark a function for special use by Sizzle
                     * @param {Function} fn The function to mark
                     */
                    function markFunction( fn ) {
                        fn[ expando ] = true;
                        return fn;
                    }

                    /**
                     * Support testing using an element
                     * @param {Function} fn Passed the created div and expects a boolean result
                     */
                    function assert( fn ) {
                        var div = document.createElement("div");

                        try {
                            return !!fn( div );
                        } catch (e) {
                            return false;
                        } finally {
                            // Remove from its parent by default
                            if ( div.parentNode ) {
                                div.parentNode.removeChild( div );
                            }
                            // release memory in IE
                            div = null;
                        }
                    }

                    /**
                     * Adds the same handler for all of the specified attrs
                     * @param {String} attrs Pipe-separated list of attributes
                     * @param {Function} handler The method that will be applied
                     */
                    function addHandle( attrs, handler ) {
                        var arr = attrs.split("|"),
                            i = arr.length;

                        while ( i-- ) {
                            Expr.attrHandle[ arr[i] ] = handler;
                        }
                    }

                    /**
                     * Checks document order of two siblings
                     * @param {Element} a
                     * @param {Element} b
                     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                     */
                    function siblingCheck( a, b ) {
                        var cur = b && a,
                            diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                                ( ~b.sourceIndex || MAX_NEGATIVE ) -
                                ( ~a.sourceIndex || MAX_NEGATIVE );

                        // Use IE sourceIndex if available on both nodes
                        if ( diff ) {
                            return diff;
                        }

                        // Check if b follows a
                        if ( cur ) {
                            while ( (cur = cur.nextSibling) ) {
                                if ( cur === b ) {
                                    return -1;
                                }
                            }
                        }

                        return a ? 1 : -1;
                    }

                    /**
                     * Returns a function to use in pseudos for input types
                     * @param {String} type
                     */
                    function createInputPseudo( type ) {
                        return function( elem ) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for buttons
                     * @param {String} type
                     */
                    function createButtonPseudo( type ) {
                        return function( elem ) {
                            var name = elem.nodeName.toLowerCase();
                            return (name === "input" || name === "button") && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for positionals
                     * @param {Function} fn
                     */
                    function createPositionalPseudo( fn ) {
                        return markFunction(function( argument ) {
                            argument = +argument;
                            return markFunction(function( seed, matches ) {
                                var j,
                                    matchIndexes = fn( [], seed.length, argument ),
                                    i = matchIndexes.length;

                                // Match elements found at the specified indexes
                                while ( i-- ) {
                                    if ( seed[ (j = matchIndexes[i]) ] ) {
                                        seed[j] = !(matches[j] = seed[j]);
                                    }
                                }
                            });
                        });
                    }

                    /**
                     * Checks a node for validity as a Sizzle context
                     * @param {Element|Object=} context
                     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                     */
                    function testContext( context ) {
                        return context && typeof context.getElementsByTagName !== "undefined" && context;
                    }

                    // Expose support vars for convenience
                    support = Sizzle.support = {};

                    /**
                     * Detects XML nodes
                     * @param {Element|Object} elem An element or a document
                     * @returns {Boolean} True iff elem is a non-HTML XML node
                     */
                    isXML = Sizzle.isXML = function( elem ) {
                        // documentElement is verified for cases where it doesn't yet exist
                        // (such as loading iframes in IE - #4833)
                        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                        return documentElement ? documentElement.nodeName !== "HTML" : false;
                    };

                    /**
                     * Sets document-related variables once based on the current document
                     * @param {Element|Object} [doc] An element or document object to use to set the document
                     * @returns {Object} Returns the current document
                     */
                    setDocument = Sizzle.setDocument = function( node ) {
                        var hasCompare, parent,
                            doc = node ? node.ownerDocument || node : preferredDoc;

                        // Return early if doc is invalid or already selected
                        if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
                            return document;
                        }

                        // Update global variables
                        document = doc;
                        docElem = document.documentElement;
                        documentIsHTML = !isXML( document );

                        // Support: IE 9-11, Edge
                        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                        if ( (parent = document.defaultView) && parent.top !== parent ) {
                            // Support: IE 11
                            if ( parent.addEventListener ) {
                                parent.addEventListener( "unload", unloadHandler, false );

                                // Support: IE 9 - 10 only
                            } else if ( parent.attachEvent ) {
                                parent.attachEvent( "onunload", unloadHandler );
                            }
                        }

                        /* Attributes
    	---------------------------------------------------------------------- */

                        // Support: IE<8
                        // Verify that getAttribute really returns attributes and not properties
                        // (excepting IE8 booleans)
                        support.attributes = assert(function( div ) {
                            div.className = "i";
                            return !div.getAttribute("className");
                        });

                        /* getElement(s)By*
    	---------------------------------------------------------------------- */

                        // Check if getElementsByTagName("*") returns only elements
                        support.getElementsByTagName = assert(function( div ) {
                            div.appendChild( document.createComment("") );
                            return !div.getElementsByTagName("*").length;
                        });

                        // Support: IE<9
                        support.getElementsByClassName = rnative.test( document.getElementsByClassName );

                        // Support: IE<10
                        // Check if getElementById returns elements by name
                        // The broken getElementById methods don't pick up programatically-set names,
                        // so use a roundabout getElementsByName test
                        support.getById = assert(function( div ) {
                            docElem.appendChild( div ).id = expando;
                            return !document.getElementsByName || !document.getElementsByName( expando ).length;
                        });

                        // ID find and filter
                        if ( support.getById ) {
                            Expr.find["ID"] = function( id, context ) {
                                if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                                    var m = context.getElementById( id );
                                    return m ? [ m ] : [];
                                }
                            };
                            Expr.filter["ID"] = function( id ) {
                                var attrId = id.replace( runescape, funescape );
                                return function( elem ) {
                                    return elem.getAttribute("id") === attrId;
                                };
                            };
                        } else {
                            // Support: IE6/7
                            // getElementById is not reliable as a find shortcut
                            delete Expr.find["ID"];

                            Expr.filter["ID"] =  function( id ) {
                                var attrId = id.replace( runescape, funescape );
                                return function( elem ) {
                                    var node = typeof elem.getAttributeNode !== "undefined" &&
                                        elem.getAttributeNode("id");
                                    return node && node.value === attrId;
                                };
                            };
                        }

                        // Tag
                        Expr.find["TAG"] = support.getElementsByTagName ?
                            function( tag, context ) {
                                if ( typeof context.getElementsByTagName !== "undefined" ) {
                                    return context.getElementsByTagName( tag );

                                    // DocumentFragment nodes don't have gEBTN
                                } else if ( support.qsa ) {
                                    return context.querySelectorAll( tag );
                                }
                            } :

                            function( tag, context ) {
                                var elem,
                                    tmp = [],
                                    i = 0,
                                    // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                                    results = context.getElementsByTagName( tag );

                                // Filter out possible comments
                                if ( tag === "*" ) {
                                    while ( (elem = results[i++]) ) {
                                        if ( elem.nodeType === 1 ) {
                                            tmp.push( elem );
                                        }
                                    }

                                    return tmp;
                                }
                                return results;
                            };

                        // Class
                        Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
                            if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
                                return context.getElementsByClassName( className );
                            }
                        };

                        /* QSA/matchesSelector
    	---------------------------------------------------------------------- */

                        // QSA and matchesSelector support

                        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                        rbuggyMatches = [];

                        // qSa(:focus) reports false when true (Chrome 21)
                        // We allow this because of a bug in IE8/9 that throws an error
                        // whenever `document.activeElement` is accessed on an iframe
                        // So, we allow :focus to pass through QSA all the time to avoid the IE error
                        // See http://bugs.jquery.com/ticket/13378
                        rbuggyQSA = [];

                        if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
                            // Build QSA regex
                            // Regex strategy adopted from Diego Perini
                            assert(function( div ) {
                                // Select is set to empty string on purpose
                                // This is to test IE's treatment of not explicitly
                                // setting a boolean content attribute,
                                // since its presence should be enough
                                // http://bugs.jquery.com/ticket/12359
                                docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
                                    "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                                    "<option selected=''></option></select>";

                                // Support: IE8, Opera 11-12.16
                                // Nothing should be selected when empty strings follow ^= or $= or *=
                                // The test attribute must be unknown in Opera but "safe" for WinRT
                                // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                                if ( div.querySelectorAll("[msallowcapture^='']").length ) {
                                    rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                                }

                                // Support: IE8
                                // Boolean attributes and "value" are not treated correctly
                                if ( !div.querySelectorAll("[selected]").length ) {
                                    rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                                }

                                // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                                if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
                                    rbuggyQSA.push("~=");
                                }

                                // Webkit/Opera - :checked should return selected option elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                // IE8 throws error here and will not see later tests
                                if ( !div.querySelectorAll(":checked").length ) {
                                    rbuggyQSA.push(":checked");
                                }

                                // Support: Safari 8+, iOS 8+
                                // https://bugs.webkit.org/show_bug.cgi?id=136851
                                // In-page `selector#id sibing-combinator selector` fails
                                if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
                                    rbuggyQSA.push(".#.+[+~]");
                                }
                            });

                            assert(function( div ) {
                                // Support: Windows 8 Native Apps
                                // The type and name attributes are restricted during .innerHTML assignment
                                var input = document.createElement("input");
                                input.setAttribute( "type", "hidden" );
                                div.appendChild( input ).setAttribute( "name", "D" );

                                // Support: IE8
                                // Enforce case-sensitivity of name attribute
                                if ( div.querySelectorAll("[name=d]").length ) {
                                    rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                                }

                                // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                                // IE8 throws error here and will not see later tests
                                if ( !div.querySelectorAll(":enabled").length ) {
                                    rbuggyQSA.push( ":enabled", ":disabled" );
                                }

                                // Opera 10-11 does not throw on post-comma invalid pseudos
                                div.querySelectorAll("*,:x");
                                rbuggyQSA.push(",.*:");
                            });
                        }

                        if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
                            docElem.webkitMatchesSelector ||
                            docElem.mozMatchesSelector ||
                            docElem.oMatchesSelector ||
                            docElem.msMatchesSelector) )) ) {

                            assert(function( div ) {
                                // Check to see if it's possible to do matchesSelector
                                // on a disconnected node (IE 9)
                                support.disconnectedMatch = matches.call( div, "div" );

                                // This should fail with an exception
                                // Gecko does not error, returns false instead
                                matches.call( div, "[s!='']:x" );
                                rbuggyMatches.push( "!=", pseudos );
                            });
                        }

                        rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
                        rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

                        /* Contains
    	---------------------------------------------------------------------- */
                        hasCompare = rnative.test( docElem.compareDocumentPosition );

                        // Element contains another
                        // Purposefully self-exclusive
                        // As in, an element does not contain itself
                        contains = hasCompare || rnative.test( docElem.contains ) ?
                            function( a, b ) {
                                var adown = a.nodeType === 9 ? a.documentElement : a,
                                    bup = b && b.parentNode;
                                return a === bup || !!( bup && bup.nodeType === 1 && (
                                    adown.contains ?
                                        adown.contains( bup ) :
                                        a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                                ));
                            } :
                            function( a, b ) {
                                if ( b ) {
                                    while ( (b = b.parentNode) ) {
                                        if ( b === a ) {
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            };

                        /* Sorting
    	---------------------------------------------------------------------- */

                        // Document order sorting
                        sortOrder = hasCompare ?
                            function( a, b ) {

                                // Flag for duplicate removal
                                if ( a === b ) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                // Sort on method existence if only one input has compareDocumentPosition
                                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                                if ( compare ) {
                                    return compare;
                                }

                                // Calculate position if both inputs belong to the same document
                                compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                                    a.compareDocumentPosition( b ) :

                                    // Otherwise we know they are disconnected
                                    1;

                                // Disconnected nodes
                                if ( compare & 1 ||
                                    (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

                                    // Choose the first element that is related to our preferred document
                                    if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                                        return -1;
                                    }
                                    if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                                        return 1;
                                    }

                                    // Maintain original order
                                    return sortInput ?
                                        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                        0;
                                }

                                return compare & 4 ? -1 : 1;
                            } :
                            function( a, b ) {
                                // Exit early if the nodes are identical
                                if ( a === b ) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                var cur,
                                    i = 0,
                                    aup = a.parentNode,
                                    bup = b.parentNode,
                                    ap = [ a ],
                                    bp = [ b ];

                                // Parentless nodes are either documents or disconnected
                                if ( !aup || !bup ) {
                                    return a === document ? -1 :
                                        b === document ? 1 :
                                            aup ? -1 :
                                                bup ? 1 :
                                                    sortInput ?
                                                        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                                        0;

                                    // If the nodes are siblings, we can do a quick check
                                } else if ( aup === bup ) {
                                    return siblingCheck( a, b );
                                }

                                // Otherwise we need full lists of their ancestors for comparison
                                cur = a;
                                while ( (cur = cur.parentNode) ) {
                                    ap.unshift( cur );
                                }
                                cur = b;
                                while ( (cur = cur.parentNode) ) {
                                    bp.unshift( cur );
                                }

                                // Walk down the tree looking for a discrepancy
                                while ( ap[i] === bp[i] ) {
                                    i++;
                                }

                                return i ?
                                    // Do a sibling check if the nodes have a common ancestor
                                    siblingCheck( ap[i], bp[i] ) :

                                    // Otherwise nodes in our document sort first
                                    ap[i] === preferredDoc ? -1 :
                                        bp[i] === preferredDoc ? 1 :
                                            0;
                            };

                        return document;
                    };

                    Sizzle.matches = function( expr, elements ) {
                        return Sizzle( expr, null, null, elements );
                    };

                    Sizzle.matchesSelector = function( elem, expr ) {
                        // Set document vars if needed
                        if ( ( elem.ownerDocument || elem ) !== document ) {
                            setDocument( elem );
                        }

                        // Make sure that attribute selectors are quoted
                        expr = expr.replace( rattributeQuotes, "='$1']" );

                        if ( support.matchesSelector && documentIsHTML &&
                            !compilerCache[ expr + " " ] &&
                            ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
                            ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

                            try {
                                var ret = matches.call( elem, expr );

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if ( ret || support.disconnectedMatch ||
                                    // As well, disconnected nodes are said to be in a document
                                    // fragment in IE 9
                                    elem.document && elem.document.nodeType !== 11 ) {
                                    return ret;
                                }
                            } catch (e) {}
                        }

                        return Sizzle( expr, document, null, [ elem ] ).length > 0;
                    };

                    Sizzle.contains = function( context, elem ) {
                        // Set document vars if needed
                        if ( ( context.ownerDocument || context ) !== document ) {
                            setDocument( context );
                        }
                        return contains( context, elem );
                    };

                    Sizzle.attr = function( elem, name ) {
                        // Set document vars if needed
                        if ( ( elem.ownerDocument || elem ) !== document ) {
                            setDocument( elem );
                        }

                        var fn = Expr.attrHandle[ name.toLowerCase() ],
                            // Don't get fooled by Object.prototype properties (jQuery #13807)
                            val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                                fn( elem, name, !documentIsHTML ) :
                                undefined;

                        return val !== undefined ?
                            val :
                            support.attributes || !documentIsHTML ?
                                elem.getAttribute( name ) :
                                (val = elem.getAttributeNode(name)) && val.specified ?
                                    val.value :
                                    null;
                    };

                    Sizzle.error = function( msg ) {
                        throw new Error( "Syntax error, unrecognized expression: " + msg );
                    };

                    /**
                     * Document sorting and removing duplicates
                     * @param {ArrayLike} results
                     */
                    Sizzle.uniqueSort = function( results ) {
                        var elem,
                            duplicates = [],
                            j = 0,
                            i = 0;

                        // Unless we *know* we can detect duplicates, assume their presence
                        hasDuplicate = !support.detectDuplicates;
                        sortInput = !support.sortStable && results.slice( 0 );
                        results.sort( sortOrder );

                        if ( hasDuplicate ) {
                            while ( (elem = results[i++]) ) {
                                if ( elem === results[ i ] ) {
                                    j = duplicates.push( i );
                                }
                            }
                            while ( j-- ) {
                                results.splice( duplicates[ j ], 1 );
                            }
                        }

                        // Clear input after sorting to release objects
                        // See https://github.com/jquery/sizzle/pull/225
                        sortInput = null;

                        return results;
                    };

                    /**
                     * Utility function for retrieving the text value of an array of DOM nodes
                     * @param {Array|Element} elem
                     */
                    getText = Sizzle.getText = function( elem ) {
                        var node,
                            ret = "",
                            i = 0,
                            nodeType = elem.nodeType;

                        if ( !nodeType ) {
                            // If no nodeType, this is expected to be an array
                            while ( (node = elem[i++]) ) {
                                // Do not traverse comment nodes
                                ret += getText( node );
                            }
                        } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                            // Use textContent for elements
                            // innerText usage removed for consistency of new lines (jQuery #11153)
                            if ( typeof elem.textContent === "string" ) {
                                return elem.textContent;
                            } else {
                                // Traverse its children
                                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                    ret += getText( elem );
                                }
                            }
                        } else if ( nodeType === 3 || nodeType === 4 ) {
                            return elem.nodeValue;
                        }
                        // Do not include comment or processing instruction nodes

                        return ret;
                    };

                    Expr = Sizzle.selectors = {

                        // Can be adjusted by the user
                        cacheLength: 50,

                        createPseudo: markFunction,

                        match: matchExpr,

                        attrHandle: {},

                        find: {},

                        relative: {
                            ">": { dir: "parentNode", first: true },
                            " ": { dir: "parentNode" },
                            "+": { dir: "previousSibling", first: true },
                            "~": { dir: "previousSibling" }
                        },

                        preFilter: {
                            "ATTR": function( match ) {
                                match[1] = match[1].replace( runescape, funescape );

                                // Move the given value to match[3] whether quoted or unquoted
                                match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

                                if ( match[2] === "~=" ) {
                                    match[3] = " " + match[3] + " ";
                                }

                                return match.slice( 0, 4 );
                            },

                            "CHILD": function( match ) {
                                /* matches from matchExpr["CHILD"]
    				1 type (only|nth|...)
    				2 what (child|of-type)
    				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
    				4 xn-component of xn+y argument ([+-]?\d*n|)
    				5 sign of xn-component
    				6 x of xn-component
    				7 sign of y-component
    				8 y of y-component
    			*/
                                match[1] = match[1].toLowerCase();

                                if ( match[1].slice( 0, 3 ) === "nth" ) {
                                    // nth-* requires argument
                                    if ( !match[3] ) {
                                        Sizzle.error( match[0] );
                                    }

                                    // numeric x and y parameters for Expr.filter.CHILD
                                    // remember that false/true cast respectively to 0/1
                                    match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                                    match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

                                    // other types prohibit arguments
                                } else if ( match[3] ) {
                                    Sizzle.error( match[0] );
                                }

                                return match;
                            },

                            "PSEUDO": function( match ) {
                                var excess,
                                    unquoted = !match[6] && match[2];

                                if ( matchExpr["CHILD"].test( match[0] ) ) {
                                    return null;
                                }

                                // Accept quoted arguments as-is
                                if ( match[3] ) {
                                    match[2] = match[4] || match[5] || "";

                                    // Strip excess characters from unquoted arguments
                                } else if ( unquoted && rpseudo.test( unquoted ) &&
                                    // Get excess from tokenize (recursively)
                                    (excess = tokenize( unquoted, true )) &&
                                    // advance to the next closing parenthesis
                                    (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                                    // excess is a negative index
                                    match[0] = match[0].slice( 0, excess );
                                    match[2] = unquoted.slice( 0, excess );
                                }

                                // Return only captures needed by the pseudo filter method (type and argument)
                                return match.slice( 0, 3 );
                            }
                        },

                        filter: {

                            "TAG": function( nodeNameSelector ) {
                                var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                                return nodeNameSelector === "*" ?
                                    function() { return true; } :
                                    function( elem ) {
                                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                    };
                            },

                            "CLASS": function( className ) {
                                var pattern = classCache[ className + " " ];

                                return pattern ||
                                    (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                                    classCache( className, function( elem ) {
                                        return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
                                    });
                            },

                            "ATTR": function( name, operator, check ) {
                                return function( elem ) {
                                    var result = Sizzle.attr( elem, name );

                                    if ( result == null ) {
                                        return operator === "!=";
                                    }
                                    if ( !operator ) {
                                        return true;
                                    }

                                    result += "";

                                    return operator === "=" ? result === check :
                                        operator === "!=" ? result !== check :
                                            operator === "^=" ? check && result.indexOf( check ) === 0 :
                                                operator === "*=" ? check && result.indexOf( check ) > -1 :
                                                    operator === "$=" ? check && result.slice( -check.length ) === check :
                                                        operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                                                            operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                                                false;
                                };
                            },

                            "CHILD": function( type, what, argument, first, last ) {
                                var simple = type.slice( 0, 3 ) !== "nth",
                                    forward = type.slice( -4 ) !== "last",
                                    ofType = what === "of-type";

                                return first === 1 && last === 0 ?

                                    // Shortcut for :nth-*(n)
                                    function( elem ) {
                                        return !!elem.parentNode;
                                    } :

                                    function( elem, context, xml ) {
                                        var cache, uniqueCache, outerCache, node, nodeIndex, start,
                                            dir = simple !== forward ? "nextSibling" : "previousSibling",
                                            parent = elem.parentNode,
                                            name = ofType && elem.nodeName.toLowerCase(),
                                            useCache = !xml && !ofType,
                                            diff = false;

                                        if ( parent ) {

                                            // :(first|last|only)-(child|of-type)
                                            if ( simple ) {
                                                while ( dir ) {
                                                    node = elem;
                                                    while ( (node = node[ dir ]) ) {
                                                        if ( ofType ?
                                                            node.nodeName.toLowerCase() === name :
                                                            node.nodeType === 1 ) {

                                                            return false;
                                                        }
                                                    }
                                                    // Reverse direction for :only-* (if we haven't yet done so)
                                                    start = dir = type === "only" && !start && "nextSibling";
                                                }
                                                return true;
                                            }

                                            start = [ forward ? parent.firstChild : parent.lastChild ];

                                            // non-xml :nth-child(...) stores cache data on `parent`
                                            if ( forward && useCache ) {

                                                // Seek `elem` from a previously-cached index

                                                // ...in a gzip-friendly way
                                                node = parent;
                                                outerCache = node[ expando ] || (node[ expando ] = {});

                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                uniqueCache = outerCache[ node.uniqueID ] ||
                                                    (outerCache[ node.uniqueID ] = {});

                                                cache = uniqueCache[ type ] || [];
                                                nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                                diff = nodeIndex && cache[ 2 ];
                                                node = nodeIndex && parent.childNodes[ nodeIndex ];

                                                while ( (node = ++nodeIndex && node && node[ dir ] ||

                                                    // Fallback to seeking `elem` from the start
                                                    (diff = nodeIndex = 0) || start.pop()) ) {

                                                    // When found, cache indexes on `parent` and break
                                                    if ( node.nodeType === 1 && ++diff && node === elem ) {
                                                        uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                                                        break;
                                                    }
                                                }

                                            } else {
                                                // Use previously-cached element index if available
                                                if ( useCache ) {
                                                    // ...in a gzip-friendly way
                                                    node = elem;
                                                    outerCache = node[ expando ] || (node[ expando ] = {});

                                                    // Support: IE <9 only
                                                    // Defend against cloned attroperties (jQuery gh-1709)
                                                    uniqueCache = outerCache[ node.uniqueID ] ||
                                                        (outerCache[ node.uniqueID ] = {});

                                                    cache = uniqueCache[ type ] || [];
                                                    nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                                    diff = nodeIndex;
                                                }

                                                // xml :nth-child(...)
                                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                                if ( diff === false ) {
                                                    // Use the same loop as above to seek `elem` from the start
                                                    while ( (node = ++nodeIndex && node && node[ dir ] ||
                                                        (diff = nodeIndex = 0) || start.pop()) ) {

                                                        if ( ( ofType ?
                                                            node.nodeName.toLowerCase() === name :
                                                            node.nodeType === 1 ) &&
                                                            ++diff ) {

                                                            // Cache the index of each encountered element
                                                            if ( useCache ) {
                                                                outerCache = node[ expando ] || (node[ expando ] = {});

                                                                // Support: IE <9 only
                                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                                uniqueCache = outerCache[ node.uniqueID ] ||
                                                                    (outerCache[ node.uniqueID ] = {});

                                                                uniqueCache[ type ] = [ dirruns, diff ];
                                                            }

                                                            if ( node === elem ) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            // Incorporate the offset, then check against cycle size
                                            diff -= last;
                                            return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                        }
                                    };
                            },

                            "PSEUDO": function( pseudo, argument ) {
                                // pseudo-class names are case-insensitive
                                // http://www.w3.org/TR/selectors/#pseudo-classes
                                // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                // Remember that setFilters inherits from pseudos
                                var args,
                                    fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                        Sizzle.error( "unsupported pseudo: " + pseudo );

                                // The user may use createPseudo to indicate that
                                // arguments are needed to create the filter function
                                // just as Sizzle does
                                if ( fn[ expando ] ) {
                                    return fn( argument );
                                }

                                // But maintain support for old signatures
                                if ( fn.length > 1 ) {
                                    args = [ pseudo, pseudo, "", argument ];
                                    return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                                        markFunction(function( seed, matches ) {
                                            var idx,
                                                matched = fn( seed, argument ),
                                                i = matched.length;
                                            while ( i-- ) {
                                                idx = indexOf( seed, matched[i] );
                                                seed[ idx ] = !( matches[ idx ] = matched[i] );
                                            }
                                        }) :
                                        function( elem ) {
                                            return fn( elem, 0, args );
                                        };
                                }

                                return fn;
                            }
                        },

                        pseudos: {
                            // Potentially complex pseudos
                            "not": markFunction(function( selector ) {
                                // Trim the selector passed to compile
                                // to avoid treating leading and trailing
                                // spaces as combinators
                                var input = [],
                                    results = [],
                                    matcher = compile( selector.replace( rtrim, "$1" ) );

                                return matcher[ expando ] ?
                                    markFunction(function( seed, matches, context, xml ) {
                                        var elem,
                                            unmatched = matcher( seed, null, xml, [] ),
                                            i = seed.length;

                                        // Match elements unmatched by `matcher`
                                        while ( i-- ) {
                                            if ( (elem = unmatched[i]) ) {
                                                seed[i] = !(matches[i] = elem);
                                            }
                                        }
                                    }) :
                                    function( elem, context, xml ) {
                                        input[0] = elem;
                                        matcher( input, null, xml, results );
                                        // Don't keep the element (issue #299)
                                        input[0] = null;
                                        return !results.pop();
                                    };
                            }),

                            "has": markFunction(function( selector ) {
                                return function( elem ) {
                                    return Sizzle( selector, elem ).length > 0;
                                };
                            }),

                            "contains": markFunction(function( text ) {
                                text = text.replace( runescape, funescape );
                                return function( elem ) {
                                    return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
                                };
                            }),

                            // "Whether an element is represented by a :lang() selector
                            // is based solely on the element's language value
                            // being equal to the identifier C,
                            // or beginning with the identifier C immediately followed by "-".
                            // The matching of C against the element's language value is performed case-insensitively.
                            // The identifier C does not have to be a valid language name."
                            // http://www.w3.org/TR/selectors/#lang-pseudo
                            "lang": markFunction( function( lang ) {
                                // lang value must be a valid identifier
                                if ( !ridentifier.test(lang || "") ) {
                                    Sizzle.error( "unsupported lang: " + lang );
                                }
                                lang = lang.replace( runescape, funescape ).toLowerCase();
                                return function( elem ) {
                                    var elemLang;
                                    do {
                                        if ( (elemLang = documentIsHTML ?
                                            elem.lang :
                                            elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                                            elemLang = elemLang.toLowerCase();
                                            return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                                        }
                                    } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                                    return false;
                                };
                            }),

                            // Miscellaneous
                            "target": function( elem ) {
                                var hash = window.location && window.location.hash;
                                return hash && hash.slice( 1 ) === elem.id;
                            },

                            "root": function( elem ) {
                                return elem === docElem;
                            },

                            "focus": function( elem ) {
                                return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                            },

                            // Boolean properties
                            "enabled": function( elem ) {
                                return elem.disabled === false;
                            },

                            "disabled": function( elem ) {
                                return elem.disabled === true;
                            },

                            "checked": function( elem ) {
                                // In CSS3, :checked should return both checked and selected elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                var nodeName = elem.nodeName.toLowerCase();
                                return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                            },

                            "selected": function( elem ) {
                                // Accessing this property makes selected-by-default
                                // options in Safari work properly
                                if ( elem.parentNode ) {
                                    elem.parentNode.selectedIndex;
                                }

                                return elem.selected === true;
                            },

                            // Contents
                            "empty": function( elem ) {
                                // http://www.w3.org/TR/selectors/#empty-pseudo
                                // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                //   but not by others (comment: 8; processing instruction: 7; etc.)
                                // nodeType < 6 works because attributes (2) do not appear as children
                                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                    if ( elem.nodeType < 6 ) {
                                        return false;
                                    }
                                }
                                return true;
                            },

                            "parent": function( elem ) {
                                return !Expr.pseudos["empty"]( elem );
                            },

                            // Element/input types
                            "header": function( elem ) {
                                return rheader.test( elem.nodeName );
                            },

                            "input": function( elem ) {
                                return rinputs.test( elem.nodeName );
                            },

                            "button": function( elem ) {
                                var name = elem.nodeName.toLowerCase();
                                return name === "input" && elem.type === "button" || name === "button";
                            },

                            "text": function( elem ) {
                                var attr;
                                return elem.nodeName.toLowerCase() === "input" &&
                                    elem.type === "text" &&

                                    // Support: IE<8
                                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                    ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
                            },

                            // Position-in-collection
                            "first": createPositionalPseudo(function() {
                                return [ 0 ];
                            }),

                            "last": createPositionalPseudo(function( matchIndexes, length ) {
                                return [ length - 1 ];
                            }),

                            "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
                                return [ argument < 0 ? argument + length : argument ];
                            }),

                            "even": createPositionalPseudo(function( matchIndexes, length ) {
                                var i = 0;
                                for ( ; i < length; i += 2 ) {
                                    matchIndexes.push( i );
                                }
                                return matchIndexes;
                            }),

                            "odd": createPositionalPseudo(function( matchIndexes, length ) {
                                var i = 1;
                                for ( ; i < length; i += 2 ) {
                                    matchIndexes.push( i );
                                }
                                return matchIndexes;
                            }),

                            "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                                var i = argument < 0 ? argument + length : argument;
                                for ( ; --i >= 0; ) {
                                    matchIndexes.push( i );
                                }
                                return matchIndexes;
                            }),

                            "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                                var i = argument < 0 ? argument + length : argument;
                                for ( ; ++i < length; ) {
                                    matchIndexes.push( i );
                                }
                                return matchIndexes;
                            })
                        }
                    };

                    Expr.pseudos["nth"] = Expr.pseudos["eq"];

                    // Add button/input type pseudos
                    for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
                        Expr.pseudos[ i ] = createInputPseudo( i );
                    }
                    for ( i in { submit: true, reset: true } ) {
                        Expr.pseudos[ i ] = createButtonPseudo( i );
                    }

                    // Easy API for creating new setFilters
                    function setFilters() {}
                    setFilters.prototype = Expr.filters = Expr.pseudos;
                    Expr.setFilters = new setFilters();

                    tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
                        var matched, match, tokens, type,
                            soFar, groups, preFilters,
                            cached = tokenCache[ selector + " " ];

                        if ( cached ) {
                            return parseOnly ? 0 : cached.slice( 0 );
                        }

                        soFar = selector;
                        groups = [];
                        preFilters = Expr.preFilter;

                        while ( soFar ) {

                            // Comma and first run
                            if ( !matched || (match = rcomma.exec( soFar )) ) {
                                if ( match ) {
                                    // Don't consume trailing commas as valid
                                    soFar = soFar.slice( match[0].length ) || soFar;
                                }
                                groups.push( (tokens = []) );
                            }

                            matched = false;

                            // Combinators
                            if ( (match = rcombinators.exec( soFar )) ) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    // Cast descendant combinators to space
                                    type: match[0].replace( rtrim, " " )
                                });
                                soFar = soFar.slice( matched.length );
                            }

                            // Filters
                            for ( type in Expr.filter ) {
                                if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                                    (match = preFilters[ type ]( match ))) ) {
                                    matched = match.shift();
                                    tokens.push({
                                        value: matched,
                                        type: type,
                                        matches: match
                                    });
                                    soFar = soFar.slice( matched.length );
                                }
                            }

                            if ( !matched ) {
                                break;
                            }
                        }

                        // Return the length of the invalid excess
                        // if we're just parsing
                        // Otherwise, throw an error or return tokens
                        return parseOnly ?
                            soFar.length :
                            soFar ?
                                Sizzle.error( selector ) :
                                // Cache the tokens
                                tokenCache( selector, groups ).slice( 0 );
                    };

                    function toSelector( tokens ) {
                        var i = 0,
                            len = tokens.length,
                            selector = "";
                        for ( ; i < len; i++ ) {
                            selector += tokens[i].value;
                        }
                        return selector;
                    }

                    function addCombinator( matcher, combinator, base ) {
                        var dir = combinator.dir,
                            checkNonElements = base && dir === "parentNode",
                            doneName = done++;

                        return combinator.first ?
                            // Check against closest ancestor/preceding element
                            function( elem, context, xml ) {
                                while ( (elem = elem[ dir ]) ) {
                                    if ( elem.nodeType === 1 || checkNonElements ) {
                                        return matcher( elem, context, xml );
                                    }
                                }
                            } :

                            // Check against all ancestor/preceding elements
                            function( elem, context, xml ) {
                                var oldCache, uniqueCache, outerCache,
                                    newCache = [ dirruns, doneName ];

                                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                                if ( xml ) {
                                    while ( (elem = elem[ dir ]) ) {
                                        if ( elem.nodeType === 1 || checkNonElements ) {
                                            if ( matcher( elem, context, xml ) ) {
                                                return true;
                                            }
                                        }
                                    }
                                } else {
                                    while ( (elem = elem[ dir ]) ) {
                                        if ( elem.nodeType === 1 || checkNonElements ) {
                                            outerCache = elem[ expando ] || (elem[ expando ] = {});

                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

                                            if ( (oldCache = uniqueCache[ dir ]) &&
                                                oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                                                // Assign to newCache so results back-propagate to previous elements
                                                return (newCache[ 2 ] = oldCache[ 2 ]);
                                            } else {
                                                // Reuse newcache so results back-propagate to previous elements
                                                uniqueCache[ dir ] = newCache;

                                                // A match means we're done; a fail means we have to keep checking
                                                if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                    }

                    function elementMatcher( matchers ) {
                        return matchers.length > 1 ?
                            function( elem, context, xml ) {
                                var i = matchers.length;
                                while ( i-- ) {
                                    if ( !matchers[i]( elem, context, xml ) ) {
                                        return false;
                                    }
                                }
                                return true;
                            } :
                            matchers[0];
                    }

                    function multipleContexts( selector, contexts, results ) {
                        var i = 0,
                            len = contexts.length;
                        for ( ; i < len; i++ ) {
                            Sizzle( selector, contexts[i], results );
                        }
                        return results;
                    }

                    function condense( unmatched, map, filter, context, xml ) {
                        var elem,
                            newUnmatched = [],
                            i = 0,
                            len = unmatched.length,
                            mapped = map != null;

                        for ( ; i < len; i++ ) {
                            if ( (elem = unmatched[i]) ) {
                                if ( !filter || filter( elem, context, xml ) ) {
                                    newUnmatched.push( elem );
                                    if ( mapped ) {
                                        map.push( i );
                                    }
                                }
                            }
                        }

                        return newUnmatched;
                    }

                    function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
                        if ( postFilter && !postFilter[ expando ] ) {
                            postFilter = setMatcher( postFilter );
                        }
                        if ( postFinder && !postFinder[ expando ] ) {
                            postFinder = setMatcher( postFinder, postSelector );
                        }
                        return markFunction(function( seed, results, context, xml ) {
                            var temp, i, elem,
                                preMap = [],
                                postMap = [],
                                preexisting = results.length,

                                // Get initial elements from seed or context
                                elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

                                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                                matcherIn = preFilter && ( seed || !selector ) ?
                                    condense( elems, preMap, preFilter, context, xml ) :
                                    elems,

                                matcherOut = matcher ?
                                    // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                                    postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                                        // ...intermediate processing is necessary
                                        [] :

                                        // ...otherwise use results directly
                                        results :
                                    matcherIn;

                            // Find primary matches
                            if ( matcher ) {
                                matcher( matcherIn, matcherOut, context, xml );
                            }

                            // Apply postFilter
                            if ( postFilter ) {
                                temp = condense( matcherOut, postMap );
                                postFilter( temp, [], context, xml );

                                // Un-match failing elements by moving them back to matcherIn
                                i = temp.length;
                                while ( i-- ) {
                                    if ( (elem = temp[i]) ) {
                                        matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                                    }
                                }
                            }

                            if ( seed ) {
                                if ( postFinder || preFilter ) {
                                    if ( postFinder ) {
                                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                        temp = [];
                                        i = matcherOut.length;
                                        while ( i-- ) {
                                            if ( (elem = matcherOut[i]) ) {
                                                // Restore matcherIn since elem is not yet a final match
                                                temp.push( (matcherIn[i] = elem) );
                                            }
                                        }
                                        postFinder( null, (matcherOut = []), temp, xml );
                                    }

                                    // Move matched elements from seed to results to keep them synchronized
                                    i = matcherOut.length;
                                    while ( i-- ) {
                                        if ( (elem = matcherOut[i]) &&
                                            (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

                                            seed[temp] = !(results[temp] = elem);
                                        }
                                    }
                                }

                                // Add elements to results, through postFinder if defined
                            } else {
                                matcherOut = condense(
                                    matcherOut === results ?
                                        matcherOut.splice( preexisting, matcherOut.length ) :
                                        matcherOut
                                );
                                if ( postFinder ) {
                                    postFinder( null, results, matcherOut, xml );
                                } else {
                                    push.apply( results, matcherOut );
                                }
                            }
                        });
                    }

                    function matcherFromTokens( tokens ) {
                        var checkContext, matcher, j,
                            len = tokens.length,
                            leadingRelative = Expr.relative[ tokens[0].type ],
                            implicitRelative = leadingRelative || Expr.relative[" "],
                            i = leadingRelative ? 1 : 0,

                            // The foundational matcher ensures that elements are reachable from top-level context(s)
                            matchContext = addCombinator( function( elem ) {
                                return elem === checkContext;
                            }, implicitRelative, true ),
                            matchAnyContext = addCombinator( function( elem ) {
                                return indexOf( checkContext, elem ) > -1;
                            }, implicitRelative, true ),
                            matchers = [ function( elem, context, xml ) {
                                var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                                    (checkContext = context).nodeType ?
                                        matchContext( elem, context, xml ) :
                                        matchAnyContext( elem, context, xml ) );
                                // Avoid hanging onto element (issue #299)
                                checkContext = null;
                                return ret;
                            } ];

                        for ( ; i < len; i++ ) {
                            if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                                matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
                            } else {
                                matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

                                // Return special upon seeing a positional matcher
                                if ( matcher[ expando ] ) {
                                    // Find the next relative operator (if any) for proper handling
                                    j = ++i;
                                    for ( ; j < len; j++ ) {
                                        if ( Expr.relative[ tokens[j].type ] ) {
                                            break;
                                        }
                                    }
                                    return setMatcher(
                                        i > 1 && elementMatcher( matchers ),
                                        i > 1 && toSelector(
                                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                        tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                                        ).replace( rtrim, "$1" ),
                                        matcher,
                                        i < j && matcherFromTokens( tokens.slice( i, j ) ),
                                        j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                                        j < len && toSelector( tokens )
                                    );
                                }
                                matchers.push( matcher );
                            }
                        }

                        return elementMatcher( matchers );
                    }

                    function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
                        var bySet = setMatchers.length > 0,
                            byElement = elementMatchers.length > 0,
                            superMatcher = function( seed, context, xml, results, outermost ) {
                                var elem, j, matcher,
                                    matchedCount = 0,
                                    i = "0",
                                    unmatched = seed && [],
                                    setMatched = [],
                                    contextBackup = outermostContext,
                                    // We must always have either seed elements or outermost context
                                    elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                                    // Use integer dirruns iff this is the outermost matcher
                                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                    len = elems.length;

                                if ( outermost ) {
                                    outermostContext = context === document || context || outermost;
                                }

                                // Add elements passing elementMatchers directly to results
                                // Support: IE<9, Safari
                                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                                for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                                    if ( byElement && elem ) {
                                        j = 0;
                                        if ( !context && elem.ownerDocument !== document ) {
                                            setDocument( elem );
                                            xml = !documentIsHTML;
                                        }
                                        while ( (matcher = elementMatchers[j++]) ) {
                                            if ( matcher( elem, context || document, xml) ) {
                                                results.push( elem );
                                                break;
                                            }
                                        }
                                        if ( outermost ) {
                                            dirruns = dirrunsUnique;
                                        }
                                    }

                                    // Track unmatched elements for set filters
                                    if ( bySet ) {
                                        // They will have gone through all possible matchers
                                        if ( (elem = !matcher && elem) ) {
                                            matchedCount--;
                                        }

                                        // Lengthen the array for every element, matched or not
                                        if ( seed ) {
                                            unmatched.push( elem );
                                        }
                                    }
                                }

                                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                                // makes the latter nonnegative.
                                matchedCount += i;

                                // Apply set filters to unmatched elements
                                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                                // no element matchers and no seed.
                                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                                // numerically zero.
                                if ( bySet && i !== matchedCount ) {
                                    j = 0;
                                    while ( (matcher = setMatchers[j++]) ) {
                                        matcher( unmatched, setMatched, context, xml );
                                    }

                                    if ( seed ) {
                                        // Reintegrate element matches to eliminate the need for sorting
                                        if ( matchedCount > 0 ) {
                                            while ( i-- ) {
                                                if ( !(unmatched[i] || setMatched[i]) ) {
                                                    setMatched[i] = pop.call( results );
                                                }
                                            }
                                        }

                                        // Discard index placeholder values to get only actual matches
                                        setMatched = condense( setMatched );
                                    }

                                    // Add matches to results
                                    push.apply( results, setMatched );

                                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                    if ( outermost && !seed && setMatched.length > 0 &&
                                        ( matchedCount + setMatchers.length ) > 1 ) {

                                        Sizzle.uniqueSort( results );
                                    }
                                }

                                // Override manipulation of globals by nested matchers
                                if ( outermost ) {
                                    dirruns = dirrunsUnique;
                                    outermostContext = contextBackup;
                                }

                                return unmatched;
                            };

                        return bySet ?
                            markFunction( superMatcher ) :
                            superMatcher;
                    }

                    compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
                        var i,
                            setMatchers = [],
                            elementMatchers = [],
                            cached = compilerCache[ selector + " " ];

                        if ( !cached ) {
                            // Generate a function of recursive functions that can be used to check each element
                            if ( !match ) {
                                match = tokenize( selector );
                            }
                            i = match.length;
                            while ( i-- ) {
                                cached = matcherFromTokens( match[i] );
                                if ( cached[ expando ] ) {
                                    setMatchers.push( cached );
                                } else {
                                    elementMatchers.push( cached );
                                }
                            }

                            // Cache the compiled function
                            cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

                            // Save selector and tokenization
                            cached.selector = selector;
                        }
                        return cached;
                    };

                    /**
                     * A low-level selection function that works with Sizzle's compiled
                     *  selector functions
                     * @param {String|Function} selector A selector or a pre-compiled
                     *  selector function built with Sizzle.compile
                     * @param {Element} context
                     * @param {Array} [results]
                     * @param {Array} [seed] A set of elements to match against
                     */
                    select = Sizzle.select = function( selector, context, results, seed ) {
                        var i, tokens, token, type, find,
                            compiled = typeof selector === "function" && selector,
                            match = !seed && tokenize( (selector = compiled.selector || selector) );

                        results = results || [];

                        // Try to minimize operations if there is only one selector in the list and no seed
                        // (the latter of which guarantees us context)
                        if ( match.length === 1 ) {

                            // Reduce context if the leading compound selector is an ID
                            tokens = match[0] = match[0].slice( 0 );
                            if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                                support.getById && context.nodeType === 9 && documentIsHTML &&
                                Expr.relative[ tokens[1].type ] ) {

                                context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                                if ( !context ) {
                                    return results;

                                    // Precompiled matchers will still verify ancestry, so step up a level
                                } else if ( compiled ) {
                                    context = context.parentNode;
                                }

                                selector = selector.slice( tokens.shift().value.length );
                            }

                            // Fetch a seed set for right-to-left matching
                            i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
                            while ( i-- ) {
                                token = tokens[i];

                                // Abort if we hit a combinator
                                if ( Expr.relative[ (type = token.type) ] ) {
                                    break;
                                }
                                if ( (find = Expr.find[ type ]) ) {
                                    // Search, expanding context for leading sibling combinators
                                    if ( (seed = find(
                                        token.matches[0].replace( runescape, funescape ),
                                        rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                                    )) ) {

                                        // If seed is empty or no tokens remain, we can return early
                                        tokens.splice( i, 1 );
                                        selector = seed.length && toSelector( tokens );
                                        if ( !selector ) {
                                            push.apply( results, seed );
                                            return results;
                                        }

                                        break;
                                    }
                                }
                            }
                        }

                        // Compile and execute a filtering function if one is not provided
                        // Provide `match` to avoid retokenization if we modified the selector above
                        ( compiled || compile( selector, match ) )(
                            seed,
                            context,
                            !documentIsHTML,
                            results,
                            !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
                        );
                        return results;
                    };

                    // One-time assignments

                    // Sort stability
                    support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

                    // Support: Chrome 14-35+
                    // Always assume duplicates if they aren't passed to the comparison function
                    support.detectDuplicates = !!hasDuplicate;

                    // Initialize against the default document
                    setDocument();

                    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                    // Detached nodes confoundingly follow *each other*
                    support.sortDetached = assert(function( div1 ) {
                        // Should return 1, but returns 4 (following)
                        return div1.compareDocumentPosition( document.createElement("div") ) & 1;
                    });

                    // Support: IE<8
                    // Prevent attribute/property "interpolation"
                    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                    if ( !assert(function( div ) {
                        div.innerHTML = "<a href='#'></a>";
                        return div.firstChild.getAttribute("href") === "#" ;
                    }) ) {
                        addHandle( "type|href|height|width", function( elem, name, isXML ) {
                            if ( !isXML ) {
                                return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
                            }
                        });
                    }

                    // Support: IE<9
                    // Use defaultValue in place of getAttribute("value")
                    if ( !support.attributes || !assert(function( div ) {
                        div.innerHTML = "<input/>";
                        div.firstChild.setAttribute( "value", "" );
                        return div.firstChild.getAttribute( "value" ) === "";
                    }) ) {
                        addHandle( "value", function( elem, name, isXML ) {
                            if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                                return elem.defaultValue;
                            }
                        });
                    }

                    // Support: IE<9
                    // Use getAttributeNode to fetch booleans when getAttribute lies
                    if ( !assert(function( div ) {
                        return div.getAttribute("disabled") == null;
                    }) ) {
                        addHandle( booleans, function( elem, name, isXML ) {
                            var val;
                            if ( !isXML ) {
                                return elem[ name ] === true ? name.toLowerCase() :
                                    (val = elem.getAttributeNode( name )) && val.specified ?
                                        val.value :
                                        null;
                            }
                        });
                    }

                    return Sizzle;

                })( window );



            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[ ":" ] = jQuery.expr.pseudos;
            jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;



            var dir = function( elem, dir, until ) {
                var matched = [],
                    truncate = until !== undefined;

                while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
                    if ( elem.nodeType === 1 ) {
                        if ( truncate && jQuery( elem ).is( until ) ) {
                            break;
                        }
                        matched.push( elem );
                    }
                }
                return matched;
            };


            var siblings = function( n, elem ) {
                var matched = [];

                for ( ; n; n = n.nextSibling ) {
                    if ( n.nodeType === 1 && n !== elem ) {
                        matched.push( n );
                    }
                }

                return matched;
            };


            var rneedsContext = jQuery.expr.match.needsContext;

            var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



            var risSimple = /^.[^:#\[\.,]*$/;

            // Implement the identical functionality for filter and not
            function winnow( elements, qualifier, not ) {
                if ( jQuery.isFunction( qualifier ) ) {
                    return jQuery.grep( elements, function( elem, i ) {
                        /* jshint -W018 */
                        return !!qualifier.call( elem, i, elem ) !== not;
                    } );

                }

                if ( qualifier.nodeType ) {
                    return jQuery.grep( elements, function( elem ) {
                        return ( elem === qualifier ) !== not;
                    } );

                }

                if ( typeof qualifier === "string" ) {
                    if ( risSimple.test( qualifier ) ) {
                        return jQuery.filter( qualifier, elements, not );
                    }

                    qualifier = jQuery.filter( qualifier, elements );
                }

                return jQuery.grep( elements, function( elem ) {
                    return ( jQuery.inArray( elem, qualifier ) > -1 ) !== not;
                } );
            }

            jQuery.filter = function( expr, elems, not ) {
                var elem = elems[ 0 ];

                if ( not ) {
                    expr = ":not(" + expr + ")";
                }

                return elems.length === 1 && elem.nodeType === 1 ?
                    jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
                    jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                        return elem.nodeType === 1;
                    } ) );
            };

            jQuery.fn.extend( {
                find: function( selector ) {
                    var i,
                        ret = [],
                        self = this,
                        len = self.length;

                    if ( typeof selector !== "string" ) {
                        return this.pushStack( jQuery( selector ).filter( function() {
                            for ( i = 0; i < len; i++ ) {
                                if ( jQuery.contains( self[ i ], this ) ) {
                                    return true;
                                }
                            }
                        } ) );
                    }

                    for ( i = 0; i < len; i++ ) {
                        jQuery.find( selector, self[ i ], ret );
                    }

                    // Needed because $( selector, context ) becomes $( context ).find( selector )
                    ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
                    ret.selector = this.selector ? this.selector + " " + selector : selector;
                    return ret;
                },
                filter: function( selector ) {
                    return this.pushStack( winnow( this, selector || [], false ) );
                },
                not: function( selector ) {
                    return this.pushStack( winnow( this, selector || [], true ) );
                },
                is: function( selector ) {
                    return !!winnow(
                        this,

                        // If this is a positional/relative selector, check membership in the returned set
                        // so $("p:first").is("p:last") won't return true for a doc with two "p".
                        typeof selector === "string" && rneedsContext.test( selector ) ?
                            jQuery( selector ) :
                            selector || [],
                        false
                    ).length;
                }
            } );


            // Initialize a jQuery object


            // A central reference to the root jQuery(document)
            var rootjQuery,

                // A simple way to check for HTML strings
                // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
                // Strict HTML recognition (#11290: must start with <)
                rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

                init = jQuery.fn.init = function( selector, context, root ) {
                    var match, elem;

                    // HANDLE: $(""), $(null), $(undefined), $(false)
                    if ( !selector ) {
                        return this;
                    }

                    // init accepts an alternate rootjQuery
                    // so migrate can support jQuery.sub (gh-2101)
                    root = root || rootjQuery;

                    // Handle HTML strings
                    if ( typeof selector === "string" ) {
                        if ( selector.charAt( 0 ) === "<" &&
                            selector.charAt( selector.length - 1 ) === ">" &&
                            selector.length >= 3 ) {

                            // Assume that strings that start and end with <> are HTML and skip the regex check
                            match = [ null, selector, null ];

                        } else {
                            match = rquickExpr.exec( selector );
                        }

                        // Match html or make sure no context is specified for #id
                        if ( match && ( match[ 1 ] || !context ) ) {

                            // HANDLE: $(html) -> $(array)
                            if ( match[ 1 ] ) {
                                context = context instanceof jQuery ? context[ 0 ] : context;

                                // scripts is true for back-compat
                                // Intentionally let the error be thrown if parseHTML is not present
                                jQuery.merge( this, jQuery.parseHTML(
                                    match[ 1 ],
                                    context && context.nodeType ? context.ownerDocument || context : document,
                                    true
                                ) );

                                // HANDLE: $(html, props)
                                if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
                                    for ( match in context ) {

                                        // Properties of context are called as methods if possible
                                        if ( jQuery.isFunction( this[ match ] ) ) {
                                            this[ match ]( context[ match ] );

                                            // ...and otherwise set as attributes
                                        } else {
                                            this.attr( match, context[ match ] );
                                        }
                                    }
                                }

                                return this;

                                // HANDLE: $(#id)
                            } else {
                                elem = document.getElementById( match[ 2 ] );

                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document #6963
                                if ( elem && elem.parentNode ) {

                                    // Handle the case where IE and Opera return items
                                    // by name instead of ID
                                    if ( elem.id !== match[ 2 ] ) {
                                        return rootjQuery.find( selector );
                                    }

                                    // Otherwise, we inject the element directly into the jQuery object
                                    this.length = 1;
                                    this[ 0 ] = elem;
                                }

                                this.context = document;
                                this.selector = selector;
                                return this;
                            }

                            // HANDLE: $(expr, $(...))
                        } else if ( !context || context.jquery ) {
                            return ( context || root ).find( selector );

                            // HANDLE: $(expr, context)
                            // (which is just equivalent to: $(context).find(expr)
                        } else {
                            return this.constructor( context ).find( selector );
                        }

                        // HANDLE: $(DOMElement)
                    } else if ( selector.nodeType ) {
                        this.context = this[ 0 ] = selector;
                        this.length = 1;
                        return this;

                        // HANDLE: $(function)
                        // Shortcut for document ready
                    } else if ( jQuery.isFunction( selector ) ) {
                        return typeof root.ready !== "undefined" ?
                            root.ready( selector ) :

                            // Execute immediately if ready is not present
                            selector( jQuery );
                    }

                    if ( selector.selector !== undefined ) {
                        this.selector = selector.selector;
                        this.context = selector.context;
                    }

                    return jQuery.makeArray( selector, this );
                };

            // Give the init function the jQuery prototype for later instantiation
            init.prototype = jQuery.fn;

            // Initialize central reference
            rootjQuery = jQuery( document );


            var rparentsprev = /^(?:parents|prev(?:Until|All))/,

                // methods guaranteed to produce a unique set when starting from a unique set
                guaranteedUnique = {
                    children: true,
                    contents: true,
                    next: true,
                    prev: true
                };

            jQuery.fn.extend( {
                has: function( target ) {
                    var i,
                        targets = jQuery( target, this ),
                        len = targets.length;

                    return this.filter( function() {
                        for ( i = 0; i < len; i++ ) {
                            if ( jQuery.contains( this, targets[ i ] ) ) {
                                return true;
                            }
                        }
                    } );
                },

                closest: function( selectors, context ) {
                    var cur,
                        i = 0,
                        l = this.length,
                        matched = [],
                        pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                            jQuery( selectors, context || this.context ) :
                            0;

                    for ( ; i < l; i++ ) {
                        for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

                            // Always skip document fragments
                            if ( cur.nodeType < 11 && ( pos ?
                                pos.index( cur ) > -1 :

                                // Don't pass non-elements to Sizzle
                                cur.nodeType === 1 &&
                                jQuery.find.matchesSelector( cur, selectors ) ) ) {

                                matched.push( cur );
                                break;
                            }
                        }
                    }

                    return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
                },

                // Determine the position of an element within
                // the matched set of elements
                index: function( elem ) {

                    // No argument, return index in parent
                    if ( !elem ) {
                        return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
                    }

                    // index in selector
                    if ( typeof elem === "string" ) {
                        return jQuery.inArray( this[ 0 ], jQuery( elem ) );
                    }

                    // Locate the position of the desired element
                    return jQuery.inArray(

                        // If it receives a jQuery object, the first element is used
                        elem.jquery ? elem[ 0 ] : elem, this );
                },

                add: function( selector, context ) {
                    return this.pushStack(
                        jQuery.uniqueSort(
                            jQuery.merge( this.get(), jQuery( selector, context ) )
                        )
                    );
                },

                addBack: function( selector ) {
                    return this.add( selector == null ?
                        this.prevObject : this.prevObject.filter( selector )
                    );
                }
            } );

            function sibling( cur, dir ) {
                do {
                    cur = cur[ dir ];
                } while ( cur && cur.nodeType !== 1 );

                return cur;
            }

            jQuery.each( {
                parent: function( elem ) {
                    var parent = elem.parentNode;
                    return parent && parent.nodeType !== 11 ? parent : null;
                },
                parents: function( elem ) {
                    return dir( elem, "parentNode" );
                },
                parentsUntil: function( elem, i, until ) {
                    return dir( elem, "parentNode", until );
                },
                next: function( elem ) {
                    return sibling( elem, "nextSibling" );
                },
                prev: function( elem ) {
                    return sibling( elem, "previousSibling" );
                },
                nextAll: function( elem ) {
                    return dir( elem, "nextSibling" );
                },
                prevAll: function( elem ) {
                    return dir( elem, "previousSibling" );
                },
                nextUntil: function( elem, i, until ) {
                    return dir( elem, "nextSibling", until );
                },
                prevUntil: function( elem, i, until ) {
                    return dir( elem, "previousSibling", until );
                },
                siblings: function( elem ) {
                    return siblings( ( elem.parentNode || {} ).firstChild, elem );
                },
                children: function( elem ) {
                    return siblings( elem.firstChild );
                },
                contents: function( elem ) {
                    return jQuery.nodeName( elem, "iframe" ) ?
                        elem.contentDocument || elem.contentWindow.document :
                        jQuery.merge( [], elem.childNodes );
                }
            }, function( name, fn ) {
                jQuery.fn[ name ] = function( until, selector ) {
                    var ret = jQuery.map( this, fn, until );

                    if ( name.slice( -5 ) !== "Until" ) {
                        selector = until;
                    }

                    if ( selector && typeof selector === "string" ) {
                        ret = jQuery.filter( selector, ret );
                    }

                    if ( this.length > 1 ) {

                        // Remove duplicates
                        if ( !guaranteedUnique[ name ] ) {
                            ret = jQuery.uniqueSort( ret );
                        }

                        // Reverse order for parents* and prev-derivatives
                        if ( rparentsprev.test( name ) ) {
                            ret = ret.reverse();
                        }
                    }

                    return this.pushStack( ret );
                };
            } );
            var rnotwhite = ( /\S+/g );



            // Convert String-formatted options into Object-formatted ones
            function createOptions( options ) {
                var object = {};
                jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
                    object[ flag ] = true;
                } );
                return object;
            }

            /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
            jQuery.Callbacks = function( options ) {

                // Convert options from String-formatted to Object-formatted if needed
                // (we check in cache first)
                options = typeof options === "string" ?
                    createOptions( options ) :
                    jQuery.extend( {}, options );

                var // Flag to know if list is currently firing
                    firing,

                    // Last fire value for non-forgettable lists
                    memory,

                    // Flag to know if list was already fired
                    fired,

                    // Flag to prevent firing
                    locked,

                    // Actual callback list
                    list = [],

                    // Queue of execution data for repeatable lists
                    queue = [],

                    // Index of currently firing callback (modified by add/remove as needed)
                    firingIndex = -1,

                    // Fire callbacks
                    fire = function() {

                        // Enforce single-firing
                        locked = options.once;

                        // Execute callbacks for all pending executions,
                        // respecting firingIndex overrides and runtime changes
                        fired = firing = true;
                        for ( ; queue.length; firingIndex = -1 ) {
                            memory = queue.shift();
                            while ( ++firingIndex < list.length ) {

                                // Run callback and check for early termination
                                if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
                                    options.stopOnFalse ) {

                                    // Jump to end and forget the data so .add doesn't re-fire
                                    firingIndex = list.length;
                                    memory = false;
                                }
                            }
                        }

                        // Forget the data if we're done with it
                        if ( !options.memory ) {
                            memory = false;
                        }

                        firing = false;

                        // Clean up if we're done firing for good
                        if ( locked ) {

                            // Keep an empty list if we have data for future add calls
                            if ( memory ) {
                                list = [];

                                // Otherwise, this object is spent
                            } else {
                                list = "";
                            }
                        }
                    },

                    // Actual Callbacks object
                    self = {

                        // Add a callback or a collection of callbacks to the list
                        add: function() {
                            if ( list ) {

                                // If we have memory from a past run, we should fire after adding
                                if ( memory && !firing ) {
                                    firingIndex = list.length - 1;
                                    queue.push( memory );
                                }

                                ( function add( args ) {
                                    jQuery.each( args, function( _, arg ) {
                                        if ( jQuery.isFunction( arg ) ) {
                                            if ( !options.unique || !self.has( arg ) ) {
                                                list.push( arg );
                                            }
                                        } else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

                                            // Inspect recursively
                                            add( arg );
                                        }
                                    } );
                                } )( arguments );

                                if ( memory && !firing ) {
                                    fire();
                                }
                            }
                            return this;
                        },

                        // Remove a callback from the list
                        remove: function() {
                            jQuery.each( arguments, function( _, arg ) {
                                var index;
                                while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                                    list.splice( index, 1 );

                                    // Handle firing indexes
                                    if ( index <= firingIndex ) {
                                        firingIndex--;
                                    }
                                }
                            } );
                            return this;
                        },

                        // Check if a given callback is in the list.
                        // If no argument is given, return whether or not list has callbacks attached.
                        has: function( fn ) {
                            return fn ?
                                jQuery.inArray( fn, list ) > -1 :
                                list.length > 0;
                        },

                        // Remove all callbacks from the list
                        empty: function() {
                            if ( list ) {
                                list = [];
                            }
                            return this;
                        },

                        // Disable .fire and .add
                        // Abort any current/pending executions
                        // Clear all callbacks and values
                        disable: function() {
                            locked = queue = [];
                            list = memory = "";
                            return this;
                        },
                        disabled: function() {
                            return !list;
                        },

                        // Disable .fire
                        // Also disable .add unless we have memory (since it would have no effect)
                        // Abort any pending executions
                        lock: function() {
                            locked = true;
                            if ( !memory ) {
                                self.disable();
                            }
                            return this;
                        },
                        locked: function() {
                            return !!locked;
                        },

                        // Call all callbacks with the given context and arguments
                        fireWith: function( context, args ) {
                            if ( !locked ) {
                                args = args || [];
                                args = [ context, args.slice ? args.slice() : args ];
                                queue.push( args );
                                if ( !firing ) {
                                    fire();
                                }
                            }
                            return this;
                        },

                        // Call all the callbacks with the given arguments
                        fire: function() {
                            self.fireWith( this, arguments );
                            return this;
                        },

                        // To know if the callbacks have already been called at least once
                        fired: function() {
                            return !!fired;
                        }
                    };

                return self;
            };


            jQuery.extend( {

                Deferred: function( func ) {
                    var tuples = [

                            // action, add listener, listener list, final state
                            [ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
                            [ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
                            [ "notify", "progress", jQuery.Callbacks( "memory" ) ]
                        ],
                        state = "pending",
                        promise = {
                            state: function() {
                                return state;
                            },
                            always: function() {
                                deferred.done( arguments ).fail( arguments );
                                return this;
                            },
                            then: function( /* fnDone, fnFail, fnProgress */ ) {
                                var fns = arguments;
                                return jQuery.Deferred( function( newDefer ) {
                                    jQuery.each( tuples, function( i, tuple ) {
                                        var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

                                        // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                        deferred[ tuple[ 1 ] ]( function() {
                                            var returned = fn && fn.apply( this, arguments );
                                            if ( returned && jQuery.isFunction( returned.promise ) ) {
                                                returned.promise()
                                                    .progress( newDefer.notify )
                                                    .done( newDefer.resolve )
                                                    .fail( newDefer.reject );
                                            } else {
                                                newDefer[ tuple[ 0 ] + "With" ](
                                                    this === promise ? newDefer.promise() : this,
                                                    fn ? [ returned ] : arguments
                                                );
                                            }
                                        } );
                                    } );
                                    fns = null;
                                } ).promise();
                            },

                            // Get a promise for this deferred
                            // If obj is provided, the promise aspect is added to the object
                            promise: function( obj ) {
                                return obj != null ? jQuery.extend( obj, promise ) : promise;
                            }
                        },
                        deferred = {};

                    // Keep pipe for back-compat
                    promise.pipe = promise.then;

                    // Add list-specific methods
                    jQuery.each( tuples, function( i, tuple ) {
                        var list = tuple[ 2 ],
                            stateString = tuple[ 3 ];

                        // promise[ done | fail | progress ] = list.add
                        promise[ tuple[ 1 ] ] = list.add;

                        // Handle state
                        if ( stateString ) {
                            list.add( function() {

                                // state = [ resolved | rejected ]
                                state = stateString;

                                // [ reject_list | resolve_list ].disable; progress_list.lock
                            }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
                        }

                        // deferred[ resolve | reject | notify ]
                        deferred[ tuple[ 0 ] ] = function() {
                            deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
                            return this;
                        };
                        deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
                    } );

                    // Make the deferred a promise
                    promise.promise( deferred );

                    // Call given func if any
                    if ( func ) {
                        func.call( deferred, deferred );
                    }

                    // All done!
                    return deferred;
                },

                // Deferred helper
                when: function( subordinate /* , ..., subordinateN */ ) {
                    var i = 0,
                        resolveValues = slice.call( arguments ),
                        length = resolveValues.length,

                        // the count of uncompleted subordinates
                        remaining = length !== 1 ||
                        ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

                        // the master Deferred.
                        // If resolveValues consist of only a single Deferred, just use that.
                        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                        // Update function for both resolve and progress values
                        updateFunc = function( i, contexts, values ) {
                            return function( value ) {
                                contexts[ i ] = this;
                                values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                                if ( values === progressValues ) {
                                    deferred.notifyWith( contexts, values );

                                } else if ( !( --remaining ) ) {
                                    deferred.resolveWith( contexts, values );
                                }
                            };
                        },

                        progressValues, progressContexts, resolveContexts;

                    // add listeners to Deferred subordinates; treat others as resolved
                    if ( length > 1 ) {
                        progressValues = new Array( length );
                        progressContexts = new Array( length );
                        resolveContexts = new Array( length );
                        for ( ; i < length; i++ ) {
                            if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                                resolveValues[ i ].promise()
                                    .progress( updateFunc( i, progressContexts, progressValues ) )
                                    .done( updateFunc( i, resolveContexts, resolveValues ) )
                                    .fail( deferred.reject );
                            } else {
                                --remaining;
                            }
                        }
                    }

                    // if we're not waiting on anything, resolve the master
                    if ( !remaining ) {
                        deferred.resolveWith( resolveContexts, resolveValues );
                    }

                    return deferred.promise();
                }
            } );


            // The deferred used on DOM ready
            var readyList;

            jQuery.fn.ready = function( fn ) {

                // Add the callback
                jQuery.ready.promise().done( fn );

                return this;
            };

            jQuery.extend( {

                // Is the DOM ready to be used? Set to true once it occurs.
                isReady: false,

                // A counter to track how many items to wait for before
                // the ready event fires. See #6781
                readyWait: 1,

                // Hold (or release) the ready event
                holdReady: function( hold ) {
                    if ( hold ) {
                        jQuery.readyWait++;
                    } else {
                        jQuery.ready( true );
                    }
                },

                // Handle when the DOM is ready
                ready: function( wait ) {

                    // Abort if there are pending holds or we're already ready
                    if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                        return;
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if ( wait !== true && --jQuery.readyWait > 0 ) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.resolveWith( document, [ jQuery ] );

                    // Trigger any bound ready events
                    if ( jQuery.fn.triggerHandler ) {
                        jQuery( document ).triggerHandler( "ready" );
                        jQuery( document ).off( "ready" );
                    }
                }
            } );

            /**
             * Clean-up method for dom ready events
             */
            function detach() {
                if ( document.addEventListener ) {
                    document.removeEventListener( "DOMContentLoaded", completed );
                    window.removeEventListener( "load", completed );

                } else {
                    document.detachEvent( "onreadystatechange", completed );
                    window.detachEvent( "onload", completed );
                }
            }

            /**
             * The ready event handler and self cleanup method
             */
            function completed() {

                // readyState === "complete" is good enough for us to call the dom ready in oldIE
                if ( document.addEventListener ||
                    window.event.type === "load" ||
                    document.readyState === "complete" ) {

                    detach();
                    jQuery.ready();
                }
            }

            jQuery.ready.promise = function( obj ) {
                if ( !readyList ) {

                    readyList = jQuery.Deferred();

                    // Catch cases where $(document).ready() is called
                    // after the browser event has already occurred.
                    // Support: IE6-10
                    // Older IE sometimes signals "interactive" too soon
                    if ( document.readyState === "complete" ||
                        ( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

                        // Handle it asynchronously to allow scripts the opportunity to delay ready
                        window.setTimeout( jQuery.ready );

                        // Standards-based browsers support DOMContentLoaded
                    } else if ( document.addEventListener ) {

                        // Use the handy event callback
                        document.addEventListener( "DOMContentLoaded", completed );

                        // A fallback to window.onload, that will always work
                        window.addEventListener( "load", completed );

                        // If IE event model is used
                    } else {

                        // Ensure firing before onload, maybe late but safe also for iframes
                        document.attachEvent( "onreadystatechange", completed );

                        // A fallback to window.onload, that will always work
                        window.attachEvent( "onload", completed );

                        // If IE and not a frame
                        // continually check to see if the document is ready
                        var top = false;

                        try {
                            top = window.frameElement == null && document.documentElement;
                        } catch ( e ) {}

                        if ( top && top.doScroll ) {
                            ( function doScrollCheck() {
                                if ( !jQuery.isReady ) {

                                    try {

                                        // Use the trick by Diego Perini
                                        // http://javascript.nwbox.com/IEContentLoaded/
                                        top.doScroll( "left" );
                                    } catch ( e ) {
                                        return window.setTimeout( doScrollCheck, 50 );
                                    }

                                    // detach all dom ready events
                                    detach();

                                    // and execute any waiting functions
                                    jQuery.ready();
                                }
                            } )();
                        }
                    }
                }
                return readyList.promise( obj );
            };

            // Kick off the DOM ready check even if the user does not
            jQuery.ready.promise();




            // Support: IE<9
            // Iteration over object's inherited properties before its own
            var i;
            for ( i in jQuery( support ) ) {
                break;
            }
            support.ownFirst = i === "0";

            // Note: most support tests are defined in their respective modules.
            // false until the test is run
            support.inlineBlockNeedsLayout = false;

            // Execute ASAP in case we need to set body.style.zoom
            jQuery( function() {

                // Minified: var a,b,c,d
                var val, div, body, container;

                body = document.getElementsByTagName( "body" )[ 0 ];
                if ( !body || !body.style ) {

                    // Return for frameset docs that don't have a body
                    return;
                }

                // Setup
                div = document.createElement( "div" );
                container = document.createElement( "div" );
                container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
                body.appendChild( container ).appendChild( div );

                if ( typeof div.style.zoom !== "undefined" ) {

                    // Support: IE<8
                    // Check if natively block-level elements act like inline-block
                    // elements when setting their display to 'inline' and giving
                    // them layout
                    div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

                    support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
                    if ( val ) {

                        // Prevent IE 6 from affecting layout for positioned elements #11048
                        // Prevent IE from shrinking the body in IE 7 mode #12869
                        // Support: IE<8
                        body.style.zoom = 1;
                    }
                }

                body.removeChild( container );
            } );


            ( function() {
                var div = document.createElement( "div" );

                // Support: IE<9
                support.deleteExpando = true;
                try {
                    delete div.test;
                } catch ( e ) {
                    support.deleteExpando = false;
                }

                // Null elements to avoid leaks in IE.
                div = null;
            } )();
            var acceptData = function( elem ) {
                var noData = jQuery.noData[ ( elem.nodeName + " " ).toLowerCase() ],
                    nodeType = +elem.nodeType || 1;

                // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
                return nodeType !== 1 && nodeType !== 9 ?
                    false :

                    // Nodes accept data unless otherwise specified; rejection can be conditional
                    !noData || noData !== true && elem.getAttribute( "classid" ) === noData;
            };




            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                rmultiDash = /([A-Z])/g;

            function dataAttr( elem, key, data ) {

                // If nothing was found internally, try to fetch any
                // data from the HTML5 data-* attribute
                if ( data === undefined && elem.nodeType === 1 ) {

                    var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

                    data = elem.getAttribute( name );

                    if ( typeof data === "string" ) {
                        try {
                            data = data === "true" ? true :
                                data === "false" ? false :
                                    data === "null" ? null :

                                        // Only convert to a number if it doesn't change the string
                                        +data + "" === data ? +data :
                                            rbrace.test( data ) ? jQuery.parseJSON( data ) :
                                                data;
                        } catch ( e ) {}

                        // Make sure we set the data so it isn't changed later
                        jQuery.data( elem, key, data );

                    } else {
                        data = undefined;
                    }
                }

                return data;
            }

            // checks a cache object for emptiness
            function isEmptyDataObject( obj ) {
                var name;
                for ( name in obj ) {

                    // if the public data object is empty, the private is still empty
                    if ( name === "data" && jQuery.isEmptyObject( obj[ name ] ) ) {
                        continue;
                    }
                    if ( name !== "toJSON" ) {
                        return false;
                    }
                }

                return true;
            }

            function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
                if ( !acceptData( elem ) ) {
                    return;
                }

                var ret, thisCache,
                    internalKey = jQuery.expando,

                    // We have to handle DOM nodes and JS objects differently because IE6-7
                    // can't GC object references properly across the DOM-JS boundary
                    isNode = elem.nodeType,

                    // Only DOM nodes need the global jQuery cache; JS object data is
                    // attached directly to the object so GC can occur automatically
                    cache = isNode ? jQuery.cache : elem,

                    // Only defining an ID for JS objects if its cache already exists allows
                    // the code to shortcut on the same path as a DOM node with no cache
                    id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

                // Avoid doing any more work than we need to when trying to get data on an
                // object that has no data at all
                if ( ( !id || !cache[ id ] || ( !pvt && !cache[ id ].data ) ) &&
                    data === undefined && typeof name === "string" ) {
                    return;
                }

                if ( !id ) {

                    // Only DOM nodes need a new unique ID for each element since their data
                    // ends up in the global cache
                    if ( isNode ) {
                        id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
                    } else {
                        id = internalKey;
                    }
                }

                if ( !cache[ id ] ) {

                    // Avoid exposing jQuery metadata on plain JS objects when the object
                    // is serialized using JSON.stringify
                    cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
                }

                // An object can be passed to jQuery.data instead of a key/value pair; this gets
                // shallow copied over onto the existing cache
                if ( typeof name === "object" || typeof name === "function" ) {
                    if ( pvt ) {
                        cache[ id ] = jQuery.extend( cache[ id ], name );
                    } else {
                        cache[ id ].data = jQuery.extend( cache[ id ].data, name );
                    }
                }

                thisCache = cache[ id ];

                // jQuery data() is stored in a separate object inside the object's internal data
                // cache in order to avoid key collisions between internal data and user-defined
                // data.
                if ( !pvt ) {
                    if ( !thisCache.data ) {
                        thisCache.data = {};
                    }

                    thisCache = thisCache.data;
                }

                if ( data !== undefined ) {
                    thisCache[ jQuery.camelCase( name ) ] = data;
                }

                // Check for both converted-to-camel and non-converted data property names
                // If a data property was specified
                if ( typeof name === "string" ) {

                    // First Try to find as-is property data
                    ret = thisCache[ name ];

                    // Test for null|undefined property data
                    if ( ret == null ) {

                        // Try to find the camelCased property
                        ret = thisCache[ jQuery.camelCase( name ) ];
                    }
                } else {
                    ret = thisCache;
                }

                return ret;
            }

            function internalRemoveData( elem, name, pvt ) {
                if ( !acceptData( elem ) ) {
                    return;
                }

                var thisCache, i,
                    isNode = elem.nodeType,

                    // See jQuery.data for more information
                    cache = isNode ? jQuery.cache : elem,
                    id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

                // If there is already no cache entry for this object, there is no
                // purpose in continuing
                if ( !cache[ id ] ) {
                    return;
                }

                if ( name ) {

                    thisCache = pvt ? cache[ id ] : cache[ id ].data;

                    if ( thisCache ) {

                        // Support array or space separated string names for data keys
                        if ( !jQuery.isArray( name ) ) {

                            // try the string as a key before any manipulation
                            if ( name in thisCache ) {
                                name = [ name ];
                            } else {

                                // split the camel cased version by spaces unless a key with the spaces exists
                                name = jQuery.camelCase( name );
                                if ( name in thisCache ) {
                                    name = [ name ];
                                } else {
                                    name = name.split( " " );
                                }
                            }
                        } else {

                            // If "name" is an array of keys...
                            // When data is initially created, via ("key", "val") signature,
                            // keys will be converted to camelCase.
                            // Since there is no way to tell _how_ a key was added, remove
                            // both plain key and camelCase key. #12786
                            // This will only penalize the array argument path.
                            name = name.concat( jQuery.map( name, jQuery.camelCase ) );
                        }

                        i = name.length;
                        while ( i-- ) {
                            delete thisCache[ name[ i ] ];
                        }

                        // If there is no data left in the cache, we want to continue
                        // and let the cache object itself get destroyed
                        if ( pvt ? !isEmptyDataObject( thisCache ) : !jQuery.isEmptyObject( thisCache ) ) {
                            return;
                        }
                    }
                }

                // See jQuery.data for more information
                if ( !pvt ) {
                    delete cache[ id ].data;

                    // Don't destroy the parent cache unless the internal data object
                    // had been the only thing left in it
                    if ( !isEmptyDataObject( cache[ id ] ) ) {
                        return;
                    }
                }

                // Destroy the cache
                if ( isNode ) {
                    jQuery.cleanData( [ elem ], true );

                    // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
                    /* jshint eqeqeq: false */
                } else if ( support.deleteExpando || cache != cache.window ) {
                    /* jshint eqeqeq: true */
                    delete cache[ id ];

                    // When all else fails, undefined
                } else {
                    cache[ id ] = undefined;
                }
            }

            jQuery.extend( {
                cache: {},

                // The following elements (space-suffixed to avoid Object.prototype collisions)
                // throw uncatchable exceptions if you attempt to set expando properties
                noData: {
                    "applet ": true,
                    "embed ": true,

                    // ...but Flash objects (which have this classid) *can* handle expandos
                    "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
                },

                hasData: function( elem ) {
                    elem = elem.nodeType ? jQuery.cache[ elem[ jQuery.expando ] ] : elem[ jQuery.expando ];
                    return !!elem && !isEmptyDataObject( elem );
                },

                data: function( elem, name, data ) {
                    return internalData( elem, name, data );
                },

                removeData: function( elem, name ) {
                    return internalRemoveData( elem, name );
                },

                // For internal use only.
                _data: function( elem, name, data ) {
                    return internalData( elem, name, data, true );
                },

                _removeData: function( elem, name ) {
                    return internalRemoveData( elem, name, true );
                }
            } );

            jQuery.fn.extend( {
                data: function( key, value ) {
                    var i, name, data,
                        elem = this[ 0 ],
                        attrs = elem && elem.attributes;

                    // Special expections of .data basically thwart jQuery.access,
                    // so implement the relevant behavior ourselves

                    // Gets all values
                    if ( key === undefined ) {
                        if ( this.length ) {
                            data = jQuery.data( elem );

                            if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                                i = attrs.length;
                                while ( i-- ) {

                                    // Support: IE11+
                                    // The attrs elements can be null (#14894)
                                    if ( attrs[ i ] ) {
                                        name = attrs[ i ].name;
                                        if ( name.indexOf( "data-" ) === 0 ) {
                                            name = jQuery.camelCase( name.slice( 5 ) );
                                            dataAttr( elem, name, data[ name ] );
                                        }
                                    }
                                }
                                jQuery._data( elem, "parsedAttrs", true );
                            }
                        }

                        return data;
                    }

                    // Sets multiple values
                    if ( typeof key === "object" ) {
                        return this.each( function() {
                            jQuery.data( this, key );
                        } );
                    }

                    return arguments.length > 1 ?

                        // Sets one value
                        this.each( function() {
                            jQuery.data( this, key, value );
                        } ) :

                        // Gets one value
                        // Try to fetch any internally stored data first
                        elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
                },

                removeData: function( key ) {
                    return this.each( function() {
                        jQuery.removeData( this, key );
                    } );
                }
            } );


            jQuery.extend( {
                queue: function( elem, type, data ) {
                    var queue;

                    if ( elem ) {
                        type = ( type || "fx" ) + "queue";
                        queue = jQuery._data( elem, type );

                        // Speed up dequeue by getting out quickly if this is just a lookup
                        if ( data ) {
                            if ( !queue || jQuery.isArray( data ) ) {
                                queue = jQuery._data( elem, type, jQuery.makeArray( data ) );
                            } else {
                                queue.push( data );
                            }
                        }
                        return queue || [];
                    }
                },

                dequeue: function( elem, type ) {
                    type = type || "fx";

                    var queue = jQuery.queue( elem, type ),
                        startLength = queue.length,
                        fn = queue.shift(),
                        hooks = jQuery._queueHooks( elem, type ),
                        next = function() {
                            jQuery.dequeue( elem, type );
                        };

                    // If the fx queue is dequeued, always remove the progress sentinel
                    if ( fn === "inprogress" ) {
                        fn = queue.shift();
                        startLength--;
                    }

                    if ( fn ) {

                        // Add a progress sentinel to prevent the fx queue from being
                        // automatically dequeued
                        if ( type === "fx" ) {
                            queue.unshift( "inprogress" );
                        }

                        // clear up the last queue stop function
                        delete hooks.stop;
                        fn.call( elem, next, hooks );
                    }

                    if ( !startLength && hooks ) {
                        hooks.empty.fire();
                    }
                },

                // not intended for public consumption - generates a queueHooks object,
                // or returns the current one
                _queueHooks: function( elem, type ) {
                    var key = type + "queueHooks";
                    return jQuery._data( elem, key ) || jQuery._data( elem, key, {
                        empty: jQuery.Callbacks( "once memory" ).add( function() {
                            jQuery._removeData( elem, type + "queue" );
                            jQuery._removeData( elem, key );
                        } )
                    } );
                }
            } );

            jQuery.fn.extend( {
                queue: function( type, data ) {
                    var setter = 2;

                    if ( typeof type !== "string" ) {
                        data = type;
                        type = "fx";
                        setter--;
                    }

                    if ( arguments.length < setter ) {
                        return jQuery.queue( this[ 0 ], type );
                    }

                    return data === undefined ?
                        this :
                        this.each( function() {
                            var queue = jQuery.queue( this, type, data );

                            // ensure a hooks for this queue
                            jQuery._queueHooks( this, type );

                            if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
                                jQuery.dequeue( this, type );
                            }
                        } );
                },
                dequeue: function( type ) {
                    return this.each( function() {
                        jQuery.dequeue( this, type );
                    } );
                },
                clearQueue: function( type ) {
                    return this.queue( type || "fx", [] );
                },

                // Get a promise resolved when queues of a certain type
                // are emptied (fx is the type by default)
                promise: function( type, obj ) {
                    var tmp,
                        count = 1,
                        defer = jQuery.Deferred(),
                        elements = this,
                        i = this.length,
                        resolve = function() {
                            if ( !( --count ) ) {
                                defer.resolveWith( elements, [ elements ] );
                            }
                        };

                    if ( typeof type !== "string" ) {
                        obj = type;
                        type = undefined;
                    }
                    type = type || "fx";

                    while ( i-- ) {
                        tmp = jQuery._data( elements[ i ], type + "queueHooks" );
                        if ( tmp && tmp.empty ) {
                            count++;
                            tmp.empty.add( resolve );
                        }
                    }
                    resolve();
                    return defer.promise( obj );
                }
            } );


            ( function() {
                var shrinkWrapBlocksVal;

                support.shrinkWrapBlocks = function() {
                    if ( shrinkWrapBlocksVal != null ) {
                        return shrinkWrapBlocksVal;
                    }

                    // Will be changed later if needed.
                    shrinkWrapBlocksVal = false;

                    // Minified: var b,c,d
                    var div, body, container;

                    body = document.getElementsByTagName( "body" )[ 0 ];
                    if ( !body || !body.style ) {

                        // Test fired too early or in an unsupported environment, exit.
                        return;
                    }

                    // Setup
                    div = document.createElement( "div" );
                    container = document.createElement( "div" );
                    container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
                    body.appendChild( container ).appendChild( div );

                    // Support: IE6
                    // Check if elements with layout shrink-wrap their children
                    if ( typeof div.style.zoom !== "undefined" ) {

                        // Reset CSS: box-sizing; display; margin; border
                        div.style.cssText =

                            // Support: Firefox<29, Android 2.3
                            // Vendor-prefix box-sizing
                            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                            "box-sizing:content-box;display:block;margin:0;border:0;" +
                            "padding:1px;width:1px;zoom:1";
                        div.appendChild( document.createElement( "div" ) ).style.width = "5px";
                        shrinkWrapBlocksVal = div.offsetWidth !== 3;
                    }

                    body.removeChild( container );

                    return shrinkWrapBlocksVal;
                };

            } )();
            var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

            var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


            var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

            var isHidden = function( elem, el ) {

                // isHidden might be called from jQuery#filter function;
                // in that case, element will be second argument
                elem = el || elem;
                return jQuery.css( elem, "display" ) === "none" ||
                    !jQuery.contains( elem.ownerDocument, elem );
            };



            function adjustCSS( elem, prop, valueParts, tween ) {
                var adjusted,
                    scale = 1,
                    maxIterations = 20,
                    currentValue = tween ?
                        function() { return tween.cur(); } :
                        function() { return jQuery.css( elem, prop, "" ); },
                    initial = currentValue(),
                    unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

                    // Starting value computation is required for potential unit mismatches
                    initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
                        rcssNum.exec( jQuery.css( elem, prop ) );

                if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

                    // Trust units reported by jQuery.css
                    unit = unit || initialInUnit[ 3 ];

                    // Make sure we update the tween properties later on
                    valueParts = valueParts || [];

                    // Iteratively approximate from a nonzero starting point
                    initialInUnit = +initial || 1;

                    do {

                        // If previous iteration zeroed out, double until we get *something*.
                        // Use string for doubling so we don't accidentally see scale as unchanged below
                        scale = scale || ".5";

                        // Adjust and apply
                        initialInUnit = initialInUnit / scale;
                        jQuery.style( elem, prop, initialInUnit + unit );

                        // Update scale, tolerating zero or NaN from tween.cur()
                        // Break the loop if scale is unchanged or perfect, or if we've just had enough.
                    } while (
                        scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
                        );
                }

                if ( valueParts ) {
                    initialInUnit = +initialInUnit || +initial || 0;

                    // Apply relative offset (+=/-=) if specified
                    adjusted = valueParts[ 1 ] ?
                        initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
                        +valueParts[ 2 ];
                    if ( tween ) {
                        tween.unit = unit;
                        tween.start = initialInUnit;
                        tween.end = adjusted;
                    }
                }
                return adjusted;
            }


            // Multifunctional method to get and set values of a collection
            // The value/s can optionally be executed if it's a function
            var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
                var i = 0,
                    length = elems.length,
                    bulk = key == null;

                // Sets many values
                if ( jQuery.type( key ) === "object" ) {
                    chainable = true;
                    for ( i in key ) {
                        access( elems, fn, i, key[ i ], true, emptyGet, raw );
                    }

                    // Sets one value
                } else if ( value !== undefined ) {
                    chainable = true;

                    if ( !jQuery.isFunction( value ) ) {
                        raw = true;
                    }

                    if ( bulk ) {

                        // Bulk operations run against the entire set
                        if ( raw ) {
                            fn.call( elems, value );
                            fn = null;

                            // ...except when executing function values
                        } else {
                            bulk = fn;
                            fn = function( elem, key, value ) {
                                return bulk.call( jQuery( elem ), value );
                            };
                        }
                    }

                    if ( fn ) {
                        for ( ; i < length; i++ ) {
                            fn(
                                elems[ i ],
                                key,
                                raw ? value : value.call( elems[ i ], i, fn( elems[ i ], key ) )
                            );
                        }
                    }
                }

                return chainable ?
                    elems :

                    // Gets
                    bulk ?
                        fn.call( elems ) :
                        length ? fn( elems[ 0 ], key ) : emptyGet;
            };
            var rcheckableType = ( /^(?:checkbox|radio)$/i );

            var rtagName = ( /<([\w:-]+)/ );

            var rscriptType = ( /^$|\/(?:java|ecma)script/i );

            var rleadingWhitespace = ( /^\s+/ );

            var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|" +
                "details|dialog|figcaption|figure|footer|header|hgroup|main|" +
                "mark|meter|nav|output|picture|progress|section|summary|template|time|video";



            function createSafeFragment( document ) {
                var list = nodeNames.split( "|" ),
                    safeFrag = document.createDocumentFragment();

                if ( safeFrag.createElement ) {
                    while ( list.length ) {
                        safeFrag.createElement(
                            list.pop()
                        );
                    }
                }
                return safeFrag;
            }


            ( function() {
                var div = document.createElement( "div" ),
                    fragment = document.createDocumentFragment(),
                    input = document.createElement( "input" );

                // Setup
                div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

                // IE strips leading whitespace when .innerHTML is used
                support.leadingWhitespace = div.firstChild.nodeType === 3;

                // Make sure that tbody elements aren't automatically inserted
                // IE will insert them into empty tables
                support.tbody = !div.getElementsByTagName( "tbody" ).length;

                // Make sure that link elements get serialized correctly by innerHTML
                // This requires a wrapper element in IE
                support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

                // Makes sure cloning an html5 element does not cause problems
                // Where outerHTML is undefined, this still works
                support.html5Clone =
                    document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

                // Check if a disconnected checkbox will retain its checked
                // value of true after appended to the DOM (IE6/7)
                input.type = "checkbox";
                input.checked = true;
                fragment.appendChild( input );
                support.appendChecked = input.checked;

                // Make sure textarea (and checkbox) defaultValue is properly cloned
                // Support: IE6-IE11+
                div.innerHTML = "<textarea>x</textarea>";
                support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

                // #11217 - WebKit loses check when the name is after the checked attribute
                fragment.appendChild( div );

                // Support: Windows Web Apps (WWA)
                // `name` and `type` must use .setAttribute for WWA (#14901)
                input = document.createElement( "input" );
                input.setAttribute( "type", "radio" );
                input.setAttribute( "checked", "checked" );
                input.setAttribute( "name", "t" );

                div.appendChild( input );

                // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
                // old WebKit doesn't clone checked state correctly in fragments
                support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

                // Support: IE<9
                // Cloned elements keep attachEvent handlers, we use addEventListener on IE9+
                support.noCloneEvent = !!div.addEventListener;

                // Support: IE<9
                // Since attributes and properties are the same in IE,
                // cleanData must set properties to undefined rather than use removeAttribute
                div[ jQuery.expando ] = 1;
                support.attributes = !div.getAttribute( jQuery.expando );
            } )();


            // We have to close these tags to support XHTML (#13200)
            var wrapMap = {
                option: [ 1, "<select multiple='multiple'>", "</select>" ],
                legend: [ 1, "<fieldset>", "</fieldset>" ],
                area: [ 1, "<map>", "</map>" ],

                // Support: IE8
                param: [ 1, "<object>", "</object>" ],
                thead: [ 1, "<table>", "</table>" ],
                tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
                td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

                // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
                // unless wrapped in a div with non-breaking characters in front of it.
                _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
            };

            // Support: IE8-IE9
            wrapMap.optgroup = wrapMap.option;

            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;


            function getAll( context, tag ) {
                var elems, elem,
                    i = 0,
                    found = typeof context.getElementsByTagName !== "undefined" ?
                        context.getElementsByTagName( tag || "*" ) :
                        typeof context.querySelectorAll !== "undefined" ?
                            context.querySelectorAll( tag || "*" ) :
                            undefined;

                if ( !found ) {
                    for ( found = [], elems = context.childNodes || context;
                          ( elem = elems[ i ] ) != null;
                          i++
                    ) {
                        if ( !tag || jQuery.nodeName( elem, tag ) ) {
                            found.push( elem );
                        } else {
                            jQuery.merge( found, getAll( elem, tag ) );
                        }
                    }
                }

                return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
                    jQuery.merge( [ context ], found ) :
                    found;
            }


            // Mark scripts as having already been evaluated
            function setGlobalEval( elems, refElements ) {
                var elem,
                    i = 0;
                for ( ; ( elem = elems[ i ] ) != null; i++ ) {
                    jQuery._data(
                        elem,
                        "globalEval",
                        !refElements || jQuery._data( refElements[ i ], "globalEval" )
                    );
                }
            }


            var rhtml = /<|&#?\w+;/,
                rtbody = /<tbody/i;

            function fixDefaultChecked( elem ) {
                if ( rcheckableType.test( elem.type ) ) {
                    elem.defaultChecked = elem.checked;
                }
            }

            function buildFragment( elems, context, scripts, selection, ignored ) {
                var j, elem, contains,
                    tmp, tag, tbody, wrap,
                    l = elems.length,

                    // Ensure a safe fragment
                    safe = createSafeFragment( context ),

                    nodes = [],
                    i = 0;

                for ( ; i < l; i++ ) {
                    elem = elems[ i ];

                    if ( elem || elem === 0 ) {

                        // Add nodes directly
                        if ( jQuery.type( elem ) === "object" ) {
                            jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                            // Convert non-html into a text node
                        } else if ( !rhtml.test( elem ) ) {
                            nodes.push( context.createTextNode( elem ) );

                            // Convert html into DOM nodes
                        } else {
                            tmp = tmp || safe.appendChild( context.createElement( "div" ) );

                            // Deserialize a standard representation
                            tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
                            wrap = wrapMap[ tag ] || wrapMap._default;

                            tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

                            // Descend through wrappers to the right content
                            j = wrap[ 0 ];
                            while ( j-- ) {
                                tmp = tmp.lastChild;
                            }

                            // Manually add leading whitespace removed by IE
                            if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                                nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[ 0 ] ) );
                            }

                            // Remove IE's autoinserted <tbody> from table fragments
                            if ( !support.tbody ) {

                                // String was a <table>, *may* have spurious <tbody>
                                elem = tag === "table" && !rtbody.test( elem ) ?
                                    tmp.firstChild :

                                    // String was a bare <thead> or <tfoot>
                                    wrap[ 1 ] === "<table>" && !rtbody.test( elem ) ?
                                        tmp :
                                        0;

                                j = elem && elem.childNodes.length;
                                while ( j-- ) {
                                    if ( jQuery.nodeName( ( tbody = elem.childNodes[ j ] ), "tbody" ) &&
                                        !tbody.childNodes.length ) {

                                        elem.removeChild( tbody );
                                    }
                                }
                            }

                            jQuery.merge( nodes, tmp.childNodes );

                            // Fix #12392 for WebKit and IE > 9
                            tmp.textContent = "";

                            // Fix #12392 for oldIE
                            while ( tmp.firstChild ) {
                                tmp.removeChild( tmp.firstChild );
                            }

                            // Remember the top-level container for proper cleanup
                            tmp = safe.lastChild;
                        }
                    }
                }

                // Fix #11356: Clear elements from fragment
                if ( tmp ) {
                    safe.removeChild( tmp );
                }

                // Reset defaultChecked for any radios and checkboxes
                // about to be appended to the DOM in IE 6/7 (#8060)
                if ( !support.appendChecked ) {
                    jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
                }

                i = 0;
                while ( ( elem = nodes[ i++ ] ) ) {

                    // Skip elements already in the context collection (trac-4087)
                    if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
                        if ( ignored ) {
                            ignored.push( elem );
                        }

                        continue;
                    }

                    contains = jQuery.contains( elem.ownerDocument, elem );

                    // Append to fragment
                    tmp = getAll( safe.appendChild( elem ), "script" );

                    // Preserve script evaluation history
                    if ( contains ) {
                        setGlobalEval( tmp );
                    }

                    // Capture executables
                    if ( scripts ) {
                        j = 0;
                        while ( ( elem = tmp[ j++ ] ) ) {
                            if ( rscriptType.test( elem.type || "" ) ) {
                                scripts.push( elem );
                            }
                        }
                    }
                }

                tmp = null;

                return safe;
            }


            ( function() {
                var i, eventName,
                    div = document.createElement( "div" );

                // Support: IE<9 (lack submit/change bubble), Firefox (lack focus(in | out) events)
                for ( i in { submit: true, change: true, focusin: true } ) {
                    eventName = "on" + i;

                    if ( !( support[ i ] = eventName in window ) ) {

                        // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
                        div.setAttribute( eventName, "t" );
                        support[ i ] = div.attributes[ eventName ].expando === false;
                    }
                }

                // Null elements to avoid leaks in IE.
                div = null;
            } )();


            var rformElems = /^(?:input|select|textarea)$/i,
                rkeyEvent = /^key/,
                rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
                rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

            function returnTrue() {
                return true;
            }

            function returnFalse() {
                return false;
            }

            // Support: IE9
            // See #13393 for more info
            function safeActiveElement() {
                try {
                    return document.activeElement;
                } catch ( err ) { }
            }

            function on( elem, types, selector, data, fn, one ) {
                var origFn, type;

                // Types can be a map of types/handlers
                if ( typeof types === "object" ) {

                    // ( types-Object, selector, data )
                    if ( typeof selector !== "string" ) {

                        // ( types-Object, data )
                        data = data || selector;
                        selector = undefined;
                    }
                    for ( type in types ) {
                        on( elem, type, selector, data, types[ type ], one );
                    }
                    return elem;
                }

                if ( data == null && fn == null ) {

                    // ( types, fn )
                    fn = selector;
                    data = selector = undefined;
                } else if ( fn == null ) {
                    if ( typeof selector === "string" ) {

                        // ( types, selector, fn )
                        fn = data;
                        data = undefined;
                    } else {

                        // ( types, data, fn )
                        fn = data;
                        data = selector;
                        selector = undefined;
                    }
                }
                if ( fn === false ) {
                    fn = returnFalse;
                } else if ( !fn ) {
                    return elem;
                }

                if ( one === 1 ) {
                    origFn = fn;
                    fn = function( event ) {

                        // Can use an empty set, since event contains the info
                        jQuery().off( event );
                        return origFn.apply( this, arguments );
                    };

                    // Use same guid so caller can remove using origFn
                    fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
                }
                return elem.each( function() {
                    jQuery.event.add( this, types, fn, data, selector );
                } );
            }

            /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
            jQuery.event = {

                global: {},

                add: function( elem, types, handler, data, selector ) {
                    var tmp, events, t, handleObjIn,
                        special, eventHandle, handleObj,
                        handlers, type, namespaces, origType,
                        elemData = jQuery._data( elem );

                    // Don't attach events to noData or text/comment nodes (but allow plain objects)
                    if ( !elemData ) {
                        return;
                    }

                    // Caller can pass in an object of custom data in lieu of the handler
                    if ( handler.handler ) {
                        handleObjIn = handler;
                        handler = handleObjIn.handler;
                        selector = handleObjIn.selector;
                    }

                    // Make sure that the handler has a unique ID, used to find/remove it later
                    if ( !handler.guid ) {
                        handler.guid = jQuery.guid++;
                    }

                    // Init the element's event structure and main handler, if this is the first
                    if ( !( events = elemData.events ) ) {
                        events = elemData.events = {};
                    }
                    if ( !( eventHandle = elemData.handle ) ) {
                        eventHandle = elemData.handle = function( e ) {

                            // Discard the second event of a jQuery.event.trigger() and
                            // when an event is called after a page has unloaded
                            return typeof jQuery !== "undefined" &&
                            ( !e || jQuery.event.triggered !== e.type ) ?
                                jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                                undefined;
                        };

                        // Add elem as a property of the handle fn to prevent a memory leak
                        // with IE non-native events
                        eventHandle.elem = elem;
                    }

                    // Handle multiple events separated by a space
                    types = ( types || "" ).match( rnotwhite ) || [ "" ];
                    t = types.length;
                    while ( t-- ) {
                        tmp = rtypenamespace.exec( types[ t ] ) || [];
                        type = origType = tmp[ 1 ];
                        namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

                        // There *must* be a type, no attaching namespace-only handlers
                        if ( !type ) {
                            continue;
                        }

                        // If event changes its type, use the special event handlers for the changed type
                        special = jQuery.event.special[ type ] || {};

                        // If selector defined, determine special event api type, otherwise given type
                        type = ( selector ? special.delegateType : special.bindType ) || type;

                        // Update special based on newly reset type
                        special = jQuery.event.special[ type ] || {};

                        // handleObj is passed to all event handlers
                        handleObj = jQuery.extend( {
                            type: type,
                            origType: origType,
                            data: data,
                            handler: handler,
                            guid: handler.guid,
                            selector: selector,
                            needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                            namespace: namespaces.join( "." )
                        }, handleObjIn );

                        // Init the event handler queue if we're the first
                        if ( !( handlers = events[ type ] ) ) {
                            handlers = events[ type ] = [];
                            handlers.delegateCount = 0;

                            // Only use addEventListener/attachEvent if the special events handler returns false
                            if ( !special.setup ||
                                special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

                                // Bind the global event handler to the element
                                if ( elem.addEventListener ) {
                                    elem.addEventListener( type, eventHandle, false );

                                } else if ( elem.attachEvent ) {
                                    elem.attachEvent( "on" + type, eventHandle );
                                }
                            }
                        }

                        if ( special.add ) {
                            special.add.call( elem, handleObj );

                            if ( !handleObj.handler.guid ) {
                                handleObj.handler.guid = handler.guid;
                            }
                        }

                        // Add to the element's handler list, delegates in front
                        if ( selector ) {
                            handlers.splice( handlers.delegateCount++, 0, handleObj );
                        } else {
                            handlers.push( handleObj );
                        }

                        // Keep track of which events have ever been used, for event optimization
                        jQuery.event.global[ type ] = true;
                    }

                    // Nullify elem to prevent memory leaks in IE
                    elem = null;
                },

                // Detach an event or set of events from an element
                remove: function( elem, types, handler, selector, mappedTypes ) {
                    var j, handleObj, tmp,
                        origCount, t, events,
                        special, handlers, type,
                        namespaces, origType,
                        elemData = jQuery.hasData( elem ) && jQuery._data( elem );

                    if ( !elemData || !( events = elemData.events ) ) {
                        return;
                    }

                    // Once for each type.namespace in types; type may be omitted
                    types = ( types || "" ).match( rnotwhite ) || [ "" ];
                    t = types.length;
                    while ( t-- ) {
                        tmp = rtypenamespace.exec( types[ t ] ) || [];
                        type = origType = tmp[ 1 ];
                        namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

                        // Unbind all events (on this namespace, if provided) for the element
                        if ( !type ) {
                            for ( type in events ) {
                                jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                            }
                            continue;
                        }

                        special = jQuery.event.special[ type ] || {};
                        type = ( selector ? special.delegateType : special.bindType ) || type;
                        handlers = events[ type ] || [];
                        tmp = tmp[ 2 ] &&
                            new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

                        // Remove matching events
                        origCount = j = handlers.length;
                        while ( j-- ) {
                            handleObj = handlers[ j ];

                            if ( ( mappedTypes || origType === handleObj.origType ) &&
                                ( !handler || handler.guid === handleObj.guid ) &&
                                ( !tmp || tmp.test( handleObj.namespace ) ) &&
                                ( !selector || selector === handleObj.selector ||
                                    selector === "**" && handleObj.selector ) ) {
                                handlers.splice( j, 1 );

                                if ( handleObj.selector ) {
                                    handlers.delegateCount--;
                                }
                                if ( special.remove ) {
                                    special.remove.call( elem, handleObj );
                                }
                            }
                        }

                        // Remove generic event handler if we removed something and no more handlers exist
                        // (avoids potential for endless recursion during removal of special event handlers)
                        if ( origCount && !handlers.length ) {
                            if ( !special.teardown ||
                                special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

                                jQuery.removeEvent( elem, type, elemData.handle );
                            }

                            delete events[ type ];
                        }
                    }

                    // Remove the expando if it's no longer used
                    if ( jQuery.isEmptyObject( events ) ) {
                        delete elemData.handle;

                        // removeData also checks for emptiness and clears the expando if empty
                        // so use it instead of delete
                        jQuery._removeData( elem, "events" );
                    }
                },

                trigger: function( event, data, elem, onlyHandlers ) {
                    var handle, ontype, cur,
                        bubbleType, special, tmp, i,
                        eventPath = [ elem || document ],
                        type = hasOwn.call( event, "type" ) ? event.type : event,
                        namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

                    cur = tmp = elem = elem || document;

                    // Don't do events on text and comment nodes
                    if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                        return;
                    }

                    // focus/blur morphs to focusin/out; ensure we're not firing them right now
                    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                        return;
                    }

                    if ( type.indexOf( "." ) > -1 ) {

                        // Namespaced trigger; create a regexp to match event type in handle()
                        namespaces = type.split( "." );
                        type = namespaces.shift();
                        namespaces.sort();
                    }
                    ontype = type.indexOf( ":" ) < 0 && "on" + type;

                    // Caller can pass in a jQuery.Event object, Object, or just an event type string
                    event = event[ jQuery.expando ] ?
                        event :
                        new jQuery.Event( type, typeof event === "object" && event );

                    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                    event.isTrigger = onlyHandlers ? 2 : 3;
                    event.namespace = namespaces.join( "." );
                    event.rnamespace = event.namespace ?
                        new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
                        null;

                    // Clean up the event in case it is being reused
                    event.result = undefined;
                    if ( !event.target ) {
                        event.target = elem;
                    }

                    // Clone any incoming data and prepend the event, creating the handler arg list
                    data = data == null ?
                        [ event ] :
                        jQuery.makeArray( data, [ event ] );

                    // Allow special events to draw outside the lines
                    special = jQuery.event.special[ type ] || {};
                    if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                        return;
                    }

                    // Determine event propagation path in advance, per W3C events spec (#9951)
                    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                    if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

                        bubbleType = special.delegateType || type;
                        if ( !rfocusMorph.test( bubbleType + type ) ) {
                            cur = cur.parentNode;
                        }
                        for ( ; cur; cur = cur.parentNode ) {
                            eventPath.push( cur );
                            tmp = cur;
                        }

                        // Only add window if we got to document (e.g., not plain obj or detached DOM)
                        if ( tmp === ( elem.ownerDocument || document ) ) {
                            eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                        }
                    }

                    // Fire handlers on the event path
                    i = 0;
                    while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

                        event.type = i > 1 ?
                            bubbleType :
                            special.bindType || type;

                        // jQuery handler
                        handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] &&
                            jQuery._data( cur, "handle" );

                        if ( handle ) {
                            handle.apply( cur, data );
                        }

                        // Native handler
                        handle = ontype && cur[ ontype ];
                        if ( handle && handle.apply && acceptData( cur ) ) {
                            event.result = handle.apply( cur, data );
                            if ( event.result === false ) {
                                event.preventDefault();
                            }
                        }
                    }
                    event.type = type;

                    // If nobody prevented the default action, do it now
                    if ( !onlyHandlers && !event.isDefaultPrevented() ) {

                        if (
                            ( !special._default ||
                                special._default.apply( eventPath.pop(), data ) === false
                            ) && acceptData( elem )
                        ) {

                            // Call a native DOM method on the target with the same name name as the event.
                            // Can't use an .isFunction() check here because IE6/7 fails that test.
                            // Don't do default actions on window, that's where global variables be (#6170)
                            if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

                                // Don't re-trigger an onFOO event when we call its FOO() method
                                tmp = elem[ ontype ];

                                if ( tmp ) {
                                    elem[ ontype ] = null;
                                }

                                // Prevent re-triggering of the same event, since we already bubbled it above
                                jQuery.event.triggered = type;
                                try {
                                    elem[ type ]();
                                } catch ( e ) {

                                    // IE<9 dies on focus/blur to hidden element (#1486,#12518)
                                    // only reproducible on winXP IE8 native, not IE9 in IE8 mode
                                }
                                jQuery.event.triggered = undefined;

                                if ( tmp ) {
                                    elem[ ontype ] = tmp;
                                }
                            }
                        }
                    }

                    return event.result;
                },

                dispatch: function( event ) {

                    // Make a writable jQuery.Event from the native event object
                    event = jQuery.event.fix( event );

                    var i, j, ret, matched, handleObj,
                        handlerQueue = [],
                        args = slice.call( arguments ),
                        handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
                        special = jQuery.event.special[ event.type ] || {};

                    // Use the fix-ed jQuery.Event rather than the (read-only) native event
                    args[ 0 ] = event;
                    event.delegateTarget = this;

                    // Call the preDispatch hook for the mapped type, and let it bail if desired
                    if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                        return;
                    }

                    // Determine handlers
                    handlerQueue = jQuery.event.handlers.call( this, event, handlers );

                    // Run delegates first; they may want to stop propagation beneath us
                    i = 0;
                    while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
                        event.currentTarget = matched.elem;

                        j = 0;
                        while ( ( handleObj = matched.handlers[ j++ ] ) &&
                        !event.isImmediatePropagationStopped() ) {

                            // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                            // a subset or equal to those in the bound event (both can have no namespace).
                            if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

                                event.handleObj = handleObj;
                                event.data = handleObj.data;

                                ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
                                    handleObj.handler ).apply( matched.elem, args );

                                if ( ret !== undefined ) {
                                    if ( ( event.result = ret ) === false ) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }
                    }

                    // Call the postDispatch hook for the mapped type
                    if ( special.postDispatch ) {
                        special.postDispatch.call( this, event );
                    }

                    return event.result;
                },

                handlers: function( event, handlers ) {
                    var i, matches, sel, handleObj,
                        handlerQueue = [],
                        delegateCount = handlers.delegateCount,
                        cur = event.target;

                    // Support (at least): Chrome, IE9
                    // Find delegate handlers
                    // Black-hole SVG <use> instance trees (#13180)
                    //
                    // Support: Firefox<=42+
                    // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
                    if ( delegateCount && cur.nodeType &&
                        ( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

                        /* jshint eqeqeq: false */
                        for ( ; cur != this; cur = cur.parentNode || this ) {
                            /* jshint eqeqeq: true */

                            // Don't check non-elements (#13208)
                            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                            if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
                                matches = [];
                                for ( i = 0; i < delegateCount; i++ ) {
                                    handleObj = handlers[ i ];

                                    // Don't conflict with Object.prototype properties (#13203)
                                    sel = handleObj.selector + " ";

                                    if ( matches[ sel ] === undefined ) {
                                        matches[ sel ] = handleObj.needsContext ?
                                            jQuery( sel, this ).index( cur ) > -1 :
                                            jQuery.find( sel, this, null, [ cur ] ).length;
                                    }
                                    if ( matches[ sel ] ) {
                                        matches.push( handleObj );
                                    }
                                }
                                if ( matches.length ) {
                                    handlerQueue.push( { elem: cur, handlers: matches } );
                                }
                            }
                        }
                    }

                    // Add the remaining (directly-bound) handlers
                    if ( delegateCount < handlers.length ) {
                        handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
                    }

                    return handlerQueue;
                },

                fix: function( event ) {
                    if ( event[ jQuery.expando ] ) {
                        return event;
                    }

                    // Create a writable copy of the event object and normalize some properties
                    var i, prop, copy,
                        type = event.type,
                        originalEvent = event,
                        fixHook = this.fixHooks[ type ];

                    if ( !fixHook ) {
                        this.fixHooks[ type ] = fixHook =
                            rmouseEvent.test( type ) ? this.mouseHooks :
                                rkeyEvent.test( type ) ? this.keyHooks :
                                    {};
                    }
                    copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

                    event = new jQuery.Event( originalEvent );

                    i = copy.length;
                    while ( i-- ) {
                        prop = copy[ i ];
                        event[ prop ] = originalEvent[ prop ];
                    }

                    // Support: IE<9
                    // Fix target property (#1925)
                    if ( !event.target ) {
                        event.target = originalEvent.srcElement || document;
                    }

                    // Support: Safari 6-8+
                    // Target should not be a text node (#504, #13143)
                    if ( event.target.nodeType === 3 ) {
                        event.target = event.target.parentNode;
                    }

                    // Support: IE<9
                    // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
                    event.metaKey = !!event.metaKey;

                    return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
                },

                // Includes some event props shared by KeyEvent and MouseEvent
                props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
                    "metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

                fixHooks: {},

                keyHooks: {
                    props: "char charCode key keyCode".split( " " ),
                    filter: function( event, original ) {

                        // Add which for key events
                        if ( event.which == null ) {
                            event.which = original.charCode != null ? original.charCode : original.keyCode;
                        }

                        return event;
                    }
                },

                mouseHooks: {
                    props: ( "button buttons clientX clientY fromElement offsetX offsetY " +
                        "pageX pageY screenX screenY toElement" ).split( " " ),
                    filter: function( event, original ) {
                        var body, eventDoc, doc,
                            button = original.button,
                            fromElement = original.fromElement;

                        // Calculate pageX/Y if missing and clientX/Y available
                        if ( event.pageX == null && original.clientX != null ) {
                            eventDoc = event.target.ownerDocument || document;
                            doc = eventDoc.documentElement;
                            body = eventDoc.body;

                            event.pageX = original.clientX +
                                ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
                                ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                            event.pageY = original.clientY +
                                ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
                                ( doc && doc.clientTop  || body && body.clientTop  || 0 );
                        }

                        // Add relatedTarget, if necessary
                        if ( !event.relatedTarget && fromElement ) {
                            event.relatedTarget = fromElement === event.target ?
                                original.toElement :
                                fromElement;
                        }

                        // Add which for click: 1 === left; 2 === middle; 3 === right
                        // Note: button is not normalized, so don't use it
                        if ( !event.which && button !== undefined ) {
                            event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                        }

                        return event;
                    }
                },

                special: {
                    load: {

                        // Prevent triggered image.load events from bubbling to window.load
                        noBubble: true
                    },
                    focus: {

                        // Fire native event if possible so blur/focus sequence is correct
                        trigger: function() {
                            if ( this !== safeActiveElement() && this.focus ) {
                                try {
                                    this.focus();
                                    return false;
                                } catch ( e ) {

                                    // Support: IE<9
                                    // If we error on focus to hidden element (#1486, #12518),
                                    // let .trigger() run the handlers
                                }
                            }
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            if ( this === safeActiveElement() && this.blur ) {
                                this.blur();
                                return false;
                            }
                        },
                        delegateType: "focusout"
                    },
                    click: {

                        // For checkbox, fire native event so checked state will be right
                        trigger: function() {
                            if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
                                this.click();
                                return false;
                            }
                        },

                        // For cross-browser consistency, don't fire native .click() on links
                        _default: function( event ) {
                            return jQuery.nodeName( event.target, "a" );
                        }
                    },

                    beforeunload: {
                        postDispatch: function( event ) {

                            // Support: Firefox 20+
                            // Firefox doesn't alert if the returnValue field is not set.
                            if ( event.result !== undefined && event.originalEvent ) {
                                event.originalEvent.returnValue = event.result;
                            }
                        }
                    }
                },

                // Piggyback on a donor event to simulate a different one
                simulate: function( type, elem, event ) {
                    var e = jQuery.extend(
                        new jQuery.Event(),
                        event,
                        {
                            type: type,
                            isSimulated: true

                            // Previously, `originalEvent: {}` was set here, so stopPropagation call
                            // would not be triggered on donor event, since in our own
                            // jQuery.event.stopPropagation function we had a check for existence of
                            // originalEvent.stopPropagation method, so, consequently it would be a noop.
                            //
                            // Guard for simulated events was moved to jQuery.event.stopPropagation function
                            // since `originalEvent` should point to the original event for the
                            // constancy with other events and for more focused logic
                        }
                    );

                    jQuery.event.trigger( e, null, elem );

                    if ( e.isDefaultPrevented() ) {
                        event.preventDefault();
                    }
                }
            };

            jQuery.removeEvent = document.removeEventListener ?
                function( elem, type, handle ) {

                    // This "if" is needed for plain objects
                    if ( elem.removeEventListener ) {
                        elem.removeEventListener( type, handle );
                    }
                } :
                function( elem, type, handle ) {
                    var name = "on" + type;

                    if ( elem.detachEvent ) {

                        // #8545, #7054, preventing memory leaks for custom events in IE6-8
                        // detachEvent needed property on element, by name of that event,
                        // to properly expose it to GC
                        if ( typeof elem[ name ] === "undefined" ) {
                            elem[ name ] = null;
                        }

                        elem.detachEvent( name, handle );
                    }
                };

            jQuery.Event = function( src, props ) {

                // Allow instantiation without the 'new' keyword
                if ( !( this instanceof jQuery.Event ) ) {
                    return new jQuery.Event( src, props );
                }

                // Event object
                if ( src && src.type ) {
                    this.originalEvent = src;
                    this.type = src.type;

                    // Events bubbling up the document may have been marked as prevented
                    // by a handler lower down the tree; reflect the correct value.
                    this.isDefaultPrevented = src.defaultPrevented ||
                    src.defaultPrevented === undefined &&

                    // Support: IE < 9, Android < 4.0
                    src.returnValue === false ?
                        returnTrue :
                        returnFalse;

                    // Event type
                } else {
                    this.type = src;
                }

                // Put explicitly provided properties onto the event object
                if ( props ) {
                    jQuery.extend( this, props );
                }

                // Create a timestamp if incoming event doesn't have one
                this.timeStamp = src && src.timeStamp || jQuery.now();

                // Mark it as fixed
                this[ jQuery.expando ] = true;
            };

            // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
            // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
            jQuery.Event.prototype = {
                constructor: jQuery.Event,
                isDefaultPrevented: returnFalse,
                isPropagationStopped: returnFalse,
                isImmediatePropagationStopped: returnFalse,

                preventDefault: function() {
                    var e = this.originalEvent;

                    this.isDefaultPrevented = returnTrue;
                    if ( !e ) {
                        return;
                    }

                    // If preventDefault exists, run it on the original event
                    if ( e.preventDefault ) {
                        e.preventDefault();

                        // Support: IE
                        // Otherwise set the returnValue property of the original event to false
                    } else {
                        e.returnValue = false;
                    }
                },
                stopPropagation: function() {
                    var e = this.originalEvent;

                    this.isPropagationStopped = returnTrue;

                    if ( !e || this.isSimulated ) {
                        return;
                    }

                    // If stopPropagation exists, run it on the original event
                    if ( e.stopPropagation ) {
                        e.stopPropagation();
                    }

                    // Support: IE
                    // Set the cancelBubble property of the original event to true
                    e.cancelBubble = true;
                },
                stopImmediatePropagation: function() {
                    var e = this.originalEvent;

                    this.isImmediatePropagationStopped = returnTrue;

                    if ( e && e.stopImmediatePropagation ) {
                        e.stopImmediatePropagation();
                    }

                    this.stopPropagation();
                }
            };

            // Create mouseenter/leave events using mouseover/out and event-time checks
            // so that event delegation works in jQuery.
            // Do the same for pointerenter/pointerleave and pointerover/pointerout
            //
            // Support: Safari 7 only
            // Safari sends mouseenter too often; see:
            // https://code.google.com/p/chromium/issues/detail?id=470258
            // for the description of the bug (it existed in older Chrome versions as well).
            jQuery.each( {
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function( orig, fix ) {
                jQuery.event.special[ orig ] = {
                    delegateType: fix,
                    bindType: fix,

                    handle: function( event ) {
                        var ret,
                            target = this,
                            related = event.relatedTarget,
                            handleObj = event.handleObj;

                        // For mouseenter/leave call the handler if related is outside the target.
                        // NB: No relatedTarget if the mouse left/entered the browser window
                        if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
                            event.type = handleObj.origType;
                            ret = handleObj.handler.apply( this, arguments );
                            event.type = fix;
                        }
                        return ret;
                    }
                };
            } );

            // IE submit delegation
            if ( !support.submit ) {

                jQuery.event.special.submit = {
                    setup: function() {

                        // Only need this for delegated form submit events
                        if ( jQuery.nodeName( this, "form" ) ) {
                            return false;
                        }

                        // Lazy-add a submit handler when a descendant form may potentially be submitted
                        jQuery.event.add( this, "click._submit keypress._submit", function( e ) {

                            // Node name check avoids a VML-related crash in IE (#9807)
                            var elem = e.target,
                                form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ?

                                    // Support: IE <=8
                                    // We use jQuery.prop instead of elem.form
                                    // to allow fixing the IE8 delegated submit issue (gh-2332)
                                    // by 3rd party polyfills/workarounds.
                                    jQuery.prop( elem, "form" ) :
                                    undefined;

                            if ( form && !jQuery._data( form, "submit" ) ) {
                                jQuery.event.add( form, "submit._submit", function( event ) {
                                    event._submitBubble = true;
                                } );
                                jQuery._data( form, "submit", true );
                            }
                        } );

                        // return undefined since we don't need an event listener
                    },

                    postDispatch: function( event ) {

                        // If form was submitted by the user, bubble the event up the tree
                        if ( event._submitBubble ) {
                            delete event._submitBubble;
                            if ( this.parentNode && !event.isTrigger ) {
                                jQuery.event.simulate( "submit", this.parentNode, event );
                            }
                        }
                    },

                    teardown: function() {

                        // Only need this for delegated form submit events
                        if ( jQuery.nodeName( this, "form" ) ) {
                            return false;
                        }

                        // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                        jQuery.event.remove( this, "._submit" );
                    }
                };
            }

            // IE change delegation and checkbox/radio fix
            if ( !support.change ) {

                jQuery.event.special.change = {

                    setup: function() {

                        if ( rformElems.test( this.nodeName ) ) {

                            // IE doesn't fire change on a check/radio until blur; trigger it on click
                            // after a propertychange. Eat the blur-change in special.change.handle.
                            // This still fires onchange a second time for check/radio after blur.
                            if ( this.type === "checkbox" || this.type === "radio" ) {
                                jQuery.event.add( this, "propertychange._change", function( event ) {
                                    if ( event.originalEvent.propertyName === "checked" ) {
                                        this._justChanged = true;
                                    }
                                } );
                                jQuery.event.add( this, "click._change", function( event ) {
                                    if ( this._justChanged && !event.isTrigger ) {
                                        this._justChanged = false;
                                    }

                                    // Allow triggered, simulated change events (#11500)
                                    jQuery.event.simulate( "change", this, event );
                                } );
                            }
                            return false;
                        }

                        // Delegated event; lazy-add a change handler on descendant inputs
                        jQuery.event.add( this, "beforeactivate._change", function( e ) {
                            var elem = e.target;

                            if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "change" ) ) {
                                jQuery.event.add( elem, "change._change", function( event ) {
                                    if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                                        jQuery.event.simulate( "change", this.parentNode, event );
                                    }
                                } );
                                jQuery._data( elem, "change", true );
                            }
                        } );
                    },

                    handle: function( event ) {
                        var elem = event.target;

                        // Swallow native change events from checkbox/radio, we already triggered them above
                        if ( this !== elem || event.isSimulated || event.isTrigger ||
                            ( elem.type !== "radio" && elem.type !== "checkbox" ) ) {

                            return event.handleObj.handler.apply( this, arguments );
                        }
                    },

                    teardown: function() {
                        jQuery.event.remove( this, "._change" );

                        return !rformElems.test( this.nodeName );
                    }
                };
            }

            // Support: Firefox
            // Firefox doesn't have focus(in | out) events
            // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
            //
            // Support: Chrome, Safari
            // focus(in | out) events fire after focus & blur events,
            // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
            // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
            if ( !support.focusin ) {
                jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

                    // Attach a single capturing handler on the document while someone wants focusin/focusout
                    var handler = function( event ) {
                        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
                    };

                    jQuery.event.special[ fix ] = {
                        setup: function() {
                            var doc = this.ownerDocument || this,
                                attaches = jQuery._data( doc, fix );

                            if ( !attaches ) {
                                doc.addEventListener( orig, handler, true );
                            }
                            jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
                        },
                        teardown: function() {
                            var doc = this.ownerDocument || this,
                                attaches = jQuery._data( doc, fix ) - 1;

                            if ( !attaches ) {
                                doc.removeEventListener( orig, handler, true );
                                jQuery._removeData( doc, fix );
                            } else {
                                jQuery._data( doc, fix, attaches );
                            }
                        }
                    };
                } );
            }

            jQuery.fn.extend( {

                on: function( types, selector, data, fn ) {
                    return on( this, types, selector, data, fn );
                },
                one: function( types, selector, data, fn ) {
                    return on( this, types, selector, data, fn, 1 );
                },
                off: function( types, selector, fn ) {
                    var handleObj, type;
                    if ( types && types.preventDefault && types.handleObj ) {

                        // ( event )  dispatched jQuery.Event
                        handleObj = types.handleObj;
                        jQuery( types.delegateTarget ).off(
                            handleObj.namespace ?
                                handleObj.origType + "." + handleObj.namespace :
                                handleObj.origType,
                            handleObj.selector,
                            handleObj.handler
                        );
                        return this;
                    }
                    if ( typeof types === "object" ) {

                        // ( types-object [, selector] )
                        for ( type in types ) {
                            this.off( type, selector, types[ type ] );
                        }
                        return this;
                    }
                    if ( selector === false || typeof selector === "function" ) {

                        // ( types [, fn] )
                        fn = selector;
                        selector = undefined;
                    }
                    if ( fn === false ) {
                        fn = returnFalse;
                    }
                    return this.each( function() {
                        jQuery.event.remove( this, types, fn, selector );
                    } );
                },

                trigger: function( type, data ) {
                    return this.each( function() {
                        jQuery.event.trigger( type, data, this );
                    } );
                },
                triggerHandler: function( type, data ) {
                    var elem = this[ 0 ];
                    if ( elem ) {
                        return jQuery.event.trigger( type, data, elem, true );
                    }
                }
            } );


            var rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
                rnoshimcache = new RegExp( "<(?:" + nodeNames + ")[\\s/>]", "i" ),
                rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

                // Support: IE 10-11, Edge 10240+
                // In IE/Edge using regex groups here causes severe slowdowns.
                // See https://connect.microsoft.com/IE/feedback/details/1736512/
                rnoInnerhtml = /<script|<style|<link/i,

                // checked="checked" or checked
                rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                rscriptTypeMasked = /^true\/(.*)/,
                rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
                safeFragment = createSafeFragment( document ),
                fragmentDiv = safeFragment.appendChild( document.createElement( "div" ) );

            // Support: IE<8
            // Manipulating tables requires a tbody
            function manipulationTarget( elem, content ) {
                return jQuery.nodeName( elem, "table" ) &&
                jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

                    elem.getElementsByTagName( "tbody" )[ 0 ] ||
                    elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
                    elem;
            }

            // Replace/restore the type attribute of script elements for safe DOM manipulation
            function disableScript( elem ) {
                elem.type = ( jQuery.find.attr( elem, "type" ) !== null ) + "/" + elem.type;
                return elem;
            }
            function restoreScript( elem ) {
                var match = rscriptTypeMasked.exec( elem.type );
                if ( match ) {
                    elem.type = match[ 1 ];
                } else {
                    elem.removeAttribute( "type" );
                }
                return elem;
            }

            function cloneCopyEvent( src, dest ) {
                if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
                    return;
                }

                var type, i, l,
                    oldData = jQuery._data( src ),
                    curData = jQuery._data( dest, oldData ),
                    events = oldData.events;

                if ( events ) {
                    delete curData.handle;
                    curData.events = {};

                    for ( type in events ) {
                        for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                            jQuery.event.add( dest, type, events[ type ][ i ] );
                        }
                    }
                }

                // make the cloned public data object a copy from the original
                if ( curData.data ) {
                    curData.data = jQuery.extend( {}, curData.data );
                }
            }

            function fixCloneNodeIssues( src, dest ) {
                var nodeName, e, data;

                // We do not need to do anything for non-Elements
                if ( dest.nodeType !== 1 ) {
                    return;
                }

                nodeName = dest.nodeName.toLowerCase();

                // IE6-8 copies events bound via attachEvent when using cloneNode.
                if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
                    data = jQuery._data( dest );

                    for ( e in data.events ) {
                        jQuery.removeEvent( dest, e, data.handle );
                    }

                    // Event data gets referenced instead of copied if the expando gets copied too
                    dest.removeAttribute( jQuery.expando );
                }

                // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
                if ( nodeName === "script" && dest.text !== src.text ) {
                    disableScript( dest ).text = src.text;
                    restoreScript( dest );

                    // IE6-10 improperly clones children of object elements using classid.
                    // IE10 throws NoModificationAllowedError if parent is null, #12132.
                } else if ( nodeName === "object" ) {
                    if ( dest.parentNode ) {
                        dest.outerHTML = src.outerHTML;
                    }

                    // This path appears unavoidable for IE9. When cloning an object
                    // element in IE9, the outerHTML strategy above is not sufficient.
                    // If the src has innerHTML and the destination does not,
                    // copy the src.innerHTML into the dest.innerHTML. #10324
                    if ( support.html5Clone && ( src.innerHTML && !jQuery.trim( dest.innerHTML ) ) ) {
                        dest.innerHTML = src.innerHTML;
                    }

                } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {

                    // IE6-8 fails to persist the checked state of a cloned checkbox
                    // or radio button. Worse, IE6-7 fail to give the cloned element
                    // a checked appearance if the defaultChecked value isn't also set

                    dest.defaultChecked = dest.checked = src.checked;

                    // IE6-7 get confused and end up setting the value of a cloned
                    // checkbox/radio button to an empty string instead of "on"
                    if ( dest.value !== src.value ) {
                        dest.value = src.value;
                    }

                    // IE6-8 fails to return the selected option to the default selected
                    // state when cloning options
                } else if ( nodeName === "option" ) {
                    dest.defaultSelected = dest.selected = src.defaultSelected;

                    // IE6-8 fails to set the defaultValue to the correct value when
                    // cloning other types of input fields
                } else if ( nodeName === "input" || nodeName === "textarea" ) {
                    dest.defaultValue = src.defaultValue;
                }
            }

            function domManip( collection, args, callback, ignored ) {

                // Flatten any nested arrays
                args = concat.apply( [], args );

                var first, node, hasScripts,
                    scripts, doc, fragment,
                    i = 0,
                    l = collection.length,
                    iNoClone = l - 1,
                    value = args[ 0 ],
                    isFunction = jQuery.isFunction( value );

                // We can't cloneNode fragments that contain checked, in WebKit
                if ( isFunction ||
                    ( l > 1 && typeof value === "string" &&
                        !support.checkClone && rchecked.test( value ) ) ) {
                    return collection.each( function( index ) {
                        var self = collection.eq( index );
                        if ( isFunction ) {
                            args[ 0 ] = value.call( this, index, self.html() );
                        }
                        domManip( self, args, callback, ignored );
                    } );
                }

                if ( l ) {
                    fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
                    first = fragment.firstChild;

                    if ( fragment.childNodes.length === 1 ) {
                        fragment = first;
                    }

                    // Require either new content or an interest in ignored elements to invoke the callback
                    if ( first || ignored ) {
                        scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                        hasScripts = scripts.length;

                        // Use the original fragment for the last item
                        // instead of the first because it can end up
                        // being emptied incorrectly in certain situations (#8070).
                        for ( ; i < l; i++ ) {
                            node = fragment;

                            if ( i !== iNoClone ) {
                                node = jQuery.clone( node, true, true );

                                // Keep references to cloned scripts for later restoration
                                if ( hasScripts ) {

                                    // Support: Android<4.1, PhantomJS<2
                                    // push.apply(_, arraylike) throws on ancient WebKit
                                    jQuery.merge( scripts, getAll( node, "script" ) );
                                }
                            }

                            callback.call( collection[ i ], node, i );
                        }

                        if ( hasScripts ) {
                            doc = scripts[ scripts.length - 1 ].ownerDocument;

                            // Reenable scripts
                            jQuery.map( scripts, restoreScript );

                            // Evaluate executable scripts on first document insertion
                            for ( i = 0; i < hasScripts; i++ ) {
                                node = scripts[ i ];
                                if ( rscriptType.test( node.type || "" ) &&
                                    !jQuery._data( node, "globalEval" ) &&
                                    jQuery.contains( doc, node ) ) {

                                    if ( node.src ) {

                                        // Optional AJAX dependency, but won't run scripts if not present
                                        if ( jQuery._evalUrl ) {
                                            jQuery._evalUrl( node.src );
                                        }
                                    } else {
                                        jQuery.globalEval(
                                            ( node.text || node.textContent || node.innerHTML || "" )
                                                .replace( rcleanScript, "" )
                                        );
                                    }
                                }
                            }
                        }

                        // Fix #11809: Avoid leaking memory
                        fragment = first = null;
                    }
                }

                return collection;
            }

            function remove( elem, selector, keepData ) {
                var node,
                    elems = selector ? jQuery.filter( selector, elem ) : elem,
                    i = 0;

                for ( ; ( node = elems[ i ] ) != null; i++ ) {

                    if ( !keepData && node.nodeType === 1 ) {
                        jQuery.cleanData( getAll( node ) );
                    }

                    if ( node.parentNode ) {
                        if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
                            setGlobalEval( getAll( node, "script" ) );
                        }
                        node.parentNode.removeChild( node );
                    }
                }

                return elem;
            }

            jQuery.extend( {
                htmlPrefilter: function( html ) {
                    return html.replace( rxhtmlTag, "<$1></$2>" );
                },

                clone: function( elem, dataAndEvents, deepDataAndEvents ) {
                    var destElements, node, clone, i, srcElements,
                        inPage = jQuery.contains( elem.ownerDocument, elem );

                    if ( support.html5Clone || jQuery.isXMLDoc( elem ) ||
                        !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {

                        clone = elem.cloneNode( true );

                        // IE<=8 does not properly clone detached, unknown element nodes
                    } else {
                        fragmentDiv.innerHTML = elem.outerHTML;
                        fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
                    }

                    if ( ( !support.noCloneEvent || !support.noCloneChecked ) &&
                        ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {

                        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                        destElements = getAll( clone );
                        srcElements = getAll( elem );

                        // Fix all IE cloning issues
                        for ( i = 0; ( node = srcElements[ i ] ) != null; ++i ) {

                            // Ensure that the destination node is not null; Fixes #9587
                            if ( destElements[ i ] ) {
                                fixCloneNodeIssues( node, destElements[ i ] );
                            }
                        }
                    }

                    // Copy the events from the original to the clone
                    if ( dataAndEvents ) {
                        if ( deepDataAndEvents ) {
                            srcElements = srcElements || getAll( elem );
                            destElements = destElements || getAll( clone );

                            for ( i = 0; ( node = srcElements[ i ] ) != null; i++ ) {
                                cloneCopyEvent( node, destElements[ i ] );
                            }
                        } else {
                            cloneCopyEvent( elem, clone );
                        }
                    }

                    // Preserve script evaluation history
                    destElements = getAll( clone, "script" );
                    if ( destElements.length > 0 ) {
                        setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
                    }

                    destElements = srcElements = node = null;

                    // Return the cloned set
                    return clone;
                },

                cleanData: function( elems, /* internal */ forceAcceptData ) {
                    var elem, type, id, data,
                        i = 0,
                        internalKey = jQuery.expando,
                        cache = jQuery.cache,
                        attributes = support.attributes,
                        special = jQuery.event.special;

                    for ( ; ( elem = elems[ i ] ) != null; i++ ) {
                        if ( forceAcceptData || acceptData( elem ) ) {

                            id = elem[ internalKey ];
                            data = id && cache[ id ];

                            if ( data ) {
                                if ( data.events ) {
                                    for ( type in data.events ) {
                                        if ( special[ type ] ) {
                                            jQuery.event.remove( elem, type );

                                            // This is a shortcut to avoid jQuery.event.remove's overhead
                                        } else {
                                            jQuery.removeEvent( elem, type, data.handle );
                                        }
                                    }
                                }

                                // Remove cache only if it was not already removed by jQuery.event.remove
                                if ( cache[ id ] ) {

                                    delete cache[ id ];

                                    // Support: IE<9
                                    // IE does not allow us to delete expando properties from nodes
                                    // IE creates expando attributes along with the property
                                    // IE does not have a removeAttribute function on Document nodes
                                    if ( !attributes && typeof elem.removeAttribute !== "undefined" ) {
                                        elem.removeAttribute( internalKey );

                                        // Webkit & Blink performance suffers when deleting properties
                                        // from DOM nodes, so set to undefined instead
                                        // https://code.google.com/p/chromium/issues/detail?id=378607
                                    } else {
                                        elem[ internalKey ] = undefined;
                                    }

                                    deletedIds.push( id );
                                }
                            }
                        }
                    }
                }
            } );

            jQuery.fn.extend( {

                // Keep domManip exposed until 3.0 (gh-2225)
                domManip: domManip,

                detach: function( selector ) {
                    return remove( this, selector, true );
                },

                remove: function( selector ) {
                    return remove( this, selector );
                },

                text: function( value ) {
                    return access( this, function( value ) {
                        return value === undefined ?
                            jQuery.text( this ) :
                            this.empty().append(
                                ( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value )
                            );
                    }, null, value, arguments.length );
                },

                append: function() {
                    return domManip( this, arguments, function( elem ) {
                        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            var target = manipulationTarget( this, elem );
                            target.appendChild( elem );
                        }
                    } );
                },

                prepend: function() {
                    return domManip( this, arguments, function( elem ) {
                        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            var target = manipulationTarget( this, elem );
                            target.insertBefore( elem, target.firstChild );
                        }
                    } );
                },

                before: function() {
                    return domManip( this, arguments, function( elem ) {
                        if ( this.parentNode ) {
                            this.parentNode.insertBefore( elem, this );
                        }
                    } );
                },

                after: function() {
                    return domManip( this, arguments, function( elem ) {
                        if ( this.parentNode ) {
                            this.parentNode.insertBefore( elem, this.nextSibling );
                        }
                    } );
                },

                empty: function() {
                    var elem,
                        i = 0;

                    for ( ; ( elem = this[ i ] ) != null; i++ ) {

                        // Remove element nodes and prevent memory leaks
                        if ( elem.nodeType === 1 ) {
                            jQuery.cleanData( getAll( elem, false ) );
                        }

                        // Remove any remaining nodes
                        while ( elem.firstChild ) {
                            elem.removeChild( elem.firstChild );
                        }

                        // If this is a select, ensure that it displays empty (#12336)
                        // Support: IE<9
                        if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
                            elem.options.length = 0;
                        }
                    }

                    return this;
                },

                clone: function( dataAndEvents, deepDataAndEvents ) {
                    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                    return this.map( function() {
                        return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
                    } );
                },

                html: function( value ) {
                    return access( this, function( value ) {
                        var elem = this[ 0 ] || {},
                            i = 0,
                            l = this.length;

                        if ( value === undefined ) {
                            return elem.nodeType === 1 ?
                                elem.innerHTML.replace( rinlinejQuery, "" ) :
                                undefined;
                        }

                        // See if we can take a shortcut and just use innerHTML
                        if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                            ( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
                            ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                            !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

                            value = jQuery.htmlPrefilter( value );

                            try {
                                for ( ; i < l; i++ ) {

                                    // Remove element nodes and prevent memory leaks
                                    elem = this[ i ] || {};
                                    if ( elem.nodeType === 1 ) {
                                        jQuery.cleanData( getAll( elem, false ) );
                                        elem.innerHTML = value;
                                    }
                                }

                                elem = 0;

                                // If using innerHTML throws an exception, use the fallback method
                            } catch ( e ) {}
                        }

                        if ( elem ) {
                            this.empty().append( value );
                        }
                    }, null, value, arguments.length );
                },

                replaceWith: function() {
                    var ignored = [];

                    // Make the changes, replacing each non-ignored context element with the new content
                    return domManip( this, arguments, function( elem ) {
                        var parent = this.parentNode;

                        if ( jQuery.inArray( this, ignored ) < 0 ) {
                            jQuery.cleanData( getAll( this ) );
                            if ( parent ) {
                                parent.replaceChild( elem, this );
                            }
                        }

                        // Force callback invocation
                    }, ignored );
                }
            } );

            jQuery.each( {
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function( name, original ) {
                jQuery.fn[ name ] = function( selector ) {
                    var elems,
                        i = 0,
                        ret = [],
                        insert = jQuery( selector ),
                        last = insert.length - 1;

                    for ( ; i <= last; i++ ) {
                        elems = i === last ? this : this.clone( true );
                        jQuery( insert[ i ] )[ original ]( elems );

                        // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
                        push.apply( ret, elems.get() );
                    }

                    return this.pushStack( ret );
                };
            } );


            var iframe,
                elemdisplay = {

                    // Support: Firefox
                    // We have to pre-define these values for FF (#10227)
                    HTML: "block",
                    BODY: "block"
                };

            /**
             * Retrieve the actual display of a element
             * @param {String} name nodeName of the element
             * @param {Object} doc Document object
             */

            // Called only from within defaultDisplay
            function actualDisplay( name, doc ) {
                var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

                    display = jQuery.css( elem[ 0 ], "display" );

                // We don't have any data stored on the element,
                // so use "detach" method as fast way to get rid of the element
                elem.detach();

                return display;
            }

            /**
             * Try to determine the default display value of an element
             * @param {String} nodeName
             */
            function defaultDisplay( nodeName ) {
                var doc = document,
                    display = elemdisplay[ nodeName ];

                if ( !display ) {
                    display = actualDisplay( nodeName, doc );

                    // If the simple way fails, read from inside an iframe
                    if ( display === "none" || !display ) {

                        // Use the already-created iframe if possible
                        iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
                            .appendTo( doc.documentElement );

                        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                        doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

                        // Support: IE
                        doc.write();
                        doc.close();

                        display = actualDisplay( nodeName, doc );
                        iframe.detach();
                    }

                    // Store the correct default display
                    elemdisplay[ nodeName ] = display;
                }

                return display;
            }
            var rmargin = ( /^margin/ );

            var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

            var swap = function( elem, options, callback, args ) {
                var ret, name,
                    old = {};

                // Remember the old values, and insert the new ones
                for ( name in options ) {
                    old[ name ] = elem.style[ name ];
                    elem.style[ name ] = options[ name ];
                }

                ret = callback.apply( elem, args || [] );

                // Revert the old values
                for ( name in options ) {
                    elem.style[ name ] = old[ name ];
                }

                return ret;
            };


            var documentElement = document.documentElement;



            ( function() {
                var pixelPositionVal, pixelMarginRightVal, boxSizingReliableVal,
                    reliableHiddenOffsetsVal, reliableMarginRightVal, reliableMarginLeftVal,
                    container = document.createElement( "div" ),
                    div = document.createElement( "div" );

                // Finish early in limited (non-browser) environments
                if ( !div.style ) {
                    return;
                }

                div.style.cssText = "float:left;opacity:.5";

                // Support: IE<9
                // Make sure that element opacity exists (as opposed to filter)
                support.opacity = div.style.opacity === "0.5";

                // Verify style float existence
                // (IE uses styleFloat instead of cssFloat)
                support.cssFloat = !!div.style.cssFloat;

                div.style.backgroundClip = "content-box";
                div.cloneNode( true ).style.backgroundClip = "";
                support.clearCloneStyle = div.style.backgroundClip === "content-box";

                container = document.createElement( "div" );
                container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
                    "padding:0;margin-top:1px;position:absolute";
                div.innerHTML = "";
                container.appendChild( div );

                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                support.boxSizing = div.style.boxSizing === "" || div.style.MozBoxSizing === "" ||
                    div.style.WebkitBoxSizing === "";

                jQuery.extend( support, {
                    reliableHiddenOffsets: function() {
                        if ( pixelPositionVal == null ) {
                            computeStyleTests();
                        }
                        return reliableHiddenOffsetsVal;
                    },

                    boxSizingReliable: function() {

                        // We're checking for pixelPositionVal here instead of boxSizingReliableVal
                        // since that compresses better and they're computed together anyway.
                        if ( pixelPositionVal == null ) {
                            computeStyleTests();
                        }
                        return boxSizingReliableVal;
                    },

                    pixelMarginRight: function() {

                        // Support: Android 4.0-4.3
                        if ( pixelPositionVal == null ) {
                            computeStyleTests();
                        }
                        return pixelMarginRightVal;
                    },

                    pixelPosition: function() {
                        if ( pixelPositionVal == null ) {
                            computeStyleTests();
                        }
                        return pixelPositionVal;
                    },

                    reliableMarginRight: function() {

                        // Support: Android 2.3
                        if ( pixelPositionVal == null ) {
                            computeStyleTests();
                        }
                        return reliableMarginRightVal;
                    },

                    reliableMarginLeft: function() {

                        // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
                        if ( pixelPositionVal == null ) {
                            computeStyleTests();
                        }
                        return reliableMarginLeftVal;
                    }
                } );

                function computeStyleTests() {
                    var contents, divStyle,
                        documentElement = document.documentElement;

                    // Setup
                    documentElement.appendChild( container );

                    div.style.cssText =

                        // Support: Android 2.3
                        // Vendor-prefix box-sizing
                        "-webkit-box-sizing:border-box;box-sizing:border-box;" +
                        "position:relative;display:block;" +
                        "margin:auto;border:1px;padding:1px;" +
                        "top:1%;width:50%";

                    // Support: IE<9
                    // Assume reasonable values in the absence of getComputedStyle
                    pixelPositionVal = boxSizingReliableVal = reliableMarginLeftVal = false;
                    pixelMarginRightVal = reliableMarginRightVal = true;

                    // Check for getComputedStyle so that this code is not run in IE<9.
                    if ( window.getComputedStyle ) {
                        divStyle = window.getComputedStyle( div );
                        pixelPositionVal = ( divStyle || {} ).top !== "1%";
                        reliableMarginLeftVal = ( divStyle || {} ).marginLeft === "2px";
                        boxSizingReliableVal = ( divStyle || { width: "4px" } ).width === "4px";

                        // Support: Android 4.0 - 4.3 only
                        // Some styles come back with percentage values, even though they shouldn't
                        div.style.marginRight = "50%";
                        pixelMarginRightVal = ( divStyle || { marginRight: "4px" } ).marginRight === "4px";

                        // Support: Android 2.3 only
                        // Div with explicit width and no margin-right incorrectly
                        // gets computed margin-right based on width of container (#3333)
                        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                        contents = div.appendChild( document.createElement( "div" ) );

                        // Reset CSS: box-sizing; display; margin; border; padding
                        contents.style.cssText = div.style.cssText =

                            // Support: Android 2.3
                            // Vendor-prefix box-sizing
                            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                            "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                        contents.style.marginRight = contents.style.width = "0";
                        div.style.width = "1px";

                        reliableMarginRightVal =
                            !parseFloat( ( window.getComputedStyle( contents ) || {} ).marginRight );

                        div.removeChild( contents );
                    }

                    // Support: IE6-8
                    // First check that getClientRects works as expected
                    // Check if table cells still have offsetWidth/Height when they are set
                    // to display:none and there are still other visible table cells in a
                    // table row; if so, offsetWidth/Height are not reliable for use when
                    // determining if an element has been hidden directly using
                    // display:none (it is still safe to use offsets if a parent element is
                    // hidden; don safety goggles and see bug #4512 for more information).
                    div.style.display = "none";
                    reliableHiddenOffsetsVal = div.getClientRects().length === 0;
                    if ( reliableHiddenOffsetsVal ) {
                        div.style.display = "";
                        div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
                        div.childNodes[ 0 ].style.borderCollapse = "separate";
                        contents = div.getElementsByTagName( "td" );
                        contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
                        reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
                        if ( reliableHiddenOffsetsVal ) {
                            contents[ 0 ].style.display = "";
                            contents[ 1 ].style.display = "none";
                            reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
                        }
                    }

                    // Teardown
                    documentElement.removeChild( container );
                }

            } )();


            var getStyles, curCSS,
                rposition = /^(top|right|bottom|left)$/;

            if ( window.getComputedStyle ) {
                getStyles = function( elem ) {

                    // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
                    // IE throws on elements created in popups
                    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                    var view = elem.ownerDocument.defaultView;

                    if ( !view || !view.opener ) {
                        view = window;
                    }

                    return view.getComputedStyle( elem );
                };

                curCSS = function( elem, name, computed ) {
                    var width, minWidth, maxWidth, ret,
                        style = elem.style;

                    computed = computed || getStyles( elem );

                    // getPropertyValue is only needed for .css('filter') in IE9, see #12537
                    ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

                    // Support: Opera 12.1x only
                    // Fall back to style even without computed
                    // computed is undefined for elems on document fragments
                    if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
                        ret = jQuery.style( elem, name );
                    }

                    if ( computed ) {

                        // A tribute to the "awesome hack by Dean Edwards"
                        // Chrome < 17 and Safari 5.0 uses "computed value"
                        // instead of "used value" for margin-right
                        // Safari 5.1.7 (at least) returns percentage for a larger set of values,
                        // but width seems to be reliably pixels
                        // this is against the CSSOM draft spec:
                        // http://dev.w3.org/csswg/cssom/#resolved-values
                        if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

                            // Remember the original values
                            width = style.width;
                            minWidth = style.minWidth;
                            maxWidth = style.maxWidth;

                            // Put in the new values to get a computed value out
                            style.minWidth = style.maxWidth = style.width = ret;
                            ret = computed.width;

                            // Revert the changed values
                            style.width = width;
                            style.minWidth = minWidth;
                            style.maxWidth = maxWidth;
                        }
                    }

                    // Support: IE
                    // IE returns zIndex value as an integer.
                    return ret === undefined ?
                        ret :
                        ret + "";
                };
            } else if ( documentElement.currentStyle ) {
                getStyles = function( elem ) {
                    return elem.currentStyle;
                };

                curCSS = function( elem, name, computed ) {
                    var left, rs, rsLeft, ret,
                        style = elem.style;

                    computed = computed || getStyles( elem );
                    ret = computed ? computed[ name ] : undefined;

                    // Avoid setting ret to empty string here
                    // so we don't default to auto
                    if ( ret == null && style && style[ name ] ) {
                        ret = style[ name ];
                    }

                    // From the awesome hack by Dean Edwards
                    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

                    // If we're not dealing with a regular pixel number
                    // but a number that has a weird ending, we need to convert it to pixels
                    // but not position css attributes, as those are
                    // proportional to the parent element instead
                    // and we can't measure the parent instead because it
                    // might trigger a "stacking dolls" problem
                    if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

                        // Remember the original values
                        left = style.left;
                        rs = elem.runtimeStyle;
                        rsLeft = rs && rs.left;

                        // Put in the new values to get a computed value out
                        if ( rsLeft ) {
                            rs.left = elem.currentStyle.left;
                        }
                        style.left = name === "fontSize" ? "1em" : ret;
                        ret = style.pixelLeft + "px";

                        // Revert the changed values
                        style.left = left;
                        if ( rsLeft ) {
                            rs.left = rsLeft;
                        }
                    }

                    // Support: IE
                    // IE returns zIndex value as an integer.
                    return ret === undefined ?
                        ret :
                        ret + "" || "auto";
                };
            }




            function addGetHookIf( conditionFn, hookFn ) {

                // Define the hook, we'll check on the first run if it's really needed.
                return {
                    get: function() {
                        if ( conditionFn() ) {

                            // Hook not needed (or it's not possible to use it due
                            // to missing dependency), remove it.
                            delete this.get;
                            return;
                        }

                        // Hook needed; redefine it so that the support test is not executed again.
                        return ( this.get = hookFn ).apply( this, arguments );
                    }
                };
            }


            var

                ralpha = /alpha\([^)]*\)/i,
                ropacity = /opacity\s*=\s*([^)]*)/i,

                // swappable if display is none or starts with table except
                // "table", "table-cell", or "table-caption"
                // see here for display values:
                // https://developer.mozilla.org/en-US/docs/CSS/display
                rdisplayswap = /^(none|table(?!-c[ea]).+)/,
                rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),

                cssShow = { position: "absolute", visibility: "hidden", display: "block" },
                cssNormalTransform = {
                    letterSpacing: "0",
                    fontWeight: "400"
                },

                cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
                emptyStyle = document.createElement( "div" ).style;


            // return a css property mapped to a potentially vendor prefixed property
            function vendorPropName( name ) {

                // shortcut for names that are not vendor prefixed
                if ( name in emptyStyle ) {
                    return name;
                }

                // check for vendor prefixed names
                var capName = name.charAt( 0 ).toUpperCase() + name.slice( 1 ),
                    i = cssPrefixes.length;

                while ( i-- ) {
                    name = cssPrefixes[ i ] + capName;
                    if ( name in emptyStyle ) {
                        return name;
                    }
                }
            }

            function showHide( elements, show ) {
                var display, elem, hidden,
                    values = [],
                    index = 0,
                    length = elements.length;

                for ( ; index < length; index++ ) {
                    elem = elements[ index ];
                    if ( !elem.style ) {
                        continue;
                    }

                    values[ index ] = jQuery._data( elem, "olddisplay" );
                    display = elem.style.display;
                    if ( show ) {

                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if ( !values[ index ] && display === "none" ) {
                            elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if ( elem.style.display === "" && isHidden( elem ) ) {
                            values[ index ] =
                                jQuery._data( elem, "olddisplay", defaultDisplay( elem.nodeName ) );
                        }
                    } else {
                        hidden = isHidden( elem );

                        if ( display && display !== "none" || !hidden ) {
                            jQuery._data(
                                elem,
                                "olddisplay",
                                hidden ? display : jQuery.css( elem, "display" )
                            );
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for ( index = 0; index < length; index++ ) {
                    elem = elements[ index ];
                    if ( !elem.style ) {
                        continue;
                    }
                    if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
                        elem.style.display = show ? values[ index ] || "" : "none";
                    }
                }

                return elements;
            }

            function setPositiveNumber( elem, value, subtract ) {
                var matches = rnumsplit.exec( value );
                return matches ?

                    // Guard against undefined "subtract", e.g., when used as in cssHooks
                    Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
                    value;
            }

            function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
                var i = extra === ( isBorderBox ? "border" : "content" ) ?

                    // If we already have the right measurement, avoid augmentation
                    4 :

                    // Otherwise initialize for horizontal or vertical properties
                    name === "width" ? 1 : 0,

                    val = 0;

                for ( ; i < 4; i += 2 ) {

                    // both box models exclude margin, so add it if we want it
                    if ( extra === "margin" ) {
                        val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
                    }

                    if ( isBorderBox ) {

                        // border-box includes padding, so remove it if we want content
                        if ( extra === "content" ) {
                            val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                        }

                        // at this point, extra isn't border nor margin, so remove border
                        if ( extra !== "margin" ) {
                            val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                        }
                    } else {

                        // at this point, extra isn't content, so add padding
                        val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

                        // at this point, extra isn't content nor padding, so add border
                        if ( extra !== "padding" ) {
                            val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                        }
                    }
                }

                return val;
            }

            function getWidthOrHeight( elem, name, extra ) {

                // Start with offset property, which is equivalent to the border-box value
                var valueIsBorderBox = true,
                    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
                    styles = getStyles( elem ),
                    isBorderBox = support.boxSizing &&
                        jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

                // some non-html elements return undefined for offsetWidth, so check for null/undefined
                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
                if ( val <= 0 || val == null ) {

                    // Fall back to computed then uncomputed css if necessary
                    val = curCSS( elem, name, styles );
                    if ( val < 0 || val == null ) {
                        val = elem.style[ name ];
                    }

                    // Computed unit is not pixels. Stop here and return.
                    if ( rnumnonpx.test( val ) ) {
                        return val;
                    }

                    // we need the check for style in case a browser which returns unreliable values
                    // for getComputedStyle silently falls back to the reliable elem.style
                    valueIsBorderBox = isBorderBox &&
                        ( support.boxSizingReliable() || val === elem.style[ name ] );

                    // Normalize "", auto, and prepare for extra
                    val = parseFloat( val ) || 0;
                }

                // use the active box-sizing model to add/subtract irrelevant styles
                return ( val +
                    augmentWidthOrHeight(
                        elem,
                        name,
                        extra || ( isBorderBox ? "border" : "content" ),
                        valueIsBorderBox,
                        styles
                    )
                ) + "px";
            }

            jQuery.extend( {

                // Add in style property hooks for overriding the default
                // behavior of getting and setting a style property
                cssHooks: {
                    opacity: {
                        get: function( elem, computed ) {
                            if ( computed ) {

                                // We should always get a number back from opacity
                                var ret = curCSS( elem, "opacity" );
                                return ret === "" ? "1" : ret;
                            }
                        }
                    }
                },

                // Don't automatically add "px" to these possibly-unitless properties
                cssNumber: {
                    "animationIterationCount": true,
                    "columnCount": true,
                    "fillOpacity": true,
                    "flexGrow": true,
                    "flexShrink": true,
                    "fontWeight": true,
                    "lineHeight": true,
                    "opacity": true,
                    "order": true,
                    "orphans": true,
                    "widows": true,
                    "zIndex": true,
                    "zoom": true
                },

                // Add in properties whose names you wish to fix before
                // setting or getting the value
                cssProps: {

                    // normalize float css property
                    "float": support.cssFloat ? "cssFloat" : "styleFloat"
                },

                // Get and set the style property on a DOM Node
                style: function( elem, name, value, extra ) {

                    // Don't set styles on text and comment nodes
                    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                        return;
                    }

                    // Make sure that we're working with the right name
                    var ret, type, hooks,
                        origName = jQuery.camelCase( name ),
                        style = elem.style;

                    name = jQuery.cssProps[ origName ] ||
                        ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

                    // gets hook for the prefixed version
                    // followed by the unprefixed version
                    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                    // Check if we're setting a value
                    if ( value !== undefined ) {
                        type = typeof value;

                        // Convert "+=" or "-=" to relative numbers (#7345)
                        if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
                            value = adjustCSS( elem, name, ret );

                            // Fixes bug #9237
                            type = "number";
                        }

                        // Make sure that null and NaN values aren't set. See: #7116
                        if ( value == null || value !== value ) {
                            return;
                        }

                        // If a number was passed in, add the unit (except for certain CSS properties)
                        if ( type === "number" ) {
                            value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
                        }

                        // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
                        // but it would mean to define eight
                        // (for every problematic property) identical functions
                        if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
                            style[ name ] = "inherit";
                        }

                        // If a hook was provided, use that value, otherwise just set the specified value
                        if ( !hooks || !( "set" in hooks ) ||
                            ( value = hooks.set( elem, value, extra ) ) !== undefined ) {

                            // Support: IE
                            // Swallow errors from 'invalid' CSS values (#5509)
                            try {
                                style[ name ] = value;
                            } catch ( e ) {}
                        }

                    } else {

                        // If a hook was provided get the non-computed value from there
                        if ( hooks && "get" in hooks &&
                            ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

                            return ret;
                        }

                        // Otherwise just get the value from the style object
                        return style[ name ];
                    }
                },

                css: function( elem, name, extra, styles ) {
                    var num, val, hooks,
                        origName = jQuery.camelCase( name );

                    // Make sure that we're working with the right name
                    name = jQuery.cssProps[ origName ] ||
                        ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

                    // gets hook for the prefixed version
                    // followed by the unprefixed version
                    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                    // If a hook was provided get the computed value from there
                    if ( hooks && "get" in hooks ) {
                        val = hooks.get( elem, true, extra );
                    }

                    // Otherwise, if a way to get the computed value exists, use that
                    if ( val === undefined ) {
                        val = curCSS( elem, name, styles );
                    }

                    //convert "normal" to computed value
                    if ( val === "normal" && name in cssNormalTransform ) {
                        val = cssNormalTransform[ name ];
                    }

                    // Return, converting to number if forced or a qualifier was provided and val looks numeric
                    if ( extra === "" || extra ) {
                        num = parseFloat( val );
                        return extra === true || isFinite( num ) ? num || 0 : val;
                    }
                    return val;
                }
            } );

            jQuery.each( [ "height", "width" ], function( i, name ) {
                jQuery.cssHooks[ name ] = {
                    get: function( elem, computed, extra ) {
                        if ( computed ) {

                            // certain elements can have dimension info if we invisibly show them
                            // however, it must have a current display style that would benefit from this
                            return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
                            elem.offsetWidth === 0 ?
                                swap( elem, cssShow, function() {
                                    return getWidthOrHeight( elem, name, extra );
                                } ) :
                                getWidthOrHeight( elem, name, extra );
                        }
                    },

                    set: function( elem, value, extra ) {
                        var styles = extra && getStyles( elem );
                        return setPositiveNumber( elem, value, extra ?
                            augmentWidthOrHeight(
                                elem,
                                name,
                                extra,
                                support.boxSizing &&
                                jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                                styles
                            ) : 0
                        );
                    }
                };
            } );

            if ( !support.opacity ) {
                jQuery.cssHooks.opacity = {
                    get: function( elem, computed ) {

                        // IE uses filters for opacity
                        return ropacity.test( ( computed && elem.currentStyle ?
                            elem.currentStyle.filter :
                            elem.style.filter ) || "" ) ?
                            ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
                            computed ? "1" : "";
                    },

                    set: function( elem, value ) {
                        var style = elem.style,
                            currentStyle = elem.currentStyle,
                            opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                            filter = currentStyle && currentStyle.filter || style.filter || "";

                        // IE has trouble with opacity if it does not have layout
                        // Force it by setting the zoom level
                        style.zoom = 1;

                        // if setting opacity to 1, and no other filters exist -
                        // attempt to remove filter attribute #6652
                        // if value === "", then remove inline opacity #12685
                        if ( ( value >= 1 || value === "" ) &&
                            jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
                            style.removeAttribute ) {

                            // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                            // if "filter:" is present at all, clearType is disabled, we want to avoid this
                            // style.removeAttribute is IE Only, but so apparently is this code path...
                            style.removeAttribute( "filter" );

                            // if there is no filter style applied in a css rule
                            // or unset inline opacity, we are done
                            if ( value === "" || currentStyle && !currentStyle.filter ) {
                                return;
                            }
                        }

                        // otherwise, set new filter values
                        style.filter = ralpha.test( filter ) ?
                            filter.replace( ralpha, opacity ) :
                            filter + " " + opacity;
                    }
                };
            }

            jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
                function( elem, computed ) {
                    if ( computed ) {
                        return swap( elem, { "display": "inline-block" },
                            curCSS, [ elem, "marginRight" ] );
                    }
                }
            );

            jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
                function( elem, computed ) {
                    if ( computed ) {
                        return (
                            parseFloat( curCSS( elem, "marginLeft" ) ) ||

                            // Support: IE<=11+
                            // Running getBoundingClientRect on a disconnected node in IE throws an error
                            // Support: IE8 only
                            // getClientRects() errors on disconnected elems
                            ( jQuery.contains( elem.ownerDocument, elem ) ?
                                    elem.getBoundingClientRect().left -
                                    swap( elem, { marginLeft: 0 }, function() {
                                        return elem.getBoundingClientRect().left;
                                    } ) :
                                    0
                            )
                        ) + "px";
                    }
                }
            );

            // These hooks are used by animate to expand properties
            jQuery.each( {
                margin: "",
                padding: "",
                border: "Width"
            }, function( prefix, suffix ) {
                jQuery.cssHooks[ prefix + suffix ] = {
                    expand: function( value ) {
                        var i = 0,
                            expanded = {},

                            // assumes a single number if not a string
                            parts = typeof value === "string" ? value.split( " " ) : [ value ];

                        for ( ; i < 4; i++ ) {
                            expanded[ prefix + cssExpand[ i ] + suffix ] =
                                parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                        }

                        return expanded;
                    }
                };

                if ( !rmargin.test( prefix ) ) {
                    jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
                }
            } );

            jQuery.fn.extend( {
                css: function( name, value ) {
                    return access( this, function( elem, name, value ) {
                        var styles, len,
                            map = {},
                            i = 0;

                        if ( jQuery.isArray( name ) ) {
                            styles = getStyles( elem );
                            len = name.length;

                            for ( ; i < len; i++ ) {
                                map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                            }

                            return map;
                        }

                        return value !== undefined ?
                            jQuery.style( elem, name, value ) :
                            jQuery.css( elem, name );
                    }, name, value, arguments.length > 1 );
                },
                show: function() {
                    return showHide( this, true );
                },
                hide: function() {
                    return showHide( this );
                },
                toggle: function( state ) {
                    if ( typeof state === "boolean" ) {
                        return state ? this.show() : this.hide();
                    }

                    return this.each( function() {
                        if ( isHidden( this ) ) {
                            jQuery( this ).show();
                        } else {
                            jQuery( this ).hide();
                        }
                    } );
                }
            } );


            function Tween( elem, options, prop, end, easing ) {
                return new Tween.prototype.init( elem, options, prop, end, easing );
            }
            jQuery.Tween = Tween;

            Tween.prototype = {
                constructor: Tween,
                init: function( elem, options, prop, end, easing, unit ) {
                    this.elem = elem;
                    this.prop = prop;
                    this.easing = easing || jQuery.easing._default;
                    this.options = options;
                    this.start = this.now = this.cur();
                    this.end = end;
                    this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
                },
                cur: function() {
                    var hooks = Tween.propHooks[ this.prop ];

                    return hooks && hooks.get ?
                        hooks.get( this ) :
                        Tween.propHooks._default.get( this );
                },
                run: function( percent ) {
                    var eased,
                        hooks = Tween.propHooks[ this.prop ];

                    if ( this.options.duration ) {
                        this.pos = eased = jQuery.easing[ this.easing ](
                            percent, this.options.duration * percent, 0, 1, this.options.duration
                        );
                    } else {
                        this.pos = eased = percent;
                    }
                    this.now = ( this.end - this.start ) * eased + this.start;

                    if ( this.options.step ) {
                        this.options.step.call( this.elem, this.now, this );
                    }

                    if ( hooks && hooks.set ) {
                        hooks.set( this );
                    } else {
                        Tween.propHooks._default.set( this );
                    }
                    return this;
                }
            };

            Tween.prototype.init.prototype = Tween.prototype;

            Tween.propHooks = {
                _default: {
                    get: function( tween ) {
                        var result;

                        // Use a property on the element directly when it is not a DOM element,
                        // or when there is no matching style property that exists.
                        if ( tween.elem.nodeType !== 1 ||
                            tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
                            return tween.elem[ tween.prop ];
                        }

                        // passing an empty string as a 3rd parameter to .css will automatically
                        // attempt a parseFloat and fallback to a string if the parse fails
                        // so, simple values such as "10px" are parsed to Float.
                        // complex values such as "rotate(1rad)" are returned as is.
                        result = jQuery.css( tween.elem, tween.prop, "" );

                        // Empty strings, null, undefined and "auto" are converted to 0.
                        return !result || result === "auto" ? 0 : result;
                    },
                    set: function( tween ) {

                        // use step hook for back compat - use cssHook if its there - use .style if its
                        // available and use plain properties where available
                        if ( jQuery.fx.step[ tween.prop ] ) {
                            jQuery.fx.step[ tween.prop ]( tween );
                        } else if ( tween.elem.nodeType === 1 &&
                            ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
                                jQuery.cssHooks[ tween.prop ] ) ) {
                            jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                        } else {
                            tween.elem[ tween.prop ] = tween.now;
                        }
                    }
                }
            };

            // Support: IE <=9
            // Panic based approach to setting things on disconnected nodes

            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                set: function( tween ) {
                    if ( tween.elem.nodeType && tween.elem.parentNode ) {
                        tween.elem[ tween.prop ] = tween.now;
                    }
                }
            };

            jQuery.easing = {
                linear: function( p ) {
                    return p;
                },
                swing: function( p ) {
                    return 0.5 - Math.cos( p * Math.PI ) / 2;
                },
                _default: "swing"
            };

            jQuery.fx = Tween.prototype.init;

            // Back Compat <1.8 extension point
            jQuery.fx.step = {};




            var
                fxNow, timerId,
                rfxtypes = /^(?:toggle|show|hide)$/,
                rrun = /queueHooks$/;

            // Animations created synchronously will run synchronously
            function createFxNow() {
                window.setTimeout( function() {
                    fxNow = undefined;
                } );
                return ( fxNow = jQuery.now() );
            }

            // Generate parameters to create a standard animation
            function genFx( type, includeWidth ) {
                var which,
                    attrs = { height: type },
                    i = 0;

                // if we include width, step value is 1 to do all cssExpand values,
                // if we don't include width, step value is 2 to skip over Left and Right
                includeWidth = includeWidth ? 1 : 0;
                for ( ; i < 4 ; i += 2 - includeWidth ) {
                    which = cssExpand[ i ];
                    attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
                }

                if ( includeWidth ) {
                    attrs.opacity = attrs.width = type;
                }

                return attrs;
            }

            function createTween( value, prop, animation ) {
                var tween,
                    collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
                    index = 0,
                    length = collection.length;
                for ( ; index < length; index++ ) {
                    if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

                        // we're done with this property
                        return tween;
                    }
                }
            }

            function defaultPrefilter( elem, props, opts ) {
                /* jshint validthis: true */
                var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
                    anim = this,
                    orig = {},
                    style = elem.style,
                    hidden = elem.nodeType && isHidden( elem ),
                    dataShow = jQuery._data( elem, "fxshow" );

                // handle queue: false promises
                if ( !opts.queue ) {
                    hooks = jQuery._queueHooks( elem, "fx" );
                    if ( hooks.unqueued == null ) {
                        hooks.unqueued = 0;
                        oldfire = hooks.empty.fire;
                        hooks.empty.fire = function() {
                            if ( !hooks.unqueued ) {
                                oldfire();
                            }
                        };
                    }
                    hooks.unqueued++;

                    anim.always( function() {

                        // doing this makes sure that the complete handler will be called
                        // before this completes
                        anim.always( function() {
                            hooks.unqueued--;
                            if ( !jQuery.queue( elem, "fx" ).length ) {
                                hooks.empty.fire();
                            }
                        } );
                    } );
                }

                // height/width overflow pass
                if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

                    // Make sure that nothing sneaks out
                    // Record all 3 overflow attributes because IE does not
                    // change the overflow attribute when overflowX and
                    // overflowY are set to the same value
                    opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

                    // Set display property to inline-block for height/width
                    // animations on inline elements that are having width/height animated
                    display = jQuery.css( elem, "display" );

                    // Test default display if display is currently "none"
                    checkDisplay = display === "none" ?
                        jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

                    if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {

                        // inline-level elements accept inline-block;
                        // block-level elements need to be inline with layout
                        if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
                            style.display = "inline-block";
                        } else {
                            style.zoom = 1;
                        }
                    }
                }

                if ( opts.overflow ) {
                    style.overflow = "hidden";
                    if ( !support.shrinkWrapBlocks() ) {
                        anim.always( function() {
                            style.overflow = opts.overflow[ 0 ];
                            style.overflowX = opts.overflow[ 1 ];
                            style.overflowY = opts.overflow[ 2 ];
                        } );
                    }
                }

                // show/hide pass
                for ( prop in props ) {
                    value = props[ prop ];
                    if ( rfxtypes.exec( value ) ) {
                        delete props[ prop ];
                        toggle = toggle || value === "toggle";
                        if ( value === ( hidden ? "hide" : "show" ) ) {

                            // If there is dataShow left over from a stopped hide or show
                            // and we are going to proceed with show, we should pretend to be hidden
                            if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                                hidden = true;
                            } else {
                                continue;
                            }
                        }
                        orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

                        // Any non-fx value stops us from restoring the original display value
                    } else {
                        display = undefined;
                    }
                }

                if ( !jQuery.isEmptyObject( orig ) ) {
                    if ( dataShow ) {
                        if ( "hidden" in dataShow ) {
                            hidden = dataShow.hidden;
                        }
                    } else {
                        dataShow = jQuery._data( elem, "fxshow", {} );
                    }

                    // store state if its toggle - enables .stop().toggle() to "reverse"
                    if ( toggle ) {
                        dataShow.hidden = !hidden;
                    }
                    if ( hidden ) {
                        jQuery( elem ).show();
                    } else {
                        anim.done( function() {
                            jQuery( elem ).hide();
                        } );
                    }
                    anim.done( function() {
                        var prop;
                        jQuery._removeData( elem, "fxshow" );
                        for ( prop in orig ) {
                            jQuery.style( elem, prop, orig[ prop ] );
                        }
                    } );
                    for ( prop in orig ) {
                        tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

                        if ( !( prop in dataShow ) ) {
                            dataShow[ prop ] = tween.start;
                            if ( hidden ) {
                                tween.end = tween.start;
                                tween.start = prop === "width" || prop === "height" ? 1 : 0;
                            }
                        }
                    }

                    // If this is a noop like .hide().hide(), restore an overwritten display value
                } else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
                    style.display = display;
                }
            }

            function propFilter( props, specialEasing ) {
                var index, name, easing, value, hooks;

                // camelCase, specialEasing and expand cssHook pass
                for ( index in props ) {
                    name = jQuery.camelCase( index );
                    easing = specialEasing[ name ];
                    value = props[ index ];
                    if ( jQuery.isArray( value ) ) {
                        easing = value[ 1 ];
                        value = props[ index ] = value[ 0 ];
                    }

                    if ( index !== name ) {
                        props[ name ] = value;
                        delete props[ index ];
                    }

                    hooks = jQuery.cssHooks[ name ];
                    if ( hooks && "expand" in hooks ) {
                        value = hooks.expand( value );
                        delete props[ name ];

                        // not quite $.extend, this wont overwrite keys already present.
                        // also - reusing 'index' from above because we have the correct "name"
                        for ( index in value ) {
                            if ( !( index in props ) ) {
                                props[ index ] = value[ index ];
                                specialEasing[ index ] = easing;
                            }
                        }
                    } else {
                        specialEasing[ name ] = easing;
                    }
                }
            }

            function Animation( elem, properties, options ) {
                var result,
                    stopped,
                    index = 0,
                    length = Animation.prefilters.length,
                    deferred = jQuery.Deferred().always( function() {

                        // don't match elem in the :animated selector
                        delete tick.elem;
                    } ),
                    tick = function() {
                        if ( stopped ) {
                            return false;
                        }
                        var currentTime = fxNow || createFxNow(),
                            remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

                            // Support: Android 2.3
                            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                            temp = remaining / animation.duration || 0,
                            percent = 1 - temp,
                            index = 0,
                            length = animation.tweens.length;

                        for ( ; index < length ; index++ ) {
                            animation.tweens[ index ].run( percent );
                        }

                        deferred.notifyWith( elem, [ animation, percent, remaining ] );

                        if ( percent < 1 && length ) {
                            return remaining;
                        } else {
                            deferred.resolveWith( elem, [ animation ] );
                            return false;
                        }
                    },
                    animation = deferred.promise( {
                        elem: elem,
                        props: jQuery.extend( {}, properties ),
                        opts: jQuery.extend( true, {
                            specialEasing: {},
                            easing: jQuery.easing._default
                        }, options ),
                        originalProperties: properties,
                        originalOptions: options,
                        startTime: fxNow || createFxNow(),
                        duration: options.duration,
                        tweens: [],
                        createTween: function( prop, end ) {
                            var tween = jQuery.Tween( elem, animation.opts, prop, end,
                                animation.opts.specialEasing[ prop ] || animation.opts.easing );
                            animation.tweens.push( tween );
                            return tween;
                        },
                        stop: function( gotoEnd ) {
                            var index = 0,

                                // if we are going to the end, we want to run all the tweens
                                // otherwise we skip this part
                                length = gotoEnd ? animation.tweens.length : 0;
                            if ( stopped ) {
                                return this;
                            }
                            stopped = true;
                            for ( ; index < length ; index++ ) {
                                animation.tweens[ index ].run( 1 );
                            }

                            // resolve when we played the last frame
                            // otherwise, reject
                            if ( gotoEnd ) {
                                deferred.notifyWith( elem, [ animation, 1, 0 ] );
                                deferred.resolveWith( elem, [ animation, gotoEnd ] );
                            } else {
                                deferred.rejectWith( elem, [ animation, gotoEnd ] );
                            }
                            return this;
                        }
                    } ),
                    props = animation.props;

                propFilter( props, animation.opts.specialEasing );

                for ( ; index < length ; index++ ) {
                    result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
                    if ( result ) {
                        if ( jQuery.isFunction( result.stop ) ) {
                            jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
                                jQuery.proxy( result.stop, result );
                        }
                        return result;
                    }
                }

                jQuery.map( props, createTween, animation );

                if ( jQuery.isFunction( animation.opts.start ) ) {
                    animation.opts.start.call( elem, animation );
                }

                jQuery.fx.timer(
                    jQuery.extend( tick, {
                        elem: elem,
                        anim: animation,
                        queue: animation.opts.queue
                    } )
                );

                // attach callbacks from options
                return animation.progress( animation.opts.progress )
                    .done( animation.opts.done, animation.opts.complete )
                    .fail( animation.opts.fail )
                    .always( animation.opts.always );
            }

            jQuery.Animation = jQuery.extend( Animation, {

                tweeners: {
                    "*": [ function( prop, value ) {
                        var tween = this.createTween( prop, value );
                        adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
                        return tween;
                    } ]
                },

                tweener: function( props, callback ) {
                    if ( jQuery.isFunction( props ) ) {
                        callback = props;
                        props = [ "*" ];
                    } else {
                        props = props.match( rnotwhite );
                    }

                    var prop,
                        index = 0,
                        length = props.length;

                    for ( ; index < length ; index++ ) {
                        prop = props[ index ];
                        Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
                        Animation.tweeners[ prop ].unshift( callback );
                    }
                },

                prefilters: [ defaultPrefilter ],

                prefilter: function( callback, prepend ) {
                    if ( prepend ) {
                        Animation.prefilters.unshift( callback );
                    } else {
                        Animation.prefilters.push( callback );
                    }
                }
            } );

            jQuery.speed = function( speed, easing, fn ) {
                var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
                    complete: fn || !fn && easing ||
                        jQuery.isFunction( speed ) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
                };

                opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                    opt.duration in jQuery.fx.speeds ?
                        jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

                // normalize opt.queue - true/undefined/null -> "fx"
                if ( opt.queue == null || opt.queue === true ) {
                    opt.queue = "fx";
                }

                // Queueing
                opt.old = opt.complete;

                opt.complete = function() {
                    if ( jQuery.isFunction( opt.old ) ) {
                        opt.old.call( this );
                    }

                    if ( opt.queue ) {
                        jQuery.dequeue( this, opt.queue );
                    }
                };

                return opt;
            };

            jQuery.fn.extend( {
                fadeTo: function( speed, to, easing, callback ) {

                    // show any hidden elements after setting opacity to 0
                    return this.filter( isHidden ).css( "opacity", 0 ).show()

                        // animate to the value specified
                        .end().animate( { opacity: to }, speed, easing, callback );
                },
                animate: function( prop, speed, easing, callback ) {
                    var empty = jQuery.isEmptyObject( prop ),
                        optall = jQuery.speed( speed, easing, callback ),
                        doAnimation = function() {

                            // Operate on a copy of prop so per-property easing won't be lost
                            var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                            // Empty animations, or finishing resolves immediately
                            if ( empty || jQuery._data( this, "finish" ) ) {
                                anim.stop( true );
                            }
                        };
                    doAnimation.finish = doAnimation;

                    return empty || optall.queue === false ?
                        this.each( doAnimation ) :
                        this.queue( optall.queue, doAnimation );
                },
                stop: function( type, clearQueue, gotoEnd ) {
                    var stopQueue = function( hooks ) {
                        var stop = hooks.stop;
                        delete hooks.stop;
                        stop( gotoEnd );
                    };

                    if ( typeof type !== "string" ) {
                        gotoEnd = clearQueue;
                        clearQueue = type;
                        type = undefined;
                    }
                    if ( clearQueue && type !== false ) {
                        this.queue( type || "fx", [] );
                    }

                    return this.each( function() {
                        var dequeue = true,
                            index = type != null && type + "queueHooks",
                            timers = jQuery.timers,
                            data = jQuery._data( this );

                        if ( index ) {
                            if ( data[ index ] && data[ index ].stop ) {
                                stopQueue( data[ index ] );
                            }
                        } else {
                            for ( index in data ) {
                                if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                                    stopQueue( data[ index ] );
                                }
                            }
                        }

                        for ( index = timers.length; index--; ) {
                            if ( timers[ index ].elem === this &&
                                ( type == null || timers[ index ].queue === type ) ) {

                                timers[ index ].anim.stop( gotoEnd );
                                dequeue = false;
                                timers.splice( index, 1 );
                            }
                        }

                        // start the next in the queue if the last step wasn't forced
                        // timers currently will call their complete callbacks, which will dequeue
                        // but only if they were gotoEnd
                        if ( dequeue || !gotoEnd ) {
                            jQuery.dequeue( this, type );
                        }
                    } );
                },
                finish: function( type ) {
                    if ( type !== false ) {
                        type = type || "fx";
                    }
                    return this.each( function() {
                        var index,
                            data = jQuery._data( this ),
                            queue = data[ type + "queue" ],
                            hooks = data[ type + "queueHooks" ],
                            timers = jQuery.timers,
                            length = queue ? queue.length : 0;

                        // enable finishing flag on private data
                        data.finish = true;

                        // empty the queue first
                        jQuery.queue( this, type, [] );

                        if ( hooks && hooks.stop ) {
                            hooks.stop.call( this, true );
                        }

                        // look for any active animations, and finish them
                        for ( index = timers.length; index--; ) {
                            if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                                timers[ index ].anim.stop( true );
                                timers.splice( index, 1 );
                            }
                        }

                        // look for any animations in the old queue and finish them
                        for ( index = 0; index < length; index++ ) {
                            if ( queue[ index ] && queue[ index ].finish ) {
                                queue[ index ].finish.call( this );
                            }
                        }

                        // turn off finishing flag
                        delete data.finish;
                    } );
                }
            } );

            jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
                var cssFn = jQuery.fn[ name ];
                jQuery.fn[ name ] = function( speed, easing, callback ) {
                    return speed == null || typeof speed === "boolean" ?
                        cssFn.apply( this, arguments ) :
                        this.animate( genFx( name, true ), speed, easing, callback );
                };
            } );

            // Generate shortcuts for custom animations
            jQuery.each( {
                slideDown: genFx( "show" ),
                slideUp: genFx( "hide" ),
                slideToggle: genFx( "toggle" ),
                fadeIn: { opacity: "show" },
                fadeOut: { opacity: "hide" },
                fadeToggle: { opacity: "toggle" }
            }, function( name, props ) {
                jQuery.fn[ name ] = function( speed, easing, callback ) {
                    return this.animate( props, speed, easing, callback );
                };
            } );

            jQuery.timers = [];
            jQuery.fx.tick = function() {
                var timer,
                    timers = jQuery.timers,
                    i = 0;

                fxNow = jQuery.now();

                for ( ; i < timers.length; i++ ) {
                    timer = timers[ i ];

                    // Checks the timer has not already been removed
                    if ( !timer() && timers[ i ] === timer ) {
                        timers.splice( i--, 1 );
                    }
                }

                if ( !timers.length ) {
                    jQuery.fx.stop();
                }
                fxNow = undefined;
            };

            jQuery.fx.timer = function( timer ) {
                jQuery.timers.push( timer );
                if ( timer() ) {
                    jQuery.fx.start();
                } else {
                    jQuery.timers.pop();
                }
            };

            jQuery.fx.interval = 13;

            jQuery.fx.start = function() {
                if ( !timerId ) {
                    timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
                }
            };

            jQuery.fx.stop = function() {
                window.clearInterval( timerId );
                timerId = null;
            };

            jQuery.fx.speeds = {
                slow: 600,
                fast: 200,

                // Default speed
                _default: 400
            };


            // Based off of the plugin by Clint Helfers, with permission.
            // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
            jQuery.fn.delay = function( time, type ) {
                time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
                type = type || "fx";

                return this.queue( type, function( next, hooks ) {
                    var timeout = window.setTimeout( next, time );
                    hooks.stop = function() {
                        window.clearTimeout( timeout );
                    };
                } );
            };


            ( function() {
                var a,
                    input = document.createElement( "input" ),
                    div = document.createElement( "div" ),
                    select = document.createElement( "select" ),
                    opt = select.appendChild( document.createElement( "option" ) );

                // Setup
                div = document.createElement( "div" );
                div.setAttribute( "className", "t" );
                div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
                a = div.getElementsByTagName( "a" )[ 0 ];

                // Support: Windows Web Apps (WWA)
                // `type` must use .setAttribute for WWA (#14901)
                input.setAttribute( "type", "checkbox" );
                div.appendChild( input );

                a = div.getElementsByTagName( "a" )[ 0 ];

                // First batch of tests.
                a.style.cssText = "top:1px";

                // Test setAttribute on camelCase class.
                // If it works, we need attrFixes when doing get/setAttribute (ie6/7)
                support.getSetAttribute = div.className !== "t";

                // Get the style information from getAttribute
                // (IE uses .cssText instead)
                support.style = /top/.test( a.getAttribute( "style" ) );

                // Make sure that URLs aren't manipulated
                // (IE normalizes it by default)
                support.hrefNormalized = a.getAttribute( "href" ) === "/a";

                // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
                support.checkOn = !!input.value;

                // Make sure that a selected-by-default option has a working selected property.
                // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
                support.optSelected = opt.selected;

                // Tests for enctype support on a form (#6743)
                support.enctype = !!document.createElement( "form" ).enctype;

                // Make sure that the options inside disabled selects aren't marked as disabled
                // (WebKit marks them as disabled)
                select.disabled = true;
                support.optDisabled = !opt.disabled;

                // Support: IE8 only
                // Check if we can trust getAttribute("value")
                input = document.createElement( "input" );
                input.setAttribute( "value", "" );
                support.input = input.getAttribute( "value" ) === "";

                // Check if an input maintains its value after becoming a radio
                input.value = "t";
                input.setAttribute( "type", "radio" );
                support.radioValue = input.value === "t";
            } )();


            var rreturn = /\r/g,
                rspaces = /[\x20\t\r\n\f]+/g;

            jQuery.fn.extend( {
                val: function( value ) {
                    var hooks, ret, isFunction,
                        elem = this[ 0 ];

                    if ( !arguments.length ) {
                        if ( elem ) {
                            hooks = jQuery.valHooks[ elem.type ] ||
                                jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                            if (
                                hooks &&
                                "get" in hooks &&
                                ( ret = hooks.get( elem, "value" ) ) !== undefined
                            ) {
                                return ret;
                            }

                            ret = elem.value;

                            return typeof ret === "string" ?

                                // handle most common string cases
                                ret.replace( rreturn, "" ) :

                                // handle cases where value is null/undef or number
                                ret == null ? "" : ret;
                        }

                        return;
                    }

                    isFunction = jQuery.isFunction( value );

                    return this.each( function( i ) {
                        var val;

                        if ( this.nodeType !== 1 ) {
                            return;
                        }

                        if ( isFunction ) {
                            val = value.call( this, i, jQuery( this ).val() );
                        } else {
                            val = value;
                        }

                        // Treat null/undefined as ""; convert numbers to string
                        if ( val == null ) {
                            val = "";
                        } else if ( typeof val === "number" ) {
                            val += "";
                        } else if ( jQuery.isArray( val ) ) {
                            val = jQuery.map( val, function( value ) {
                                return value == null ? "" : value + "";
                            } );
                        }

                        hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                        // If set returns undefined, fall back to normal setting
                        if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
                            this.value = val;
                        }
                    } );
                }
            } );

            jQuery.extend( {
                valHooks: {
                    option: {
                        get: function( elem ) {
                            var val = jQuery.find.attr( elem, "value" );
                            return val != null ?
                                val :

                                // Support: IE10-11+
                                // option.text throws exceptions (#14686, #14858)
                                // Strip and collapse whitespace
                                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                                jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
                        }
                    },
                    select: {
                        get: function( elem ) {
                            var value, option,
                                options = elem.options,
                                index = elem.selectedIndex,
                                one = elem.type === "select-one" || index < 0,
                                values = one ? null : [],
                                max = one ? index + 1 : options.length,
                                i = index < 0 ?
                                    max :
                                    one ? index : 0;

                            // Loop through all the selected options
                            for ( ; i < max; i++ ) {
                                option = options[ i ];

                                // oldIE doesn't update selected after form reset (#2551)
                                if ( ( option.selected || i === index ) &&

                                    // Don't return options that are disabled or in a disabled optgroup
                                    ( support.optDisabled ?
                                        !option.disabled :
                                        option.getAttribute( "disabled" ) === null ) &&
                                    ( !option.parentNode.disabled ||
                                        !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                                    // Get the specific value for the option
                                    value = jQuery( option ).val();

                                    // We don't need an array for one selects
                                    if ( one ) {
                                        return value;
                                    }

                                    // Multi-Selects return an array
                                    values.push( value );
                                }
                            }

                            return values;
                        },

                        set: function( elem, value ) {
                            var optionSet, option,
                                options = elem.options,
                                values = jQuery.makeArray( value ),
                                i = options.length;

                            while ( i-- ) {
                                option = options[ i ];

                                if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1 ) {

                                    // Support: IE6
                                    // When new option element is added to select box we need to
                                    // force reflow of newly added node in order to workaround delay
                                    // of initialization properties
                                    try {
                                        option.selected = optionSet = true;

                                    } catch ( _ ) {

                                        // Will be executed only in IE6
                                        option.scrollHeight;
                                    }

                                } else {
                                    option.selected = false;
                                }
                            }

                            // Force browsers to behave consistently when non-matching value is set
                            if ( !optionSet ) {
                                elem.selectedIndex = -1;
                            }

                            return options;
                        }
                    }
                }
            } );

            // Radios and checkboxes getter/setter
            jQuery.each( [ "radio", "checkbox" ], function() {
                jQuery.valHooks[ this ] = {
                    set: function( elem, value ) {
                        if ( jQuery.isArray( value ) ) {
                            return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
                        }
                    }
                };
                if ( !support.checkOn ) {
                    jQuery.valHooks[ this ].get = function( elem ) {
                        return elem.getAttribute( "value" ) === null ? "on" : elem.value;
                    };
                }
            } );




            var nodeHook, boolHook,
                attrHandle = jQuery.expr.attrHandle,
                ruseDefault = /^(?:checked|selected)$/i,
                getSetAttribute = support.getSetAttribute,
                getSetInput = support.input;

            jQuery.fn.extend( {
                attr: function( name, value ) {
                    return access( this, jQuery.attr, name, value, arguments.length > 1 );
                },

                removeAttr: function( name ) {
                    return this.each( function() {
                        jQuery.removeAttr( this, name );
                    } );
                }
            } );

            jQuery.extend( {
                attr: function( elem, name, value ) {
                    var ret, hooks,
                        nType = elem.nodeType;

                    // Don't get/set attributes on text, comment and attribute nodes
                    if ( nType === 3 || nType === 8 || nType === 2 ) {
                        return;
                    }

                    // Fallback to prop when attributes are not supported
                    if ( typeof elem.getAttribute === "undefined" ) {
                        return jQuery.prop( elem, name, value );
                    }

                    // All attributes are lowercase
                    // Grab necessary hook if one is defined
                    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                        name = name.toLowerCase();
                        hooks = jQuery.attrHooks[ name ] ||
                            ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
                    }

                    if ( value !== undefined ) {
                        if ( value === null ) {
                            jQuery.removeAttr( elem, name );
                            return;
                        }

                        if ( hooks && "set" in hooks &&
                            ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                            return ret;
                        }

                        elem.setAttribute( name, value + "" );
                        return value;
                    }

                    if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                        return ret;
                    }

                    ret = jQuery.find.attr( elem, name );

                    // Non-existent attributes return null, we normalize to undefined
                    return ret == null ? undefined : ret;
                },

                attrHooks: {
                    type: {
                        set: function( elem, value ) {
                            if ( !support.radioValue && value === "radio" &&
                                jQuery.nodeName( elem, "input" ) ) {

                                // Setting the type on a radio button after the value resets the value in IE8-9
                                // Reset value to default in case type is set after value during creation
                                var val = elem.value;
                                elem.setAttribute( "type", value );
                                if ( val ) {
                                    elem.value = val;
                                }
                                return value;
                            }
                        }
                    }
                },

                removeAttr: function( elem, value ) {
                    var name, propName,
                        i = 0,
                        attrNames = value && value.match( rnotwhite );

                    if ( attrNames && elem.nodeType === 1 ) {
                        while ( ( name = attrNames[ i++ ] ) ) {
                            propName = jQuery.propFix[ name ] || name;

                            // Boolean attributes get special treatment (#10870)
                            if ( jQuery.expr.match.bool.test( name ) ) {

                                // Set corresponding property to false
                                if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                                    elem[ propName ] = false;

                                    // Support: IE<9
                                    // Also clear defaultChecked/defaultSelected (if appropriate)
                                } else {
                                    elem[ jQuery.camelCase( "default-" + name ) ] =
                                        elem[ propName ] = false;
                                }

                                // See #9699 for explanation of this approach (setting first, then removal)
                            } else {
                                jQuery.attr( elem, name, "" );
                            }

                            elem.removeAttribute( getSetAttribute ? name : propName );
                        }
                    }
                }
            } );

            // Hooks for boolean attributes
            boolHook = {
                set: function( elem, value, name ) {
                    if ( value === false ) {

                        // Remove boolean attributes when set to false
                        jQuery.removeAttr( elem, name );
                    } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {

                        // IE<8 needs the *property* name
                        elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

                    } else {

                        // Support: IE<9
                        // Use defaultChecked and defaultSelected for oldIE
                        elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
                    }
                    return name;
                }
            };

            jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
                var getter = attrHandle[ name ] || jQuery.find.attr;

                if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                    attrHandle[ name ] = function( elem, name, isXML ) {
                        var ret, handle;
                        if ( !isXML ) {

                            // Avoid an infinite loop by temporarily removing this function from the getter
                            handle = attrHandle[ name ];
                            attrHandle[ name ] = ret;
                            ret = getter( elem, name, isXML ) != null ?
                                name.toLowerCase() :
                                null;
                            attrHandle[ name ] = handle;
                        }
                        return ret;
                    };
                } else {
                    attrHandle[ name ] = function( elem, name, isXML ) {
                        if ( !isXML ) {
                            return elem[ jQuery.camelCase( "default-" + name ) ] ?
                                name.toLowerCase() :
                                null;
                        }
                    };
                }
            } );

            // fix oldIE attroperties
            if ( !getSetInput || !getSetAttribute ) {
                jQuery.attrHooks.value = {
                    set: function( elem, value, name ) {
                        if ( jQuery.nodeName( elem, "input" ) ) {

                            // Does not return so that setAttribute is also used
                            elem.defaultValue = value;
                        } else {

                            // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                            return nodeHook && nodeHook.set( elem, value, name );
                        }
                    }
                };
            }

            // IE6/7 do not support getting/setting some attributes with get/setAttribute
            if ( !getSetAttribute ) {

                // Use this for any attribute in IE6/7
                // This fixes almost every IE6/7 issue
                nodeHook = {
                    set: function( elem, value, name ) {

                        // Set the existing or create a new attribute node
                        var ret = elem.getAttributeNode( name );
                        if ( !ret ) {
                            elem.setAttributeNode(
                                ( ret = elem.ownerDocument.createAttribute( name ) )
                            );
                        }

                        ret.value = value += "";

                        // Break association with cloned elements by also using setAttribute (#9646)
                        if ( name === "value" || value === elem.getAttribute( name ) ) {
                            return value;
                        }
                    }
                };

                // Some attributes are constructed with empty-string values when not defined
                attrHandle.id = attrHandle.name = attrHandle.coords =
                    function( elem, name, isXML ) {
                        var ret;
                        if ( !isXML ) {
                            return ( ret = elem.getAttributeNode( name ) ) && ret.value !== "" ?
                                ret.value :
                                null;
                        }
                    };

                // Fixing value retrieval on a button requires this module
                jQuery.valHooks.button = {
                    get: function( elem, name ) {
                        var ret = elem.getAttributeNode( name );
                        if ( ret && ret.specified ) {
                            return ret.value;
                        }
                    },
                    set: nodeHook.set
                };

                // Set contenteditable to false on removals(#10429)
                // Setting to empty string throws an error as an invalid value
                jQuery.attrHooks.contenteditable = {
                    set: function( elem, value, name ) {
                        nodeHook.set( elem, value === "" ? false : value, name );
                    }
                };

                // Set width and height to auto instead of 0 on empty string( Bug #8150 )
                // This is for removals
                jQuery.each( [ "width", "height" ], function( i, name ) {
                    jQuery.attrHooks[ name ] = {
                        set: function( elem, value ) {
                            if ( value === "" ) {
                                elem.setAttribute( name, "auto" );
                                return value;
                            }
                        }
                    };
                } );
            }

            if ( !support.style ) {
                jQuery.attrHooks.style = {
                    get: function( elem ) {

                        // Return undefined in the case of empty string
                        // Note: IE uppercases css property names, but if we were to .toLowerCase()
                        // .cssText, that would destroy case sensitivity in URL's, like in "background"
                        return elem.style.cssText || undefined;
                    },
                    set: function( elem, value ) {
                        return ( elem.style.cssText = value + "" );
                    }
                };
            }




            var rfocusable = /^(?:input|select|textarea|button|object)$/i,
                rclickable = /^(?:a|area)$/i;

            jQuery.fn.extend( {
                prop: function( name, value ) {
                    return access( this, jQuery.prop, name, value, arguments.length > 1 );
                },

                removeProp: function( name ) {
                    name = jQuery.propFix[ name ] || name;
                    return this.each( function() {

                        // try/catch handles cases where IE balks (such as removing a property on window)
                        try {
                            this[ name ] = undefined;
                            delete this[ name ];
                        } catch ( e ) {}
                    } );
                }
            } );

            jQuery.extend( {
                prop: function( elem, name, value ) {
                    var ret, hooks,
                        nType = elem.nodeType;

                    // Don't get/set properties on text, comment and attribute nodes
                    if ( nType === 3 || nType === 8 || nType === 2 ) {
                        return;
                    }

                    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

                        // Fix name and attach hooks
                        name = jQuery.propFix[ name ] || name;
                        hooks = jQuery.propHooks[ name ];
                    }

                    if ( value !== undefined ) {
                        if ( hooks && "set" in hooks &&
                            ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                            return ret;
                        }

                        return ( elem[ name ] = value );
                    }

                    if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                        return ret;
                    }

                    return elem[ name ];
                },

                propHooks: {
                    tabIndex: {
                        get: function( elem ) {

                            // elem.tabIndex doesn't always return the
                            // correct value when it hasn't been explicitly set
                            // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                            // Use proper attribute retrieval(#12072)
                            var tabindex = jQuery.find.attr( elem, "tabindex" );

                            return tabindex ?
                                parseInt( tabindex, 10 ) :
                                rfocusable.test( elem.nodeName ) ||
                                rclickable.test( elem.nodeName ) && elem.href ?
                                    0 :
                                    -1;
                        }
                    }
                },

                propFix: {
                    "for": "htmlFor",
                    "class": "className"
                }
            } );

            // Some attributes require a special call on IE
            // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if ( !support.hrefNormalized ) {

                // href/src property should get the full normalized URL (#10299/#12915)
                jQuery.each( [ "href", "src" ], function( i, name ) {
                    jQuery.propHooks[ name ] = {
                        get: function( elem ) {
                            return elem.getAttribute( name, 4 );
                        }
                    };
                } );
            }

            // Support: Safari, IE9+
            // Accessing the selectedIndex property
            // forces the browser to respect setting selected
            // on the option
            // The getter ensures a default option is selected
            // when in an optgroup
            if ( !support.optSelected ) {
                jQuery.propHooks.selected = {
                    get: function( elem ) {
                        var parent = elem.parentNode;

                        if ( parent ) {
                            parent.selectedIndex;

                            // Make sure that it also works with optgroups, see #5701
                            if ( parent.parentNode ) {
                                parent.parentNode.selectedIndex;
                            }
                        }
                        return null;
                    },
                    set: function( elem ) {
                        var parent = elem.parentNode;
                        if ( parent ) {
                            parent.selectedIndex;

                            if ( parent.parentNode ) {
                                parent.parentNode.selectedIndex;
                            }
                        }
                    }
                };
            }

            jQuery.each( [
                "tabIndex",
                "readOnly",
                "maxLength",
                "cellSpacing",
                "cellPadding",
                "rowSpan",
                "colSpan",
                "useMap",
                "frameBorder",
                "contentEditable"
            ], function() {
                jQuery.propFix[ this.toLowerCase() ] = this;
            } );

            // IE6/7 call enctype encoding
            if ( !support.enctype ) {
                jQuery.propFix.enctype = "encoding";
            }




            var rclass = /[\t\r\n\f]/g;

            function getClass( elem ) {
                return jQuery.attr( elem, "class" ) || "";
            }

            jQuery.fn.extend( {
                addClass: function( value ) {
                    var classes, elem, cur, curValue, clazz, j, finalValue,
                        i = 0;

                    if ( jQuery.isFunction( value ) ) {
                        return this.each( function( j ) {
                            jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
                        } );
                    }

                    if ( typeof value === "string" && value ) {
                        classes = value.match( rnotwhite ) || [];

                        while ( ( elem = this[ i++ ] ) ) {
                            curValue = getClass( elem );
                            cur = elem.nodeType === 1 &&
                                ( " " + curValue + " " ).replace( rclass, " " );

                            if ( cur ) {
                                j = 0;
                                while ( ( clazz = classes[ j++ ] ) ) {
                                    if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                        cur += clazz + " ";
                                    }
                                }

                                // only assign if different to avoid unneeded rendering.
                                finalValue = jQuery.trim( cur );
                                if ( curValue !== finalValue ) {
                                    jQuery.attr( elem, "class", finalValue );
                                }
                            }
                        }
                    }

                    return this;
                },

                removeClass: function( value ) {
                    var classes, elem, cur, curValue, clazz, j, finalValue,
                        i = 0;

                    if ( jQuery.isFunction( value ) ) {
                        return this.each( function( j ) {
                            jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
                        } );
                    }

                    if ( !arguments.length ) {
                        return this.attr( "class", "" );
                    }

                    if ( typeof value === "string" && value ) {
                        classes = value.match( rnotwhite ) || [];

                        while ( ( elem = this[ i++ ] ) ) {
                            curValue = getClass( elem );

                            // This expression is here for better compressibility (see addClass)
                            cur = elem.nodeType === 1 &&
                                ( " " + curValue + " " ).replace( rclass, " " );

                            if ( cur ) {
                                j = 0;
                                while ( ( clazz = classes[ j++ ] ) ) {

                                    // Remove *all* instances
                                    while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
                                        cur = cur.replace( " " + clazz + " ", " " );
                                    }
                                }

                                // Only assign if different to avoid unneeded rendering.
                                finalValue = jQuery.trim( cur );
                                if ( curValue !== finalValue ) {
                                    jQuery.attr( elem, "class", finalValue );
                                }
                            }
                        }
                    }

                    return this;
                },

                toggleClass: function( value, stateVal ) {
                    var type = typeof value;

                    if ( typeof stateVal === "boolean" && type === "string" ) {
                        return stateVal ? this.addClass( value ) : this.removeClass( value );
                    }

                    if ( jQuery.isFunction( value ) ) {
                        return this.each( function( i ) {
                            jQuery( this ).toggleClass(
                                value.call( this, i, getClass( this ), stateVal ),
                                stateVal
                            );
                        } );
                    }

                    return this.each( function() {
                        var className, i, self, classNames;

                        if ( type === "string" ) {

                            // Toggle individual class names
                            i = 0;
                            self = jQuery( this );
                            classNames = value.match( rnotwhite ) || [];

                            while ( ( className = classNames[ i++ ] ) ) {

                                // Check each className given, space separated list
                                if ( self.hasClass( className ) ) {
                                    self.removeClass( className );
                                } else {
                                    self.addClass( className );
                                }
                            }

                            // Toggle whole class name
                        } else if ( value === undefined || type === "boolean" ) {
                            className = getClass( this );
                            if ( className ) {

                                // store className if set
                                jQuery._data( this, "__className__", className );
                            }

                            // If the element has a class name or if we're passed "false",
                            // then remove the whole classname (if there was one, the above saved it).
                            // Otherwise bring back whatever was previously saved (if anything),
                            // falling back to the empty string if nothing was stored.
                            jQuery.attr( this, "class",
                                className || value === false ?
                                    "" :
                                    jQuery._data( this, "__className__" ) || ""
                            );
                        }
                    } );
                },

                hasClass: function( selector ) {
                    var className, elem,
                        i = 0;

                    className = " " + selector + " ";
                    while ( ( elem = this[ i++ ] ) ) {
                        if ( elem.nodeType === 1 &&
                            ( " " + getClass( elem ) + " " ).replace( rclass, " " )
                                .indexOf( className ) > -1
                        ) {
                            return true;
                        }
                    }

                    return false;
                }
            } );




            // Return jQuery for attributes-only inclusion


            jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
                "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
                "change select submit keydown keypress keyup error contextmenu" ).split( " " ),
                function( i, name ) {

                    // Handle event binding
                    jQuery.fn[ name ] = function( data, fn ) {
                        return arguments.length > 0 ?
                            this.on( name, null, data, fn ) :
                            this.trigger( name );
                    };
                } );

            jQuery.fn.extend( {
                hover: function( fnOver, fnOut ) {
                    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
                }
            } );


            var location = window.location;

            var nonce = jQuery.now();

            var rquery = ( /\?/ );



            var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

            jQuery.parseJSON = function( data ) {

                // Attempt to parse using the native JSON parser first
                if ( window.JSON && window.JSON.parse ) {

                    // Support: Android 2.3
                    // Workaround failure to string-cast null input
                    return window.JSON.parse( data + "" );
                }

                var requireNonComma,
                    depth = null,
                    str = jQuery.trim( data + "" );

                // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
                // after removing valid tokens
                return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

                    // Force termination if we see a misplaced comma
                    if ( requireNonComma && comma ) {
                        depth = 0;
                    }

                    // Perform no more replacements after returning to outermost depth
                    if ( depth === 0 ) {
                        return token;
                    }

                    // Commas must not follow "[", "{", or ","
                    requireNonComma = open || comma;

                    // Determine new depth
                    // array/object open ("[" or "{"): depth += true - false (increment)
                    // array/object close ("]" or "}"): depth += false - true (decrement)
                    // other cases ("," or primitive): depth += true - true (numeric cast)
                    depth += !close - !open;

                    // Remove this token
                    return "";
                } ) ) ?
                    ( Function( "return " + str ) )() :
                    jQuery.error( "Invalid JSON: " + data );
            };


            // Cross-browser xml parsing
            jQuery.parseXML = function( data ) {
                var xml, tmp;
                if ( !data || typeof data !== "string" ) {
                    return null;
                }
                try {
                    if ( window.DOMParser ) { // Standard
                        tmp = new window.DOMParser();
                        xml = tmp.parseFromString( data, "text/xml" );
                    } else { // IE
                        xml = new window.ActiveXObject( "Microsoft.XMLDOM" );
                        xml.async = "false";
                        xml.loadXML( data );
                    }
                } catch ( e ) {
                    xml = undefined;
                }
                if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
                    jQuery.error( "Invalid XML: " + data );
                }
                return xml;
            };


            var
                rhash = /#.*$/,
                rts = /([?&])_=[^&]*/,

                // IE leaves an \r character at EOL
                rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,

                // #7653, #8125, #8152: local protocol detection
                rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                rnoContent = /^(?:GET|HEAD)$/,
                rprotocol = /^\/\//,
                rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

                /* Prefilters
    	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
    	 * 2) These are called:
    	 *    - BEFORE asking for a transport
    	 *    - AFTER param serialization (s.data is a string if s.processData is true)
    	 * 3) key is the dataType
    	 * 4) the catchall symbol "*" can be used
    	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
    	 */
                prefilters = {},

                /* Transports bindings
    	 * 1) key is the dataType
    	 * 2) the catchall symbol "*" can be used
    	 * 3) selection will start with transport dataType and THEN go to "*" if needed
    	 */
                transports = {},

                // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                allTypes = "*/".concat( "*" ),

                // Document location
                ajaxLocation = location.href,

                // Segment location into parts
                ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

            // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
            function addToPrefiltersOrTransports( structure ) {

                // dataTypeExpression is optional and defaults to "*"
                return function( dataTypeExpression, func ) {

                    if ( typeof dataTypeExpression !== "string" ) {
                        func = dataTypeExpression;
                        dataTypeExpression = "*";
                    }

                    var dataType,
                        i = 0,
                        dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

                    if ( jQuery.isFunction( func ) ) {

                        // For each dataType in the dataTypeExpression
                        while ( ( dataType = dataTypes[ i++ ] ) ) {

                            // Prepend if requested
                            if ( dataType.charAt( 0 ) === "+" ) {
                                dataType = dataType.slice( 1 ) || "*";
                                ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

                                // Otherwise append
                            } else {
                                ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
                            }
                        }
                    }
                };
            }

            // Base inspection function for prefilters and transports
            function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

                var inspected = {},
                    seekingTransport = ( structure === transports );

                function inspect( dataType ) {
                    var selected;
                    inspected[ dataType ] = true;
                    jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                        var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                        if ( typeof dataTypeOrTransport === "string" &&
                            !seekingTransport && !inspected[ dataTypeOrTransport ] ) {

                            options.dataTypes.unshift( dataTypeOrTransport );
                            inspect( dataTypeOrTransport );
                            return false;
                        } else if ( seekingTransport ) {
                            return !( selected = dataTypeOrTransport );
                        }
                    } );
                    return selected;
                }

                return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
            }

            // A special extend for ajax options
            // that takes "flat" options (not to be deep extended)
            // Fixes #9887
            function ajaxExtend( target, src ) {
                var deep, key,
                    flatOptions = jQuery.ajaxSettings.flatOptions || {};

                for ( key in src ) {
                    if ( src[ key ] !== undefined ) {
                        ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
                    }
                }
                if ( deep ) {
                    jQuery.extend( true, target, deep );
                }

                return target;
            }

            /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
            function ajaxHandleResponses( s, jqXHR, responses ) {
                var firstDataType, ct, finalDataType, type,
                    contents = s.contents,
                    dataTypes = s.dataTypes;

                // Remove auto dataType and get content-type in the process
                while ( dataTypes[ 0 ] === "*" ) {
                    dataTypes.shift();
                    if ( ct === undefined ) {
                        ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
                    }
                }

                // Check if we're dealing with a known content-type
                if ( ct ) {
                    for ( type in contents ) {
                        if ( contents[ type ] && contents[ type ].test( ct ) ) {
                            dataTypes.unshift( type );
                            break;
                        }
                    }
                }

                // Check to see if we have a response for the expected dataType
                if ( dataTypes[ 0 ] in responses ) {
                    finalDataType = dataTypes[ 0 ];
                } else {

                    // Try convertible dataTypes
                    for ( type in responses ) {
                        if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
                            finalDataType = type;
                            break;
                        }
                        if ( !firstDataType ) {
                            firstDataType = type;
                        }
                    }

                    // Or just use first one
                    finalDataType = finalDataType || firstDataType;
                }

                // If we found a dataType
                // We add the dataType to the list if needed
                // and return the corresponding response
                if ( finalDataType ) {
                    if ( finalDataType !== dataTypes[ 0 ] ) {
                        dataTypes.unshift( finalDataType );
                    }
                    return responses[ finalDataType ];
                }
            }

            /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */
            function ajaxConvert( s, response, jqXHR, isSuccess ) {
                var conv2, current, conv, tmp, prev,
                    converters = {},

                    // Work with a copy of dataTypes in case we need to modify it for conversion
                    dataTypes = s.dataTypes.slice();

                // Create converters map with lowercased keys
                if ( dataTypes[ 1 ] ) {
                    for ( conv in s.converters ) {
                        converters[ conv.toLowerCase() ] = s.converters[ conv ];
                    }
                }

                current = dataTypes.shift();

                // Convert to each sequential dataType
                while ( current ) {

                    if ( s.responseFields[ current ] ) {
                        jqXHR[ s.responseFields[ current ] ] = response;
                    }

                    // Apply the dataFilter if provided
                    if ( !prev && isSuccess && s.dataFilter ) {
                        response = s.dataFilter( response, s.dataType );
                    }

                    prev = current;
                    current = dataTypes.shift();

                    if ( current ) {

                        // There's only work to do if current dataType is non-auto
                        if ( current === "*" ) {

                            current = prev;

                            // Convert response if prev dataType is non-auto and differs from current
                        } else if ( prev !== "*" && prev !== current ) {

                            // Seek a direct converter
                            conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                            // If none found, seek a pair
                            if ( !conv ) {
                                for ( conv2 in converters ) {

                                    // If conv2 outputs current
                                    tmp = conv2.split( " " );
                                    if ( tmp[ 1 ] === current ) {

                                        // If prev can be converted to accepted input
                                        conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                            converters[ "* " + tmp[ 0 ] ];
                                        if ( conv ) {

                                            // Condense equivalence converters
                                            if ( conv === true ) {
                                                conv = converters[ conv2 ];

                                                // Otherwise, insert the intermediate dataType
                                            } else if ( converters[ conv2 ] !== true ) {
                                                current = tmp[ 0 ];
                                                dataTypes.unshift( tmp[ 1 ] );
                                            }
                                            break;
                                        }
                                    }
                                }
                            }

                            // Apply converter (if not an equivalence)
                            if ( conv !== true ) {

                                // Unless errors are allowed to bubble, catch and return them
                                if ( conv && s[ "throws" ] ) { // jscs:ignore requireDotNotation
                                    response = conv( response );
                                } else {
                                    try {
                                        response = conv( response );
                                    } catch ( e ) {
                                        return {
                                            state: "parsererror",
                                            error: conv ? e : "No conversion from " + prev + " to " + current
                                        };
                                    }
                                }
                            }
                        }
                    }
                }

                return { state: "success", data: response };
            }

            jQuery.extend( {

                // Counter for holding the number of active queries
                active: 0,

                // Last-Modified header cache for next request
                lastModified: {},
                etag: {},

                ajaxSettings: {
                    url: ajaxLocation,
                    type: "GET",
                    isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
                    global: true,
                    processData: true,
                    async: true,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    /*
    		timeout: 0,
    		data: null,
    		dataType: null,
    		username: null,
    		password: null,
    		cache: null,
    		throws: false,
    		traditional: false,
    		headers: {},
    		*/

                    accepts: {
                        "*": allTypes,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },

                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },

                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },

                    // Data converters
                    // Keys separate source (or catchall "*") and destination types with a single space
                    converters: {

                        // Convert anything to text
                        "* text": String,

                        // Text to html (true = no transformation)
                        "text html": true,

                        // Evaluate text as a json expression
                        "text json": jQuery.parseJSON,

                        // Parse text as xml
                        "text xml": jQuery.parseXML
                    },

                    // For options that shouldn't be deep extended:
                    // you can add your own custom options here if
                    // and when you create one that shouldn't be
                    // deep extended (see ajaxExtend)
                    flatOptions: {
                        url: true,
                        context: true
                    }
                },

                // Creates a full fledged settings object into target
                // with both ajaxSettings and settings fields.
                // If target is omitted, writes into ajaxSettings.
                ajaxSetup: function( target, settings ) {
                    return settings ?

                        // Building a settings object
                        ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

                        // Extending ajaxSettings
                        ajaxExtend( jQuery.ajaxSettings, target );
                },

                ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
                ajaxTransport: addToPrefiltersOrTransports( transports ),

                // Main method
                ajax: function( url, options ) {

                    // If url is an object, simulate pre-1.5 signature
                    if ( typeof url === "object" ) {
                        options = url;
                        url = undefined;
                    }

                    // Force options to be an object
                    options = options || {};

                    var

                        // Cross-domain detection vars
                        parts,

                        // Loop variable
                        i,

                        // URL without anti-cache param
                        cacheURL,

                        // Response headers as string
                        responseHeadersString,

                        // timeout handle
                        timeoutTimer,

                        // To know if global events are to be dispatched
                        fireGlobals,

                        transport,

                        // Response headers
                        responseHeaders,

                        // Create the final options object
                        s = jQuery.ajaxSetup( {}, options ),

                        // Callbacks context
                        callbackContext = s.context || s,

                        // Context for global events is callbackContext if it is a DOM node or jQuery collection
                        globalEventContext = s.context &&
                        ( callbackContext.nodeType || callbackContext.jquery ) ?
                            jQuery( callbackContext ) :
                            jQuery.event,

                        // Deferreds
                        deferred = jQuery.Deferred(),
                        completeDeferred = jQuery.Callbacks( "once memory" ),

                        // Status-dependent callbacks
                        statusCode = s.statusCode || {},

                        // Headers (they are sent all at once)
                        requestHeaders = {},
                        requestHeadersNames = {},

                        // The jqXHR state
                        state = 0,

                        // Default abort message
                        strAbort = "canceled",

                        // Fake xhr
                        jqXHR = {
                            readyState: 0,

                            // Builds headers hashtable if needed
                            getResponseHeader: function( key ) {
                                var match;
                                if ( state === 2 ) {
                                    if ( !responseHeaders ) {
                                        responseHeaders = {};
                                        while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                            responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
                                        }
                                    }
                                    match = responseHeaders[ key.toLowerCase() ];
                                }
                                return match == null ? null : match;
                            },

                            // Raw string
                            getAllResponseHeaders: function() {
                                return state === 2 ? responseHeadersString : null;
                            },

                            // Caches the header
                            setRequestHeader: function( name, value ) {
                                var lname = name.toLowerCase();
                                if ( !state ) {
                                    name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                                    requestHeaders[ name ] = value;
                                }
                                return this;
                            },

                            // Overrides response content-type header
                            overrideMimeType: function( type ) {
                                if ( !state ) {
                                    s.mimeType = type;
                                }
                                return this;
                            },

                            // Status-dependent callbacks
                            statusCode: function( map ) {
                                var code;
                                if ( map ) {
                                    if ( state < 2 ) {
                                        for ( code in map ) {

                                            // Lazy-add the new callback in a way that preserves old ones
                                            statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                        }
                                    } else {

                                        // Execute the appropriate callbacks
                                        jqXHR.always( map[ jqXHR.status ] );
                                    }
                                }
                                return this;
                            },

                            // Cancel the request
                            abort: function( statusText ) {
                                var finalText = statusText || strAbort;
                                if ( transport ) {
                                    transport.abort( finalText );
                                }
                                done( 0, finalText );
                                return this;
                            }
                        };

                    // Attach deferreds
                    deferred.promise( jqXHR ).complete = completeDeferred.add;
                    jqXHR.success = jqXHR.done;
                    jqXHR.error = jqXHR.fail;

                    // Remove hash character (#7531: and string promotion)
                    // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
                    // Handle falsy url in the settings object (#10093: consistency with old signature)
                    // We also use the url parameter if available
                    s.url = ( ( url || s.url || ajaxLocation ) + "" )
                        .replace( rhash, "" )
                        .replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

                    // Alias method option to type as per ticket #12004
                    s.type = options.method || options.type || s.method || s.type;

                    // Extract dataTypes list
                    s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

                    // A cross-domain request is in order when we have a protocol:host:port mismatch
                    if ( s.crossDomain == null ) {
                        parts = rurl.exec( s.url.toLowerCase() );
                        s.crossDomain = !!( parts &&
                            ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                                ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
                                ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
                        );
                    }

                    // Convert data if not already a string
                    if ( s.data && s.processData && typeof s.data !== "string" ) {
                        s.data = jQuery.param( s.data, s.traditional );
                    }

                    // Apply prefilters
                    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

                    // If request was aborted inside a prefilter, stop there
                    if ( state === 2 ) {
                        return jqXHR;
                    }

                    // We can fire global events as of now if asked to
                    // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                    fireGlobals = jQuery.event && s.global;

                    // Watch for a new set of requests
                    if ( fireGlobals && jQuery.active++ === 0 ) {
                        jQuery.event.trigger( "ajaxStart" );
                    }

                    // Uppercase the type
                    s.type = s.type.toUpperCase();

                    // Determine if request has content
                    s.hasContent = !rnoContent.test( s.type );

                    // Save the URL in case we're toying with the If-Modified-Since
                    // and/or If-None-Match header later on
                    cacheURL = s.url;

                    // More options handling for requests with no content
                    if ( !s.hasContent ) {

                        // If data is available, append data to url
                        if ( s.data ) {
                            cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

                            // #9682: remove data so that it's not used in an eventual retry
                            delete s.data;
                        }

                        // Add anti-cache in url if needed
                        if ( s.cache === false ) {
                            s.url = rts.test( cacheURL ) ?

                                // If there is already a '_' parameter, set its value
                                cacheURL.replace( rts, "$1_=" + nonce++ ) :

                                // Otherwise add one to the end
                                cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
                        }
                    }

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if ( s.ifModified ) {
                        if ( jQuery.lastModified[ cacheURL ] ) {
                            jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                        }
                        if ( jQuery.etag[ cacheURL ] ) {
                            jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                        }
                    }

                    // Set the correct header, if data is being sent
                    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                        jqXHR.setRequestHeader( "Content-Type", s.contentType );
                    }

                    // Set the Accepts header for the server, depending on the dataType
                    jqXHR.setRequestHeader(
                        "Accept",
                        s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
                            s.accepts[ s.dataTypes[ 0 ] ] +
                            ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                            s.accepts[ "*" ]
                    );

                    // Check for headers option
                    for ( i in s.headers ) {
                        jqXHR.setRequestHeader( i, s.headers[ i ] );
                    }

                    // Allow custom headers/mimetypes and early abort
                    if ( s.beforeSend &&
                        ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

                        // Abort if not done already and return
                        return jqXHR.abort();
                    }

                    // aborting is no longer a cancellation
                    strAbort = "abort";

                    // Install callbacks on deferreds
                    for ( i in { success: 1, error: 1, complete: 1 } ) {
                        jqXHR[ i ]( s[ i ] );
                    }

                    // Get transport
                    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

                    // If no transport, we auto-abort
                    if ( !transport ) {
                        done( -1, "No Transport" );
                    } else {
                        jqXHR.readyState = 1;

                        // Send global event
                        if ( fireGlobals ) {
                            globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                        }

                        // If request was aborted inside ajaxSend, stop there
                        if ( state === 2 ) {
                            return jqXHR;
                        }

                        // Timeout
                        if ( s.async && s.timeout > 0 ) {
                            timeoutTimer = window.setTimeout( function() {
                                jqXHR.abort( "timeout" );
                            }, s.timeout );
                        }

                        try {
                            state = 1;
                            transport.send( requestHeaders, done );
                        } catch ( e ) {

                            // Propagate exception as error if not done
                            if ( state < 2 ) {
                                done( -1, e );

                                // Simply rethrow otherwise
                            } else {
                                throw e;
                            }
                        }
                    }

                    // Callback for when everything is done
                    function done( status, nativeStatusText, responses, headers ) {
                        var isSuccess, success, error, response, modified,
                            statusText = nativeStatusText;

                        // Called once
                        if ( state === 2 ) {
                            return;
                        }

                        // State is "done" now
                        state = 2;

                        // Clear timeout if it exists
                        if ( timeoutTimer ) {
                            window.clearTimeout( timeoutTimer );
                        }

                        // Dereference transport for early garbage collection
                        // (no matter how long the jqXHR object will be used)
                        transport = undefined;

                        // Cache response headers
                        responseHeadersString = headers || "";

                        // Set readyState
                        jqXHR.readyState = status > 0 ? 4 : 0;

                        // Determine if successful
                        isSuccess = status >= 200 && status < 300 || status === 304;

                        // Get response data
                        if ( responses ) {
                            response = ajaxHandleResponses( s, jqXHR, responses );
                        }

                        // Convert no matter what (that way responseXXX fields are always set)
                        response = ajaxConvert( s, response, jqXHR, isSuccess );

                        // If successful, handle type chaining
                        if ( isSuccess ) {

                            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            if ( s.ifModified ) {
                                modified = jqXHR.getResponseHeader( "Last-Modified" );
                                if ( modified ) {
                                    jQuery.lastModified[ cacheURL ] = modified;
                                }
                                modified = jqXHR.getResponseHeader( "etag" );
                                if ( modified ) {
                                    jQuery.etag[ cacheURL ] = modified;
                                }
                            }

                            // if no content
                            if ( status === 204 || s.type === "HEAD" ) {
                                statusText = "nocontent";

                                // if not modified
                            } else if ( status === 304 ) {
                                statusText = "notmodified";

                                // If we have data, let's convert it
                            } else {
                                statusText = response.state;
                                success = response.data;
                                error = response.error;
                                isSuccess = !error;
                            }
                        } else {

                            // We extract error from statusText
                            // then normalize statusText and status for non-aborts
                            error = statusText;
                            if ( status || !statusText ) {
                                statusText = "error";
                                if ( status < 0 ) {
                                    status = 0;
                                }
                            }
                        }

                        // Set data for the fake xhr object
                        jqXHR.status = status;
                        jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                        // Success/Error
                        if ( isSuccess ) {
                            deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                        } else {
                            deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                        }

                        // Status-dependent callbacks
                        jqXHR.statusCode( statusCode );
                        statusCode = undefined;

                        if ( fireGlobals ) {
                            globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                                [ jqXHR, s, isSuccess ? success : error ] );
                        }

                        // Complete
                        completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                        if ( fireGlobals ) {
                            globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

                            // Handle the global AJAX counter
                            if ( !( --jQuery.active ) ) {
                                jQuery.event.trigger( "ajaxStop" );
                            }
                        }
                    }

                    return jqXHR;
                },

                getJSON: function( url, data, callback ) {
                    return jQuery.get( url, data, callback, "json" );
                },

                getScript: function( url, callback ) {
                    return jQuery.get( url, undefined, callback, "script" );
                }
            } );

            jQuery.each( [ "get", "post" ], function( i, method ) {
                jQuery[ method ] = function( url, data, callback, type ) {

                    // shift arguments if data argument was omitted
                    if ( jQuery.isFunction( data ) ) {
                        type = type || callback;
                        callback = data;
                        data = undefined;
                    }

                    // The url can be an options object (which then must have .url)
                    return jQuery.ajax( jQuery.extend( {
                        url: url,
                        type: method,
                        dataType: type,
                        data: data,
                        success: callback
                    }, jQuery.isPlainObject( url ) && url ) );
                };
            } );


            jQuery._evalUrl = function( url ) {
                return jQuery.ajax( {
                    url: url,

                    // Make this explicit, since user can override this through ajaxSetup (#11264)
                    type: "GET",
                    dataType: "script",
                    cache: true,
                    async: false,
                    global: false,
                    "throws": true
                } );
            };


            jQuery.fn.extend( {
                wrapAll: function( html ) {
                    if ( jQuery.isFunction( html ) ) {
                        return this.each( function( i ) {
                            jQuery( this ).wrapAll( html.call( this, i ) );
                        } );
                    }

                    if ( this[ 0 ] ) {

                        // The elements to wrap the target around
                        var wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

                        if ( this[ 0 ].parentNode ) {
                            wrap.insertBefore( this[ 0 ] );
                        }

                        wrap.map( function() {
                            var elem = this;

                            while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                                elem = elem.firstChild;
                            }

                            return elem;
                        } ).append( this );
                    }

                    return this;
                },

                wrapInner: function( html ) {
                    if ( jQuery.isFunction( html ) ) {
                        return this.each( function( i ) {
                            jQuery( this ).wrapInner( html.call( this, i ) );
                        } );
                    }

                    return this.each( function() {
                        var self = jQuery( this ),
                            contents = self.contents();

                        if ( contents.length ) {
                            contents.wrapAll( html );

                        } else {
                            self.append( html );
                        }
                    } );
                },

                wrap: function( html ) {
                    var isFunction = jQuery.isFunction( html );

                    return this.each( function( i ) {
                        jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
                    } );
                },

                unwrap: function() {
                    return this.parent().each( function() {
                        if ( !jQuery.nodeName( this, "body" ) ) {
                            jQuery( this ).replaceWith( this.childNodes );
                        }
                    } ).end();
                }
            } );


            function getDisplay( elem ) {
                return elem.style && elem.style.display || jQuery.css( elem, "display" );
            }

            function filterHidden( elem ) {

                // Disconnected elements are considered hidden
                if ( !jQuery.contains( elem.ownerDocument || document, elem ) ) {
                    return true;
                }
                while ( elem && elem.nodeType === 1 ) {
                    if ( getDisplay( elem ) === "none" || elem.type === "hidden" ) {
                        return true;
                    }
                    elem = elem.parentNode;
                }
                return false;
            }

            jQuery.expr.filters.hidden = function( elem ) {

                // Support: Opera <= 12.12
                // Opera reports offsetWidths and offsetHeights less than zero on some elements
                return support.reliableHiddenOffsets() ?
                    ( elem.offsetWidth <= 0 && elem.offsetHeight <= 0 &&
                        !elem.getClientRects().length ) :
                    filterHidden( elem );
            };

            jQuery.expr.filters.visible = function( elem ) {
                return !jQuery.expr.filters.hidden( elem );
            };




            var r20 = /%20/g,
                rbracket = /\[\]$/,
                rCRLF = /\r?\n/g,
                rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                rsubmittable = /^(?:input|select|textarea|keygen)/i;

            function buildParams( prefix, obj, traditional, add ) {
                var name;

                if ( jQuery.isArray( obj ) ) {

                    // Serialize array item.
                    jQuery.each( obj, function( i, v ) {
                        if ( traditional || rbracket.test( prefix ) ) {

                            // Treat each array item as a scalar.
                            add( prefix, v );

                        } else {

                            // Item is non-scalar (array or object), encode its numeric index.
                            buildParams(
                                prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
                                v,
                                traditional,
                                add
                            );
                        }
                    } );

                } else if ( !traditional && jQuery.type( obj ) === "object" ) {

                    // Serialize object item.
                    for ( name in obj ) {
                        buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
                    }

                } else {

                    // Serialize scalar item.
                    add( prefix, obj );
                }
            }

            // Serialize an array of form elements or a set of
            // key/values into a query string
            jQuery.param = function( a, traditional ) {
                var prefix,
                    s = [],
                    add = function( key, value ) {

                        // If value is a function, invoke it and return its value
                        value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
                        s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
                    };

                // Set traditional to true for jQuery <= 1.3.2 behavior.
                if ( traditional === undefined ) {
                    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                }

                // If an array was passed in, assume that it is an array of form elements.
                if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

                    // Serialize the form elements
                    jQuery.each( a, function() {
                        add( this.name, this.value );
                    } );

                } else {

                    // If traditional, encode the "old" way (the way 1.3.2 or older
                    // did it), otherwise encode params recursively.
                    for ( prefix in a ) {
                        buildParams( prefix, a[ prefix ], traditional, add );
                    }
                }

                // Return the resulting serialization
                return s.join( "&" ).replace( r20, "+" );
            };

            jQuery.fn.extend( {
                serialize: function() {
                    return jQuery.param( this.serializeArray() );
                },
                serializeArray: function() {
                    return this.map( function() {

                        // Can add propHook for "elements" to filter or add form elements
                        var elements = jQuery.prop( this, "elements" );
                        return elements ? jQuery.makeArray( elements ) : this;
                    } )
                        .filter( function() {
                            var type = this.type;

                            // Use .is(":disabled") so that fieldset[disabled] works
                            return this.name && !jQuery( this ).is( ":disabled" ) &&
                                rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                                ( this.checked || !rcheckableType.test( type ) );
                        } )
                        .map( function( i, elem ) {
                            var val = jQuery( this ).val();

                            return val == null ?
                                null :
                                jQuery.isArray( val ) ?
                                    jQuery.map( val, function( val ) {
                                        return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                                    } ) :
                                    { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                        } ).get();
                }
            } );


            // Create the request object
            // (This is still attached to ajaxSettings for backward compatibility)
            jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?

                // Support: IE6-IE8
                function() {

                    // XHR cannot access local files, always use ActiveX for that case
                    if ( this.isLocal ) {
                        return createActiveXHR();
                    }

                    // Support: IE 9-11
                    // IE seems to error on cross-domain PATCH requests when ActiveX XHR
                    // is used. In IE 9+ always use the native XHR.
                    // Note: this condition won't catch Edge as it doesn't define
                    // document.documentMode but it also doesn't support ActiveX so it won't
                    // reach this code.
                    if ( document.documentMode > 8 ) {
                        return createStandardXHR();
                    }

                    // Support: IE<9
                    // oldIE XHR does not support non-RFC2616 methods (#13240)
                    // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
                    // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
                    // Although this check for six methods instead of eight
                    // since IE also does not support "trace" and "connect"
                    return /^(get|post|head|put|delete|options)$/i.test( this.type ) &&
                        createStandardXHR() || createActiveXHR();
                } :

                // For all other browsers, use the standard XMLHttpRequest object
                createStandardXHR;

            var xhrId = 0,
                xhrCallbacks = {},
                xhrSupported = jQuery.ajaxSettings.xhr();

            // Support: IE<10
            // Open requests must be manually aborted on unload (#5280)
            // See https://support.microsoft.com/kb/2856746 for more info
            if ( window.attachEvent ) {
                window.attachEvent( "onunload", function() {
                    for ( var key in xhrCallbacks ) {
                        xhrCallbacks[ key ]( undefined, true );
                    }
                } );
            }

            // Determine support properties
            support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
            xhrSupported = support.ajax = !!xhrSupported;

            // Create transport if the browser can provide an xhr
            if ( xhrSupported ) {

                jQuery.ajaxTransport( function( options ) {

                    // Cross domain only allowed if supported through XMLHttpRequest
                    if ( !options.crossDomain || support.cors ) {

                        var callback;

                        return {
                            send: function( headers, complete ) {
                                var i,
                                    xhr = options.xhr(),
                                    id = ++xhrId;

                                // Open the socket
                                xhr.open(
                                    options.type,
                                    options.url,
                                    options.async,
                                    options.username,
                                    options.password
                                );

                                // Apply custom fields if provided
                                if ( options.xhrFields ) {
                                    for ( i in options.xhrFields ) {
                                        xhr[ i ] = options.xhrFields[ i ];
                                    }
                                }

                                // Override mime type if needed
                                if ( options.mimeType && xhr.overrideMimeType ) {
                                    xhr.overrideMimeType( options.mimeType );
                                }

                                // X-Requested-With header
                                // For cross-domain requests, seeing as conditions for a preflight are
                                // akin to a jigsaw puzzle, we simply never set it to be sure.
                                // (it can always be set on a per-request basis or even using ajaxSetup)
                                // For same-domain requests, won't change header if already provided.
                                if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
                                    headers[ "X-Requested-With" ] = "XMLHttpRequest";
                                }

                                // Set headers
                                for ( i in headers ) {

                                    // Support: IE<9
                                    // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
                                    // request header to a null-value.
                                    //
                                    // To keep consistent with other XHR implementations, cast the value
                                    // to string and ignore `undefined`.
                                    if ( headers[ i ] !== undefined ) {
                                        xhr.setRequestHeader( i, headers[ i ] + "" );
                                    }
                                }

                                // Do send the request
                                // This may raise an exception which is actually
                                // handled in jQuery.ajax (so no try/catch here)
                                xhr.send( ( options.hasContent && options.data ) || null );

                                // Listener
                                callback = function( _, isAbort ) {
                                    var status, statusText, responses;

                                    // Was never called and is aborted or complete
                                    if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

                                        // Clean up
                                        delete xhrCallbacks[ id ];
                                        callback = undefined;
                                        xhr.onreadystatechange = jQuery.noop;

                                        // Abort manually if needed
                                        if ( isAbort ) {
                                            if ( xhr.readyState !== 4 ) {
                                                xhr.abort();
                                            }
                                        } else {
                                            responses = {};
                                            status = xhr.status;

                                            // Support: IE<10
                                            // Accessing binary-data responseText throws an exception
                                            // (#11426)
                                            if ( typeof xhr.responseText === "string" ) {
                                                responses.text = xhr.responseText;
                                            }

                                            // Firefox throws an exception when accessing
                                            // statusText for faulty cross-domain requests
                                            try {
                                                statusText = xhr.statusText;
                                            } catch ( e ) {

                                                // We normalize with Webkit giving an empty statusText
                                                statusText = "";
                                            }

                                            // Filter status for non standard behaviors

                                            // If the request is local and we have data: assume a success
                                            // (success with no data won't get notified, that's the best we
                                            // can do given current implementations)
                                            if ( !status && options.isLocal && !options.crossDomain ) {
                                                status = responses.text ? 200 : 404;

                                                // IE - #1450: sometimes returns 1223 when it should be 204
                                            } else if ( status === 1223 ) {
                                                status = 204;
                                            }
                                        }
                                    }

                                    // Call complete if needed
                                    if ( responses ) {
                                        complete( status, statusText, responses, xhr.getAllResponseHeaders() );
                                    }
                                };

                                // Do send the request
                                // `xhr.send` may raise an exception, but it will be
                                // handled in jQuery.ajax (so no try/catch here)
                                if ( !options.async ) {

                                    // If we're in sync mode we fire the callback
                                    callback();
                                } else if ( xhr.readyState === 4 ) {

                                    // (IE6 & IE7) if it's in cache and has been
                                    // retrieved directly we need to fire the callback
                                    window.setTimeout( callback );
                                } else {

                                    // Register the callback, but delay it in case `xhr.send` throws
                                    // Add to the list of active xhr callbacks
                                    xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
                                }
                            },

                            abort: function() {
                                if ( callback ) {
                                    callback( undefined, true );
                                }
                            }
                        };
                    }
                } );
            }

            // Functions to create xhrs
            function createStandardXHR() {
                try {
                    return new window.XMLHttpRequest();
                } catch ( e ) {}
            }

            function createActiveXHR() {
                try {
                    return new window.ActiveXObject( "Microsoft.XMLHTTP" );
                } catch ( e ) {}
            }




            // Install script dataType
            jQuery.ajaxSetup( {
                accepts: {
                    script: "text/javascript, application/javascript, " +
                        "application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function( text ) {
                        jQuery.globalEval( text );
                        return text;
                    }
                }
            } );

            // Handle cache's special case and global
            jQuery.ajaxPrefilter( "script", function( s ) {
                if ( s.cache === undefined ) {
                    s.cache = false;
                }
                if ( s.crossDomain ) {
                    s.type = "GET";
                    s.global = false;
                }
            } );

            // Bind script tag hack transport
            jQuery.ajaxTransport( "script", function( s ) {

                // This transport only deals with cross domain requests
                if ( s.crossDomain ) {

                    var script,
                        head = document.head || jQuery( "head" )[ 0 ] || document.documentElement;

                    return {

                        send: function( _, callback ) {

                            script = document.createElement( "script" );

                            script.async = true;

                            if ( s.scriptCharset ) {
                                script.charset = s.scriptCharset;
                            }

                            script.src = s.url;

                            // Attach handlers for all browsers
                            script.onload = script.onreadystatechange = function( _, isAbort ) {

                                if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                                    // Handle memory leak in IE
                                    script.onload = script.onreadystatechange = null;

                                    // Remove the script
                                    if ( script.parentNode ) {
                                        script.parentNode.removeChild( script );
                                    }

                                    // Dereference the script
                                    script = null;

                                    // Callback if not abort
                                    if ( !isAbort ) {
                                        callback( 200, "success" );
                                    }
                                }
                            };

                            // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                            // Use native DOM manipulation to avoid our domManip AJAX trickery
                            head.insertBefore( script, head.firstChild );
                        },

                        abort: function() {
                            if ( script ) {
                                script.onload( undefined, true );
                            }
                        }
                    };
                }
            } );




            var oldCallbacks = [],
                rjsonp = /(=)\?(?=&|$)|\?\?/;

            // Default jsonp settings
            jQuery.ajaxSetup( {
                jsonp: "callback",
                jsonpCallback: function() {
                    var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
                    this[ callback ] = true;
                    return callback;
                }
            } );

            // Detect, normalize options and install callbacks for jsonp requests
            jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

                var callbackName, overwritten, responseContainer,
                    jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                            "url" :
                            typeof s.data === "string" &&
                            ( s.contentType || "" )
                                .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
                            rjsonp.test( s.data ) && "data"
                    );

                // Handle iff the expected data type is "jsonp" or we have a parameter to set
                if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

                    // Get callback name, remembering preexisting value associated with it
                    callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                        s.jsonpCallback() :
                        s.jsonpCallback;

                    // Insert callback into url or form data
                    if ( jsonProp ) {
                        s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
                    } else if ( s.jsonp !== false ) {
                        s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
                    }

                    // Use data converter to retrieve json after script execution
                    s.converters[ "script json" ] = function() {
                        if ( !responseContainer ) {
                            jQuery.error( callbackName + " was not called" );
                        }
                        return responseContainer[ 0 ];
                    };

                    // force json dataType
                    s.dataTypes[ 0 ] = "json";

                    // Install callback
                    overwritten = window[ callbackName ];
                    window[ callbackName ] = function() {
                        responseContainer = arguments;
                    };

                    // Clean-up function (fires after converters)
                    jqXHR.always( function() {

                        // If previous value didn't exist - remove it
                        if ( overwritten === undefined ) {
                            jQuery( window ).removeProp( callbackName );

                            // Otherwise restore preexisting value
                        } else {
                            window[ callbackName ] = overwritten;
                        }

                        // Save back as free
                        if ( s[ callbackName ] ) {

                            // make sure that re-using the options doesn't screw things around
                            s.jsonpCallback = originalSettings.jsonpCallback;

                            // save the callback name for future use
                            oldCallbacks.push( callbackName );
                        }

                        // Call if it was a function and we have a response
                        if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                            overwritten( responseContainer[ 0 ] );
                        }

                        responseContainer = overwritten = undefined;
                    } );

                    // Delegate to script
                    return "script";
                }
            } );




            // data: string of html
            // context (optional): If specified, the fragment will be created in this context,
            // defaults to document
            // keepScripts (optional): If true, will include scripts passed in the html string
            jQuery.parseHTML = function( data, context, keepScripts ) {
                if ( !data || typeof data !== "string" ) {
                    return null;
                }
                if ( typeof context === "boolean" ) {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;

                var parsed = rsingleTag.exec( data ),
                    scripts = !keepScripts && [];

                // Single tag
                if ( parsed ) {
                    return [ context.createElement( parsed[ 1 ] ) ];
                }

                parsed = buildFragment( [ data ], context, scripts );

                if ( scripts && scripts.length ) {
                    jQuery( scripts ).remove();
                }

                return jQuery.merge( [], parsed.childNodes );
            };


            // Keep a copy of the old load method
            var _load = jQuery.fn.load;

            /**
             * Load a url into a page
             */
            jQuery.fn.load = function( url, params, callback ) {
                if ( typeof url !== "string" && _load ) {
                    return _load.apply( this, arguments );
                }

                var selector, type, response,
                    self = this,
                    off = url.indexOf( " " );

                if ( off > -1 ) {
                    selector = jQuery.trim( url.slice( off, url.length ) );
                    url = url.slice( 0, off );
                }

                // If it's a function
                if ( jQuery.isFunction( params ) ) {

                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if ( params && typeof params === "object" ) {
                    type = "POST";
                }

                // If we have elements to modify, make the request
                if ( self.length > 0 ) {
                    jQuery.ajax( {
                        url: url,

                        // If "type" variable is undefined, then "GET" method will be used.
                        // Make value of this field explicit since
                        // user can override it through ajaxSetup method
                        type: type || "GET",
                        dataType: "html",
                        data: params
                    } ).done( function( responseText ) {

                        // Save response for use in complete callback
                        response = arguments;

                        self.html( selector ?

                            // If a selector was specified, locate the right elements in a dummy div
                            // Exclude scripts to avoid IE 'Permission Denied' errors
                            jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

                            // Otherwise use the full result
                            responseText );

                        // If the request succeeds, this function gets "data", "status", "jqXHR"
                        // but they are ignored because response was set above.
                        // If it fails, this function gets "jqXHR", "status", "error"
                    } ).always( callback && function( jqXHR, status ) {
                        self.each( function() {
                            callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
                        } );
                    } );
                }

                return this;
            };




            // Attach a bunch of functions for handling common AJAX events
            jQuery.each( [
                "ajaxStart",
                "ajaxStop",
                "ajaxComplete",
                "ajaxError",
                "ajaxSuccess",
                "ajaxSend"
            ], function( i, type ) {
                jQuery.fn[ type ] = function( fn ) {
                    return this.on( type, fn );
                };
            } );




            jQuery.expr.filters.animated = function( elem ) {
                return jQuery.grep( jQuery.timers, function( fn ) {
                    return elem === fn.elem;
                } ).length;
            };





            /**
             * Gets a window from an element
             */
            function getWindow( elem ) {
                return jQuery.isWindow( elem ) ?
                    elem :
                    elem.nodeType === 9 ?
                        elem.defaultView || elem.parentWindow :
                        false;
            }

            jQuery.offset = {
                setOffset: function( elem, options, i ) {
                    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                        position = jQuery.css( elem, "position" ),
                        curElem = jQuery( elem ),
                        props = {};

                    // set position first, in-case top/left are set even on static elem
                    if ( position === "static" ) {
                        elem.style.position = "relative";
                    }

                    curOffset = curElem.offset();
                    curCSSTop = jQuery.css( elem, "top" );
                    curCSSLeft = jQuery.css( elem, "left" );
                    calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                        jQuery.inArray( "auto", [ curCSSTop, curCSSLeft ] ) > -1;

                    // need to be able to calculate position if either top or left
                    // is auto and position is either absolute or fixed
                    if ( calculatePosition ) {
                        curPosition = curElem.position();
                        curTop = curPosition.top;
                        curLeft = curPosition.left;
                    } else {
                        curTop = parseFloat( curCSSTop ) || 0;
                        curLeft = parseFloat( curCSSLeft ) || 0;
                    }

                    if ( jQuery.isFunction( options ) ) {

                        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                        options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
                    }

                    if ( options.top != null ) {
                        props.top = ( options.top - curOffset.top ) + curTop;
                    }
                    if ( options.left != null ) {
                        props.left = ( options.left - curOffset.left ) + curLeft;
                    }

                    if ( "using" in options ) {
                        options.using.call( elem, props );
                    } else {
                        curElem.css( props );
                    }
                }
            };

            jQuery.fn.extend( {
                offset: function( options ) {
                    if ( arguments.length ) {
                        return options === undefined ?
                            this :
                            this.each( function( i ) {
                                jQuery.offset.setOffset( this, options, i );
                            } );
                    }

                    var docElem, win,
                        box = { top: 0, left: 0 },
                        elem = this[ 0 ],
                        doc = elem && elem.ownerDocument;

                    if ( !doc ) {
                        return;
                    }

                    docElem = doc.documentElement;

                    // Make sure it's not a disconnected DOM node
                    if ( !jQuery.contains( docElem, elem ) ) {
                        return box;
                    }

                    // If we don't have gBCR, just use 0,0 rather than error
                    // BlackBerry 5, iOS 3 (original iPhone)
                    if ( typeof elem.getBoundingClientRect !== "undefined" ) {
                        box = elem.getBoundingClientRect();
                    }
                    win = getWindow( doc );
                    return {
                        top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
                        left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
                    };
                },

                position: function() {
                    if ( !this[ 0 ] ) {
                        return;
                    }

                    var offsetParent, offset,
                        parentOffset = { top: 0, left: 0 },
                        elem = this[ 0 ];

                    // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
                    // because it is its only offset parent
                    if ( jQuery.css( elem, "position" ) === "fixed" ) {

                        // we assume that getBoundingClientRect is available when computed position is fixed
                        offset = elem.getBoundingClientRect();
                    } else {

                        // Get *real* offsetParent
                        offsetParent = this.offsetParent();

                        // Get correct offsets
                        offset = this.offset();
                        if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                            parentOffset = offsetParent.offset();
                        }

                        // Add offsetParent borders
                        parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
                        parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
                    }

                    // Subtract parent offsets and element margins
                    // note: when an element has margin: auto the offsetLeft and marginLeft
                    // are the same in Safari causing offset.left to incorrectly be 0
                    return {
                        top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                        left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
                    };
                },

                offsetParent: function() {
                    return this.map( function() {
                        var offsetParent = this.offsetParent;

                        while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) &&
                            jQuery.css( offsetParent, "position" ) === "static" ) ) {
                            offsetParent = offsetParent.offsetParent;
                        }
                        return offsetParent || documentElement;
                    } );
                }
            } );

            // Create scrollLeft and scrollTop methods
            jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
                var top = /Y/.test( prop );

                jQuery.fn[ method ] = function( val ) {
                    return access( this, function( elem, method, val ) {
                        var win = getWindow( elem );

                        if ( val === undefined ) {
                            return win ? ( prop in win ) ? win[ prop ] :
                                win.document.documentElement[ method ] :
                                elem[ method ];
                        }

                        if ( win ) {
                            win.scrollTo(
                                !top ? val : jQuery( win ).scrollLeft(),
                                top ? val : jQuery( win ).scrollTop()
                            );

                        } else {
                            elem[ method ] = val;
                        }
                    }, method, val, arguments.length, null );
                };
            } );

            // Support: Safari<7-8+, Chrome<37-44+
            // Add the top/left cssHooks using jQuery.fn.position
            // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
            // getComputedStyle returns percent when specified for top/left/bottom/right
            // rather than make the css module depend on the offset module, we just check for it here
            jQuery.each( [ "top", "left" ], function( i, prop ) {
                jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
                    function( elem, computed ) {
                        if ( computed ) {
                            computed = curCSS( elem, prop );

                            // if curCSS returns percentage, fallback to offset
                            return rnumnonpx.test( computed ) ?
                                jQuery( elem ).position()[ prop ] + "px" :
                                computed;
                        }
                    }
                );
            } );


            // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
            jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
                jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
                    function( defaultExtra, funcName ) {

                        // margin is only for outerHeight, outerWidth
                        jQuery.fn[ funcName ] = function( margin, value ) {
                            var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                                extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                            return access( this, function( elem, type, value ) {
                                var doc;

                                if ( jQuery.isWindow( elem ) ) {

                                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                                    // isn't a whole lot we can do. See pull request at this URL for discussion:
                                    // https://github.com/jquery/jquery/pull/764
                                    return elem.document.documentElement[ "client" + name ];
                                }

                                // Get document width or height
                                if ( elem.nodeType === 9 ) {
                                    doc = elem.documentElement;

                                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                    // whichever is greatest
                                    // unfortunately, this causes bug #3838 in IE6/8 only,
                                    // but there is currently no good, small way to fix it.
                                    return Math.max(
                                        elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                                        elem.body[ "offset" + name ], doc[ "offset" + name ],
                                        doc[ "client" + name ]
                                    );
                                }

                                return value === undefined ?

                                    // Get width or height on the element, requesting but not forcing parseFloat
                                    jQuery.css( elem, type, extra ) :

                                    // Set width or height on the element
                                    jQuery.style( elem, type, value, extra );
                            }, type, chainable ? margin : undefined, chainable, null );
                        };
                    } );
            } );


            jQuery.fn.extend( {

                bind: function( types, data, fn ) {
                    return this.on( types, null, data, fn );
                },
                unbind: function( types, fn ) {
                    return this.off( types, null, fn );
                },

                delegate: function( selector, types, data, fn ) {
                    return this.on( types, selector, data, fn );
                },
                undelegate: function( selector, types, fn ) {

                    // ( namespace ) or ( selector, types [, fn] )
                    return arguments.length === 1 ?
                        this.off( selector, "**" ) :
                        this.off( types, selector || "**", fn );
                }
            } );

            // The number of elements contained in the matched element set
            jQuery.fn.size = function() {
                return this.length;
            };

            jQuery.fn.andSelf = jQuery.fn.addBack;



            var

                // Map over jQuery in case of overwrite
                _jQuery = window.jQuery,

                // Map over the $ in case of overwrite
                _$ = window.$;

            jQuery.noConflict = function( deep ) {
                if ( window.$ === jQuery ) {
                    window.$ = _$;
                }

                if ( deep && window.jQuery === jQuery ) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            };

            // Expose jQuery and $ identifiers, even in
            // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
            // and CommonJS for browser emulators (#13566)
            if ( !noGlobal ) {
                window.jQuery = window.$ = jQuery;
            }

            return jQuery;
        }));
    });

    var tuiCodeSnippet = createCommonjsModule(function (module, exports) {
        /*!
     * tui-code-snippet.js
     * @version 1.5.2
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     * @license MIT
     */
        (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory();
        })(commonjsGlobal, function() {
            return /******/ (function(modules) { // webpackBootstrap
                /******/ 	// The module cache
                /******/ 	var installedModules = {};

                /******/ 	// The require function
                /******/ 	function __webpack_require__(moduleId) {

                    /******/ 		// Check if module is in cache
                    /******/ 		if(installedModules[moduleId])
                        /******/ 			return installedModules[moduleId].exports;

                    /******/ 		// Create a new module (and put it into the cache)
                    /******/ 		var module = installedModules[moduleId] = {
                        /******/ 			exports: {},
                        /******/ 			id: moduleId,
                        /******/ 			loaded: false
                        /******/ 		};

                    /******/ 		// Execute the module function
                    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

                    /******/ 		// Flag the module as loaded
                    /******/ 		module.loaded = true;

                    /******/ 		// Return the exports of the module
                    /******/ 		return module.exports;
                    /******/ 	}


                /******/ 	// expose the modules object (__webpack_modules__)
                /******/ 	__webpack_require__.m = modules;

                /******/ 	// expose the module cache
                /******/ 	__webpack_require__.c = installedModules;

                /******/ 	// __webpack_public_path__
                /******/ 	__webpack_require__.p = "dist";

                /******/ 	// Load entry module and return exports
                /******/ 	return __webpack_require__(0);
                /******/ })
                /************************************************************************/
                /******/ ([
                    /* 0 */
                    /***/ (function(module, exports, __webpack_require__) {

                        /**
                         * @fileoverview
                         * @author NHN.
                         *         FE Development Lab <dl_javascript@nhn.com>
                         * @namespace tui.util
                         * @example
                         * // node, commonjs
                         * var util = require('tui-code-snippet');
                         * @example
                         * // distribution file, script
                         * <script src='path-to/tui-code-snippt.js'></script>
                         * <script>
                         * var util = tui.util;
                         * <script>
                         */
                        var util = {};
                        var object = __webpack_require__(1);
                        var extend = object.extend;

                        extend(util, object);
                        extend(util, __webpack_require__(3));
                        extend(util, __webpack_require__(2));
                        extend(util, __webpack_require__(4));
                        extend(util, __webpack_require__(5));
                        extend(util, __webpack_require__(6));
                        extend(util, __webpack_require__(7));
                        extend(util, __webpack_require__(8));
                        extend(util, __webpack_require__(9));

                        util.browser = __webpack_require__(10);
                        util.popup = __webpack_require__(11);
                        util.formatDate = __webpack_require__(12);
                        util.defineClass = __webpack_require__(13);
                        util.defineModule = __webpack_require__(14);
                        util.defineNamespace = __webpack_require__(15);
                        util.CustomEvents = __webpack_require__(16);
                        util.Enum = __webpack_require__(17);
                        util.ExMap = __webpack_require__(18);
                        util.HashMap = __webpack_require__(20);
                        util.Map = __webpack_require__(19);

                        module.exports = util;


                        /***/ }),
                    /* 1 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var type = __webpack_require__(2);
                        var array = __webpack_require__(3);

                        /**
                         * The last id of stamp
                         * @type {number}
                         * @private
                         */
                        var lastId = 0;

                        /**
                         * Extend the target object from other objects.
                         * @param {object} target - Object that will be extended
                         * @param {...object} objects - Objects as sources
                         * @returns {object} Extended object
                         * @memberof tui.util
                         */
                        function extend(target, objects) { // eslint-disable-line no-unused-vars
                            var hasOwnProp = Object.prototype.hasOwnProperty;
                            var source, prop, i, len;

                            for (i = 1, len = arguments.length; i < len; i += 1) {
                                source = arguments[i];
                                for (prop in source) {
                                    if (hasOwnProp.call(source, prop)) {
                                        target[prop] = source[prop];
                                    }
                                }
                            }

                            return target;
                        }

                        /**
                         * Assign a unique id to an object
                         * @param {object} obj - Object that will be assigned id.
                         * @returns {number} Stamped id
                         * @memberof tui.util
                         */
                        function stamp(obj) {
                            if (!obj.__fe_id) {
                                lastId += 1;
                                obj.__fe_id = lastId; // eslint-disable-line camelcase
                            }

                            return obj.__fe_id;
                        }

                        /**
                         * Verify whether an object has a stamped id or not.
                         * @param {object} obj - adjusted object
                         * @returns {boolean}
                         * @memberof tui.util
                         */
                        function hasStamp(obj) {
                            return type.isExisty(pick(obj, '__fe_id'));
                        }

                        /**
                         * Reset the last id of stamp
                         * @private
                         */
                        function resetLastId() {
                            lastId = 0;
                        }

                        /**
                         * Return a key-list(array) of a given object
                         * @param {object} obj - Object from which a key-list will be extracted
                         * @returns {Array} A key-list(array)
                         * @memberof tui.util
                         */
                        function keys(obj) {
                            var keyArray = [];
                            var key;

                            for (key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    keyArray.push(key);
                                }
                            }

                            return keyArray;
                        }

                        /**
                         * Return the equality for multiple objects(jsonObjects).<br>
                         *  See {@link http://stackoverflow.com/questions/1068834/object-comparison-in-javascript}
                         * @param {...object} object - Multiple objects for comparing.
                         * @returns {boolean} Equality
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var jsonObj1 = {name:'milk', price: 1000};
                         * var jsonObj2 = {name:'milk', price: 1000};
                         * var jsonObj3 = {name:'milk', price: 1000};
                         * util.compareJSON(jsonObj1, jsonObj2, jsonObj3);   // true
                         *
                         * var jsonObj4 = {name:'milk', price: 1000};
                         * var jsonObj5 = {name:'beer', price: 3000};
                         * util.compareJSON(jsonObj4, jsonObj5); // false
                         */
                        function compareJSON(object) {
                            var argsLen = arguments.length;
                            var i = 1;

                            if (argsLen < 1) {
                                return true;
                            }

                            for (; i < argsLen; i += 1) {
                                if (!isSameObject(object, arguments[i])) {
                                    return false;
                                }
                            }

                            return true;
                        }

                        /**
                         * @param {*} x - object to compare
                         * @param {*} y - object to compare
                         * @returns {boolean} - whether object x and y is same or not
                         * @private
                         */
                        function isSameObject(x, y) { // eslint-disable-line complexity
                            var leftChain = [];
                            var rightChain = [];
                            var p;

                            // remember that NaN === NaN returns false
                            // and isNaN(undefined) returns true
                            if (isNaN(x) &&
                                isNaN(y) &&
                                type.isNumber(x) &&
                                type.isNumber(y)) {
                                return true;
                            }

                            // Compare primitives and functions.
                            // Check if both arguments link to the same object.
                            // Especially useful on step when comparing prototypes
                            if (x === y) {
                                return true;
                            }

                            // Works in case when functions are created in constructor.
                            // Comparing dates is a common scenario. Another built-ins?
                            // We can even handle functions passed across iframes
                            if ((type.isFunction(x) && type.isFunction(y)) ||
                                (x instanceof Date && y instanceof Date) ||
                                (x instanceof RegExp && y instanceof RegExp) ||
                                (x instanceof String && y instanceof String) ||
                                (x instanceof Number && y instanceof Number)) {
                                return x.toString() === y.toString();
                            }

                            // At last checking prototypes as good a we can
                            if (!(x instanceof Object && y instanceof Object)) {
                                return false;
                            }

                            if (x.isPrototypeOf(y) ||
                                y.isPrototypeOf(x) ||
                                x.constructor !== y.constructor ||
                                x.prototype !== y.prototype) {
                                return false;
                            }

                            // check for infinitive linking loops
                            if (array.inArray(x, leftChain) > -1 ||
                                array.inArray(y, rightChain) > -1) {
                                return false;
                            }

                            // Quick checking of one object beeing a subset of another.
                            for (p in y) {
                                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                                    return false;
                                } else if (typeof y[p] !== typeof x[p]) {
                                    return false;
                                }
                            }

                            // This for loop executes comparing with hasOwnProperty() and typeof for each property in 'x' object,
                            // and verifying equality for x[property] and y[property].
                            for (p in x) {
                                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                                    return false;
                                } else if (typeof y[p] !== typeof x[p]) {
                                    return false;
                                }

                                if (typeof (x[p]) === 'object' || typeof (x[p]) === 'function') {
                                    leftChain.push(x);
                                    rightChain.push(y);

                                    if (!isSameObject(x[p], y[p])) {
                                        return false;
                                    }

                                    leftChain.pop();
                                    rightChain.pop();
                                } else if (x[p] !== y[p]) {
                                    return false;
                                }
                            }

                            return true;
                        }
                        /* eslint-enable complexity */

                        /**
                         * Retrieve a nested item from the given object/array
                         * @param {object|Array} obj - Object for retrieving
                         * @param {...string|number} paths - Paths of property
                         * @returns {*} Value
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var obj = {
                         *     'key1': 1,
                         *     'nested' : {
                         *         'key1': 11,
                         *         'nested': {
                         *             'key1': 21
                         *         }
                         *     }
                         * };
                         * util.pick(obj, 'nested', 'nested', 'key1'); // 21
                         * util.pick(obj, 'nested', 'nested', 'key2'); // undefined
                         *
                         * var arr = ['a', 'b', 'c'];
                         * util.pick(arr, 1); // 'b'
                         */
                        function pick(obj, paths) { // eslint-disable-line no-unused-vars
                            var args = arguments;
                            var target = args[0];
                            var i = 1;
                            var length = args.length;

                            for (; i < length; i += 1) {
                                if (type.isUndefined(target) ||
                                    type.isNull(target)) {
                                    return;
                                }

                                target = target[args[i]];
                            }

                            return target; // eslint-disable-line consistent-return
                        }

                        module.exports = {
                            extend: extend,
                            stamp: stamp,
                            hasStamp: hasStamp,
                            resetLastId: resetLastId,
                            keys: Object.prototype.keys || keys,
                            compareJSON: compareJSON,
                            pick: pick
                        };


                        /***/ }),
                    /* 2 */
                    /***/ (function(module, exports) {

                        var toString = Object.prototype.toString;

                        /**
                         * Check whether the given variable is existing or not.<br>
                         *  If the given variable is not null and not undefined, returns true.
                         * @param {*} param - Target for checking
                         * @returns {boolean} Is existy?
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * util.isExisty(''); //true
                         * util.isExisty(0); //true
                         * util.isExisty([]); //true
                         * util.isExisty({}); //true
                         * util.isExisty(null); //false
                         * util.isExisty(undefined); //false
                         */
                        function isExisty(param) {
                            return !isUndefined(param) && !isNull(param);
                        }

                        /**
                         * Check whether the given variable is undefined or not.<br>
                         *  If the given variable is undefined, returns true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is undefined?
                         * @memberof tui.util
                         */
                        function isUndefined(obj) {
                            return obj === undefined; // eslint-disable-line no-undefined
                        }

                        /**
                         * Check whether the given variable is null or not.<br>
                         *  If the given variable(arguments[0]) is null, returns true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is null?
                         * @memberof tui.util
                         */
                        function isNull(obj) {
                            return obj === null;
                        }

                        /**
                         * Check whether the given variable is truthy or not.<br>
                         *  If the given variable is not null or not undefined or not false, returns true.<br>
                         *  (It regards 0 as true)
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is truthy?
                         * @memberof tui.util
                         */
                        function isTruthy(obj) {
                            return isExisty(obj) && obj !== false;
                        }

                        /**
                         * Check whether the given variable is falsy or not.<br>
                         *  If the given variable is null or undefined or false, returns true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is falsy?
                         * @memberof tui.util
                         */
                        function isFalsy(obj) {
                            return !isTruthy(obj);
                        }

                        /**
                         * Check whether the given variable is an arguments object or not.<br>
                         *  If the given variable is an arguments object, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is arguments?
                         * @memberof tui.util
                         */
                        function isArguments(obj) {
                            var result = isExisty(obj) &&
                                ((toString.call(obj) === '[object Arguments]') || !!obj.callee);

                            return result;
                        }

                        /**
                         * Check whether the given variable is an instance of Array or not.<br>
                         *  If the given variable is an instance of Array, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is array instance?
                         * @memberof tui.util
                         */
                        function isArray(obj) {
                            return obj instanceof Array;
                        }

                        /**
                         * Check whether the given variable is an object or not.<br>
                         *  If the given variable is an object, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is object?
                         * @memberof tui.util
                         */
                        function isObject(obj) {
                            return obj === Object(obj);
                        }

                        /**
                         * Check whether the given variable is a function or not.<br>
                         *  If the given variable is a function, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is function?
                         * @memberof tui.util
                         */
                        function isFunction(obj) {
                            return obj instanceof Function;
                        }

                        /**
                         * Check whether the given variable is a number or not.<br>
                         *  If the given variable is a number, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is number?
                         * @memberof tui.util
                         */
                        function isNumber(obj) {
                            return typeof obj === 'number' || obj instanceof Number;
                        }

                        /**
                         * Check whether the given variable is a string or not.<br>
                         *  If the given variable is a string, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is string?
                         * @memberof tui.util
                         */
                        function isString(obj) {
                            return typeof obj === 'string' || obj instanceof String;
                        }

                        /**
                         * Check whether the given variable is a boolean or not.<br>
                         *  If the given variable is a boolean, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is boolean?
                         * @memberof tui.util
                         */
                        function isBoolean(obj) {
                            return typeof obj === 'boolean' || obj instanceof Boolean;
                        }

                        /**
                         * Check whether the given variable is an instance of Array or not.<br>
                         *  If the given variable is an instance of Array, return true.<br>
                         *  (It is used for multiple frame environments)
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is an instance of array?
                         * @memberof tui.util
                         */
                        function isArraySafe(obj) {
                            return toString.call(obj) === '[object Array]';
                        }

                        /**
                         * Check whether the given variable is a function or not.<br>
                         *  If the given variable is a function, return true.<br>
                         *  (It is used for multiple frame environments)
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is a function?
                         * @memberof tui.util
                         */
                        function isFunctionSafe(obj) {
                            return toString.call(obj) === '[object Function]';
                        }

                        /**
                         * Check whether the given variable is a number or not.<br>
                         *  If the given variable is a number, return true.<br>
                         *  (It is used for multiple frame environments)
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is a number?
                         * @memberof tui.util
                         */
                        function isNumberSafe(obj) {
                            return toString.call(obj) === '[object Number]';
                        }

                        /**
                         * Check whether the given variable is a string or not.<br>
                         *  If the given variable is a string, return true.<br>
                         *  (It is used for multiple frame environments)
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is a string?
                         * @memberof tui.util
                         */
                        function isStringSafe(obj) {
                            return toString.call(obj) === '[object String]';
                        }

                        /**
                         * Check whether the given variable is a boolean or not.<br>
                         *  If the given variable is a boolean, return true.<br>
                         *  (It is used for multiple frame environments)
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is a boolean?
                         * @memberof tui.util
                         */
                        function isBooleanSafe(obj) {
                            return toString.call(obj) === '[object Boolean]';
                        }

                        /**
                         * Check whether the given variable is a instance of HTMLNode or not.<br>
                         *  If the given variables is a instance of HTMLNode, return true.
                         * @param {*} html - Target for checking
                         * @returns {boolean} Is HTMLNode ?
                         * @memberof tui.util
                         */
                        function isHTMLNode(html) {
                            if (typeof HTMLElement === 'object') {
                                return (html && (html instanceof HTMLElement || !!html.nodeType));
                            }

                            return !!(html && html.nodeType);
                        }

                        /**
                         * Check whether the given variable is a HTML tag or not.<br>
                         *  If the given variables is a HTML tag, return true.
                         * @param {*} html - Target for checking
                         * @returns {Boolean} Is HTML tag?
                         * @memberof tui.util
                         */
                        function isHTMLTag(html) {
                            if (typeof HTMLElement === 'object') {
                                return (html && (html instanceof HTMLElement));
                            }

                            return !!(html && html.nodeType && html.nodeType === 1);
                        }

                        /**
                         * Check whether the given variable is empty(null, undefined, or empty array, empty object) or not.<br>
                         *  If the given variables is empty, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is empty?
                         * @memberof tui.util
                         */
                        function isEmpty(obj) {
                            if (!isExisty(obj) || _isEmptyString(obj)) {
                                return true;
                            }

                            if (isArray(obj) || isArguments(obj)) {
                                return obj.length === 0;
                            }

                            if (isObject(obj) && !isFunction(obj)) {
                                return !_hasOwnProperty(obj);
                            }

                            return true;
                        }

                        /**
                         * Check whether given argument is empty string
                         * @param {*} obj - Target for checking
                         * @returns {boolean} whether given argument is empty string
                         * @memberof tui.util
                         * @private
                         */
                        function _isEmptyString(obj) {
                            return isString(obj) && obj === '';
                        }

                        /**
                         * Check whether given argument has own property
                         * @param {Object} obj - Target for checking
                         * @returns {boolean} - whether given argument has own property
                         * @memberof tui.util
                         * @private
                         */
                        function _hasOwnProperty(obj) {
                            var key;
                            for (key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    return true;
                                }
                            }

                            return false;
                        }

                        /**
                         * Check whether the given variable is not empty
                         * (not null, not undefined, or not empty array, not empty object) or not.<br>
                         *  If the given variables is not empty, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is not empty?
                         * @memberof tui.util
                         */
                        function isNotEmpty(obj) {
                            return !isEmpty(obj);
                        }

                        /**
                         * Check whether the given variable is an instance of Date or not.<br>
                         *  If the given variables is an instance of Date, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is an instance of Date?
                         * @memberof tui.util
                         */
                        function isDate(obj) {
                            return obj instanceof Date;
                        }

                        /**
                         * Check whether the given variable is an instance of Date or not.<br>
                         *  If the given variables is an instance of Date, return true.<br>
                         *  (It is used for multiple frame environments)
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is an instance of Date?
                         * @memberof tui.util
                         */
                        function isDateSafe(obj) {
                            return toString.call(obj) === '[object Date]';
                        }

                        module.exports = {
                            isExisty: isExisty,
                            isUndefined: isUndefined,
                            isNull: isNull,
                            isTruthy: isTruthy,
                            isFalsy: isFalsy,
                            isArguments: isArguments,
                            isArray: isArray,
                            isArraySafe: isArraySafe,
                            isObject: isObject,
                            isFunction: isFunction,
                            isFunctionSafe: isFunctionSafe,
                            isNumber: isNumber,
                            isNumberSafe: isNumberSafe,
                            isDate: isDate,
                            isDateSafe: isDateSafe,
                            isString: isString,
                            isStringSafe: isStringSafe,
                            isBoolean: isBoolean,
                            isBooleanSafe: isBooleanSafe,
                            isHTMLNode: isHTMLNode,
                            isHTMLTag: isHTMLTag,
                            isEmpty: isEmpty,
                            isNotEmpty: isNotEmpty
                        };


                        /***/ }),
                    /* 3 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var collection = __webpack_require__(4);
                        var type = __webpack_require__(2);

                        var aps = Array.prototype.slice;
                        var util;

                        /**
                         * Generate an integer Array containing an arithmetic progression.
                         * @param {number} start - start index
                         * @param {number} stop - stop index
                         * @param {number} step - next visit index = current index + step
                         * @returns {Array}
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * util.range(5); // [0, 1, 2, 3, 4]
                         * util.range(1, 5); // [1,2,3,4]
                         * util.range(2, 10, 2); // [2,4,6,8]
                         * util.range(10, 2, -2); // [10,8,6,4]
                         */
                        var range = function(start, stop, step) {
                            var arr = [];
                            var flag;

                            if (type.isUndefined(stop)) {
                                stop = start || 0;
                                start = 0;
                            }

                            step = step || 1;
                            flag = step < 0 ? -1 : 1;
                            stop *= flag;

                            for (; start * flag < stop; start += step) {
                                arr.push(start);
                            }

                            return arr;
                        };

                        /* eslint-disable valid-jsdoc */
                        /**
                         * Zip together multiple lists into a single array
                         * @param {...Array}
                         * @returns {Array}
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var result = util.zip([1, 2, 3], ['a', 'b','c'], [true, false, true]);
                         * console.log(result[0]); // [1, 'a', true]
                         * console.log(result[1]); // [2, 'b', false]
                         * console.log(result[2]); // [3, 'c', true]
                         */
                        var zip = function() {/* eslint-enable valid-jsdoc */
                            var arr2d = aps.call(arguments);
                            var result = [];

                            collection.forEach(arr2d, function(arr) {
                                collection.forEach(arr, function(value, index) {
                                    if (!result[index]) {
                                        result[index] = [];
                                    }
                                    result[index].push(value);
                                });
                            });

                            return result;
                        };

                        /**
                         * Returns the first index at which a given element can be found in the array
                         * from start index(default 0), or -1 if it is not present.<br>
                         * It compares searchElement to elements of the Array using strict equality
                         * (the same method used by the ===, or triple-equals, operator).
                         * @param {*} searchElement Element to locate in the array
                         * @param {Array} array Array that will be traversed.
                         * @param {number} startIndex Start index in array for searching (default 0)
                         * @returns {number} the First index at which a given element, or -1 if it is not present
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var arr = ['one', 'two', 'three', 'four'];
                         * var idx1 = util.inArray('one', arr, 3); // -1
                         * var idx2 = util.inArray('one', arr); // 0
                         */
                        var inArray = function(searchElement, array, startIndex) {
                            var i;
                            var length;
                            startIndex = startIndex || 0;

                            if (!type.isArray(array)) {
                                return -1;
                            }

                            if (Array.prototype.indexOf) {
                                return Array.prototype.indexOf.call(array, searchElement, startIndex);
                            }

                            length = array.length;
                            for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
                                if (array[i] === searchElement) {
                                    return i;
                                }
                            }

                            return -1;
                        };

                        util = {
                            inArray: inArray,
                            range: range,
                            zip: zip
                        };

                        module.exports = util;


                        /***/ }),
                    /* 4 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var type = __webpack_require__(2);
                        var object = __webpack_require__(1);

                        /**
                         * Execute the provided callback once for each element present
                         * in the array(or Array-like object) in ascending order.<br>
                         * If the callback function returns false, the loop will be stopped.<br>
                         * Callback function(iteratee) is invoked with three arguments:
                         *  - The value of the element
                         *  - The index of the element
                         *  - The array(or Array-like object) being traversed
                         * @param {Array} arr The array(or Array-like object) that will be traversed
                         * @param {function} iteratee Callback function
                         * @param {Object} [context] Context(this) of callback function
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var sum = 0;
                         *
                         * util.forEachArray([1,2,3], function(value){
                         *     sum += value;
                         * });
                         * alert(sum); // 6
                         */
                        function forEachArray(arr, iteratee, context) {
                            var index = 0;
                            var len = arr.length;

                            context = context || null;

                            for (; index < len; index += 1) {
                                if (iteratee.call(context, arr[index], index, arr) === false) {
                                    break;
                                }
                            }
                        }

                        /**
                         * Execute the provided callback once for each property of object which actually exist.<br>
                         * If the callback function returns false, the loop will be stopped.<br>
                         * Callback function(iteratee) is invoked with three arguments:
                         *  - The value of the property
                         *  - The name of the property
                         *  - The object being traversed
                         * @param {Object} obj The object that will be traversed
                         * @param {function} iteratee  Callback function
                         * @param {Object} [context] Context(this) of callback function
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var sum = 0;
                         *
                         * util.forEachOwnProperties({a:1,b:2,c:3}, function(value){
                         *     sum += value;
                         * });
                         * alert(sum); // 6
                         **/
                        function forEachOwnProperties(obj, iteratee, context) {
                            var key;

                            context = context || null;

                            for (key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    if (iteratee.call(context, obj[key], key, obj) === false) {
                                        break;
                                    }
                                }
                            }
                        }

                        /**
                         * Execute the provided callback once for each property of object(or element of array) which actually exist.<br>
                         * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).<br>
                         * If the callback function returns false, the loop will be stopped.<br>
                         * Callback function(iteratee) is invoked with three arguments:
                         *  - The value of the property(or The value of the element)
                         *  - The name of the property(or The index of the element)
                         *  - The object being traversed
                         * @param {Object} obj The object that will be traversed
                         * @param {function} iteratee Callback function
                         * @param {Object} [context] Context(this) of callback function
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var sum = 0;
                         *
                         * util.forEach([1,2,3], function(value){
                         *     sum += value;
                         * });
                         * alert(sum); // 6
                         *
                         * // In case of Array-like object
                         * var array = Array.prototype.slice.call(arrayLike); // change to array
                         * util.forEach(array, function(value){
                         *     sum += value;
                         * });
                         */
                        function forEach(obj, iteratee, context) {
                            if (type.isArray(obj)) {
                                forEachArray(obj, iteratee, context);
                            } else {
                                forEachOwnProperties(obj, iteratee, context);
                            }
                        }

                        /**
                         * Execute the provided callback function once for each element in an array, in order,
                         * and constructs a new array from the results.<br>
                         * If the object is Array-like object(ex-arguments object),
                         * It needs to transform to Array.(see 'ex2' of forEach example)<br>
                         * Callback function(iteratee) is invoked with three arguments:
                         *  - The value of the property(or The value of the element)
                         *  - The name of the property(or The index of the element)
                         *  - The object being traversed
                         * @param {Object} obj The object that will be traversed
                         * @param {function} iteratee Callback function
                         * @param {Object} [context] Context(this) of callback function
                         * @returns {Array} A new array composed of returned values from callback function
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var result = util.map([0,1,2,3], function(value) {
                         *     return value + 1;
                         * });
                         *
                         * alert(result);  // 1,2,3,4
                         */
                        function map(obj, iteratee, context) {
                            var resultArray = [];

                            context = context || null;

                            forEach(obj, function() {
                                resultArray.push(iteratee.apply(context, arguments));
                            });

                            return resultArray;
                        }

                        /**
                         * Execute the callback function once for each element present in the array(or Array-like object or plain object).<br>
                         * If the object is Array-like object(ex-arguments object),
                         * It needs to transform to Array.(see 'ex2' of forEach example)<br>
                         * Callback function(iteratee) is invoked with four arguments:
                         *  - The previousValue
                         *  - The currentValue
                         *  - The index
                         *  - The object being traversed
                         * @param {Object} obj The object that will be traversed
                         * @param {function} iteratee Callback function
                         * @param {Object} [context] Context(this) of callback function
                         * @returns {*} The result value
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var result = util.reduce([0,1,2,3], function(stored, value) {
                         *     return stored + value;
                         * });
                         *
                         * alert(result); // 6
                         */
                        function reduce(obj, iteratee, context) {
                            var index = 0;
                            var keys, length, store;

                            context = context || null;

                            if (!type.isArray(obj)) {
                                keys = object.keys(obj);
                                length = keys.length;
                                store = obj[keys[index += 1]];
                            } else {
                                length = obj.length;
                                store = obj[index];
                            }

                            index += 1;
                            for (; index < length; index += 1) {
                                store = iteratee.call(context, store, obj[keys ? keys[index] : index]);
                            }

                            return store;
                        }

                        /**
                         * Transform the Array-like object to Array.<br>
                         * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
                         * @param {*} arrayLike Array-like object
                         * @returns {Array} Array
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var arrayLike = {
                         *     0: 'one',
                         *     1: 'two',
                         *     2: 'three',
                         *     3: 'four',
                         *     length: 4
                         * };
                         * var result = util.toArray(arrayLike);
                         *
                         * alert(result instanceof Array); // true
                         * alert(result); // one,two,three,four
                         */
                        function toArray(arrayLike) {
                            var arr;
                            try {
                                arr = Array.prototype.slice.call(arrayLike);
                            } catch (e) {
                                arr = [];
                                forEachArray(arrayLike, function(value) {
                                    arr.push(value);
                                });
                            }

                            return arr;
                        }

                        /**
                         * Create a new array or plain object with all elements(or properties)
                         * that pass the test implemented by the provided function.<br>
                         * Callback function(iteratee) is invoked with three arguments:
                         *  - The value of the property(or The value of the element)
                         *  - The name of the property(or The index of the element)
                         *  - The object being traversed
                         * @param {Object} obj Object(plain object or Array) that will be traversed
                         * @param {function} iteratee Callback function
                         * @param {Object} [context] Context(this) of callback function
                         * @returns {Object} plain object or Array
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var result1 = util.filter([0,1,2,3], function(value) {
                         *     return (value % 2 === 0);
                         * });
                         * alert(result1); // [0, 2]
                         *
                         * var result2 = util.filter({a : 1, b: 2, c: 3}, function(value) {
                         *     return (value % 2 !== 0);
                         * });
                         * alert(result2.a); // 1
                         * alert(result2.b); // undefined
                         * alert(result2.c); // 3
                         */
                        function filter(obj, iteratee, context) {
                            var result, add;

                            context = context || null;

                            if (!type.isObject(obj) || !type.isFunction(iteratee)) {
                                throw new Error('wrong parameter');
                            }

                            if (type.isArray(obj)) {
                                result = [];
                                add = function(subResult, args) {
                                    subResult.push(args[0]);
                                };
                            } else {
                                result = {};
                                add = function(subResult, args) {
                                    subResult[args[1]] = args[0];
                                };
                            }

                            forEach(obj, function() {
                                if (iteratee.apply(context, arguments)) {
                                    add(result, arguments);
                                }
                            }, context);

                            return result;
                        }

                        /**
                         * fetching a property
                         * @param {Array} arr target collection
                         * @param {String|Number} property property name
                         * @returns {Array}
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var objArr = [
                         *     {'abc': 1, 'def': 2, 'ghi': 3},
                         *     {'abc': 4, 'def': 5, 'ghi': 6},
                         *     {'abc': 7, 'def': 8, 'ghi': 9}
                         * ];
                         * var arr2d = [
                         *     [1, 2, 3],
                         *     [4, 5, 6],
                         *     [7, 8, 9]
                         * ];
                         * util.pluck(objArr, 'abc'); // [1, 4, 7]
                         * util.pluck(arr2d, 2); // [3, 6, 9]
                         */
                        function pluck(arr, property) {
                            var result = map(arr, function(item) {
                                return item[property];
                            });

                            return result;
                        }

                        module.exports = {
                            forEachOwnProperties: forEachOwnProperties,
                            forEachArray: forEachArray,
                            forEach: forEach,
                            toArray: toArray,
                            map: map,
                            reduce: reduce,
                            filter: filter,
                            pluck: pluck
                        };


                        /***/ }),
                    /* 5 */
                    /***/ (function(module, exports) {

                        /**
                         * Create a new function that, when called, has its this keyword set to the provided value.
                         * @param {function} fn A original function before binding
                         * @param {*} obj context of function in arguments[0]
                         * @returns {function()} A new bound function with context that is in arguments[1]
                         * @memberof tui.util
                         */
                        function bind(fn, obj) {
                            var slice = Array.prototype.slice;
                            var args;

                            if (fn.bind) {
                                return fn.bind.apply(fn, slice.call(arguments, 1));
                            }

                            /* istanbul ignore next */
                            args = slice.call(arguments, 2);

                            /* istanbul ignore next */
                            return function() {
                                /* istanbul ignore next */
                                return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
                            };
                        }

                        module.exports = {
                            bind: bind
                        };


                        /***/ }),
                    /* 6 */
                    /***/ (function(module, exports) {

                        /**
                         * Create a new object with the specified prototype object and properties.
                         * @param {Object} obj This object will be a prototype of the newly-created object.
                         * @returns {Object}
                         * @memberof tui.util
                         */
                        function createObject(obj) {
                            function F() {} // eslint-disable-line require-jsdoc
                            F.prototype = obj;

                            return new F();
                        }

                        /**
                         * Provide a simple inheritance in prototype-oriented.<br>
                         * Caution :
                         *  Don't overwrite the prototype of child constructor.
                         *
                         * @param {function} subType Child constructor
                         * @param {function} superType Parent constructor
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * // Parent constructor
                         * function Animal(leg) {
                         *     this.leg = leg;
                         * }
                         * Animal.prototype.growl = function() {
                         *     // ...
                         * };
                         *
                         * // Child constructor
                         * function Person(name) {
                         *     this.name = name;
                         * }
                         *
                         * // Inheritance
                         * util.inherit(Person, Animal);
                         *
                         * // After this inheritance, please use only the extending of property.
                         * // Do not overwrite prototype.
                         * Person.prototype.walk = function(direction) {
                         *     // ...
                         * };
                         */
                        function inherit(subType, superType) {
                            var prototype = createObject(superType.prototype);
                            prototype.constructor = subType;
                            subType.prototype = prototype;
                        }

                        module.exports = {
                            createObject: createObject,
                            inherit: inherit
                        };


                        /***/ }),
                    /* 7 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var collection = __webpack_require__(4);
                        var object = __webpack_require__(1);
                        /**
                         * Transform the given HTML Entity string into plain string
                         * @param {String} htmlEntity - HTML Entity type string
                         * @returns {String} Plain string
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         *  var htmlEntityString = "A &#39;quote&#39; is &lt;b&gt;bold&lt;/b&gt;"
                         *  var result = util.decodeHTMLEntity(htmlEntityString); //"A 'quote' is <b>bold</b>"
                         */
                        function decodeHTMLEntity(htmlEntity) {
                            var entities = {
                                '&quot;': '"',
                                '&amp;': '&',
                                '&lt;': '<',
                                '&gt;': '>',
                                '&#39;': '\'',
                                '&nbsp;': ' '
                            };

                            return htmlEntity.replace(/&amp;|&lt;|&gt;|&quot;|&#39;|&nbsp;/g, function(m0) {
                                return entities[m0] ? entities[m0] : m0;
                            });
                        }

                        /**
                         * Transform the given string into HTML Entity string
                         * @param {String} html - String for encoding
                         * @returns {String} HTML Entity
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         *  var htmlEntityString = "<script> alert('test');</script><a href='test'>";
                         *  var result = util.encodeHTMLEntity(htmlEntityString);
                         * //"&lt;script&gt; alert(&#39;test&#39;);&lt;/script&gt;&lt;a href=&#39;test&#39;&gt;"
                         */
                        function encodeHTMLEntity(html) {
                            var entities = {
                                '"': 'quot',
                                '&': 'amp',
                                '<': 'lt',
                                '>': 'gt',
                                '\'': '#39'
                            };

                            return html.replace(/[<>&"']/g, function(m0) {
                                return entities[m0] ? '&' + entities[m0] + ';' : m0;
                            });
                        }

                        /**
                         * Return whether the string capable to transform into plain string is in the given string or not.
                         * @param {String} string - test string
                         * @memberof tui.util
                         * @returns {boolean}
                         */
                        function hasEncodableString(string) {
                            return (/[<>&"']/).test(string);
                        }

                        /**
                         * Return duplicate charters
                         * @param {string} operandStr1 The operand string
                         * @param {string} operandStr2 The operand string
                         * @private
                         * @memberof tui.util
                         * @returns {string}
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * util.getDuplicatedChar('fe dev', 'nhn entertainment'); // 'e'
                         * util.getDuplicatedChar('fdsa', 'asdf'); // 'asdf'
                         */
                        function getDuplicatedChar(operandStr1, operandStr2) {
                            var i = 0;
                            var len = operandStr1.length;
                            var pool = {};
                            var dupl, key;

                            for (; i < len; i += 1) {
                                key = operandStr1.charAt(i);
                                pool[key] = 1;
                            }

                            for (i = 0, len = operandStr2.length; i < len; i += 1) {
                                key = operandStr2.charAt(i);
                                if (pool[key]) {
                                    pool[key] += 1;
                                }
                            }

                            pool = collection.filter(pool, function(item) {
                                return item > 1;
                            });

                            pool = object.keys(pool).sort();
                            dupl = pool.join('');

                            return dupl;
                        }

                        module.exports = {
                            decodeHTMLEntity: decodeHTMLEntity,
                            encodeHTMLEntity: encodeHTMLEntity,
                            hasEncodableString: hasEncodableString,
                            getDuplicatedChar: getDuplicatedChar
                        };


                        /***/ }),
                    /* 8 */
                    /***/ (function(module, exports) {

                        var tricks = {};
                        var aps = Array.prototype.slice;

                        /**
                         * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed
                         * since the last time the debouced function was invoked.
                         * @param {function} fn The function to debounce.
                         * @param {number} [delay=0] The number of milliseconds to delay
                         * @memberof tui.util
                         * @returns {function} debounced function.
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * function someMethodToInvokeDebounced() {}
                         *
                         * var debounced = util.debounce(someMethodToInvokeDebounced, 300);
                         *
                         * // invoke repeatedly
                         * debounced();
                         * debounced();
                         * debounced();
                         * debounced();
                         * debounced();
                         * debounced();    // last invoke of debounced()
                         *
                         * // invoke someMethodToInvokeDebounced() after 300 milliseconds.
                         */
                        function debounce(fn, delay) {
                            var timer, args;

                            /* istanbul ignore next */
                            delay = delay || 0;

                            function debounced() { // eslint-disable-line require-jsdoc
                                args = aps.call(arguments);

                                window.clearTimeout(timer);
                                timer = window.setTimeout(function() {
                                    fn.apply(null, args);
                                }, delay);
                            }

                            return debounced;
                        }

                        /**
                         * return timestamp
                         * @memberof tui.util
                         * @returns {number} The number of milliseconds from Jan. 1970 00:00:00 (GMT)
                         */
                        function timestamp() {
                            return Number(new Date());
                        }

                        /**
                         * Creates a throttled function that only invokes fn at most once per every interval milliseconds.
                         *
                         * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)
                         *
                         * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.
                         * @param {function} fn function to throttle
                         * @param {number} [interval=0] the number of milliseconds to throttle invocations to.
                         * @memberof tui.util
                         * @returns {function} throttled function
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * function someMethodToInvokeThrottled() {}
                         *
                         * var throttled = util.throttle(someMethodToInvokeThrottled, 300);
                         *
                         * // invoke repeatedly
                         * throttled();    // invoke (leading)
                         * throttled();
                         * throttled();    // invoke (near 300 milliseconds)
                         * throttled();
                         * throttled();
                         * throttled();    // invoke (near 600 milliseconds)
                         * // ...
                         * // invoke (trailing)
                         *
                         * // if you need reuse throttled method. then invoke reset()
                         * throttled.reset();
                         */
                        function throttle(fn, interval) {
                            var base;
                            var isLeading = true;
                            var tick = function(_args) {
                                fn.apply(null, _args);
                                base = null;
                            };
                            var debounced, stamp, args;

                            /* istanbul ignore next */
                            interval = interval || 0;

                            debounced = tricks.debounce(tick, interval);

                            function throttled() { // eslint-disable-line require-jsdoc
                                args = aps.call(arguments);

                                if (isLeading) {
                                    tick(args);
                                    isLeading = false;

                                    return;
                                }

                                stamp = tricks.timestamp();

                                base = base || stamp;

                                // pass array directly because `debounce()`, `tick()` are already use
                                // `apply()` method to invoke developer's `fn` handler.
                                //
                                // also, this `debounced` line invoked every time for implements
                                // `trailing` features.
                                debounced(args);

                                if ((stamp - base) >= interval) {
                                    tick(args);
                                }
                            }

                            function reset() { // eslint-disable-line require-jsdoc
                                isLeading = true;
                                base = null;
                            }

                            throttled.reset = reset;

                            return throttled;
                        }

                        tricks.timestamp = timestamp;
                        tricks.debounce = debounce;
                        tricks.throttle = throttle;

                        module.exports = tricks;


                        /***/ }),
                    /* 9 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var object = __webpack_require__(1);
                        var collection = __webpack_require__(4);
                        var type = __webpack_require__(2);
                        var ms7days = 7 * 24 * 60 * 60 * 1000;

                        /**
                         * Check if the date has passed 7 days
                         * @param {number} date - milliseconds
                         * @returns {boolean}
                         * @ignore
                         */
                        function isExpired(date) {
                            var now = new Date().getTime();

                            return now - date > ms7days;
                        }

                        /**
                         * Send hostname on DOMContentLoaded.
                         * To prevent hostname set tui.usageStatistics to false.
                         * @param {string} appName - application name
                         * @param {string} trackingId - GA tracking ID
                         * @ignore
                         */
                        function sendHostname(appName, trackingId) {
                            var url = 'https://www.google-analytics.com/collect';
                            var hostname = location.hostname;
                            var hitType = 'event';
                            var eventCategory = 'use';
                            var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
                            var date = window.localStorage.getItem(applicationKeyForStorage);

                            // skip if the flag is defined and is set to false explicitly
                            if (!type.isUndefined(window.tui) && window.tui.usageStatistics === false) {
                                return;
                            }

                            // skip if not pass seven days old
                            if (date && !isExpired(date)) {
                                return;
                            }

                            window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

                            setTimeout(function() {
                                if (document.readyState === 'interactive' || document.readyState === 'complete') {
                                    imagePing(url, {
                                        v: 1,
                                        t: hitType,
                                        tid: trackingId,
                                        cid: hostname,
                                        dp: hostname,
                                        dh: appName,
                                        el: appName,
                                        ec: eventCategory
                                    });
                                }
                            }, 1000);
                        }

                        /**
                         * Request image ping.
                         * @param {String} url url for ping request
                         * @param {Object} trackingInfo infos for make query string
                         * @returns {HTMLElement}
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * util.imagePing('https://www.google-analytics.com/collect', {
                         *     v: 1,
                         *     t: 'event',
                         *     tid: 'trackingid',
                         *     cid: 'cid',
                         *     dp: 'dp',
                         *     dh: 'dh'
                         * });
                         */
                        function imagePing(url, trackingInfo) {
                            var queryString = collection.map(object.keys(trackingInfo), function(key, index) {
                                var startWith = index === 0 ? '' : '&';

                                return startWith + key + '=' + trackingInfo[key];
                            }).join('');
                            var trackingElement = document.createElement('img');

                            trackingElement.src = url + '?' + queryString;

                            trackingElement.style.display = 'none';
                            document.body.appendChild(trackingElement);
                            document.body.removeChild(trackingElement);

                            return trackingElement;
                        }

                        module.exports = {
                            imagePing: imagePing,
                            sendHostname: sendHostname
                        };


                        /***/ }),
                    /* 10 */
                    /***/ (function(module, exports) {

                        /**
                         * This object has an information that indicate the kind of browser.<br>
                         * The list below is a detectable browser list.
                         *  - ie8 ~ ie11
                         *  - chrome
                         *  - firefox
                         *  - safari
                         *  - edge
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * util.browser.chrome === true; // chrome
                         * util.browser.firefox === true; // firefox
                         * util.browser.safari === true; // safari
                         * util.browser.msie === true; // IE
                         * util.browser.edge === true; // edge
                         * util.browser.others === true; // other browser
                         * util.browser.version; // browser version
                         */
                        var browser = {
                            chrome: false,
                            firefox: false,
                            safari: false,
                            msie: false,
                            edge: false,
                            others: false,
                            version: 0
                        };

                        if (window && window.navigator) {
                            detectBrowser();
                        }

                        /**
                         * Detect the browser.
                         * @private
                         */
                        function detectBrowser() {
                            var nav = window.navigator;
                            var appName = nav.appName.replace(/\s/g, '_');
                            var userAgent = nav.userAgent;

                            var rIE = /MSIE\s([0-9]+[.0-9]*)/;
                            var rIE11 = /Trident.*rv:11\./;
                            var rEdge = /Edge\/(\d+)\./;
                            var versionRegex = {
                                firefox: /Firefox\/(\d+)\./,
                                chrome: /Chrome\/(\d+)\./,
                                safari: /Version\/([\d.]+).*Safari\/(\d+)/
                            };

                            var key, tmp;

                            var detector = {
                                Microsoft_Internet_Explorer: function() { // eslint-disable-line camelcase
                                    var detectedVersion = userAgent.match(rIE);

                                    if (detectedVersion) { // ie8 ~ ie10
                                        browser.msie = true;
                                        browser.version = parseFloat(detectedVersion[1]);
                                    } else { // no version information
                                        browser.others = true;
                                    }
                                },
                                Netscape: function() { // eslint-disable-line complexity
                                    var detected = false;

                                    if (rIE11.exec(userAgent)) {
                                        browser.msie = true;
                                        browser.version = 11;
                                        detected = true;
                                    } else if (rEdge.exec(userAgent)) {
                                        browser.edge = true;
                                        browser.version = userAgent.match(rEdge)[1];
                                        detected = true;
                                    } else {
                                        for (key in versionRegex) {
                                            if (versionRegex.hasOwnProperty(key)) {
                                                tmp = userAgent.match(versionRegex[key]);
                                                if (tmp && tmp.length > 1) { // eslint-disable-line max-depth
                                                    browser[key] = detected = true;
                                                    browser.version = parseFloat(tmp[1] || 0);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (!detected) {
                                        browser.others = true;
                                    }
                                }
                            };

                            var fn = detector[appName];

                            if (fn) {
                                detector[appName]();
                            }
                        }

                        module.exports = browser;


                        /***/ }),
                    /* 11 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var collection = __webpack_require__(4);
                        var type = __webpack_require__(2);
                        var func = __webpack_require__(5);
                        var browser = __webpack_require__(10);
                        var object = __webpack_require__(1);

                        var popupId = 0;

                        /**
                         * Popup management class
                         * @constructor
                         * @memberof tui.util
                         * @example
                         * // node, commonjs
                         * var popup = require('tui-code-snippet').popup;
                         * @example
                         * // distribution file, script
                         * <script src='path-to/tui-code-snippt.js'></script>
                         * <script>
                         * var popup = tui.util.popup;
                         * <script>
                         */
                        function Popup() {
                            /**
                             * Caching the window-contexts of opened popups
                             * @type {Object}
                             */
                            this.openedPopup = {};

                            /**
                             * In IE7, an error occurs when the closeWithParent property attaches to window object.<br>
                             * So, It is for saving the value of closeWithParent instead of attaching to window object.
                             * @type {Object}
                             */
                            this.closeWithParentPopup = {};

                            /**
                             * Post data bridge for IE11 popup
                             * @type {string}
                             */
                            this.postBridgeUrl = '';
                        }

                        /**********
                         * public methods
                         **********/

                        /**
                         * Returns a popup-list administered by current window.
                         * @param {string} [key] The key of popup.
                         * @returns {Object} popup window list object
                         */
                        Popup.prototype.getPopupList = function(key) {
                            var target;
                            if (type.isExisty(key)) {
                                target = this.openedPopup[key];
                            } else {
                                target = this.openedPopup;
                            }

                            return target;
                        };

                        /**
                         * Open popup
                         * Caution:
                         *  In IE11, when transfer data to popup by POST, must set the postBridgeUrl.
                         *
                         * @param {string} url - popup url
                         * @param {Object} options - popup options
                         *     @param {string} [options.popupName] - Key of popup window.<br>
                         *      If the key is set, when you try to open by this key, the popup of this key is focused.<br>
                         *      Or else a new popup window having this key is opened.
                         *
                         *     @param {string} [options.popupOptionStr=""] - Option string of popup window<br>
                         *      It is same with the third parameter of window.open() method.<br>
                         *      See {@link http://www.w3schools.com/jsref/met_win_open.asp}
                         *
                         *     @param {boolean} [options.closeWithParent=true] - Is closed when parent window closed?
                         *
                         *     @param {boolean} [options.useReload=false] - This property indicates whether reload the popup or not.<br>
                         *      If true, the popup will be reloaded when you try to re-open the popup that has been opened.<br>
                         *      When transmit the POST-data, some browsers alert a message for confirming whether retransmit or not.
                         *
                         *     @param {string} [options.postBridgeUrl='']
                         *      Use this url to avoid a certain bug occuring when transmitting POST data to the popup in IE11.<br>
                         *      This specific buggy situation is known to happen because IE11 tries to open the requested url<br>
                         *      not in a new popup window as intended, but in a new tab.<br>
                         *      See {@link http://wiki.nhnent.com/pages/viewpage.action?pageId=240562844}
                         *
                         *     @param {string} [options.method=get]
                         *     The method of transmission when the form-data is transmitted to popup-window.
                         *
                         *     @param {Object} [options.param=null]
                         *     Using as parameters for transmission when the form-data is transmitted to popup-window.
                         */
                        Popup.prototype.openPopup = function(url, options) { // eslint-disable-line complexity
                            var popup, formElement, useIEPostBridge;

                            options = object.extend({
                                popupName: 'popup_' + popupId + '_' + Number(new Date()),
                                popupOptionStr: '',
                                useReload: true,
                                closeWithParent: true,
                                method: 'get',
                                param: {}
                            }, options || {});

                            options.method = options.method.toUpperCase();

                            this.postBridgeUrl = options.postBridgeUrl || this.postBridgeUrl;

                            useIEPostBridge = options.method === 'POST' && options.param &&
                                browser.msie && browser.version === 11;

                            if (!type.isExisty(url)) {
                                throw new Error('Popup#open() need popup url.');
                            }

                            popupId += 1;

                            /*
    	     * In form-data transmission
    	     * 1. Create a form before opening a popup.
    	     * 2. Transmit the form-data.
    	     * 3. Remove the form after transmission.
    	     */
                            if (options.param) {
                                if (options.method === 'GET') {
                                    url = url + (/\?/.test(url) ? '&' : '?') + this._parameterize(options.param);
                                } else if (options.method === 'POST') {
                                    if (!useIEPostBridge) {
                                        formElement = this.createForm(url, options.param, options.method, options.popupName);
                                        url = 'about:blank';
                                    }
                                }
                            }

                            popup = this.openedPopup[options.popupName];

                            if (!type.isExisty(popup)) {
                                this.openedPopup[options.popupName] = popup = this._open(useIEPostBridge, options.param,
                                    url, options.popupName, options.popupOptionStr);
                            } else if (popup.closed) {
                                this.openedPopup[options.popupName] = popup = this._open(useIEPostBridge, options.param,
                                    url, options.popupName, options.popupOptionStr);
                            } else {
                                if (options.useReload) {
                                    popup.location.replace(url);
                                }
                                popup.focus();
                            }

                            this.closeWithParentPopup[options.popupName] = options.closeWithParent;

                            if (!popup || popup.closed || type.isUndefined(popup.closed)) {
                                alert('please enable popup windows for this website');
                            }

                            if (options.param && options.method === 'POST' && !useIEPostBridge) {
                                if (popup) {
                                    formElement.submit();
                                }
                                if (formElement.parentNode) {
                                    formElement.parentNode.removeChild(formElement);
                                }
                            }

                            window.onunload = func.bind(this.closeAllPopup, this);
                        };

                        /**
                         * Close the popup
                         * @param {boolean} [skipBeforeUnload] - If true, the 'window.onunload' will be null and skip unload event.
                         * @param {Window} [popup] - Window-context of popup for closing. If omit this, current window-context will be closed.
                         */
                        Popup.prototype.close = function(skipBeforeUnload, popup) {
                            var target = popup || window;
                            skipBeforeUnload = type.isExisty(skipBeforeUnload) ? skipBeforeUnload : false;

                            if (skipBeforeUnload) {
                                window.onunload = null;
                            }

                            if (!target.closed) {
                                target.opener = window.location.href;
                                target.close();
                            }
                        };

                        /**
                         * Close all the popups in current window.
                         * @param {boolean} closeWithParent - If true, popups having the closeWithParentPopup property as true will be closed.
                         */
                        Popup.prototype.closeAllPopup = function(closeWithParent) {
                            var hasArg = type.isExisty(closeWithParent);

                            collection.forEachOwnProperties(this.openedPopup, function(popup, key) {
                                if ((hasArg && this.closeWithParentPopup[key]) || !hasArg) {
                                    this.close(false, popup);
                                }
                            }, this);
                        };

                        /**
                         * Activate(or focus) the popup of the given name.
                         * @param {string} popupName - Name of popup for activation
                         */
                        Popup.prototype.focus = function(popupName) {
                            this.getPopupList(popupName).focus();
                        };

                        /**
                         * Return an object made of parsing the query string.
                         * @returns {Object} An object having some information of the query string.
                         * @private
                         */
                        Popup.prototype.parseQuery = function() {
                            var param = {};
                            var search, pair;

                            search = window.location.search.substr(1);
                            collection.forEachArray(search.split('&'), function(part) {
                                pair = part.split('=');
                                param[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
                            });

                            return param;
                        };

                        /**
                         * Create a hidden form from the given arguments and return this form.
                         * @param {string} action - URL for form transmission
                         * @param {Object} [data] - Data for form transmission
                         * @param {string} [method] - Method of transmission
                         * @param {string} [target] - Target of transmission
                         * @param {HTMLElement} [container] - Container element of form.
                         * @returns {HTMLElement} Form element
                         */
                        Popup.prototype.createForm = function(action, data, method, target, container) {
                            var form = document.createElement('form'),
                                input;

                            container = container || document.body;

                            form.method = method || 'POST';
                            form.action = action || '';
                            form.target = target || '';
                            form.style.display = 'none';

                            collection.forEachOwnProperties(data, function(value, key) {
                                input = document.createElement('input');
                                input.name = key;
                                input.type = 'hidden';
                                input.value = value;
                                form.appendChild(input);
                            });

                            container.appendChild(form);

                            return form;
                        };

                        /**********
                         * private methods
                         **********/

                        /**
                         * Return an query string made by parsing the given object
                         * @param {Object} obj - An object that has information for query string
                         * @returns {string} - Query string
                         * @private
                         */
                        Popup.prototype._parameterize = function(obj) {
                            var query = [];

                            collection.forEachOwnProperties(obj, function(value, key) {
                                query.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
                            });

                            return query.join('&');
                        };

                        /**
                         * Open popup
                         * @param {boolean} useIEPostBridge - A switch option whether to use alternative
                         *                                  of tossing POST data to the popup window in IE11
                         * @param {Object} param - A data for tossing to popup
                         * @param {string} url - Popup url
                         * @param {string} popupName - Popup name
                         * @param {string} optionStr - Setting for popup, ex) 'width=640,height=320,scrollbars=yes'
                         * @returns {Window} Window context of popup
                         * @private
                         */
                        Popup.prototype._open = function(useIEPostBridge, param, url, popupName, optionStr) {
                            var popup;

                            if (useIEPostBridge) {
                                popup = window.open(this.postBridgeUrl, popupName, optionStr);
                                setTimeout(function() {
                                    popup.redirect(url, param);
                                }, 100);
                            } else {
                                popup = window.open(url, popupName, optionStr);
                            }

                            return popup;
                        };

                        module.exports = new Popup();


                        /***/ }),
                    /* 12 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var type = __webpack_require__(2);
                        var object = __webpack_require__(1);

                        var tokens = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*A/gi;
                        var MONTH_STR = [
                            'Invalid month', 'January', 'February', 'March', 'April', 'May',
                            'June', 'July', 'August', 'September', 'October', 'November', 'December'
                        ];
                        var MONTH_DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                        var replaceMap = {
                            M: function(date) {
                                return Number(date.month);
                            },
                            MM: function(date) {
                                var month = date.month;

                                return (Number(month) < 10) ? '0' + month : month;
                            },
                            MMM: function(date) {
                                return MONTH_STR[Number(date.month)].substr(0, 3);
                            },
                            MMMM: function(date) {
                                return MONTH_STR[Number(date.month)];
                            },
                            D: function(date) {
                                return Number(date.date);
                            },
                            d: function(date) {
                                return replaceMap.D(date); // eslint-disable-line new-cap
                            },
                            DD: function(date) {
                                var dayInMonth = date.date;

                                return (Number(dayInMonth) < 10) ? '0' + dayInMonth : dayInMonth;
                            },
                            dd: function(date) {
                                return replaceMap.DD(date); // eslint-disable-line new-cap
                            },
                            YY: function(date) {
                                return Number(date.year) % 100;
                            },
                            yy: function(date) {
                                return replaceMap.YY(date); // eslint-disable-line new-cap
                            },
                            YYYY: function(date) {
                                var prefix = '20',
                                    year = date.year;
                                if (year > 69 && year < 100) {
                                    prefix = '19';
                                }

                                return (Number(year) < 100) ? prefix + String(year) : year;
                            },
                            yyyy: function(date) {
                                return replaceMap.YYYY(date); // eslint-disable-line new-cap
                            },
                            A: function(date) {
                                return date.meridiem;
                            },
                            a: function(date) {
                                return date.meridiem;
                            },
                            hh: function(date) {
                                var hour = date.hour;

                                return (Number(hour) < 10) ? '0' + hour : hour;
                            },
                            HH: function(date) {
                                return replaceMap.hh(date);
                            },
                            h: function(date) {
                                return String(Number(date.hour));
                            },
                            H: function(date) {
                                return replaceMap.h(date);
                            },
                            m: function(date) {
                                return String(Number(date.minute));
                            },
                            mm: function(date) {
                                var minute = date.minute;

                                return (Number(minute) < 10) ? '0' + minute : minute;
                            }
                        };

                        /**
                         * Check whether the given variables are valid date or not.
                         * @param {number} year - Year
                         * @param {number} month - Month
                         * @param {number} date - Day in month.
                         * @returns {boolean} Is valid?
                         * @private
                         */
                        function isValidDate(year, month, date) { // eslint-disable-line complexity
                            var isValidYear, isValidMonth, isValid, lastDayInMonth;

                            year = Number(year);
                            month = Number(month);
                            date = Number(date);

                            isValidYear = (year > -1 && year < 100) || ((year > 1969) && (year < 2070));
                            isValidMonth = (month > 0) && (month < 13);

                            if (!isValidYear || !isValidMonth) {
                                return false;
                            }

                            lastDayInMonth = MONTH_DAYS[month];
                            if (month === 2 && year % 4 === 0) {
                                if (year % 100 !== 0 || year % 400 === 0) {
                                    lastDayInMonth = 29;
                                }
                            }

                            isValid = (date > 0) && (date <= lastDayInMonth);

                            return isValid;
                        }

                        /**
                         * Return a string that transformed from the given form and date.
                         * @param {string} form - Date form
                         * @param {Date|Object} date - Date object
                         * @param {{meridiemSet: {AM: string, PM: string}}} option - Option
                         * @returns {boolean|string} A transformed string or false.
                         * @memberof tui.util
                         * @example
                         *  // key             | Shorthand
                         *  // --------------- |-----------------------
                         *  // years           | YY / YYYY / yy / yyyy
                         *  // months(n)       | M / MM
                         *  // months(str)     | MMM / MMMM
                         *  // days            | D / DD / d / dd
                         *  // hours           | H / HH / h / hh
                         *  // minutes         | m / mm
                         *  // meridiem(AM,PM) | A / a
                         *
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var dateStr1 = util.formatDate('yyyy-MM-dd', {
                         *     year: 2014,
                         *     month: 12,
                         *     date: 12
                         * });
                         * alert(dateStr1); // '2014-12-12'
                         *
                         * var dateStr2 = util.formatDate('MMM DD YYYY HH:mm', {
                         *     year: 1999,
                         *     month: 9,
                         *     date: 9,
                         *     hour: 0,
                         *     minute: 2
                         * });
                         * alert(dateStr2); // 'Sep 09 1999 00:02'
                         *
                         * var dt = new Date(2010, 2, 13),
                         *     dateStr3 = util.formatDate('yyyy M dd', dt);
                         * alert(dateStr3); // '2010 3 13'
                         *
                         * var option4 = {
                         *     meridiemSet: {
                         *         AM: '',
                         *         PM: ''
                         *     }
                         * };
                         * var date4 = {year: 1999, month: 9, date: 9, hour: 13, minute: 2};
                         * var dateStr4 = util.formatDate('yyyy-MM-dd A hh:mm', date4, option4));
                         * alert(dateStr4); // '1999-09-09  01:02'
                         */
                        function formatDate(form, date, option) { // eslint-disable-line complexity
                            var am = object.pick(option, 'meridiemSet', 'AM') || 'AM';
                            var pm = object.pick(option, 'meridiemSet', 'PM') || 'PM';
                            var meridiem, nDate, resultStr;

                            if (type.isDate(date)) {
                                nDate = {
                                    year: date.getFullYear(),
                                    month: date.getMonth() + 1,
                                    date: date.getDate(),
                                    hour: date.getHours(),
                                    minute: date.getMinutes()
                                };
                            } else {
                                nDate = {
                                    year: date.year,
                                    month: date.month,
                                    date: date.date,
                                    hour: date.hour,
                                    minute: date.minute
                                };
                            }

                            if (!isValidDate(nDate.year, nDate.month, nDate.date)) {
                                return false;
                            }

                            nDate.meridiem = '';
                            if (/([^\\]|^)[aA]\b/.test(form)) {
                                meridiem = (nDate.hour > 11) ? pm : am;
                                if (nDate.hour > 12) { // See the clock system: https://en.wikipedia.org/wiki/12-hour_clock
                                    nDate.hour %= 12;
                                }
                                if (nDate.hour === 0) {
                                    nDate.hour = 12;
                                }
                                nDate.meridiem = meridiem;
                            }

                            resultStr = form.replace(tokens, function(key) {
                                if (key.indexOf('\\') > -1) { // escape character
                                    return key.replace(/\\/, '');
                                }

                                return replaceMap[key](nDate) || '';
                            });

                            return resultStr;
                        }

                        module.exports = formatDate;


                        /***/ }),
                    /* 13 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var inherit = __webpack_require__(6).inherit;
                        var extend = __webpack_require__(1).extend;

                        /**
                         * Help a constructor to be defined and to inherit from the other constructors
                         * @param {*} [parent] Parent constructor
                         * @param {Object} props Members of constructor
                         *  @param {Function} props.init Initialization method
                         *  @param {Object} [props.static] Static members of constructor
                         * @returns {*} Constructor
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var Parent = util.defineClass({
                         *     init: function() { // constuructor
                         *         this.name = 'made by def';
                         *     },
                         *     method: function() {
                         *         // ...
                         *     },
                         *     static: {
                         *         staticMethod: function() {
                         *              // ...
                         *         }
                         *     }
                         * });
                         *
                         * var Child = util.defineClass(Parent, {
                         *     childMethod: function() {}
                         * });
                         *
                         * Parent.staticMethod();
                         *
                         * var parentInstance = new Parent();
                         * console.log(parentInstance.name); //made by def
                         * parentInstance.staticMethod(); // Error
                         *
                         * var childInstance = new Child();
                         * childInstance.method();
                         * childInstance.childMethod();
                         */
                        function defineClass(parent, props) {
                            var obj;

                            if (!props) {
                                props = parent;
                                parent = null;
                            }

                            obj = props.init || function() {};

                            if (parent) {
                                inherit(obj, parent);
                            }

                            if (props.hasOwnProperty('static')) {
                                extend(obj, props['static']);
                                delete props['static'];
                            }

                            extend(obj.prototype, props);

                            return obj;
                        }

                        module.exports = defineClass;


                        /***/ }),
                    /* 14 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var defineNamespace = __webpack_require__(15);
                        var type = __webpack_require__(2);

                        var INITIALIZATION_METHOD_NAME = 'initialize';

                        /**
                         * Define module
                         * @param {string} namespace - Namespace of module
                         * @param {Object} moduleDefinition - Object literal for module
                         * @returns {Object} Defined module
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var myModule = util.defineModule('modules.myModule', {
                         *     name: 'john',
                         *     message: '',
                         *     initialize: function() {
                         *        this.message = 'hello world';
                         *     },
                         *     getMessage: function() {
                         *         return this.name + ': ' + this.message
                         *     }
                         * });
                         *
                         * console.log(myModule.getMessage());  // 'john: hello world';
                         */
                        function defineModule(namespace, moduleDefinition) {
                            var base = moduleDefinition || {};

                            if (type.isFunction(base[INITIALIZATION_METHOD_NAME])) {
                                base[INITIALIZATION_METHOD_NAME]();
                            }

                            return defineNamespace(namespace, base);
                        }

                        module.exports = defineModule;


                        /***/ }),
                    /* 15 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var collection = __webpack_require__(4);
                        var object = __webpack_require__(1);

                        /**
                         * Define namespace
                         * @param {string} namespace - Namespace (ex- 'foo.bar.baz')
                         * @param {(object|function)} props - A set of modules or one module
                         * @param {boolean} [isOverride] - Override the props to the namespace.<br>
                         *                                  (It removes previous properties of this namespace)
                         * @returns {(object|function)} Defined namespace
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var util = require('tui-code-snippet'); // node, commonjs
                         * var util = tui.util; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var neComp = util.defineNamespace;
                         * neComp.listMenu = defineClass({
                         *     init: function() {
                         *         // ...
                         *     }
                         * });
                         */
                        function defineNamespace(namespace, props, isOverride) {
                            var names, result, prevLast, last;

                            names = namespace.split('.');
                            names.unshift(window);

                            result = collection.reduce(names, function(obj, name) {
                                obj[name] = obj[name] || {};

                                return obj[name];
                            });

                            if (isOverride) {
                                last = names.pop();
                                prevLast = object.pick.apply(null, names);
                                result = prevLast[last] = props;
                            } else {
                                object.extend(result, props);
                            }

                            return result;
                        }

                        module.exports = defineNamespace;


                        /***/ }),
                    /* 16 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var collection = __webpack_require__(4);
                        var type = __webpack_require__(2);
                        var object = __webpack_require__(1);

                        var R_EVENTNAME_SPLIT = /\s+/g;

                        /**
                         * A unit of event handler item.
                         * @ignore
                         * @typedef {object} HandlerItem
                         * @property {function} fn - event handler
                         * @property {object} ctx - context of event handler
                         */

                        /**
                         * @class
                         * @memberof tui.util
                         * @example
                         * // node, commonjs
                         * var CustomEvents = require('tui-code-snippet').CustomEvents;
                         * @example
                         * // distribution file, script
                         * <script src='path-to/tui-code-snippt.js'></script>
                         * <script>
                         * var CustomEvents = tui.util.CustomEvents;
                         * </script>
                         */
                        function CustomEvents() {
                            /**
                             * @type {HandlerItem[]}
                             */
                            this.events = null;

                            /**
                             * only for checking specific context event was binded
                             * @type {object[]}
                             */
                            this.contexts = null;
                        }

                        /**
                         * Mixin custom events feature to specific constructor
                         * @param {function} func - constructor
                         * @example
                         * //-- #1. Get Module --//
                         * var CustomEvents = require('tui-code-snippet').CustomEvents; // node, commonjs
                         * var CustomEvents = tui.util.CustomEvents; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var model;
                         * function Model() {
                         *     this.name = '';
                         * }
                         * CustomEvents.mixin(Model);
                         *
                         * model = new Model();
                         * model.on('change', function() { this.name = 'model'; }, this);
                         * model.fire('change');
                         * alert(model.name); // 'model';
                         */
                        CustomEvents.mixin = function(func) {
                            object.extend(func.prototype, CustomEvents.prototype);
                        };

                        /**
                         * Get HandlerItem object
                         * @param {function} handler - handler function
                         * @param {object} [context] - context for handler
                         * @returns {HandlerItem} HandlerItem object
                         * @private
                         */
                        CustomEvents.prototype._getHandlerItem = function(handler, context) {
                            var item = {handler: handler};

                            if (context) {
                                item.context = context;
                            }

                            return item;
                        };

                        /**
                         * Get event object safely
                         * @param {string} [eventName] - create sub event map if not exist.
                         * @returns {(object|array)} event object. if you supplied `eventName`
                         *  parameter then make new array and return it
                         * @private
                         */
                        CustomEvents.prototype._safeEvent = function(eventName) {
                            var events = this.events;
                            var byName;

                            if (!events) {
                                events = this.events = {};
                            }

                            if (eventName) {
                                byName = events[eventName];

                                if (!byName) {
                                    byName = [];
                                    events[eventName] = byName;
                                }

                                events = byName;
                            }

                            return events;
                        };

                        /**
                         * Get context array safely
                         * @returns {array} context array
                         * @private
                         */
                        CustomEvents.prototype._safeContext = function() {
                            var context = this.contexts;

                            if (!context) {
                                context = this.contexts = [];
                            }

                            return context;
                        };

                        /**
                         * Get index of context
                         * @param {object} ctx - context that used for bind custom event
                         * @returns {number} index of context
                         * @private
                         */
                        CustomEvents.prototype._indexOfContext = function(ctx) {
                            var context = this._safeContext();
                            var index = 0;

                            while (context[index]) {
                                if (ctx === context[index][0]) {
                                    return index;
                                }

                                index += 1;
                            }

                            return -1;
                        };

                        /**
                         * Memorize supplied context for recognize supplied object is context or
                         *  name: handler pair object when off()
                         * @param {object} ctx - context object to memorize
                         * @private
                         */
                        CustomEvents.prototype._memorizeContext = function(ctx) {
                            var context, index;

                            if (!type.isExisty(ctx)) {
                                return;
                            }

                            context = this._safeContext();
                            index = this._indexOfContext(ctx);

                            if (index > -1) {
                                context[index][1] += 1;
                            } else {
                                context.push([ctx, 1]);
                            }
                        };

                        /**
                         * Forget supplied context object
                         * @param {object} ctx - context object to forget
                         * @private
                         */
                        CustomEvents.prototype._forgetContext = function(ctx) {
                            var context, contextIndex;

                            if (!type.isExisty(ctx)) {
                                return;
                            }

                            context = this._safeContext();
                            contextIndex = this._indexOfContext(ctx);

                            if (contextIndex > -1) {
                                context[contextIndex][1] -= 1;

                                if (context[contextIndex][1] <= 0) {
                                    context.splice(contextIndex, 1);
                                }
                            }
                        };

                        /**
                         * Bind event handler
                         * @param {(string|{name:string, handler:function})} eventName - custom
                         *  event name or an object {eventName: handler}
                         * @param {(function|object)} [handler] - handler function or context
                         * @param {object} [context] - context for binding
                         * @private
                         */
                        CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
                            var events = this._safeEvent(eventName);
                            this._memorizeContext(context);
                            events.push(this._getHandlerItem(handler, context));
                        };

                        /**
                         * Bind event handlers
                         * @param {(string|{name:string, handler:function})} eventName - custom
                         *  event name or an object {eventName: handler}
                         * @param {(function|object)} [handler] - handler function or context
                         * @param {object} [context] - context for binding
                         * //-- #1. Get Module --//
                         * var CustomEvents = require('tui-code-snippet').CustomEvents; // node, commonjs
                         * var CustomEvents = tui.util.CustomEvents; // distribution file
                         *
                         * //-- #2. Use property --//
                         * // # 2.1 Basic Usage
                         * CustomEvents.on('onload', handler);
                         *
                         * // # 2.2 With context
                         * CustomEvents.on('onload', handler, myObj);
                         *
                         * // # 2.3 Bind by object that name, handler pairs
                         * CustomEvents.on({
                         *     'play': handler,
                         *     'pause': handler2
                         * });
                         *
                         * // # 2.4 Bind by object that name, handler pairs with context object
                         * CustomEvents.on({
                         *     'play': handler
                         * }, myObj);
                         */
                        CustomEvents.prototype.on = function(eventName, handler, context) {
                            var self = this;

                            if (type.isString(eventName)) {
                                // [syntax 1, 2]
                                eventName = eventName.split(R_EVENTNAME_SPLIT);
                                collection.forEach(eventName, function(name) {
                                    self._bindEvent(name, handler, context);
                                });
                            } else if (type.isObject(eventName)) {
                                // [syntax 3, 4]
                                context = handler;
                                collection.forEach(eventName, function(func, name) {
                                    self.on(name, func, context);
                                });
                            }
                        };

                        /**
                         * Bind one-shot event handlers
                         * @param {(string|{name:string,handler:function})} eventName - custom
                         *  event name or an object {eventName: handler}
                         * @param {function|object} [handler] - handler function or context
                         * @param {object} [context] - context for binding
                         */
                        CustomEvents.prototype.once = function(eventName, handler, context) {
                            var self = this;

                            if (type.isObject(eventName)) {
                                context = handler;
                                collection.forEach(eventName, function(func, name) {
                                    self.once(name, func, context);
                                });

                                return;
                            }

                            function onceHandler() { // eslint-disable-line require-jsdoc
                                handler.apply(context, arguments);
                                self.off(eventName, onceHandler, context);
                            }

                            this.on(eventName, onceHandler, context);
                        };

                        /**
                         * Splice supplied array by callback result
                         * @param {array} arr - array to splice
                         * @param {function} predicate - function return boolean
                         * @private
                         */
                        CustomEvents.prototype._spliceMatches = function(arr, predicate) {
                            var i = 0;
                            var len;

                            if (!type.isArray(arr)) {
                                return;
                            }

                            for (len = arr.length; i < len; i += 1) {
                                if (predicate(arr[i]) === true) {
                                    arr.splice(i, 1);
                                    len -= 1;
                                    i -= 1;
                                }
                            }
                        };

                        /**
                         * Get matcher for unbind specific handler events
                         * @param {function} handler - handler function
                         * @returns {function} handler matcher
                         * @private
                         */
                        CustomEvents.prototype._matchHandler = function(handler) {
                            var self = this;

                            return function(item) {
                                var needRemove = handler === item.handler;

                                if (needRemove) {
                                    self._forgetContext(item.context);
                                }

                                return needRemove;
                            };
                        };

                        /**
                         * Get matcher for unbind specific context events
                         * @param {object} context - context
                         * @returns {function} object matcher
                         * @private
                         */
                        CustomEvents.prototype._matchContext = function(context) {
                            var self = this;

                            return function(item) {
                                var needRemove = context === item.context;

                                if (needRemove) {
                                    self._forgetContext(item.context);
                                }

                                return needRemove;
                            };
                        };

                        /**
                         * Get matcher for unbind specific hander, context pair events
                         * @param {function} handler - handler function
                         * @param {object} context - context
                         * @returns {function} handler, context matcher
                         * @private
                         */
                        CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
                            var self = this;

                            return function(item) {
                                var matchHandler = (handler === item.handler);
                                var matchContext = (context === item.context);
                                var needRemove = (matchHandler && matchContext);

                                if (needRemove) {
                                    self._forgetContext(item.context);
                                }

                                return needRemove;
                            };
                        };

                        /**
                         * Unbind event by event name
                         * @param {string} eventName - custom event name to unbind
                         * @param {function} [handler] - handler function
                         * @private
                         */
                        CustomEvents.prototype._offByEventName = function(eventName, handler) {
                            var self = this;
                            var forEach = collection.forEachArray;
                            var andByHandler = type.isFunction(handler);
                            var matchHandler = self._matchHandler(handler);

                            eventName = eventName.split(R_EVENTNAME_SPLIT);

                            forEach(eventName, function(name) {
                                var handlerItems = self._safeEvent(name);

                                if (andByHandler) {
                                    self._spliceMatches(handlerItems, matchHandler);
                                } else {
                                    forEach(handlerItems, function(item) {
                                        self._forgetContext(item.context);
                                    });

                                    self.events[name] = [];
                                }
                            });
                        };

                        /**
                         * Unbind event by handler function
                         * @param {function} handler - handler function
                         * @private
                         */
                        CustomEvents.prototype._offByHandler = function(handler) {
                            var self = this;
                            var matchHandler = this._matchHandler(handler);

                            collection.forEach(this._safeEvent(), function(handlerItems) {
                                self._spliceMatches(handlerItems, matchHandler);
                            });
                        };

                        /**
                         * Unbind event by object(name: handler pair object or context object)
                         * @param {object} obj - context or {name: handler} pair object
                         * @param {function} handler - handler function
                         * @private
                         */
                        CustomEvents.prototype._offByObject = function(obj, handler) {
                            var self = this;
                            var matchFunc;

                            if (this._indexOfContext(obj) < 0) {
                                collection.forEach(obj, function(func, name) {
                                    self.off(name, func);
                                });
                            } else if (type.isString(handler)) {
                                matchFunc = this._matchContext(obj);

                                self._spliceMatches(this._safeEvent(handler), matchFunc);
                            } else if (type.isFunction(handler)) {
                                matchFunc = this._matchHandlerAndContext(handler, obj);

                                collection.forEach(this._safeEvent(), function(handlerItems) {
                                    self._spliceMatches(handlerItems, matchFunc);
                                });
                            } else {
                                matchFunc = this._matchContext(obj);

                                collection.forEach(this._safeEvent(), function(handlerItems) {
                                    self._spliceMatches(handlerItems, matchFunc);
                                });
                            }
                        };

                        /**
                         * Unbind custom events
                         * @param {(string|object|function)} eventName - event name or context or
                         *  {name: handler} pair object or handler function
                         * @param {(function)} handler - handler function
                         * @example
                         * //-- #1. Get Module --//
                         * var CustomEvents = require('tui-code-snippet').CustomEvents; // node, commonjs
                         * var CustomEvents = tui.util.CustomEvents; // distribution file
                         *
                         * //-- #2. Use property --//
                         * // # 2.1 off by event name
                         * CustomEvents.off('onload');
                         *
                         * // # 2.2 off by event name and handler
                         * CustomEvents.off('play', handler);
                         *
                         * // # 2.3 off by handler
                         * CustomEvents.off(handler);
                         *
                         * // # 2.4 off by context
                         * CustomEvents.off(myObj);
                         *
                         * // # 2.5 off by context and handler
                         * CustomEvents.off(myObj, handler);
                         *
                         * // # 2.6 off by context and event name
                         * CustomEvents.off(myObj, 'onload');
                         *
                         * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
                         * CustomEvents.off({
                         *   'play': handler,
                         *   'pause': handler2
                         * });
                         *
                         * // # 2.8 off the all events
                         * CustomEvents.off();
                         */
                        CustomEvents.prototype.off = function(eventName, handler) {
                            if (type.isString(eventName)) {
                                // [syntax 1, 2]
                                this._offByEventName(eventName, handler);
                            } else if (!arguments.length) {
                                // [syntax 8]
                                this.events = {};
                                this.contexts = [];
                            } else if (type.isFunction(eventName)) {
                                // [syntax 3]
                                this._offByHandler(eventName);
                            } else if (type.isObject(eventName)) {
                                // [syntax 4, 5, 6]
                                this._offByObject(eventName, handler);
                            }
                        };

                        /**
                         * Fire custom event
                         * @param {string} eventName - name of custom event
                         */
                        CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
                            this.invoke.apply(this, arguments);
                        };

                        /**
                         * Fire a event and returns the result of operation 'boolean AND' with all
                         *  listener's results.
                         *
                         * So, It is different from {@link CustomEvents#fire}.
                         *
                         * In service code, use this as a before event in component level usually
                         *  for notifying that the event is cancelable.
                         * @param {string} eventName - Custom event name
                         * @param {...*} data - Data for event
                         * @returns {boolean} The result of operation 'boolean AND'
                         * @example
                         * var map = new Map();
                         * map.on({
                         *     'beforeZoom': function() {
                         *         // It should cancel the 'zoom' event by some conditions.
                         *         if (that.disabled && this.getState()) {
                         *             return false;
                         *         }
                         *         return true;
                         *     }
                         * });
                         *
                         * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
                         *     // if true,
                         *     // doSomething
                         * }
                         */
                        CustomEvents.prototype.invoke = function(eventName) {
                            var events, args, index, item;

                            if (!this.hasListener(eventName)) {
                                return true;
                            }

                            events = this._safeEvent(eventName);
                            args = Array.prototype.slice.call(arguments, 1);
                            index = 0;

                            while (events[index]) {
                                item = events[index];

                                if (item.handler.apply(item.context, args) === false) {
                                    return false;
                                }

                                index += 1;
                            }

                            return true;
                        };

                        /**
                         * Return whether at least one of the handlers is registered in the given
                         *  event name.
                         * @param {string} eventName - Custom event name
                         * @returns {boolean} Is there at least one handler in event name?
                         */
                        CustomEvents.prototype.hasListener = function(eventName) {
                            return this.getListenerLength(eventName) > 0;
                        };

                        /**
                         * Return a count of events registered.
                         * @param {string} eventName - Custom event name
                         * @returns {number} number of event
                         */
                        CustomEvents.prototype.getListenerLength = function(eventName) {
                            var events = this._safeEvent(eventName);

                            return events.length;
                        };

                        module.exports = CustomEvents;


                        /***/ }),
                    /* 17 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var collection = __webpack_require__(4);
                        var type = __webpack_require__(2);

                        /**
                         * Check whether the defineProperty() method is supported.
                         * @type {boolean}
                         * @ignore
                         */
                        var isSupportDefinedProperty = (function() {
                            try {
                                Object.defineProperty({}, 'x', {});

                                return true;
                            } catch (e) {
                                return false;
                            }
                        })();

                        /**
                         * A unique value of a constant.
                         * @type {number}
                         * @ignore
                         */
                        var enumValue = 0;

                        /**
                         * Make a constant-list that has unique values.<br>
                         * In modern browsers (except IE8 and lower),<br>
                         *  a value defined once can not be changed.
                         *
                         * @param {...string|string[]} itemList Constant-list (An array of string is available)
                         * @class
                         * @memberof tui.util
                         * @example
                         * //-- #1. Get Module --//
                         * var Enum = require('tui-code-snippet').Enum; // node, commonjs
                         * var Enum = tui.util.Enum; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var MYENUM = new Enum('TYPE1', 'TYPE2');
                         * var MYENUM2 = new Enum(['TYPE1', 'TYPE2']);
                         *
                         * //usage
                         * if (value === MYENUM.TYPE1) {
                         *      ....
                         * }
                         *
                         * //add (If a duplicate name is inputted, will be disregarded.)
                         * MYENUM.set('TYPE3', 'TYPE4');
                         *
                         * //get name of a constant by a value
                         * MYENUM.getName(MYENUM.TYPE1); // 'TYPE1'
                         *
                         * // In modern browsers (except IE8 and lower), a value can not be changed in constants.
                         * var originalValue = MYENUM.TYPE1;
                         * MYENUM.TYPE1 = 1234; // maybe TypeError
                         * MYENUM.TYPE1 === originalValue; // true
                         **/
                        function Enum(itemList) {
                            if (itemList) {
                                this.set.apply(this, arguments);
                            }
                        }

                        /**
                         * Define a constants-list
                         * @param {...string|string[]} itemList Constant-list (An array of string is available)
                         */
                        Enum.prototype.set = function(itemList) {
                            var self = this;

                            if (!type.isArray(itemList)) {
                                itemList = collection.toArray(arguments);
                            }

                            collection.forEach(itemList, function itemListIteratee(item) {
                                self._addItem(item);
                            });
                        };

                        /**
                         * Return a key of the constant.
                         * @param {number} value A value of the constant.
                         * @returns {string|undefined} Key of the constant.
                         */
                        Enum.prototype.getName = function(value) {
                            var self = this;
                            var foundedKey;

                            collection.forEach(this, function(itemValue, key) { // eslint-disable-line consistent-return
                                if (self._isEnumItem(key) && value === itemValue) {
                                    foundedKey = key;

                                    return false;
                                }
                            });

                            return foundedKey;
                        };

                        /**
                         * Create a constant.
                         * @private
                         * @param {string} name Constant name. (It will be a key of a constant)
                         */
                        Enum.prototype._addItem = function(name) {
                            var value;

                            if (!this.hasOwnProperty(name)) {
                                value = this._makeEnumValue();

                                if (isSupportDefinedProperty) {
                                    Object.defineProperty(this, name, {
                                        enumerable: true,
                                        configurable: false,
                                        writable: false,
                                        value: value
                                    });
                                } else {
                                    this[name] = value;
                                }
                            }
                        };

                        /**
                         * Return a unique value for assigning to a constant.
                         * @private
                         * @returns {number} A unique value
                         */
                        Enum.prototype._makeEnumValue = function() {
                            var value;

                            value = enumValue;
                            enumValue += 1;

                            return value;
                        };

                        /**
                         * Return whether a constant from the given key is in instance or not.
                         * @param {string} key - A constant key
                         * @returns {boolean} Result
                         * @private
                         */
                        Enum.prototype._isEnumItem = function(key) {
                            return type.isNumber(this[key]);
                        };

                        module.exports = Enum;


                        /***/ }),
                    /* 18 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var collection = __webpack_require__(4);
                        var Map = __webpack_require__(19);

                        // Caching tui.util for performance enhancing
                        var mapAPIsForRead = ['get', 'has', 'forEach', 'keys', 'values', 'entries'];
                        var mapAPIsForDelete = ['delete', 'clear'];

                        /**
                         * The ExMap object is Extended Version of the tui.util.Map object.<br>
                         * and added some useful feature to make it easy to manage the Map object.
                         * @constructor
                         * @param {Array} initData - Array of key-value pairs (2-element Arrays).
                         *      Each key-value pair will be added to the new Map
                         * @memberof tui.util
                         * @example
                         * // node, commonjs
                         * var ExMap = require('tui-code-snippet').ExMap;
                         * @example
                         * // distribution file, script
                         * <script src='path-to/tui-code-snippt.js'></script>
                         * <script>
                         * var ExMap = tui.util.ExMap;
                         * <script>
                         */
                        function ExMap(initData) {
                            this._map = new Map(initData);
                            this.size = this._map.size;
                        }

                        collection.forEachArray(mapAPIsForRead, function(name) {
                            ExMap.prototype[name] = function() {
                                return this._map[name].apply(this._map, arguments);
                            };
                        });

                        collection.forEachArray(mapAPIsForDelete, function(name) {
                            ExMap.prototype[name] = function() {
                                var result = this._map[name].apply(this._map, arguments);
                                this.size = this._map.size;

                                return result;
                            };
                        });

                        ExMap.prototype.set = function() {
                            this._map.set.apply(this._map, arguments);
                            this.size = this._map.size;

                            return this;
                        };

                        /**
                         * Sets all of the key-value pairs in the specified object to the Map object.
                         * @param  {Object} object - Plain object that has a key-value pair
                         */
                        ExMap.prototype.setObject = function(object) {
                            collection.forEachOwnProperties(object, function(value, key) {
                                this.set(key, value);
                            }, this);
                        };

                        /**
                         * Removes the elements associated with keys in the specified array.
                         * @param  {Array} keys - Array that contains keys of the element to remove
                         */
                        ExMap.prototype.deleteByKeys = function(keys) {
                            collection.forEachArray(keys, function(key) {
                                this['delete'](key);
                            }, this);
                        };

                        /**
                         * Sets all of the key-value pairs in the specified Map object to this Map object.
                         * @param  {Map} map - Map object to be merged into this Map object
                         */
                        ExMap.prototype.merge = function(map) {
                            map.forEach(function(value, key) {
                                this.set(key, value);
                            }, this);
                        };

                        /**
                         * Looks through each key-value pair in the map and returns the new ExMap object of
                         * all key-value pairs that pass a truth test implemented by the provided function.
                         * @param  {function} predicate - Function to test each key-value pair of the Map object.<br>
                         *      Invoked with arguments (value, key). Return true to keep the element, false otherwise.
                         * @returns {ExMap} A new ExMap object
                         */
                        ExMap.prototype.filter = function(predicate) {
                            var filtered = new ExMap();

                            this.forEach(function(value, key) {
                                if (predicate(value, key)) {
                                    filtered.set(key, value);
                                }
                            });

                            return filtered;
                        };

                        module.exports = ExMap;


                        /***/ }),
                    /* 19 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var collection = __webpack_require__(4);
                        var type = __webpack_require__(2);
                        var array = __webpack_require__(3);
                        var browser = __webpack_require__(10);
                        var func = __webpack_require__(5);

                        /**
                         * Using undefined for a key can be ambiguous if there's deleted item in the array,<br>
                         * which is also undefined when accessed by index.<br>
                         * So use this unique object as an undefined key to distinguish it from deleted keys.
                         * @private
                         * @constant
                         */
                        var _KEY_FOR_UNDEFINED = {};

                        /**
                         * For using NaN as a key, use this unique object as a NaN key.<br>
                         * This makes it easier and faster to compare an object with each keys in the array<br>
                         * through no exceptional comapring for NaN.
                         * @private
                         * @constant
                         */
                        var _KEY_FOR_NAN = {};

                        /**
                         * Constructor of MapIterator<br>
                         * Creates iterator object with new keyword.
                         * @constructor
                         * @param  {Array} keys - The array of keys in the map
                         * @param  {function} valueGetter - Function that returns certain value,
                         *      taking key and keyIndex as arguments.
                         * @ignore
                         */
                        function MapIterator(keys, valueGetter) {
                            this._keys = keys;
                            this._valueGetter = valueGetter;
                            this._length = this._keys.length;
                            this._index = -1;
                            this._done = false;
                        }

                        /**
                         * Implementation of Iterator protocol.
                         * @returns {{done: boolean, value: *}} Object that contains done(boolean) and value.
                         */
                        MapIterator.prototype.next = function() {
                            var data = {};
                            do {
                                this._index += 1;
                            } while (type.isUndefined(this._keys[this._index]) && this._index < this._length);

                            if (this._index >= this._length) {
                                data.done = true;
                            } else {
                                data.done = false;
                                data.value = this._valueGetter(this._keys[this._index], this._index);
                            }

                            return data;
                        };

                        /**
                         * The Map object implements the ES6 Map specification as closely as possible.<br>
                         * For using objects and primitive values as keys, this object uses array internally.<br>
                         * So if the key is not a string, get(), set(), has(), delete() will operates in O(n),<br>
                         * and it can cause performance issues with a large dataset.
                         *
                         * Features listed below are not supported. (can't be implented without native support)
                         * - Map object is iterable<br>
                         * - Iterable object can be used as an argument of constructor
                         *
                         * If the browser supports full implementation of ES6 Map specification, native Map obejct
                         * will be used internally.
                         * @class
                         * @param  {Array} initData - Array of key-value pairs (2-element Arrays).
                         *      Each key-value pair will be added to the new Map
                         * @memberof tui.util
                         * @example
                         * // node, commonjs
                         * var Map = require('tui-code-snippet').Map;
                         * @example
                         * // distribution file, script
                         * <script src='path-to/tui-code-snippt.js'></script>
                         * <script>
                         * var Map = tui.util.Map;
                         * <script>
                         */
                        function Map(initData) {
                            this._valuesForString = {};
                            this._valuesForIndex = {};
                            this._keys = [];

                            if (initData) {
                                this._setInitData(initData);
                            }

                            this.size = 0;
                        }

                        /* eslint-disable no-extend-native */
                        /**
                         * Add all elements in the initData to the Map object.
                         * @private
                         * @param  {Array} initData - Array of key-value pairs to add to the Map object
                         */
                        Map.prototype._setInitData = function(initData) {
                            if (!type.isArray(initData)) {
                                throw new Error('Only Array is supported.');
                            }
                            collection.forEachArray(initData, function(pair) {
                                this.set(pair[0], pair[1]);
                            }, this);
                        };

                        /**
                         * Returns true if the specified value is NaN.<br>
                         * For unsing NaN as a key, use this method to test equality of NaN<br>
                         * because === operator doesn't work for NaN.
                         * @private
                         * @param {*} value - Any object to be tested
                         * @returns {boolean} True if value is NaN, false otherwise.
                         */
                        Map.prototype._isNaN = function(value) {
                            return typeof value === 'number' && value !== value; // eslint-disable-line no-self-compare
                        };

                        /**
                         * Returns the index of the specified key.
                         * @private
                         * @param  {*} key - The key object to search for.
                         * @returns {number} The index of the specified key
                         */
                        Map.prototype._getKeyIndex = function(key) {
                            var result = -1;
                            var value;

                            if (type.isString(key)) {
                                value = this._valuesForString[key];
                                if (value) {
                                    result = value.keyIndex;
                                }
                            } else {
                                result = array.inArray(key, this._keys);
                            }

                            return result;
                        };

                        /**
                         * Returns the original key of the specified key.
                         * @private
                         * @param  {*} key - key
                         * @returns {*} Original key
                         */
                        Map.prototype._getOriginKey = function(key) {
                            var originKey = key;
                            if (key === _KEY_FOR_UNDEFINED) {
                                originKey = undefined; // eslint-disable-line no-undefined
                            } else if (key === _KEY_FOR_NAN) {
                                originKey = NaN;
                            }

                            return originKey;
                        };

                        /**
                         * Returns the unique key of the specified key.
                         * @private
                         * @param  {*} key - key
                         * @returns {*} Unique key
                         */
                        Map.prototype._getUniqueKey = function(key) {
                            var uniqueKey = key;
                            if (type.isUndefined(key)) {
                                uniqueKey = _KEY_FOR_UNDEFINED;
                            } else if (this._isNaN(key)) {
                                uniqueKey = _KEY_FOR_NAN;
                            }

                            return uniqueKey;
                        };

                        /**
                         * Returns the value object of the specified key.
                         * @private
                         * @param  {*} key - The key of the value object to be returned
                         * @param  {number} keyIndex - The index of the key
                         * @returns {{keyIndex: number, origin: *}} Value object
                         */
                        Map.prototype._getValueObject = function(key, keyIndex) { // eslint-disable-line consistent-return
                            if (type.isString(key)) {
                                return this._valuesForString[key];
                            }

                            if (type.isUndefined(keyIndex)) {
                                keyIndex = this._getKeyIndex(key);
                            }
                            if (keyIndex >= 0) {
                                return this._valuesForIndex[keyIndex];
                            }
                        };

                        /**
                         * Returns the original value of the specified key.
                         * @private
                         * @param  {*} key - The key of the value object to be returned
                         * @param  {number} keyIndex - The index of the key
                         * @returns {*} Original value
                         */
                        Map.prototype._getOriginValue = function(key, keyIndex) {
                            return this._getValueObject(key, keyIndex).origin;
                        };

                        /**
                         * Returns key-value pair of the specified key.
                         * @private
                         * @param  {*} key - The key of the value object to be returned
                         * @param  {number} keyIndex - The index of the key
                         * @returns {Array} Key-value Pair
                         */
                        Map.prototype._getKeyValuePair = function(key, keyIndex) {
                            return [this._getOriginKey(key), this._getOriginValue(key, keyIndex)];
                        };

                        /**
                         * Creates the wrapper object of original value that contains a key index
                         * and returns it.
                         * @private
                         * @param  {type} origin - Original value
                         * @param  {type} keyIndex - Index of the key
                         * @returns {{keyIndex: number, origin: *}} Value object
                         */
                        Map.prototype._createValueObject = function(origin, keyIndex) {
                            return {
                                keyIndex: keyIndex,
                                origin: origin
                            };
                        };

                        /**
                         * Sets the value for the key in the Map object.
                         * @param  {*} key - The key of the element to add to the Map object
                         * @param  {*} value - The value of the element to add to the Map object
                         * @returns {Map} The Map object
                         */
                        Map.prototype.set = function(key, value) {
                            var uniqueKey = this._getUniqueKey(key);
                            var keyIndex = this._getKeyIndex(uniqueKey);
                            var valueObject;

                            if (keyIndex < 0) {
                                keyIndex = this._keys.push(uniqueKey) - 1;
                                this.size += 1;
                            }
                            valueObject = this._createValueObject(value, keyIndex);

                            if (type.isString(key)) {
                                this._valuesForString[key] = valueObject;
                            } else {
                                this._valuesForIndex[keyIndex] = valueObject;
                            }

                            return this;
                        };

                        /**
                         * Returns the value associated to the key, or undefined if there is none.
                         * @param  {*} key - The key of the element to return
                         * @returns {*} Element associated with the specified key
                         */
                        Map.prototype.get = function(key) {
                            var uniqueKey = this._getUniqueKey(key);
                            var value = this._getValueObject(uniqueKey);

                            return value && value.origin;
                        };

                        /**
                         * Returns a new Iterator object that contains the keys for each element
                         * in the Map object in insertion order.
                         * @returns {Iterator} A new Iterator object
                         */
                        Map.prototype.keys = function() {
                            return new MapIterator(this._keys, func.bind(this._getOriginKey, this));
                        };

                        /**
                         * Returns a new Iterator object that contains the values for each element
                         * in the Map object in insertion order.
                         * @returns {Iterator} A new Iterator object
                         */
                        Map.prototype.values = function() {
                            return new MapIterator(this._keys, func.bind(this._getOriginValue, this));
                        };

                        /**
                         * Returns a new Iterator object that contains the [key, value] pairs
                         * for each element in the Map object in insertion order.
                         * @returns {Iterator} A new Iterator object
                         */
                        Map.prototype.entries = function() {
                            return new MapIterator(this._keys, func.bind(this._getKeyValuePair, this));
                        };

                        /**
                         * Returns a boolean asserting whether a value has been associated to the key
                         * in the Map object or not.
                         * @param  {*} key - The key of the element to test for presence
                         * @returns {boolean} True if an element with the specified key exists;
                         *          Otherwise false
                         */
                        Map.prototype.has = function(key) {
                            return !!this._getValueObject(key);
                        };

                        /**
                         * Removes the specified element from a Map object.
                         * @param {*} key - The key of the element to remove
                         * @function delete
                         * @memberof tui.util.Map.prototype
                         */
                        // cannot use reserved keyword as a property name in IE8 and under.
                        Map.prototype['delete'] = function(key) {
                            var keyIndex;

                            if (type.isString(key)) {
                                if (this._valuesForString[key]) {
                                    keyIndex = this._valuesForString[key].keyIndex;
                                    delete this._valuesForString[key];
                                }
                            } else {
                                keyIndex = this._getKeyIndex(key);
                                if (keyIndex >= 0) {
                                    delete this._valuesForIndex[keyIndex];
                                }
                            }

                            if (keyIndex >= 0) {
                                delete this._keys[keyIndex];
                                this.size -= 1;
                            }
                        };

                        /**
                         * Executes a provided function once per each key/value pair in the Map object,
                         * in insertion order.
                         * @param  {function} callback - Function to execute for each element
                         * @param  {thisArg} thisArg - Value to use as this when executing callback
                         */
                        Map.prototype.forEach = function(callback, thisArg) {
                            thisArg = thisArg || this;
                            collection.forEachArray(this._keys, function(key) {
                                if (!type.isUndefined(key)) {
                                    callback.call(thisArg, this._getValueObject(key).origin, key, this);
                                }
                            }, this);
                        };

                        /**
                         * Removes all elements from a Map object.
                         */
                        Map.prototype.clear = function() {
                            Map.call(this);
                        };
                        /* eslint-enable no-extend-native */

                        // Use native Map object if exists.
                        // But only latest versions of Chrome and Firefox support full implementation.
                        (function() {
                            if (window.Map && (
                                (browser.firefox && browser.version >= 37) ||
                                (browser.chrome && browser.version >= 42)
                            )
                            ) {
                                Map = window.Map; // eslint-disable-line no-func-assign
                            }
                        })();

                        module.exports = Map;


                        /***/ }),
                    /* 20 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var collection = __webpack_require__(4);
                        var type = __webpack_require__(2);
                        /**
                         * All the data in hashMap begin with _MAPDATAPREFIX;
                         * @type {string}
                         * @private
                         */
                        var _MAPDATAPREFIX = '';

                        /**
                         * HashMap can handle the key-value pairs.<br>
                         * Caution:<br>
                         *  HashMap instance has a length property but is not an instance of Array.
                         * @param {Object} [obj] A initial data for creation.
                         * @constructor
                         * @memberof tui.util
                         * @deprecated since version 1.3.0
                         * @example
                         * // node, commonjs
                         * var HashMap = require('tui-code-snippet').HashMap;
                         * var hm = new tui.util.HashMap({
    	  'mydata': {
    	    'hello': 'imfine'
    	  },
    	  'what': 'time'
    	});
                         * @example
                         * // distribution file, script
                         * <script src='path-to/tui-code-snippt.js'></script>
                         * <script>
                         * var HashMap = tui.util.HashMap;
                         * <script>
                         * var hm = new tui.util.HashMap({
    	  'mydata': {
    	    'hello': 'imfine'
    	  },
    	  'what': 'time'
    	});
                         */
                        function HashMap(obj) {
                            /**
                             * size
                             * @type {number}
                             */
                            this.length = 0;

                            if (obj) {
                                this.setObject(obj);
                            }
                        }

                        /**
                         * Set a data from the given key with value or the given object.
                         * @param {string|Object} key A string or object for key
                         * @param {*} [value] A data
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var hm = new HashMap();
                         * hm.set('key', 'value');
                         * hm.set({
                         *     'key1': 'data1',
                         *     'key2': 'data2'
                         * });
                         */
                        HashMap.prototype.set = function(key, value) {
                            if (arguments.length === 2) {
                                this.setKeyValue(key, value);
                            } else {
                                this.setObject(key);
                            }
                        };

                        /**
                         * Set a data from the given key with value.
                         * @param {string} key A string for key
                         * @param {*} value A data
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var hm = new HashMap();
                         * hm.setKeyValue('key', 'value');
                         */
                        HashMap.prototype.setKeyValue = function(key, value) {
                            if (!this.has(key)) {
                                this.length += 1;
                            }
                            this[this.encodeKey(key)] = value;
                        };

                        /**
                         * Set a data from the given object.
                         * @param {Object} obj A object for data
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var hm = new HashMap();
                         * hm.setObject({
                         *     'key1': 'data1',
                         *     'key2': 'data2'
                         * });
                         */
                        HashMap.prototype.setObject = function(obj) {
                            var self = this;

                            collection.forEachOwnProperties(obj, function(value, key) {
                                self.setKeyValue(key, value);
                            });
                        };

                        /**
                         * Merge with the given another hashMap.
                         * @param {HashMap} hashMap Another hashMap instance
                         */
                        HashMap.prototype.merge = function(hashMap) {
                            var self = this;

                            hashMap.each(function(value, key) {
                                self.setKeyValue(key, value);
                            });
                        };

                        /**
                         * Encode the given key for hashMap.
                         * @param {string} key A string for key
                         * @returns {string} A encoded key
                         * @private
                         */
                        HashMap.prototype.encodeKey = function(key) {
                            return _MAPDATAPREFIX + key;
                        };

                        /**
                         * Decode the given key in hashMap.
                         * @param {string} key A string for key
                         * @returns {string} A decoded key
                         * @private
                         */
                        HashMap.prototype.decodeKey = function(key) {
                            var decodedKey = key.split(_MAPDATAPREFIX);

                            return decodedKey[decodedKey.length - 1];
                        };

                        /**
                         * Return the value from the given key.
                         * @param {string} key A string for key
                         * @returns {*} The value from a key
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var hm = new HashMap();
                         * hm.set('key', 'value');
                         * hm.get('key') // value
                         */
                        HashMap.prototype.get = function(key) {
                            return this[this.encodeKey(key)];
                        };

                        /**
                         * Check the existence of a value from the key.
                         * @param {string} key A string for key
                         * @returns {boolean} Indicating whether a value exists or not.
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var hm = new HashMap();
                         * hm.set('key', 'value');
                         * hm.has('key') // true
                         */
                        HashMap.prototype.has = function(key) {
                            return this.hasOwnProperty(this.encodeKey(key));
                        };

                        /**
                         * Remove a data(key-value pairs) from the given key or the given key-list.
                         * @param {...string|string[]} key A string for key
                         * @returns {string|string[]} A removed data
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var hm = new HashMap();
                         * hm.set('key', 'value');
                         * hm.set('key2', 'value');
                         *
                         * hm.remove('key');
                         * hm.remove('key', 'key2');
                         * hm.remove(['key', 'key2']);
                         */
                        HashMap.prototype.remove = function(key) {
                            if (arguments.length > 1) {
                                key = collection.toArray(arguments);
                            }

                            return type.isArray(key) ? this.removeByKeyArray(key) : this.removeByKey(key);
                        };

                        /**
                         * Remove data(key-value pair) from the given key.
                         * @param {string} key A string for key
                         * @returns {*|null} A removed data
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var hm = new HashMap();
                         * hm.set('key', 'value');
                         * hm.removeByKey('key')
                         */
                        HashMap.prototype.removeByKey = function(key) {
                            var data = this.has(key) ? this.get(key) : null;

                            if (data !== null) {
                                delete this[this.encodeKey(key)];
                                this.length -= 1;
                            }

                            return data;
                        };

                        /**
                         * Remove a data(key-value pairs) from the given key-list.
                         * @param {string[]} keyArray An array of keys
                         * @returns {string[]} A removed data
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var hm = new HashMap();
                         * hm.set('key', 'value');
                         * hm.set('key2', 'value');
                         * hm.removeByKeyArray(['key', 'key2']);
                         */
                        HashMap.prototype.removeByKeyArray = function(keyArray) {
                            var data = [];
                            var self = this;

                            collection.forEach(keyArray, function(key) {
                                data.push(self.removeByKey(key));
                            });

                            return data;
                        };

                        /**
                         * Remove all the data
                         */
                        HashMap.prototype.removeAll = function() {
                            var self = this;

                            this.each(function(value, key) {
                                self.remove(key);
                            });
                        };

                        /**
                         * Execute the provided callback once for each all the data.
                         * @param {Function} iteratee Callback function
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var hm = new HashMap();
                         * hm.set('key', 'value');
                         * hm.set('key2', 'value');
                         *
                         * hm.each(function(value, key) {
                         *     //do something...
                         * });
                         */
                        HashMap.prototype.each = function(iteratee) {
                            var self = this;
                            var flag;

                            collection.forEachOwnProperties(this, function(value, key) { // eslint-disable-line consistent-return
                                if (key.charAt(0) === _MAPDATAPREFIX) {
                                    flag = iteratee(value, self.decodeKey(key));
                                }

                                if (flag === false) {
                                    return flag;
                                }
                            });
                        };

                        /**
                         * Return the key-list stored.
                         * @returns {Array} A key-list
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         *  var hm = new HashMap();
                         *  hm.set('key', 'value');
                         *  hm.set('key2', 'value');
                         *  hm.keys();  //['key', 'key2');
                         */
                        HashMap.prototype.keys = function() {
                            var keys = [];
                            var self = this;

                            this.each(function(value, key) {
                                keys.push(self.decodeKey(key));
                            });

                            return keys;
                        };

                        /**
                         * Work similarly to Array.prototype.map().<br>
                         * It executes the provided callback that checks conditions once for each element of hashMap,<br>
                         *  and returns a new array having elements satisfying the conditions
                         * @param {Function} condition A function that checks conditions
                         * @returns {Array} A new array having elements satisfying the conditions
                         * @example
                         * //-- #1. Get Module --//
                         * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
                         * var HashMap = tui.util.HashMap; // distribution file
                         *
                         * //-- #2. Use property --//
                         * var hm1 = new HashMap();
                         * hm1.set('key', 'value');
                         * hm1.set('key2', 'value');
                         *
                         * hm1.find(function(value, key) {
                         *     return key === 'key2';
                         * }); // ['value']
                         *
                         * var hm2 = new HashMap({
                         *     'myobj1': {
                         *         visible: true
                         *     },
                         *     'mybobj2': {
                         *         visible: false
                         *     }
                         * });
                         *
                         * hm2.find(function(obj, key) {
                         *     return obj.visible === true;
                         * }); // [{visible: true}];
                         */
                        HashMap.prototype.find = function(condition) {
                            var founds = [];

                            this.each(function(value, key) {
                                if (condition(value, key)) {
                                    founds.push(value);
                                }
                            });

                            return founds;
                        };

                        /**
                         * Return a new Array having all values.
                         * @returns {Array} A new array having all values
                         */
                        HashMap.prototype.toArray = function() {
                            var result = [];

                            this.each(function(v) {
                                result.push(v);
                            });

                            return result;
                        };

                        module.exports = HashMap;


                        /***/ })
                    /******/ ])
        });
    });

    var tuiTimePicker = createCommonjsModule(function (module, exports) {
        /*!
     * tui-time-picker.js
     * @version 1.5.2
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     * @license MIT
     */
        (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory(jquery, tuiCodeSnippet);
        })(commonjsGlobal, function(__WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__) {
            return /******/ (function(modules) { // webpackBootstrap
                /******/ 	// The module cache
                /******/ 	var installedModules = {};

                /******/ 	// The require function
                /******/ 	function __webpack_require__(moduleId) {

                    /******/ 		// Check if module is in cache
                    /******/ 		if(installedModules[moduleId])
                        /******/ 			return installedModules[moduleId].exports;

                    /******/ 		// Create a new module (and put it into the cache)
                    /******/ 		var module = installedModules[moduleId] = {
                        /******/ 			exports: {},
                        /******/ 			id: moduleId,
                        /******/ 			loaded: false
                        /******/ 		};

                    /******/ 		// Execute the module function
                    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

                    /******/ 		// Flag the module as loaded
                    /******/ 		module.loaded = true;

                    /******/ 		// Return the exports of the module
                    /******/ 		return module.exports;
                    /******/ 	}


                /******/ 	// expose the modules object (__webpack_modules__)
                /******/ 	__webpack_require__.m = modules;

                /******/ 	// expose the module cache
                /******/ 	__webpack_require__.c = installedModules;

                /******/ 	// __webpack_public_path__
                /******/ 	__webpack_require__.p = "dist";

                /******/ 	// Load entry module and return exports
                /******/ 	return __webpack_require__(0);
                /******/ })
                /************************************************************************/
                /******/ ([
                    /* 0 */
                    /***/ (function(module, exports, __webpack_require__) {

                        __webpack_require__(1);

                        module.exports = __webpack_require__(7);


                        /***/ }),
                    /* 1 */
                    /***/ (function(module, exports) {

                        // removed by extract-text-webpack-plugin

                        /***/ }),
                    /* 2 */,
                    /* 3 */,
                    /* 4 */,
                    /* 5 */,
                    /* 6 */,
                    /* 7 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(8);
                        var snippet = __webpack_require__(9);

                        var Spinbox = __webpack_require__(10);
                        var Selectbox = __webpack_require__(32);
                        var util = __webpack_require__(35);
                        var localeTexts = __webpack_require__(36);
                        var tmpl = __webpack_require__(37);
                        var meridiemTemplate = __webpack_require__(38);

                        var SELECTOR_MERIDIEM_ELELEMENT = '.tui-timepicker-meridiem';
                        var SELECTOR_HOUR_ELELEMENT = '.tui-timepicker-hour';
                        var SELECTOR_MINUTE_ELELEMENT = '.tui-timepicker-minute';
                        var CLASS_NAME_LEFT_MERIDIEM = 'tui-has-left';

                        /**
                         * Merge default options
                         * @ignore
                         * @param {object} options - options
                         * @returns {object} Merged options
                         */
                        var mergeDefaultOptions = function(options) {
                            return snippet.extend({
                                language: 'en',
                                initialHour: 0,
                                initialMinute: 0,
                                showMeridiem: true,
                                inputType: 'selectbox',
                                hourStep: 1,
                                minuteStep: 1,
                                meridiemPosition: 'right',
                                format: 'h:m',
                                disabledHours: [],
                                usageStatistics: true
                            }, options);
                        };

                        /**
                         * @class
                         * @param {string|jQuery|HTMLElement} container - Container element
                         * @param {Object} [options] - Options for initialization
                         * @param {number} [options.initialHour = 0] - Initial setting value of hour
                         * @param {number} [options.initialMinute = 0] - Initial setting value of minute
                         * @param {number} [options.hourStep = 1] - Step value of hour
                         * @param {number} [options.minuteStep = 1] - Step value of minute
                         * @param {string} [options.inputType = 'selectbox'] - 'selectbox' or 'spinbox'
                         * @param {string} [options.format = 'h:m'] - hour, minute format for display
                         * @param {boolean} [options.showMeridiem = true] - Show meridiem expression?
                         * @param {Array} [options.disabledHours = []] - Registered Hours is disabled.
                         * @param {string} [options.meridiemPosition = 'right'] - Set location of the meridiem element.
                         *                 If this option set 'left', the meridiem element is created in front of the hour element.
                         * @param {string} [options.language = 'en'] Set locale texts
                         * @param {Boolean} [options.usageStatistics=true|false] send hostname to google analytics [default value is true]
                         * @example
                         * var timepicker = new tui.TimePicker('#timepicker-container', {
                         *     initialHour: 15,
                         *     initialMinute: 13,
                         *     inputType: 'selectbox',
                         *     showMeridiem: false
                         * });
                         */
                        var TimePicker = snippet.defineClass(/** @lends TimePicker.prototype */ {
                            static: {
                                /**
                                 * Locale text data
                                 * @type {object}
                                 * @memberof TimePicker
                                 * @static
                                 * @example
                                 * var TimePicker = tui.TimePicker; // or require('tui-time-picker');
                                 *
                                 * TimePicker.localeTexts['customKey'] = {
                                 *     am: 'a.m.',
                                 *     pm: 'p.m.'
                                 * };
                                 *
                                 * var instance = new tui.TimePicker('#timepicker-container', {
                                 *     language: 'customKey',
                                 * });
                                 */
                                localeTexts: localeTexts
                            },
                            init: function(container, options) {
                                options = mergeDefaultOptions(options);

                                /**
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$container = $(container);

                                /**
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$element = $();

                                /**
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$meridiemElement = $();

                                /**
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$amEl = $();

                                /**
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$pmEl = $();

                                /**
                                 * @type {boolean}
                                 * @private
                                 */
                                this._showMeridiem = options.showMeridiem;

                                /**
                                 * Meridiem postion
                                 * @type {'left'|'right'}
                                 * @private
                                 */
                                this._meridiemPosition = options.meridiemPosition;

                                /**
                                 * @type {Spinbox}
                                 * @private
                                 */
                                this._hourInput = null;

                                /**
                                 * @type {Spinbox}
                                 * @private
                                 */
                                this._minuteInput = null;

                                /**
                                 * @type {number}
                                 * @private
                                 */
                                this._hour = options.initialHour;

                                /**
                                 * @type {number}
                                 * @private
                                 */
                                this._minute = options.initialMinute;

                                /**
                                 * @type {number}
                                 * @private
                                 */
                                this._hourStep = options.hourStep;

                                /**
                                 * @type {number}
                                 * @private
                                 */
                                this._minuteStep = options.minuteStep;

                                /**
                                 * @type {Array}
                                 * @private
                                 */
                                this._disabledHours = options.disabledHours;

                                /**
                                 * TimePicker inputType
                                 * @type {'spinbox'|'selectbox'}
                                 * @private
                                 */
                                this._inputType = options.inputType;

                                /**
                                 * Locale text for meridiem
                                 * @type {string}
                                 * @private
                                 */
                                this._localeText = localeTexts[options.language];

                                /**
                                 * Time format for output
                                 * @type {string}
                                 * @private
                                 */
                                this._format = this._getValidTimeFormat(options.format);

                                this._render();
                                this._setEvents();

                                if (options.usageStatistics) {
                                    util.sendHostName();
                                }
                            },

                            /**
                             * Set event handlers to selectors, container
                             * @private
                             */
                            _setEvents: function() {
                                this._hourInput.on('change', this._onChangeTimeInput, this);
                                this._minuteInput.on('change', this._onChangeTimeInput, this);

                                if (this._showMeridiem) {
                                    this._$container.on(
                                        'change.timepicker',
                                        SELECTOR_MERIDIEM_ELELEMENT,
                                        $.proxy(this._onChangeMeridiem, this)
                                    );
                                }
                            },

                            /**
                             * Render element
                             * @private
                             */
                            _render: function() {
                                var context = {
                                    showMeridiem: this._showMeridiem,
                                    inputType: this._inputType
                                };

                                if (this._showMeridiem) {
                                    snippet.extend(context, {
                                        meridiemElement: this._makeMeridiemHTML()
                                    });
                                }

                                this._$element.remove();
                                this._$element = $(tmpl(context));
                                this._$element.appendTo(this._$container);

                                this._renderTimeInputs();

                                if (this._showMeridiem) {
                                    this._setMeridiemElement();
                                }
                            },

                            /**
                             * Set meridiem element on timepicker
                             * @private
                             */
                            _setMeridiemElement: function() {
                                if (this._meridiemPosition === 'left') {
                                    this._$element.addClass(CLASS_NAME_LEFT_MERIDIEM);
                                }
                                this._$meridiemElement = this._$element.find(SELECTOR_MERIDIEM_ELELEMENT);
                                this._$amEl = this._$meridiemElement.find('[value="AM"]');
                                this._$pmEl = this._$meridiemElement.find('[value="PM"]');
                                this._syncToMeridiemElements();
                            },

                            /**
                             * Make html for meridiem element
                             * @returns {HTMLElement} Meridiem element
                             * @private
                             */
                            _makeMeridiemHTML: function() {
                                var localeText = this._localeText;

                                return meridiemTemplate({
                                    inputType: this._inputType,
                                    am: localeText.am,
                                    pm: localeText.pm
                                });
                            },

                            /**
                             * Render time selectors
                             * @private
                             */
                            _renderTimeInputs: function() {
                                var hour = this._hour;
                                var showMeridiem = this._showMeridiem;
                                var $hourElement = this._$element.find(SELECTOR_HOUR_ELELEMENT);
                                var $minuteElement = this._$element.find(SELECTOR_MINUTE_ELELEMENT);
                                var BoxComponent = this._inputType.toLowerCase() === 'selectbox' ? Selectbox : Spinbox;
                                var formatExplode = this._format.split(':');
                                var hourItems = this._getHourItems();

                                if (showMeridiem) {
                                    hour = util.getMeridiemHour(hour);
                                }

                                this._hourInput = new BoxComponent($hourElement, {
                                    initialValue: hour,
                                    items: hourItems,
                                    format: formatExplode[0],
                                    disabledItems: this._makeDisabledStatItems(hourItems)
                                });

                                this._minuteInput = new BoxComponent($minuteElement, {
                                    initialValue: this._minute,
                                    items: this._getMinuteItems(),
                                    format: formatExplode[1]
                                });
                            },

                            _makeDisabledStatItems: function(hourItems) {
                                var disabledHours = this._disabledHours.concat();

                                if (this._showMeridiem) {
                                    disabledHours = this._meridiemableTime(disabledHours);
                                }

                                return snippet.map(hourItems, function(hour) {
                                    if (disabledHours.indexOf(hour) >= 0) {
                                        return true;
                                    }

                                    return false;
                                });
                            },

                            _meridiemableTime: function(disabledHours) {
                                var diffHour = 0;
                                var startHour = 0;
                                var endHour = 11;

                                if (this._hour >= 12) {
                                    diffHour = 12;
                                    startHour = 12;
                                    endHour = 23;
                                }

                                disabledHours = snippet.map(disabledHours, function(hour) {
                                    if (hour >= startHour && hour <= endHour) {
                                        return (hour - diffHour === 0) ? 12 : hour - diffHour;
                                    }

                                    return false;
                                });
                                disabledHours = snippet.filter(disabledHours, function(hour) {
                                    return hour;
                                });

                                return disabledHours;
                            },

                            /**
                             * Return formatted format.
                             * @param {string} format - format option
                             * @returns {string}
                             * @private
                             */
                            _getValidTimeFormat: function(format) {
                                if (!format.match(/^[h]{1,2}:[m]{1,2}$/i)) {
                                    return 'h:m';
                                }

                                return format.toLowerCase();
                            },

                            /**
                             * Initialize meridiem elements
                             * @private
                             */
                            _syncToMeridiemElements: function() {
                                var isPM = this._hour >= 12;

                                this._$amEl.attr({
                                    selected: !isPM,
                                    checked: !isPM
                                });
                                this._$pmEl.attr({
                                    selected: isPM,
                                    checked: isPM
                                });
                            },

                            /**
                             * Set values in spinboxes from time
                             * @private
                             */
                            _syncToInputs: function() {
                                var hour = this._hour;
                                var minute = this._minute;

                                if (this._showMeridiem) {
                                    hour = util.getMeridiemHour(hour);
                                }

                                this._hourInput.setValue(hour);
                                this._minuteInput.setValue(minute);
                            },

                            /**
                             * DOM event handler
                             * @param {Event} event - Change event on meridiem element
                             * @private
                             */
                            _onChangeMeridiem: function(event) {
                                var hour = this._hour;
                                var isPM = (event.target.value === 'PM');

                                hour = this._to24Hour(isPM, hour);
                                this.setTime(hour, this._minute);
                                this._setDisabledHours();
                            },

                            /**
                             * Time change event handler
                             * @private
                             */
                            _onChangeTimeInput: function() {
                                var hour = this._hourInput.getValue();
                                var minute = this._minuteInput.getValue();
                                var isPM = this._hour >= 12;

                                if (this._showMeridiem) {
                                    hour = this._to24Hour(isPM, hour);
                                }
                                this.setTime(hour, minute);
                            },

                            /**
                             * 12Hour-expression to 24Hour-expression
                             * @param {boolean} isPM - Is pm?
                             * @param {number} hour - Hour
                             * @returns {number}
                             * @private
                             */
                            _to24Hour: function(isPM, hour) {
                                hour %= 12;
                                if (isPM) {
                                    hour += 12;
                                }

                                return hour;
                            },

                            _setDisabledHours: function() {
                                var hourItems = this._getHourItems();
                                var disabledItems = this._makeDisabledStatItems(hourItems);

                                this._hourInput.setDisabledItems(disabledItems);
                            },

                            /**
                             * Get items of hour
                             * @returns {array} Hour item list
                             * @private
                             */
                            _getHourItems: function() {
                                var step = this._hourStep;

                                return this._showMeridiem ? util.getRangeArr(1, 12, step) : util.getRangeArr(0, 23, step);
                            },

                            /**
                             * Get items of minute
                             * @returns {array} Minute item list
                             * @private
                             */
                            _getMinuteItems: function() {
                                return util.getRangeArr(0, 59, this._minuteStep);
                            },

                            /**
                             * Whether the hour and minute are in valid items or not
                             * @param {number} hour - Hour value
                             * @param {number} minute - Minute value
                             * @returns {boolean} State
                             * @private
                             */
                            _validItems: function(hour, minute) {
                                if (this._showMeridiem) {
                                    hour = util.getMeridiemHour(hour);
                                }

                                return snippet.inArray(hour, this._getHourItems()) > -1 &&
                                    snippet.inArray(minute, this._getMinuteItems()) > -1;
                            },

                            /**
                             * Set step of hour
                             * @param {array} step - Step to create items of hour
                             */
                            setHourStep: function(step) {
                                this._hourStep = step;
                                this._hourInput.fire('changeItems', this._getHourItems());
                            },

                            /**
                             * Get step of hour
                             * @returns {number} Step of hour
                             */
                            getHourStep: function() {
                                return this._hourStep;
                            },

                            /**
                             * Set step of minute
                             * @param {array} step - Step to create items of minute
                             */
                            setMinuteStep: function(step) {
                                this._minuteStep = step;
                                this._minuteInput.fire('changeItems', this._getMinuteItems());
                            },

                            /**
                             * Get step of minute
                             * @returns {number} Step of minute
                             */
                            getMinuteStep: function() {
                                return this._minuteStep;
                            },

                            /**
                             * Show time picker element
                             */
                            show: function() {
                                this._$element.show();
                            },

                            /**
                             * Hide time picker element
                             */
                            hide: function() {
                                this._$element.hide();
                            },

                            /**
                             * Set hour
                             * @param {number} hour for time picker - (0~23)
                             * @returns {boolean} result of set time
                             */
                            setHour: function(hour) {
                                return this.setTime(hour, this._minute);
                            },

                            /**
                             * Set minute
                             * @param {number} minute for time picker
                             * @returns {boolean} result of set time
                             */
                            setMinute: function(minute) {
                                return this.setTime(this._hour, minute);
                            },

                            /**
                             * Set time
                             * @param {number} hour for time picker - (0~23)
                             * @param {number} minute for time picker
                             */
                            setTime: function(hour, minute) {
                                var isNumber = snippet.isNumber(hour) && snippet.isNumber(minute);

                                if (!isNumber || (hour > 23) || (minute > 59)) {
                                    return;
                                }

                                if (!this._validItems(hour, minute)) {
                                    return;
                                }

                                this._hour = hour;
                                this._minute = minute;

                                this._syncToInputs();
                                this._syncToMeridiemElements();

                                /**
                                 * Change event - TimePicker
                                 * @event TimePicker#change
                                 */
                                this.fire('change', {
                                    hour: this._hour,
                                    minute: this._minute
                                });
                            },

                            /**
                             * Get hour
                             * @returns {number} hour - (0~23)
                             */
                            getHour: function() {
                                return this._hour;
                            },

                            /**
                             * Get minute
                             * @returns {number} minute
                             */
                            getMinute: function() {
                                return this._minute;
                            },

                            /**
                             * Change locale text of meridiem by language code
                             * @param {string} language - Language code
                             */
                            changeLanguage: function(language) {
                                this._localeText = localeTexts[language];
                                this._render();
                            },

                            /**
                             * Destroy
                             */
                            destroy: function() {
                                this.off();
                                this._hourInput.destroy();
                                this._minuteInput.destroy();
                                this._$container.off('.timepicker');
                                this._$element.remove();

                                this._$container
                                    = this._showMeridiem
                                    = this._hourInput
                                    = this._minuteInput
                                    = this._hour
                                    = this._minute
                                    = this._inputType
                                    = this._$element
                                    = this._$meridiemElement
                                    = this._$amEl
                                    = this._$pmEl
                                    = null;
                            }
                        });

                        snippet.CustomEvents.mixin(TimePicker);
                        module.exports = TimePicker;


                        /***/ }),
                    /* 8 */
                    /***/ (function(module, exports) {

                        module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

                        /***/ }),
                    /* 9 */
                    /***/ (function(module, exports) {

                        module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

                        /***/ }),
                    /* 10 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(8);
                        var snippet = __webpack_require__(9);

                        var tmpl = __webpack_require__(11);
                        var timeFormat = __webpack_require__(31);

                        var SELECTOR_UP_BUTTON = '.tui-timepicker-btn-up';
                        var SELECTOR_DOWN_BUTTON = '.tui-timepicker-btn-down';

                        /**
                         * @class
                         * @ignore
                         * @param {jQuery|String|HTMLElement} container - Container of spinbox
                         * @param {Object} [options] - Options for initialization
                         * @param {number} [options.initialValue] - initial setting value
                         * @param {Array.<number>} items - Items
                         */
                        var Spinbox = snippet.defineClass(/** @lends Spinbox.prototype */ {
                            init: function(container, options) {
                                options = snippet.extend({
                                    items: []
                                }, options);

                                /**
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$container = $(container);

                                /**
                                 * Spinbox element
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$element = null;

                                /**
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$inputElement = null;

                                /**
                                 * Spinbox value items
                                 * @type {Array.<number>}
                                 * @private
                                 */
                                this._items = options.items;

                                /**
                                 * Selectbox disabled items info
                                 * @type {Array.<number>}
                                 * @private
                                 */
                                this._disabledItems = options.disabledItems || [];

                                /**
                                 * @type {number}
                                 * @private
                                 */
                                this._selectedIndex = Math.max(0, snippet.inArray(options.initialValue, this._items));

                                /**
                                 * Time format for output
                                 * @type {string}
                                 * @private
                                 */
                                this._format = options.format;

                                this._render();
                                this._setEvents();
                            },

                            /**
                             * Render spinbox
                             * @private
                             */
                            _render: function() {
                                var context;

                                if (this._disabledItems[this._items.indexOf(this.getValue())]) {
                                    this._selectedIndex = this._findEnabledIndex();
                                }
                                context = {
                                    maxLength: this._getMaxLength(),
                                    initialValue: this.getValue(),
                                    format: this._format
                                };

                                this._$element = $(tmpl(context));
                                this._$element.appendTo(this._$container);
                                this._$inputElement = this._$element.find('input');
                            },

                            /**
                             * Find the index of the enabled item
                             * @returns {number} - find selected index
                             * @private
                             */
                            _findEnabledIndex: function() {
                                return snippet.inArray(false, this._disabledItems);
                            },

                            /**
                             * Returns maxlength of value
                             * @returns {number}
                             * @private
                             */
                            _getMaxLength: function() {
                                var lengths = snippet.map(this._items, function(item) {
                                    return String(item).length;
                                });

                                return Math.max.apply(null, lengths);
                            },

                            /**
                             * Set disabledItems
                             * @param {object} disabledItems - disabled status of items
                             */
                            setDisabledItems: function(disabledItems) {
                                this._disabledItems = disabledItems;
                                this._$inputElement.change();
                            },

                            /**
                             * Assign default events to up/down button
                             * @private
                             */
                            _setEvents: function() {
                                this._$container.on('click.spinbox', SELECTOR_UP_BUTTON, $.proxy(this._setNextValue, this, false))
                                    .on('click.spinbox', SELECTOR_DOWN_BUTTON, $.proxy(this._setNextValue, this, true))
                                    .on('keydown.spinbox', 'input', $.proxy(this._onKeyDownInputElement, this))
                                    .on('change.spinbox', 'input', $.proxy(this._onChangeInput, this));

                                this.on('changeItems', function(items) {
                                    this._items = items;
                                    this._render();
                                }, this);
                            },

                            /**
                             * Set input value when user click a button.
                             * @param {boolean} isDown - From down-action?
                             * @private
                             */
                            _setNextValue: function(isDown) {
                                var index = this._selectedIndex;

                                if (isDown) {
                                    index = index ? index - 1 : this._items.length - 1;
                                } else {
                                    index = (index < (this._items.length - 1)) ? index + 1 : 0;
                                }

                                if (this._disabledItems[index]) {
                                    this._selectedIndex = index;
                                    this._setNextValue(isDown);

                                    return;
                                }
                                this.setValue(this._items[index]);
                            },

                            /**
                             * DOM(Input element) Keydown Event handler
                             * @param {Event} event event-object
                             * @private
                             */
                            _onKeyDownInputElement: function(event) {
                                var keyCode = event.which || event.keyCode;
                                var isDown;

                                switch (keyCode) {
                                    case 38:
                                        isDown = false;
                                        break;
                                    case 40:
                                        isDown = true;
                                        break;
                                    default: return;
                                }

                                this._setNextValue(isDown);
                            },

                            /**
                             * DOM(Input element) Change Event handler
                             * @private
                             */
                            _onChangeInput: function() {
                                var newValue = Number(this._$inputElement.val());
                                var newIndex = snippet.inArray(newValue, this._items);
                                if (this._disabledItems[newIndex]) {
                                    newIndex = this._findEnabledIndex();
                                    newValue = this._items[newIndex];
                                } else if (newIndex === this._selectedIndex) {
                                    return;
                                }

                                if (newIndex === -1) {
                                    this.setValue(this._items[this._selectedIndex]);
                                } else {
                                    this._selectedIndex = newIndex;
                                    this.fire('change', {
                                        value: newValue
                                    });
                                }
                            },

                            /**
                             * Set value to input-box.
                             * @param {number} value - Value
                             */
                            setValue: function(value) {
                                this._$inputElement.val(timeFormat(value, this._format)).change();
                            },

                            /**
                             * Returns current value
                             * @returns {number}
                             */
                            getValue: function() {
                                return this._items[this._selectedIndex];
                            },

                            /**
                             * Destory
                             */
                            destroy: function() {
                                this.off();
                                this._$container.off('.spinbox');
                                this._$element.remove();
                                this._$container
                                    = this._$element
                                    = this._$inputElement
                                    = this._items
                                    = this._selectedIndex
                                    = null;
                            }
                        });

                        snippet.CustomEvents.mixin(Spinbox);
                        module.exports = Spinbox;


                        /***/ }),
                    /* 11 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var Handlebars = __webpack_require__(12);
                        function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
                        module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
                                var alias1=container.lambda, alias2=container.escapeExpression;

                                return "<div class=\"tui-timepicker-btn-area\">\n    <input type=\"text\" class=\"tui-timepicker-spinbox-input\"\n           maxlength=\""
                                    + alias2(alias1((depth0 != null ? depth0.maxLength : depth0), depth0))
                                    + "\"\n           size=\""
                                    + alias2(alias1((depth0 != null ? depth0.maxLength : depth0), depth0))
                                    + "\"\n           value=\""
                                    + alias2(__default(__webpack_require__(31)).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.initialValue : depth0),(depth0 != null ? depth0.format : depth0),{"name":"../helpers/timeFormat","hash":{},"data":data}))
                                    + "\"\n           aria-label=\"TimePicker spinbox value\">\n    <button type=\"button\" class=\"tui-timepicker-btn tui-timepicker-btn-up\">\n        <span class=\"tui-ico-t-btn\">Increase</span>\n    </button>\n    <button type=\"button\" class=\"tui-timepicker-btn tui-timepicker-btn-down\">\n        <span class=\"tui-ico-t-btn\">Decrease</span>\n    </button>\n</div>\n";
                            },"useData":true});

                        /***/ }),
                    /* 12 */
                    /***/ (function(module, exports, __webpack_require__) {

                        // Create a simple path alias to allow browserify to resolve
                        // the runtime on a supported path.
                        module.exports = __webpack_require__(13)['default'];


                        /***/ }),
                    /* 13 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        // istanbul ignore next

                        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

                        var _handlebarsBase = __webpack_require__(14);

                        var base = _interopRequireWildcard(_handlebarsBase);

                        // Each of these augment the Handlebars object. No need to setup here.
                        // (This is done to easily share code between commonjs and browse envs)

                        var _handlebarsSafeString = __webpack_require__(28);

                        var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

                        var _handlebarsException = __webpack_require__(16);

                        var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

                        var _handlebarsUtils = __webpack_require__(15);

                        var Utils = _interopRequireWildcard(_handlebarsUtils);

                        var _handlebarsRuntime = __webpack_require__(29);

                        var runtime = _interopRequireWildcard(_handlebarsRuntime);

                        var _handlebarsNoConflict = __webpack_require__(30);

                        var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

                        // For compatibility and usage outside of module systems, make the Handlebars object a namespace
                        function create() {
                            var hb = new base.HandlebarsEnvironment();

                            Utils.extend(hb, base);
                            hb.SafeString = _handlebarsSafeString2['default'];
                            hb.Exception = _handlebarsException2['default'];
                            hb.Utils = Utils;
                            hb.escapeExpression = Utils.escapeExpression;

                            hb.VM = runtime;
                            hb.template = function (spec) {
                                return runtime.template(spec, hb);
                            };

                            return hb;
                        }

                        var inst = create();
                        inst.create = create;

                        _handlebarsNoConflict2['default'](inst);

                        inst['default'] = inst;

                        exports['default'] = inst;
                        module.exports = exports['default'];



                        /***/ }),
                    /* 14 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        exports.HandlebarsEnvironment = HandlebarsEnvironment;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        var _utils = __webpack_require__(15);

                        var _exception = __webpack_require__(16);

                        var _exception2 = _interopRequireDefault(_exception);

                        var _helpers = __webpack_require__(17);

                        var _decorators = __webpack_require__(25);

                        var _logger = __webpack_require__(27);

                        var _logger2 = _interopRequireDefault(_logger);

                        var VERSION = '4.0.5';
                        exports.VERSION = VERSION;
                        var COMPILER_REVISION = 7;

                        exports.COMPILER_REVISION = COMPILER_REVISION;
                        var REVISION_CHANGES = {
                            1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
                            2: '== 1.0.0-rc.3',
                            3: '== 1.0.0-rc.4',
                            4: '== 1.x.x',
                            5: '== 2.0.0-alpha.x',
                            6: '>= 2.0.0-beta.1',
                            7: '>= 4.0.0'
                        };

                        exports.REVISION_CHANGES = REVISION_CHANGES;
                        var objectType = '[object Object]';

                        function HandlebarsEnvironment(helpers, partials, decorators) {
                            this.helpers = helpers || {};
                            this.partials = partials || {};
                            this.decorators = decorators || {};

                            _helpers.registerDefaultHelpers(this);
                            _decorators.registerDefaultDecorators(this);
                        }

                        HandlebarsEnvironment.prototype = {
                            constructor: HandlebarsEnvironment,

                            logger: _logger2['default'],
                            log: _logger2['default'].log,

                            registerHelper: function registerHelper(name, fn) {
                                if (_utils.toString.call(name) === objectType) {
                                    if (fn) {
                                        throw new _exception2['default']('Arg not supported with multiple helpers');
                                    }
                                    _utils.extend(this.helpers, name);
                                } else {
                                    this.helpers[name] = fn;
                                }
                            },
                            unregisterHelper: function unregisterHelper(name) {
                                delete this.helpers[name];
                            },

                            registerPartial: function registerPartial(name, partial) {
                                if (_utils.toString.call(name) === objectType) {
                                    _utils.extend(this.partials, name);
                                } else {
                                    if (typeof partial === 'undefined') {
                                        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
                                    }
                                    this.partials[name] = partial;
                                }
                            },
                            unregisterPartial: function unregisterPartial(name) {
                                delete this.partials[name];
                            },

                            registerDecorator: function registerDecorator(name, fn) {
                                if (_utils.toString.call(name) === objectType) {
                                    if (fn) {
                                        throw new _exception2['default']('Arg not supported with multiple decorators');
                                    }
                                    _utils.extend(this.decorators, name);
                                } else {
                                    this.decorators[name] = fn;
                                }
                            },
                            unregisterDecorator: function unregisterDecorator(name) {
                                delete this.decorators[name];
                            }
                        };

                        var log = _logger2['default'].log;

                        exports.log = log;
                        exports.createFrame = _utils.createFrame;
                        exports.logger = _logger2['default'];



                        /***/ }),
                    /* 15 */
                    /***/ (function(module, exports) {

                        exports.__esModule = true;
                        exports.extend = extend;
                        exports.indexOf = indexOf;
                        exports.escapeExpression = escapeExpression;
                        exports.isEmpty = isEmpty;
                        exports.createFrame = createFrame;
                        exports.blockParams = blockParams;
                        exports.appendContextPath = appendContextPath;
                        var escape = {
                            '&': '&amp;',
                            '<': '&lt;',
                            '>': '&gt;',
                            '"': '&quot;',
                            "'": '&#x27;',
                            '`': '&#x60;',
                            '=': '&#x3D;'
                        };

                        var badChars = /[&<>"'`=]/g,
                            possible = /[&<>"'`=]/;

                        function escapeChar(chr) {
                            return escape[chr];
                        }

                        function extend(obj /* , ...source */) {
                            for (var i = 1; i < arguments.length; i++) {
                                for (var key in arguments[i]) {
                                    if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                                        obj[key] = arguments[i][key];
                                    }
                                }
                            }

                            return obj;
                        }

                        var toString = Object.prototype.toString;

                        exports.toString = toString;
                        // Sourced from lodash
                        // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
                        /* eslint-disable func-style */
                        var isFunction = function isFunction(value) {
                            return typeof value === 'function';
                        };
                        // fallback for older versions of Chrome and Safari
                        /* istanbul ignore next */
                        if (isFunction(/x/)) {
                            exports.isFunction = isFunction = function (value) {
                                return typeof value === 'function' && toString.call(value) === '[object Function]';
                            };
                        }
                        exports.isFunction = isFunction;

                        /* eslint-enable func-style */

                        /* istanbul ignore next */
                        var isArray = Array.isArray || function (value) {
                            return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
                        };

                        exports.isArray = isArray;
                        // Older IE versions do not directly support indexOf so we must implement our own, sadly.

                        function indexOf(array, value) {
                            for (var i = 0, len = array.length; i < len; i++) {
                                if (array[i] === value) {
                                    return i;
                                }
                            }
                            return -1;
                        }

                        function escapeExpression(string) {
                            if (typeof string !== 'string') {
                                // don't escape SafeStrings, since they're already safe
                                if (string && string.toHTML) {
                                    return string.toHTML();
                                } else if (string == null) {
                                    return '';
                                } else if (!string) {
                                    return string + '';
                                }

                                // Force a string conversion as this will be done by the append regardless and
                                // the regex test will do this transparently behind the scenes, causing issues if
                                // an object's to string has escaped characters in it.
                                string = '' + string;
                            }

                            if (!possible.test(string)) {
                                return string;
                            }
                            return string.replace(badChars, escapeChar);
                        }

                        function isEmpty(value) {
                            if (!value && value !== 0) {
                                return true;
                            } else if (isArray(value) && value.length === 0) {
                                return true;
                            } else {
                                return false;
                            }
                        }

                        function createFrame(object) {
                            var frame = extend({}, object);
                            frame._parent = object;
                            return frame;
                        }

                        function blockParams(params, ids) {
                            params.path = ids;
                            return params;
                        }

                        function appendContextPath(contextPath, id) {
                            return (contextPath ? contextPath + '.' : '') + id;
                        }



                        /***/ }),
                    /* 16 */
                    /***/ (function(module, exports) {

                        exports.__esModule = true;

                        var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

                        function Exception(message, node) {
                            var loc = node && node.loc,
                                line = undefined,
                                column = undefined;
                            if (loc) {
                                line = loc.start.line;
                                column = loc.start.column;

                                message += ' - ' + line + ':' + column;
                            }

                            var tmp = Error.prototype.constructor.call(this, message);

                            // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
                            for (var idx = 0; idx < errorProps.length; idx++) {
                                this[errorProps[idx]] = tmp[errorProps[idx]];
                            }

                            /* istanbul ignore else */
                            if (Error.captureStackTrace) {
                                Error.captureStackTrace(this, Exception);
                            }

                            try {
                                if (loc) {
                                    this.lineNumber = line;

                                    // Work around issue under safari where we can't directly set the column value
                                    /* istanbul ignore next */
                                    if (Object.defineProperty) {
                                        Object.defineProperty(this, 'column', { value: column });
                                    } else {
                                        this.column = column;
                                    }
                                }
                            } catch (nop) {
                                /* Ignore if the browser is very particular */
                            }
                        }

                        Exception.prototype = new Error();

                        exports['default'] = Exception;
                        module.exports = exports['default'];



                        /***/ }),
                    /* 17 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        exports.registerDefaultHelpers = registerDefaultHelpers;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        var _helpersBlockHelperMissing = __webpack_require__(18);

                        var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

                        var _helpersEach = __webpack_require__(19);

                        var _helpersEach2 = _interopRequireDefault(_helpersEach);

                        var _helpersHelperMissing = __webpack_require__(20);

                        var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

                        var _helpersIf = __webpack_require__(21);

                        var _helpersIf2 = _interopRequireDefault(_helpersIf);

                        var _helpersLog = __webpack_require__(22);

                        var _helpersLog2 = _interopRequireDefault(_helpersLog);

                        var _helpersLookup = __webpack_require__(23);

                        var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

                        var _helpersWith = __webpack_require__(24);

                        var _helpersWith2 = _interopRequireDefault(_helpersWith);

                        function registerDefaultHelpers(instance) {
                            _helpersBlockHelperMissing2['default'](instance);
                            _helpersEach2['default'](instance);
                            _helpersHelperMissing2['default'](instance);
                            _helpersIf2['default'](instance);
                            _helpersLog2['default'](instance);
                            _helpersLookup2['default'](instance);
                            _helpersWith2['default'](instance);
                        }



                        /***/ }),
                    /* 18 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;

                        var _utils = __webpack_require__(15);

                        exports['default'] = function (instance) {
                            instance.registerHelper('blockHelperMissing', function (context, options) {
                                var inverse = options.inverse,
                                    fn = options.fn;

                                if (context === true) {
                                    return fn(this);
                                } else if (context === false || context == null) {
                                    return inverse(this);
                                } else if (_utils.isArray(context)) {
                                    if (context.length > 0) {
                                        if (options.ids) {
                                            options.ids = [options.name];
                                        }

                                        return instance.helpers.each(context, options);
                                    } else {
                                        return inverse(this);
                                    }
                                } else {
                                    if (options.data && options.ids) {
                                        var data = _utils.createFrame(options.data);
                                        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
                                        options = { data: data };
                                    }

                                    return fn(context, options);
                                }
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 19 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        var _utils = __webpack_require__(15);

                        var _exception = __webpack_require__(16);

                        var _exception2 = _interopRequireDefault(_exception);

                        exports['default'] = function (instance) {
                            instance.registerHelper('each', function (context, options) {
                                if (!options) {
                                    throw new _exception2['default']('Must pass iterator to #each');
                                }

                                var fn = options.fn,
                                    inverse = options.inverse,
                                    i = 0,
                                    ret = '',
                                    data = undefined,
                                    contextPath = undefined;

                                if (options.data && options.ids) {
                                    contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
                                }

                                if (_utils.isFunction(context)) {
                                    context = context.call(this);
                                }

                                if (options.data) {
                                    data = _utils.createFrame(options.data);
                                }

                                function execIteration(field, index, last) {
                                    if (data) {
                                        data.key = field;
                                        data.index = index;
                                        data.first = index === 0;
                                        data.last = !!last;

                                        if (contextPath) {
                                            data.contextPath = contextPath + field;
                                        }
                                    }

                                    ret = ret + fn(context[field], {
                                        data: data,
                                        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
                                    });
                                }

                                if (context && typeof context === 'object') {
                                    if (_utils.isArray(context)) {
                                        for (var j = context.length; i < j; i++) {
                                            if (i in context) {
                                                execIteration(i, i, i === context.length - 1);
                                            }
                                        }
                                    } else {
                                        var priorKey = undefined;

                                        for (var key in context) {
                                            if (context.hasOwnProperty(key)) {
                                                // We're running the iterations one step out of sync so we can detect
                                                // the last iteration without have to scan the object twice and create
                                                // an itermediate keys array.
                                                if (priorKey !== undefined) {
                                                    execIteration(priorKey, i - 1);
                                                }
                                                priorKey = key;
                                                i++;
                                            }
                                        }
                                        if (priorKey !== undefined) {
                                            execIteration(priorKey, i - 1, true);
                                        }
                                    }
                                }

                                if (i === 0) {
                                    ret = inverse(this);
                                }

                                return ret;
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 20 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        var _exception = __webpack_require__(16);

                        var _exception2 = _interopRequireDefault(_exception);

                        exports['default'] = function (instance) {
                            instance.registerHelper('helperMissing', function () /* [args, ]options */{
                                if (arguments.length === 1) {
                                    // A missing field in a {{foo}} construct.
                                    return undefined;
                                } else {
                                    // Someone is actually trying to call something, blow up.
                                    throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
                                }
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 21 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;

                        var _utils = __webpack_require__(15);

                        exports['default'] = function (instance) {
                            instance.registerHelper('if', function (conditional, options) {
                                if (_utils.isFunction(conditional)) {
                                    conditional = conditional.call(this);
                                }

                                // Default behavior is to render the positive path if the value is truthy and not empty.
                                // The `includeZero` option may be set to treat the condtional as purely not empty based on the
                                // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
                                if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
                                    return options.inverse(this);
                                } else {
                                    return options.fn(this);
                                }
                            });

                            instance.registerHelper('unless', function (conditional, options) {
                                return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 22 */
                    /***/ (function(module, exports) {

                        exports.__esModule = true;

                        exports['default'] = function (instance) {
                            instance.registerHelper('log', function () /* message, options */{
                                var args = [undefined],
                                    options = arguments[arguments.length - 1];
                                for (var i = 0; i < arguments.length - 1; i++) {
                                    args.push(arguments[i]);
                                }

                                var level = 1;
                                if (options.hash.level != null) {
                                    level = options.hash.level;
                                } else if (options.data && options.data.level != null) {
                                    level = options.data.level;
                                }
                                args[0] = level;

                                instance.log.apply(instance, args);
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 23 */
                    /***/ (function(module, exports) {

                        exports.__esModule = true;

                        exports['default'] = function (instance) {
                            instance.registerHelper('lookup', function (obj, field) {
                                return obj && obj[field];
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 24 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;

                        var _utils = __webpack_require__(15);

                        exports['default'] = function (instance) {
                            instance.registerHelper('with', function (context, options) {
                                if (_utils.isFunction(context)) {
                                    context = context.call(this);
                                }

                                var fn = options.fn;

                                if (!_utils.isEmpty(context)) {
                                    var data = options.data;
                                    if (options.data && options.ids) {
                                        data = _utils.createFrame(options.data);
                                        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
                                    }

                                    return fn(context, {
                                        data: data,
                                        blockParams: _utils.blockParams([context], [data && data.contextPath])
                                    });
                                } else {
                                    return options.inverse(this);
                                }
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 25 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        exports.registerDefaultDecorators = registerDefaultDecorators;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        var _decoratorsInline = __webpack_require__(26);

                        var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

                        function registerDefaultDecorators(instance) {
                            _decoratorsInline2['default'](instance);
                        }



                        /***/ }),
                    /* 26 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;

                        var _utils = __webpack_require__(15);

                        exports['default'] = function (instance) {
                            instance.registerDecorator('inline', function (fn, props, container, options) {
                                var ret = fn;
                                if (!props.partials) {
                                    props.partials = {};
                                    ret = function (context, options) {
                                        // Create a new partials stack frame prior to exec.
                                        var original = container.partials;
                                        container.partials = _utils.extend({}, original, props.partials);
                                        var ret = fn(context, options);
                                        container.partials = original;
                                        return ret;
                                    };
                                }

                                props.partials[options.args[0]] = options.fn;

                                return ret;
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 27 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;

                        var _utils = __webpack_require__(15);

                        var logger = {
                            methodMap: ['debug', 'info', 'warn', 'error'],
                            level: 'info',

                            // Maps a given level value to the `methodMap` indexes above.
                            lookupLevel: function lookupLevel(level) {
                                if (typeof level === 'string') {
                                    var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
                                    if (levelMap >= 0) {
                                        level = levelMap;
                                    } else {
                                        level = parseInt(level, 10);
                                    }
                                }

                                return level;
                            },

                            // Can be overridden in the host environment
                            log: function log(level) {
                                level = logger.lookupLevel(level);

                                if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
                                    var method = logger.methodMap[level];
                                    if (!console[method]) {
                                        // eslint-disable-line no-console
                                        method = 'log';
                                    }

                                    for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                        message[_key - 1] = arguments[_key];
                                    }

                                    console[method].apply(console, message); // eslint-disable-line no-console
                                }
                            }
                        };

                        exports['default'] = logger;
                        module.exports = exports['default'];



                        /***/ }),
                    /* 28 */
                    /***/ (function(module, exports) {

                        exports.__esModule = true;
                        function SafeString(string) {
                            this.string = string;
                        }

                        SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
                            return '' + this.string;
                        };

                        exports['default'] = SafeString;
                        module.exports = exports['default'];



                        /***/ }),
                    /* 29 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        exports.checkRevision = checkRevision;
                        exports.template = template;
                        exports.wrapProgram = wrapProgram;
                        exports.resolvePartial = resolvePartial;
                        exports.invokePartial = invokePartial;
                        exports.noop = noop;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        // istanbul ignore next

                        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

                        var _utils = __webpack_require__(15);

                        var Utils = _interopRequireWildcard(_utils);

                        var _exception = __webpack_require__(16);

                        var _exception2 = _interopRequireDefault(_exception);

                        var _base = __webpack_require__(14);

                        function checkRevision(compilerInfo) {
                            var compilerRevision = compilerInfo && compilerInfo[0] || 1,
                                currentRevision = _base.COMPILER_REVISION;

                            if (compilerRevision !== currentRevision) {
                                if (compilerRevision < currentRevision) {
                                    var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
                                        compilerVersions = _base.REVISION_CHANGES[compilerRevision];
                                    throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
                                } else {
                                    // Use the embedded version info since the runtime doesn't know about this revision yet
                                    throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
                                }
                            }
                        }

                        function template(templateSpec, env) {
                            /* istanbul ignore next */
                            if (!env) {
                                throw new _exception2['default']('No environment passed to template');
                            }
                            if (!templateSpec || !templateSpec.main) {
                                throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
                            }

                            templateSpec.main.decorator = templateSpec.main_d;

                            // Note: Using env.VM references rather than local var references throughout this section to allow
                            // for external users to override these as psuedo-supported APIs.
                            env.VM.checkRevision(templateSpec.compiler);

                            function invokePartialWrapper(partial, context, options) {
                                if (options.hash) {
                                    context = Utils.extend({}, context, options.hash);
                                    if (options.ids) {
                                        options.ids[0] = true;
                                    }
                                }

                                partial = env.VM.resolvePartial.call(this, partial, context, options);
                                var result = env.VM.invokePartial.call(this, partial, context, options);

                                if (result == null && env.compile) {
                                    options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
                                    result = options.partials[options.name](context, options);
                                }
                                if (result != null) {
                                    if (options.indent) {
                                        var lines = result.split('\n');
                                        for (var i = 0, l = lines.length; i < l; i++) {
                                            if (!lines[i] && i + 1 === l) {
                                                break;
                                            }

                                            lines[i] = options.indent + lines[i];
                                        }
                                        result = lines.join('\n');
                                    }
                                    return result;
                                } else {
                                    throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
                                }
                            }

                            // Just add water
                            var container = {
                                strict: function strict(obj, name) {
                                    if (!(name in obj)) {
                                        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
                                    }
                                    return obj[name];
                                },
                                lookup: function lookup(depths, name) {
                                    var len = depths.length;
                                    for (var i = 0; i < len; i++) {
                                        if (depths[i] && depths[i][name] != null) {
                                            return depths[i][name];
                                        }
                                    }
                                },
                                lambda: function lambda(current, context) {
                                    return typeof current === 'function' ? current.call(context) : current;
                                },

                                escapeExpression: Utils.escapeExpression,
                                invokePartial: invokePartialWrapper,

                                fn: function fn(i) {
                                    var ret = templateSpec[i];
                                    ret.decorator = templateSpec[i + '_d'];
                                    return ret;
                                },

                                programs: [],
                                program: function program(i, data, declaredBlockParams, blockParams, depths) {
                                    var programWrapper = this.programs[i],
                                        fn = this.fn(i);
                                    if (data || depths || blockParams || declaredBlockParams) {
                                        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
                                    } else if (!programWrapper) {
                                        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
                                    }
                                    return programWrapper;
                                },

                                data: function data(value, depth) {
                                    while (value && depth--) {
                                        value = value._parent;
                                    }
                                    return value;
                                },
                                merge: function merge(param, common) {
                                    var obj = param || common;

                                    if (param && common && param !== common) {
                                        obj = Utils.extend({}, common, param);
                                    }

                                    return obj;
                                },

                                noop: env.VM.noop,
                                compilerInfo: templateSpec.compiler
                            };

                            function ret(context) {
                                var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                                var data = options.data;

                                ret._setup(options);
                                if (!options.partial && templateSpec.useData) {
                                    data = initData(context, data);
                                }
                                var depths = undefined,
                                    blockParams = templateSpec.useBlockParams ? [] : undefined;
                                if (templateSpec.useDepths) {
                                    if (options.depths) {
                                        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
                                    } else {
                                        depths = [context];
                                    }
                                }

                                function main(context /*, options*/) {
                                    return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
                                }
                                main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
                                return main(context, options);
                            }
                            ret.isTop = true;

                            ret._setup = function (options) {
                                if (!options.partial) {
                                    container.helpers = container.merge(options.helpers, env.helpers);

                                    if (templateSpec.usePartial) {
                                        container.partials = container.merge(options.partials, env.partials);
                                    }
                                    if (templateSpec.usePartial || templateSpec.useDecorators) {
                                        container.decorators = container.merge(options.decorators, env.decorators);
                                    }
                                } else {
                                    container.helpers = options.helpers;
                                    container.partials = options.partials;
                                    container.decorators = options.decorators;
                                }
                            };

                            ret._child = function (i, data, blockParams, depths) {
                                if (templateSpec.useBlockParams && !blockParams) {
                                    throw new _exception2['default']('must pass block params');
                                }
                                if (templateSpec.useDepths && !depths) {
                                    throw new _exception2['default']('must pass parent depths');
                                }

                                return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
                            };
                            return ret;
                        }

                        function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
                            function prog(context) {
                                var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                                var currentDepths = depths;
                                if (depths && context != depths[0]) {
                                    currentDepths = [context].concat(depths);
                                }

                                return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
                            }

                            prog = executeDecorators(fn, prog, container, depths, data, blockParams);

                            prog.program = i;
                            prog.depth = depths ? depths.length : 0;
                            prog.blockParams = declaredBlockParams || 0;
                            return prog;
                        }

                        function resolvePartial(partial, context, options) {
                            if (!partial) {
                                if (options.name === '@partial-block') {
                                    var data = options.data;
                                    while (data['partial-block'] === noop) {
                                        data = data._parent;
                                    }
                                    partial = data['partial-block'];
                                    data['partial-block'] = noop;
                                } else {
                                    partial = options.partials[options.name];
                                }
                            } else if (!partial.call && !options.name) {
                                // This is a dynamic partial that returned a string
                                options.name = partial;
                                partial = options.partials[partial];
                            }
                            return partial;
                        }

                        function invokePartial(partial, context, options) {
                            options.partial = true;
                            if (options.ids) {
                                options.data.contextPath = options.ids[0] || options.data.contextPath;
                            }

                            var partialBlock = undefined;
                            if (options.fn && options.fn !== noop) {
                                options.data = _base.createFrame(options.data);
                                partialBlock = options.data['partial-block'] = options.fn;

                                if (partialBlock.partials) {
                                    options.partials = Utils.extend({}, options.partials, partialBlock.partials);
                                }
                            }

                            if (partial === undefined && partialBlock) {
                                partial = partialBlock;
                            }

                            if (partial === undefined) {
                                throw new _exception2['default']('The partial ' + options.name + ' could not be found');
                            } else if (partial instanceof Function) {
                                return partial(context, options);
                            }
                        }

                        function noop() {
                            return '';
                        }

                        function initData(context, data) {
                            if (!data || !('root' in data)) {
                                data = data ? _base.createFrame(data) : {};
                                data.root = context;
                            }
                            return data;
                        }

                        function executeDecorators(fn, prog, container, depths, data, blockParams) {
                            if (fn.decorator) {
                                var props = {};
                                prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
                                Utils.extend(prog, props);
                            }
                            return prog;
                        }



                        /***/ }),
                    /* 30 */
                    /***/ (function(module, exports) {

                        /* WEBPACK VAR INJECTION */(function(global) {/* global window */

                            exports.__esModule = true;

                            exports['default'] = function (Handlebars) {
                                /* istanbul ignore next */
                                var root = typeof global !== 'undefined' ? global : window,
                                    $Handlebars = root.Handlebars;
                                /* istanbul ignore next */
                                Handlebars.noConflict = function () {
                                    if (root.Handlebars === Handlebars) {
                                        root.Handlebars = $Handlebars;
                                    }
                                    return Handlebars;
                                };
                            };

                            module.exports = exports['default'];


                            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())));

                        /***/ }),
                    /* 31 */
                    /***/ (function(module, exports) {

                        var PADDING_ZERO_TYPES = ['hh', 'mm'];

                        /**
                         * @param {number} value time or minute
                         * @param {string} format - timeFormat
                         * @returns {boolean}
                         */
                        module.exports = function(value, format) {
                            value = String(value);

                            return (PADDING_ZERO_TYPES.indexOf(format) >= 0 && value.length === 1) ? '0' + value : value;
                        };


                        /***/ }),
                    /* 32 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(8);
                        var snippet = __webpack_require__(9);

                        var tmpl = __webpack_require__(33);

                        /**
                         * @class
                         * @ignore
                         * @param {jQuery|string|Element} container - Container element
                         * @param {object} options - Options
                         * @param {Array.<number>} options.items - Items
                         * @param {number} options.initialValue - Initial value
                         */
                        var Selectbox = snippet.defineClass(/** @lends Selectbox.prototype */ {
                            init: function(container, options) {
                                options = snippet.extend({
                                    items: []
                                }, options);

                                /**
                                 * Container element
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$container = $(container);

                                /**
                                 * Selectbox items
                                 * @type {Array.<number>}
                                 * @private
                                 */
                                this._items = options.items || [];

                                /**
                                 * Selectbox disabled items info
                                 * @type {Array.<number>}
                                 * @private
                                 */
                                this._disabledItems = options.disabledItems || [];

                                /**
                                 * Selected index
                                 * @type {number}
                                 * @private
                                 */
                                this._selectedIndex = Math.max(0, snippet.inArray(options.initialValue, this._items));

                                /**
                                 * Time format for output
                                 * @type {string}
                                 * @private
                                 */
                                this._format = options.format;

                                /**
                                 * Element
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$element = $();

                                this._render();
                                this._setEvents();
                            },

                            /**
                             * Render selectbox
                             * @private
                             */
                            _render: function() {
                                var context;

                                this._changeEnabledIndex();
                                context = {
                                    items: this._items,
                                    initialValue: this.getValue(),
                                    format: this._format,
                                    disabledItems: snippet.map(this._disabledItems, function(item) {
                                        if (item) {
                                            return 'disabled';
                                        }

                                        return '';
                                    })
                                };

                                this._$element.remove();
                                this._$element = $(tmpl(context));
                                this._$element.appendTo(this._$container);
                            },

                            /**
                             * Change the index of the enabled item
                             * @private
                             */
                            _changeEnabledIndex: function() {
                                if (this._disabledItems[this._items.indexOf(this.getValue())]) {
                                    this._selectedIndex = snippet.inArray(false, this._disabledItems);
                                }
                            },

                            /**
                             * Set disabledItems
                             * @param {object} disabledItems - disabled status of items
                             * @private
                             */
                            setDisabledItems: function(disabledItems) {
                                this._disabledItems = disabledItems;
                                this._render();
                            },

                            /**
                             * Set events
                             * @private
                             */
                            _setEvents: function() {
                                this._$container.on('change.selectbox', 'select', $.proxy(this._onChange, this));
                                this.on('changeItems', function(items) {
                                    this._items = items;
                                    this._render();
                                }, this);
                            },

                            /**
                             * Change event handler
                             * @param {jQuery.Event} ev - Event object
                             * @private
                             */
                            _onChange: function(ev) {
                                var newValue = Number(ev.target.value);

                                this._selectedIndex = snippet.inArray(newValue, this._items);
                                this.fire('change', {
                                    value: newValue
                                });
                            },

                            /**
                             * Returns current value
                             * @returns {number}
                             */
                            getValue: function() {
                                return this._items[this._selectedIndex];
                            },

                            /**
                             * Set value
                             * @param {number} value - New value
                             */
                            setValue: function(value) {
                                var newIndex = snippet.inArray(value, this._items);

                                if (newIndex > -1 && newIndex !== this._selectedIndex) {
                                    this._selectedIndex = newIndex;
                                    this._$element.val(value).change();
                                }
                            },

                            /**
                             * Destory
                             */
                            destroy: function() {
                                this.off();
                                this._$container.off('.selectbox');
                                this._$element.remove();

                                this._$container
                                    = this._items
                                    = this._selectedIndex
                                    = this._$element
                                    = this._$element
                                    = null;
                            }
                        });

                        snippet.CustomEvents.mixin(Selectbox);
                        module.exports = Selectbox;


                        /***/ }),
                    /* 33 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var Handlebars = __webpack_require__(12);
                        function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
                        module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data,blockParams,depths) {
                                var stack1, alias1=depth0 != null ? depth0 : {};

                                return ((stack1 = helpers["if"].call(alias1,__default(__webpack_require__(34)).call(alias1,(depths[1] != null ? depths[1].initialValue : depths[1]),blockParams[0][0],{"name":"../helpers/equals","hash":{},"data":data,"blockParams":blockParams}),{"name":"if","hash":{},"fn":container.program(2, data, 0, blockParams, depths),"inverse":container.program(4, data, 0, blockParams, depths),"data":data,"blockParams":blockParams})) != null ? stack1 : "");
                            },"2":function(container,depth0,helpers,partials,data,blockParams,depths) {
                                var alias1=container.escapeExpression, alias2=depth0 != null ? depth0 : {};

                                return "            <option value=\""
                                    + alias1(container.lambda(blockParams[1][0], depth0))
                                    + "\" selected "
                                    + alias1(helpers.lookup.call(alias2,(depths[1] != null ? depths[1].disabledItems : depths[1]),(data && data.index),{"name":"lookup","hash":{},"data":data,"blockParams":blockParams}))
                                    + ">"
                                    + alias1(__default(__webpack_require__(31)).call(alias2,blockParams[1][0],(depths[1] != null ? depths[1].format : depths[1]),{"name":"../helpers/timeFormat","hash":{},"data":data,"blockParams":blockParams}))
                                    + "</option>\n";
                            },"4":function(container,depth0,helpers,partials,data,blockParams,depths) {
                                var alias1=container.escapeExpression, alias2=depth0 != null ? depth0 : {};

                                return "            <option value=\""
                                    + alias1(container.lambda(blockParams[1][0], depth0))
                                    + "\" "
                                    + alias1(helpers.lookup.call(alias2,(depths[1] != null ? depths[1].disabledItems : depths[1]),(data && data.index),{"name":"lookup","hash":{},"data":data,"blockParams":blockParams}))
                                    + ">"
                                    + alias1(__default(__webpack_require__(31)).call(alias2,blockParams[1][0],(depths[1] != null ? depths[1].format : depths[1]),{"name":"../helpers/timeFormat","hash":{},"data":data,"blockParams":blockParams}))
                                    + "</option>\n";
                            },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data,blockParams,depths) {
                                var stack1;

                                return "<select class=\"tui-timepicker-select\" aria-label=\"Time\">\n"
                                    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.items : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 1, blockParams, depths),"inverse":container.noop,"data":data,"blockParams":blockParams})) != null ? stack1 : "")
                                    + "</select>\n";
                            },"useData":true,"useDepths":true,"useBlockParams":true});

                        /***/ }),
                    /* 34 */
                    /***/ (function(module, exports) {

                        /**
                         * @param {*} a - Anything
                         * @param {*} b - Anything
                         * @returns {boolean}
                         */
                        module.exports = function(a, b) {
                            return a === b;
                        };


                        /***/ }),
                    /* 35 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var snippet = __webpack_require__(9);

                        /**
                         * Utils
                         * @namespace util
                         * @ignore
                         */
                        var utils = {
                            /**
                             * Get meridiem hour
                             * @param {number} hour - Original hour
                             * @returns {number} Converted meridiem hour
                             */
                            getMeridiemHour: function(hour) {
                                hour %= 12;

                                if (hour === 0) {
                                    hour = 12;
                                }

                                return hour;
                            },

                            /**
                             * Returns range arr
                             * @param {number} start - Start value
                             * @param {number} end - End value
                             * @param {number} [step] - Step value
                             * @returns {Array}
                             */
                            getRangeArr: function(start, end, step) {
                                var arr = [];
                                var i;

                                step = step || 1;

                                if (start > end) {
                                    for (i = end; i >= start; i -= step) {
                                        arr.push(i);
                                    }
                                } else {
                                    for (i = start; i <= end; i += step) {
                                        arr.push(i);
                                    }
                                }

                                return arr;
                            },

                            /**
                             * send host name
                             * @ignore
                             */
                            sendHostName: function() {
                                snippet.sendHostname('time-picker', 'UA-129987462-1');
                            }
                        };

                        module.exports = utils;


                        /***/ }),
                    /* 36 */
                    /***/ (function(module, exports) {

                        module.exports = {
                            en: {
                                am: 'AM',
                                pm: 'PM'
                            },
                            ko: {
                                am: '',
                                pm: ''
                            }
                        };


                        /***/ }),
                    /* 37 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var Handlebars = __webpack_require__(12);
                        function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
                        module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data) {
                                var stack1;

                                return "                <div class=\"tui-timepicker-column tui-timepicker-spinbox tui-timepicker-hour\"></div>\n                <span class=\"tui-timepicker-column tui-timepicker-colon\"><span class=\"tui-ico-colon\">:</span></span>\n                <div class=\"tui-timepicker-column tui-timepicker-spinbox tui-timepicker-minute\"></div>\n"
                                    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.showMeridiem : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
                            },"2":function(container,depth0,helpers,partials,data) {
                                var stack1;

                                return "                    "
                                    + ((stack1 = container.lambda((depth0 != null ? depth0.meridiemElement : depth0), depth0)) != null ? stack1 : "")
                                    + "\n";
                            },"4":function(container,depth0,helpers,partials,data) {
                                var stack1;

                                return "                <div class=\"tui-timepicker-column tui-timepicker-selectbox tui-timepicker-hour\"></div>\n                <span class=\"tui-timepicker-column tui-timepicker-colon\"><span class=\"tui-ico-colon\">:</span></span>\n                <div class=\"tui-timepicker-column tui-timepicker-selectbox tui-timepicker-minute\"></div>\n"
                                    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.showMeridiem : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
                            },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
                                var stack1, alias1=depth0 != null ? depth0 : {};

                                return "<div class=\"tui-timepicker\">\n    <div class=\"tui-timepicker-body\">\n        <div class=\"tui-timepicker-row\">\n"
                                    + ((stack1 = helpers["if"].call(alias1,__default(__webpack_require__(34)).call(alias1,(depth0 != null ? depth0.inputType : depth0),"spinbox",{"name":"../helpers/equals","hash":{},"data":data}),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "")
                                    + "        </div>\n    </div>\n</div>\n";
                            },"useData":true});

                        /***/ }),
                    /* 38 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var Handlebars = __webpack_require__(12);
                        function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
                        module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data,blockParams) {
                                var stack1, alias1=depth0 != null ? depth0 : {};

                                return ((stack1 = helpers["with"].call(alias1,__default(__webpack_require__(39)).call(alias1,{"name":"../helpers/uniqueId","hash":{},"data":data,"blockParams":blockParams}),{"name":"with","hash":{},"fn":container.program(2, data, 1, blockParams),"inverse":container.noop,"data":data,"blockParams":blockParams})) != null ? stack1 : "");
                            },"2":function(container,depth0,helpers,partials,data,blockParams) {
                                var stack1, alias1=container.lambda, alias2=container.escapeExpression;

                                return "    <div class=\"tui-timepicker-column tui-timepicker-checkbox tui-timepicker-meridiem\">\n        <div class=\"tui-timepicker-check-area\">\n            <ul class=\"tui-timepicker-check-lst\">\n                <li class=\"tui-timepicker-check\">\n                    <div class=\"tui-timepicker-radio\">\n                        <input type=\"radio\"\n                               name=\"optionsRadios-"
                                    + alias2(alias1(blockParams[0][0], depth0))
                                    + "\"\n                               value=\"AM\"\n                               class=\"tui-timepicker-radio-am\"\n                               id=\"tui-timepicker-radio-am-"
                                    + alias2(alias1(blockParams[0][0], depth0))
                                    + "\">\n                        <label for=\"tui-timepicker-radio-am-"
                                    + alias2(alias1(blockParams[0][0], depth0))
                                    + "\" class=\"tui-timepicker-radio-label\">\n                            <span class=\"tui-timepicker-input-radio\"></span>"
                                    + alias2(alias1(((stack1 = (data && data.root)) && stack1.am), depth0))
                                    + "\n                        </label>\n                    </div>\n                </li>\n                <li class=\"tui-timepicker-check\">\n                    <div class=\"tui-timepicker-radio\">\n                        <input type=\"radio\"\n                               name=\"optionsRadios-"
                                    + alias2(alias1(blockParams[0][0], depth0))
                                    + "\"\n                               value=\"PM\"\n                               class=\"tui-timepicker-radio-pm\"\n                               id=\"tui-timepicker-radio-pm-"
                                    + alias2(alias1(blockParams[0][0], depth0))
                                    + "\">\n                        <label for=\"tui-timepicker-radio-pm-"
                                    + alias2(alias1(blockParams[0][0], depth0))
                                    + "\" class=\"tui-timepicker-radio-label\">\n                            <span class=\"tui-timepicker-input-radio\"></span>"
                                    + alias2(alias1(((stack1 = (data && data.root)) && stack1.pm), depth0))
                                    + "\n                        </label>\n                    </div>\n                </li>\n            </ul>\n        </div>\n    </div>\n";
                            },"4":function(container,depth0,helpers,partials,data) {
                                var alias1=container.lambda, alias2=container.escapeExpression;

                                return "    <div class=\"tui-timepicker-column tui-timepicker-selectbox tui-is-add-picker tui-timepicker-meridiem\">\n        <select class=\"tui-timepicker-select\" aria-label=\"AM/PM\">\n            <option value=\"AM\">"
                                    + alias2(alias1((depth0 != null ? depth0.am : depth0), depth0))
                                    + "</option>\n            <option value=\"PM\">"
                                    + alias2(alias1((depth0 != null ? depth0.pm : depth0), depth0))
                                    + "</option>\n        </select>\n    </div>\n";
                            },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data,blockParams) {
                                var stack1, alias1=depth0 != null ? depth0 : {};

                                return "\n"
                                    + ((stack1 = helpers["if"].call(alias1,__default(__webpack_require__(34)).call(alias1,(depth0 != null ? depth0.inputType : depth0),"spinbox",{"name":"../helpers/equals","hash":{},"data":data,"blockParams":blockParams}),{"name":"if","hash":{},"fn":container.program(1, data, 0, blockParams),"inverse":container.program(4, data, 0, blockParams),"data":data,"blockParams":blockParams})) != null ? stack1 : "");
                            },"useData":true,"useBlockParams":true});

                        /***/ }),
                    /* 39 */
                    /***/ (function(module, exports) {

                        var uniqueId = 0;

                        /**
                         * Returns unique id
                         * @returns {number}
                         */
                        module.exports = function() {
                            uniqueId += 1;

                            return uniqueId;
                        };


                        /***/ })
                    /******/ ])
        });
    });

    var tuiDatePicker = createCommonjsModule(function (module, exports) {
        /*!
     * tui-date-picker.js
     * @version 3.3.4
     * @author NHN. FE Development Lab <dl_javascript@nhn.com>
     * @license MIT
     */
        (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory(jquery, tuiCodeSnippet, tuiTimePicker);
        })(commonjsGlobal, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__) {
            return /******/ (function(modules) { // webpackBootstrap
                /******/ 	// The module cache
                /******/ 	var installedModules = {};

                /******/ 	// The require function
                /******/ 	function __webpack_require__(moduleId) {

                    /******/ 		// Check if module is in cache
                    /******/ 		if(installedModules[moduleId])
                        /******/ 			return installedModules[moduleId].exports;

                    /******/ 		// Create a new module (and put it into the cache)
                    /******/ 		var module = installedModules[moduleId] = {
                        /******/ 			exports: {},
                        /******/ 			id: moduleId,
                        /******/ 			loaded: false
                        /******/ 		};

                    /******/ 		// Execute the module function
                    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

                    /******/ 		// Flag the module as loaded
                    /******/ 		module.loaded = true;

                    /******/ 		// Return the exports of the module
                    /******/ 		return module.exports;
                    /******/ 	}


                /******/ 	// expose the modules object (__webpack_modules__)
                /******/ 	__webpack_require__.m = modules;

                /******/ 	// expose the module cache
                /******/ 	__webpack_require__.c = installedModules;

                /******/ 	// __webpack_public_path__
                /******/ 	__webpack_require__.p = "dist";

                /******/ 	// Load entry module and return exports
                /******/ 	return __webpack_require__(0);
                /******/ })
                /************************************************************************/
                /******/ ([
                    /* 0 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var DatePicker = __webpack_require__(1);
                        var DateRangePicker = __webpack_require__(49);
                        var Calendar = __webpack_require__(5);

                        __webpack_require__(50);

                        /**
                         * Create a calendar component
                         * @static
                         * @param {HTMLElement|jQuery|string} wrapperElement - Wrapper element or selector
                         *     @param {Object} [options] - Options for initialize
                         *     @param {string} [options.language = 'en'] - Calendar language - {@link Calendar.localeTexts}
                         *     @param {boolean} [options.showToday] - If true, shows today
                         *     @param {boolean} [options.showJumpButtons] - If true, shows jump buttons (next,prev-year in 'date'-Calendar)
                         *     @param {Date} [options.date = new Date()] - Initial date
                         *     @param {string} [options.type = 'date'] - Calendar types - 'date', 'month', 'year'
                         *     @param {Boolean} [options.usageStatistics=true|false] send hostname to google analytics [default value is true]
                         * @returns {Calendar} Instance of Calendar
                         * @example
                         * var DatePicker = tui.DatePicker; // or require('tui-date-picker');
                         * var calendar = DatePicker.createCalendar('#calendar-wrapper', {
                         *    language: 'en',
                         *    showToday: true,
                         *    showJumpButtons: false,
                         *    date: new Date(),
                         *    type: 'date'
                         * });
                         */
                        DatePicker.createCalendar = function(wrapperElement, options) {
                            return new Calendar(wrapperElement, options);
                        };

                        /**
                         * Create a calendar component
                         * @static
                         * @param {object} options - Date-Range picker options
                         *     @param {object} options.startpicker - Startpicker options
                         *     @param {Element|jQuery|string} options.startpicker.input - Startpicker input element
                         *     @param {Element|jQuery|string} options.startpicker.container - Startpicker container element
                         *     @param {object} options.endpicker - Endpicker options
                         *     @param {Element|jQuery|string} options.endpicker.input - Endpicker input element
                         *     @param {Element|jQuery|string} options.endpicker.container - Endpicker container element
                         *     @param {string} options.format - Input date-string format
                         *     @param {string} [options.type = 'date'] - DatePicker type - ('date' | 'month' | 'year')
                         *     @param {string} [options.language='en'] - Language key
                         *     @param {object|boolean} [options.timePicker] - {@link TimePicker} option
                         *     @param {object} [options.calendar] - {@link Calendar} option
                         *     @param {Array.<Array.<Date|number>>} [options.selectableRanges] - Selectable ranges
                         *     @param {boolean} [options.showAlways = false] - Whether the datepicker shows always
                         *     @param {boolean} [options.autoClose = true] - Close after click a date
                         *     @param {Boolean} [options.usageStatistics=true|false] send hostname to google analytics [default value is true]
                         * @returns {DateRangePicker} Instance of DateRangePicker
                         * @example
                         * var DatePicker = tui.DatePicker; // or require('tui-date-picker');
                         * var rangepicker = DatePicker.createRangePicker({
                         *     startpicker: {
                         *         input: '#start-input',
                         *         container: '#start-container'
                         *     },
                         *     endpicker: {
                         *         input: '#end-input',
                         *         container: '#end-container'
                         *     },
                         *     type: 'date',
                         *     format: 'yyyy-MM-dd'
                         *     selectableRanges: [
                         *         [new Date(2017, 3, 1), new Date(2017, 5, 1)],
                         *         [new Date(2017, 6, 3), new Date(2017, 10, 5)]
                         *     ]
                         * });
                         */
                        DatePicker.createRangePicker = function(options) {
                            return new DateRangePicker(options);
                        };

                        module.exports = DatePicker;


                        /***/ }),
                    /* 1 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(2);
                        var snippet = __webpack_require__(3);
                        var TimePicker = __webpack_require__(4);

                        var Calendar = __webpack_require__(5);
                        var RangeModel = __webpack_require__(43);
                        var constants = __webpack_require__(31);
                        var localeTexts = __webpack_require__(27);
                        var dateUtil = __webpack_require__(30);
                        var setTouchClickEvent = __webpack_require__(45);
                        var tmpl = __webpack_require__(46);
                        var DatePickerInput = __webpack_require__(48);

                        var DEFAULT_LANGUAGE_TYPE = constants.DEFAULT_LANGUAGE_TYPE;
                        var TYPE_DATE = constants.TYPE_DATE;
                        var TYPE_MONTH = constants.TYPE_MONTH;
                        var TYPE_YEAR = constants.TYPE_YEAR;
                        var CLASS_NAME_NEXT_YEAR_BTN = constants.CLASS_NAME_NEXT_YEAR_BTN;
                        var CLASS_NAME_NEXT_MONTH_BTN = constants.CLASS_NAME_NEXT_MONTH_BTN;
                        var CLASS_NAME_PREV_YEAR_BTN = constants.CLASS_NAME_PREV_YEAR_BTN;
                        var CLASS_NAME_PREV_MONTH_BTN = constants.CLASS_NAME_PREV_MONTH_BTN;
                        var CLASS_NAME_SELECTED = constants.CLASS_NAME_SELECTED;

                        var CLASS_NAME_SELECTABLE = 'tui-is-selectable';
                        var CLASS_NAME_BLOCKED = 'tui-is-blocked';
                        var CLASS_NAME_CHECKED = 'tui-is-checked';
                        var CLASS_NAME_SELECTOR_BUTTON = 'tui-datepicker-selector-button';
                        var CLASS_NAME_TODAY = 'tui-calendar-today';

                        var SELECTOR_BODY = '.tui-datepicker-body';
                        var SELECTOR_FOOTER = '.tui-datepicker-footer';
                        var SELECTOR_DATE_ICO = '.tui-ico-date';

                        /**
                         * Merge default option
                         * @ignore
                         * @param {object} option - DatePicker option
                         * @returns {object}
                         */
                        var mergeDefaultOption = function(option) {
                            option = snippet.extend({
                                language: DEFAULT_LANGUAGE_TYPE,
                                calendar: {},
                                input: {
                                    element: null,
                                    format: null
                                },
                                timepicker: null,
                                date: null,
                                showAlways: false,
                                type: TYPE_DATE,
                                selectableRanges: null,
                                openers: [],
                                autoClose: true,
                                usageStatistics: true
                            }, option);

                            option.selectableRanges = option.selectableRanges || [[constants.MIN_DATE, constants.MAX_DATE]];

                            if (!snippet.isObject(option.calendar)) {
                                throw new Error('Calendar option must be an object');
                            }
                            if (!snippet.isObject(option.input)) {
                                throw new Error('Input option must be an object');
                            }
                            if (!snippet.isArray(option.selectableRanges)) {
                                throw new Error('Selectable-ranges must be a 2d-array');
                            }

                            option.localeText = localeTexts[option.language];

                            // override calendar option
                            option.calendar.language = option.language;
                            option.calendar.type = option.type;

                            return option;
                        };

                        /**
                         * @class
                         * @param {HTMLElement|jQuery|string} container - Container element of datepicker
                         * @param {Object} [options] - Options
                         *      @param {Date|number} [options.date] - Initial date. Default - null for no initial date
                         *      @param {string} [options.type = 'date'] - DatePicker type - ('date' | 'month' | 'year')
                         *      @param {string} [options.language='en'] - Language key
                         *      @param {object|boolean} [options.timePicker] -
                         *                              [TimePicker]{@link https://nhn.github.io/tui.time-picker/latest} options
                         *      @param {object} [options.calendar] - {@link Calendar} options
                         *      @param {object} [options.input] - Input option
                         *      @param {HTMLElement|string|jQuery} [options.input.element] - Input element
                         *      @param {string} [options.input.format = 'yyyy-mm-dd'] - Date string format
                         *      @param {Array.<Array.<Date|number>>} [options.selectableRanges = 1900/1/1 ~ 2999/12/31]
                         *                                                                      - Selectable date ranges.
                         *      @param {Array} [options.openers = []] - Opener button list (example - icon, button, etc.)
                         *      @param {boolean} [options.showAlways = false] - Whether the datepicker shows always
                         *      @param {boolean} [options.autoClose = true] - Close after click a date
                         *      @param {Boolean} [options.usageStatistics=true|false] send hostname to google analytics (default value is true)
                         * @example
                         * var DatePicker = tui.DatePicker; // or require('tui-date-picker');
                         *
                         * var range1 = [new Date(2015, 2, 1), new Date(2015, 3, 1)];
                         * var range2 = [1465570800000, 1481266182155]; // timestamps
                         *
                         * var picker1 = new DatePicker('#datepicker-container1', {
                         *     showAlways: true
                         * });
                         *
                         * var picker2 = new DatePicker('#datepicker-container2', {
                         *    showAlways: true,
                         *    timepicker: true
                         * });
                         *
                         * var picker3 = new DatePicker('#datepicker-container3', {
                         *     // There are two supporting types by default - 'en' and 'ko'.
                         *     // See "{@link DatePicker.localeTexts}"
                         *     language: 'ko',
                         *     calendar: {
                         *         showToday: true
                         *     },
                         *     timepicker: {
                         *         showMeridiem: true,
                         *         defaultHour: 13,
                         *         defaultMinute: 24
                         *     },
                         *     input: {
                         *         element: '#datepicker-input',
                         *         format: 'yyyy MM dd hh:mm A'
                         *     }
                         *     type: 'date',
                         *     date: new Date(2015, 0, 1) // or timestamp. (default: null-(no initial date))
                         *     selectableRanges: [range1, range2],
                         *     openers: ['#opener']
                         * });
                         */
                        var DatePicker = snippet.defineClass(/** @lends DatePicker.prototype */{
                            static: {
                                /**
                                 * Locale text data
                                 * @type {object}
                                 * @memberof DatePicker
                                 * @static
                                 * @example
                                 * var DatePicker = tui.DatePicker; // or require('tui-date-picker');
                                 *
                                 * DatePicker.localeTexts['customKey'] = {
                                 *     titles: {
                                 *         // days
                                 *         DD: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                                 *         // daysShort
                                 *         D: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fir', 'Sat'],
                                 *         // months
                                 *         MMMM: [
                                 *             'January', 'February', 'March', 'April', 'May', 'June',
                                 *             'July', 'August', 'September', 'October', 'November', 'December'
                                 *         ],
                                 *         // monthsShort
                                 *         MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
                                 *     },
                                 *     titleFormat: 'MMM yyyy',
                                 *     todayFormat: 'D, MMMM dd, yyyy',
                                 *     date: 'Date',
                                 *     time: 'Time'
                                 * };
                                 *
                                 * var datepicker = new tui.DatePicker('#datepicker-container', {
                                 *     language: 'customKey'
                                 * });
                                 */
                                localeTexts: localeTexts
                            },
                            init: function(container, options) {
                                options = mergeDefaultOption(options);

                                /**
                                 * Language type
                                 * @type {string}
                                 * @private
                                 */
                                this._language = options.language;

                                /**
                                 * DatePicker container
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$container = $(container);

                                /**
                                 * DatePicker element
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$element = $(tmpl(options)).appendTo(this._$container);

                                /**
                                 * Calendar instance
                                 * @type {Calendar}
                                 * @private
                                 */
                                this._calendar = new Calendar(this._$element.find(SELECTOR_BODY), snippet.extend(options.calendar, {
                                    usageStatistics: options.usageStatistics
                                }));

                                /**
                                 * TimePicker instance
                                 * @type {TimePicker}
                                 * @private
                                 */
                                this._timepicker = null;

                                /**
                                 * DatePicker input
                                 * @type {DatePickerInput}
                                 * @private
                                 */
                                this._datepickerInput = null;

                                /**
                                 * Object having date values
                                 * @type {Date}
                                 * @private
                                 */
                                this._date = null;

                                /**
                                 * Selectable date-ranges model
                                 * @type {RangeModel}
                                 * @private
                                 */
                                this._rangeModel = null;

                                /**
                                 * openers - opener list
                                 * @type {Array}
                                 * @private
                                 */
                                this._openers = [];

                                /**
                                 * State of picker enable
                                 * @type {boolean}
                                 * @private
                                 */
                                this._isEnabled = true;

                                /**
                                 * ID of instance
                                 * @private
                                 * @type {number}
                                 */
                                this._id = 'tui-datepicker-' + snippet.stamp(this);

                                /**
                                 * DatePicker type
                                 * @type {TYPE_DATE|TYPE_MONTH|TYPE_YEAR}
                                 * @private
                                 */
                                this._type = options.type;

                                /**
                                 * Show always or not
                                 * @type {boolean}
                                 */
                                this.showAlways = options.showAlways;

                                /**
                                 * Close after select a date
                                 * @type {boolean}
                                 */
                                this.autoClose = options.autoClose;

                                this._initializeDatePicker(options);
                            },

                            /**
                             * Initialize method
                             * @param {Object} option - user option
                             * @private
                             */
                            _initializeDatePicker: function(option) {
                                this.setRanges(option.selectableRanges);
                                this._setEvents(option);
                                this._initTimePicker(option.timepicker, option.usageStatistics);
                                this.setInput(option.input.element);
                                this.setDateFormat(option.input.format);
                                this.setDate(option.date);

                                snippet.forEach(option.openers, this.addOpener, this);
                                if (!this.showAlways) {
                                    this._$element.hide();
                                }

                                if (this.getType() === TYPE_DATE) {
                                    this._$element.find(SELECTOR_BODY).addClass('tui-datepicker-type-date');
                                }
                            },

                            /**
                             * Set events
                             * @param {object} option - Constructor option
                             * @private
                             */
                            _setEvents: function(option) {
                                setTouchClickEvent(this._$element, $.proxy(this._onClickDate, this), {
                                    selector: '.' + CLASS_NAME_SELECTABLE,
                                    namespace: this._id
                                });

                                setTouchClickEvent(this._$element, $.proxy(this._onClickCalendarTitle, this), {
                                    selector: '.tui-calendar-title',
                                    namespace: this._id
                                });

                                if (option.timepicker && option.timepicker.layoutType === 'tab') {
                                    setTouchClickEvent(this._$element, $.proxy(this._onClickSelectorButton, this), {
                                        selector: '.' + CLASS_NAME_SELECTOR_BUTTON,
                                        namespace: this._id
                                    });
                                }

                                this._calendar.on('draw', this._onDrawCalendar, this);
                            },

                            /**
                             * Off datepicker's events
                             * @param {string|jQuery|Element} el - Element
                             * @private
                             */
                            _offDatePickerEvents: function(el) {
                                $(el).off('.' + this._id);
                            },

                            /**
                             * Set TimePicker instance
                             * @param {object|boolean} opTimePicker - TimePicker instance options
                             * @param {boolean} usageStatistics - GA tracking options
                             * @private
                             */
                            _initTimePicker: function(opTimePicker, usageStatistics) {
                                var layoutType;
                                if (!opTimePicker) {
                                    return;
                                }

                                layoutType = opTimePicker.layoutType || '';

                                if (snippet.isObject(opTimePicker)) {
                                    opTimePicker.usageStatistics = usageStatistics;
                                } else {
                                    opTimePicker = {
                                        usageStatistics: usageStatistics
                                    };
                                }

                                if (layoutType.toLowerCase() === 'tab') {
                                    this._timepicker = new TimePicker(this._$element.find(SELECTOR_BODY), opTimePicker);
                                    this._timepicker.hide();
                                } else {
                                    this._timepicker = new TimePicker(this._$element.find(SELECTOR_FOOTER), opTimePicker);
                                }

                                this._timepicker.on('change', function(ev) {
                                    var prevDate;
                                    if (this._date) {
                                        prevDate = new Date(this._date);
                                        this.setDate(prevDate.setHours(ev.hour, ev.minute));
                                    }
                                }, this);
                            },

                            /**
                             * Calendar-header click handler
                             * @private
                             */
                            _onClickCalendarTitle: function() {
                                this.drawUpperCalendar(this._date);
                            },

                            /**
                             * Selector button click handler
                             * @param {jQuery.Event} ev - Event object
                             * @private
                             */
                            _onClickSelectorButton: function(ev) {
                                var btnSelector = '.' + CLASS_NAME_SELECTOR_BUTTON;
                                var $selectedBtn = $(ev.target).closest(btnSelector);
                                var isDate = !!$selectedBtn.find(SELECTOR_DATE_ICO).length;

                                if (isDate) {
                                    this._calendar.show();
                                    this._timepicker.hide();
                                } else {
                                    this._calendar.hide();
                                    this._timepicker.show();
                                }
                                this._$element.find(btnSelector).removeClass(CLASS_NAME_CHECKED);
                                $selectedBtn.addClass(CLASS_NAME_CHECKED);
                            },

                            /**
                             * Returns whether the element is opener
                             * @param {string|jQuery|HTMLElement} element - Element
                             * @returns {boolean}
                             * @private
                             */
                            _isOpener: function(element) {
                                var el = $(element)[0];

                                return snippet.inArray(el, this._openers) > -1;
                            },

                            /**
                             * add/remove today-class-name to date element
                             * @param {jQuery} $el - date element
                             * @private
                             */
                            _setTodayClassName: function($el) {
                                var timestamp, isToday;

                                if (this.getCalendarType() !== TYPE_DATE) {
                                    return;
                                }

                                timestamp = $el.data('timestamp');
                                isToday = timestamp === new Date().setHours(0, 0, 0, 0);

                                if (isToday) {
                                    $el.addClass(CLASS_NAME_TODAY);
                                } else {
                                    $el.removeClass(CLASS_NAME_TODAY);
                                }
                            },

                            /**
                             * add/remove selectable-class-name to date element
                             * @param {jQuery} $el - date element
                             * @private
                             */
                            _setSelectableClassName: function($el) {
                                var elDate = new Date($el.data('timestamp'));

                                if (this._isSelectableOnCalendar(elDate)) {
                                    $el.addClass(CLASS_NAME_SELECTABLE)
                                        .removeClass(CLASS_NAME_BLOCKED);
                                } else {
                                    $el.addClass(CLASS_NAME_BLOCKED)
                                        .removeClass(CLASS_NAME_SELECTABLE);
                                }
                            },

                            /**
                             * add/remove selected-class-name to date element
                             * @param {jQuery} $el - date element
                             * @private
                             */
                            _setSelectedClassName: function($el) {
                                var elDate = new Date($el.data('timestamp'));

                                if (this._isSelectedOnCalendar(elDate)) {
                                    $el.addClass(CLASS_NAME_SELECTED);
                                } else {
                                    $el.removeClass(CLASS_NAME_SELECTED);
                                }
                            },

                            /**
                             * Returns whether the date is selectable on calendar
                             * @param {Date} date - Date instance
                             * @returns {boolean}
                             * @private
                             */
                            _isSelectableOnCalendar: function(date) {
                                var type = this.getCalendarType();
                                var start = dateUtil.cloneWithStartOf(date, type).getTime();
                                var end = dateUtil.cloneWithEndOf(date, type).getTime();

                                return this._rangeModel.hasOverlap(start, end);
                            },

                            /**
                             * Returns whether the date is selected on calendar
                             * @param {Date} date - Date instance
                             * @returns {boolean}
                             * @private
                             */
                            _isSelectedOnCalendar: function(date) {
                                var curDate = this.getDate();
                                var calendarType = this.getCalendarType();

                                return curDate && dateUtil.isSame(curDate, date, calendarType);
                            },

                            /**
                             * Set value a date-string of current this instance to input element
                             * @private
                             */
                            _syncToInput: function() {
                                if (!this._date) {
                                    return;
                                }

                                this._datepickerInput.setDate(this._date);
                            },

                            /**
                             * Set date from input value
                             * @param {boolean} [shouldRollback = false] - Should rollback from unselectable or error
                             * @private
                             */
                            _syncFromInput: function(shouldRollback) {
                                var isFailed = false;
                                var date;

                                try {
                                    date = this._datepickerInput.getDate();

                                    if (this.isSelectable(date)) {
                                        if (this._timepicker) {
                                            this._timepicker.setTime(date.getHours(), date.getMinutes());
                                        }
                                        this.setDate(date);
                                    } else {
                                        isFailed = true;
                                    }
                                } catch (err) {
                                    this.fire('error', {
                                        type: 'ParsingError',
                                        message: err.message
                                    });
                                    isFailed = true;
                                } finally {
                                    if (isFailed) {
                                        if (shouldRollback) {
                                            this._syncToInput();
                                        } else {
                                            this.setNull();
                                        }
                                    }
                                }
                            },

                            /**
                             * Event handler for mousedown of document<br>
                             * - When click the out of layer, close the layer
                             * @param {Event} ev - Event object
                             * @private
                             */
                            _onMousedownDocument: function(ev) {
                                var evTarget = ev.target;
                                var isContains = $.contains(this._$element[0], evTarget);
                                var isInput = this._datepickerInput.is(evTarget);
                                var isInOpener = !!$(evTarget).closest(this._openers).length;
                                var shouldClose = !(this.showAlways || isInput || isContains || isInOpener);

                                if (shouldClose) {
                                    this.close();
                                }
                            },

                            /**
                             * Event handler for click of calendar<br>
                             * - Update date form event-target
                             * @param {Event} ev - event object
                             * @private
                             */
                            _onClickDate: function(ev) {
                                var timestamp = $(ev.target).data('timestamp');
                                var newDate = new Date(timestamp);
                                var timepicker = this._timepicker;
                                var prevDate = this._date;
                                var calendarType = this.getCalendarType();
                                var pickerType = this.getType();

                                if (calendarType !== pickerType) {
                                    this.drawLowerCalendar(newDate);
                                } else {
                                    if (timepicker) {
                                        newDate.setHours(timepicker.getHour(), timepicker.getMinute());
                                    } else if (prevDate) {
                                        newDate.setHours(prevDate.getHours(), prevDate.getMinutes());
                                    }
                                    this.setDate(newDate);

                                    if (!this.showAlways && this.autoClose) {
                                        this.close();
                                    }
                                }
                            },

                            /**
                             * Event handler for 'draw'-custom event of calendar
                             * @param {Object} eventData - custom event data
                             * @see {Calendar.draw}
                             * @private
                             */
                            _onDrawCalendar: function(eventData) {
                                var $dateElements = eventData.$dateElements;
                                var self = this;

                                $dateElements.each(function(idx, el) {
                                    var $el = $(el);
                                    self._setTodayClassName($el);
                                    self._setSelectableClassName($el);
                                    self._setSelectedClassName($el);
                                });
                                this._setDisplayHeadButtons();

                                /**
                                 * Fires after calendar drawing
                                 * @event DatePicker#draw
                                 * @type {Object} evt - See {@link Calendar#event:draw}
                                 * @property {Date} date - Calendar date
                                 * @property {string} type - Calendar type
                                 * @property {jQuery} $dateElements - Calendar date elements
                                 * @example
                                 *
                                 * datepicker.on('draw', function(evt) {
                                 *     console.log(evt.date);
                                 * });
                                 */
                                this.fire('draw', eventData);
                            },

                            /**
                             * Hide useless buttons (next, next-year, prev, prev-year)
                             * @see Don't save buttons reference. The buttons are rerendered every "calendar.darw".
                             * @private
                             */
                            _setDisplayHeadButtons: function() {
                                var nextYearDate = this._calendar.getNextYearDate();
                                var prevYearDate = this._calendar.getPrevYearDate();
                                var maxTimestamp = this._rangeModel.getMaximumValue();
                                var minTimestamp = this._rangeModel.getMinimumValue();
                                var $nextYearBtn = this._$element.find('.' + CLASS_NAME_NEXT_YEAR_BTN);
                                var $prevYearBtn = this._$element.find('.' + CLASS_NAME_PREV_YEAR_BTN);
                                var nextMonthDate, prevMonthDate, $nextMonBtn, $prevMonBtn;

                                if (this.getCalendarType() === TYPE_DATE) {
                                    nextMonthDate = dateUtil.cloneWithStartOf(this._calendar.getNextDate(), TYPE_MONTH);
                                    prevMonthDate = dateUtil.cloneWithEndOf(this._calendar.getPrevDate(), TYPE_MONTH);

                                    $nextMonBtn = this._$element.find('.' + CLASS_NAME_NEXT_MONTH_BTN);
                                    $prevMonBtn = this._$element.find('.' + CLASS_NAME_PREV_MONTH_BTN);

                                    this._setDisplay($nextMonBtn, nextMonthDate.getTime() <= maxTimestamp);
                                    this._setDisplay($prevMonBtn, prevMonthDate.getTime() >= minTimestamp);

                                    prevYearDate.setDate(1);
                                    nextYearDate.setDate(1);
                                } else {
                                    prevYearDate.setMonth(12, 0);
                                    nextYearDate.setMonth(0, 1);
                                }

                                this._setDisplay($nextYearBtn, nextYearDate.getTime() <= maxTimestamp);
                                this._setDisplay($prevYearBtn, prevYearDate.getTime() >= minTimestamp);
                            },

                            /**
                             * Set display show/hide by condition
                             * @param {jQuery} $el - jQuery Element
                             * @param {boolean} shouldShow - Condition
                             * @private
                             */
                            _setDisplay: function($el, shouldShow) {
                                if (shouldShow) {
                                    $el.show();
                                } else {
                                    $el.hide();
                                }
                            },

                            /**
                             * Input change handler
                             * @private
                             * @throws {Error}
                             */
                            _onChangeInput: function() {
                                this._syncFromInput(true);
                            },

                            /**
                             * Returns whether the date is changed
                             * @param {Date} date - Date
                             * @returns {boolean}
                             * @private
                             */
                            _isChanged: function(date) {
                                var prevDate = this.getDate();

                                return !prevDate || (date.getTime() !== prevDate.getTime());
                            },

                            /**
                             * Refresh datepicker
                             * @private
                             */
                            _refreshFromRanges: function() {
                                if (!this.isSelectable(this._date)) {
                                    this.setNull();
                                } else {
                                    this._calendar.draw(); // view update
                                }
                            },

                            /**
                             * Returns current calendar type
                             * @returns {'date'|'month'|'year'}
                             */
                            getCalendarType: function() {
                                return this._calendar.getType();
                            },

                            /**
                             * Returns datepicker type
                             * @returns {'date'|'month'|'year'}
                             */
                            getType: function() {
                                return this._type;
                            },

                            /**
                             * Whether the date is selectable
                             * @param {Date} date - Date instance
                             * @returns {boolean}
                             */
                            isSelectable: function(date) {
                                var type = this.getType();
                                var start, end;

                                if (!dateUtil.isValidDate(date)) {
                                    return false;
                                }
                                start = dateUtil.cloneWithStartOf(date, type).getTime();
                                end = dateUtil.cloneWithEndOf(date, type).getTime();

                                return this._rangeModel.hasOverlap(start, end);
                            },

                            /**
                             * Returns whether the date is selected
                             * @param {Date} date - Date instance
                             * @returns {boolean}
                             */
                            isSelected: function(date) {
                                return dateUtil.isValidDate(date) && dateUtil.isSame(this._date, date, this.getType());
                            },

                            /**
                             * Set selectable ranges (prev ranges will be removed)
                             * @param {Array.<Array<Date|number>>} ranges - (2d-array) Selectable ranges
                             * @example
                             *
                             * datepicker.setRanges([
                             *     [new Date(2017, 0, 1), new Date(2018, 0, 2)],
                             *     [new Date(2015, 2, 3), new Date(2016, 4, 2)]
                             * ]);
                             */
                            setRanges: function(ranges) {
                                ranges = snippet.map(ranges, function(range) {
                                    var start = new Date(range[0]).getTime();
                                    var end = new Date(range[1]).getTime();

                                    return [start, end];
                                });

                                this._rangeModel = new RangeModel(ranges);
                                this._refreshFromRanges();
                            },

                            /**
                             * Set calendar type
                             * @param {string} type - set type
                             * @example
                             * datepicker.setType('month');
                             */
                            setType: function(type) {
                                this._type = type;
                            },

                            /**
                             * Add a range
                             * @param {Date|number} start - startDate
                             * @param {Date|number} end - endDate
                             * @example
                             * var start = new Date(2015, 1, 3);
                             * var end = new Date(2015, 2, 6);
                             *
                             * datepicker.addRange(start, end);
                             */
                            addRange: function(start, end) {
                                start = new Date(start).getTime();
                                end = new Date(end).getTime();

                                this._rangeModel.add(start, end);
                                this._refreshFromRanges();
                            },

                            /**
                             * Remove a range
                             * @param {Date|number} start - startDate
                             * @param {Date|number} end - endDate
                             * @param {null|'date'|'month'|'year'} type - Range type, If falsy -> Use strict timestamp;
                             * @example
                             * var start = new Date(2015, 1, 3);
                             * var end = new Date(2015, 2, 6);
                             *
                             * datepicker.removeRange(start, end);
                             */
                            removeRange: function(start, end, type) {
                                start = new Date(start);
                                end = new Date(end);

                                if (type) {
                                    // @todo Consider time-range on timepicker
                                    start = dateUtil.cloneWithStartOf(start, type);
                                    end = dateUtil.cloneWithEndOf(end, type);
                                }

                                this._rangeModel.exclude(start.getTime(), end.getTime());
                                this._refreshFromRanges();
                            },

                            /**
                             * Add opener
                             * @param {HTMLElement|jQuery|string} opener - element or selector
                             */
                            addOpener: function(opener) {
                                if (!this._isOpener(opener)) {
                                    this._openers.push($(opener)[0]);
                                    setTouchClickEvent(opener, $.proxy(this.toggle, this), {
                                        namespace: this._id
                                    });
                                }
                            },

                            /**
                             * Remove opener
                             * @param {HTMLElement|jQuery|string} opener - element or selector
                             */
                            removeOpener: function(opener) {
                                var $opener = $(opener);
                                var index = snippet.inArray($opener[0], this._openers);

                                if (index > -1) {
                                    this._offDatePickerEvents(opener);
                                    this._openers.splice(index, 1);
                                }
                            },

                            /**
                             * Remove all openers
                             */
                            removeAllOpeners: function() {
                                this._offDatePickerEvents(this._openers);
                                this._openers = [];
                            },

                            /**
                             * Open datepicker
                             * @example
                             * datepicker.open();
                             */
                            open: function() {
                                var docEvTypes;
                                if (this.isOpened() || !this._isEnabled) {
                                    return;
                                }

                                this._calendar.draw({
                                    date: this._date,
                                    type: this._type
                                });
                                this._$element.show();

                                if (!this.showAlways) {
                                    docEvTypes = 'touchstart.' + this._id + ' mousedown.' + this._id;
                                    $(document).on(docEvTypes, $.proxy(this._onMousedownDocument, this));
                                }

                                /**
                                 * @event DatePicker#open
                                 * @example
                                 * datepicker.on('open', function() {
                                 *     alert('open');
                                 * });
                                 */
                                this.fire('open');
                            },

                            /**
                             * Raise calendar type
                             *  - DATE --> MONTH --> YEAR
                             * @param {Date} date - Date
                             */
                            drawUpperCalendar: function(date) {
                                var calendarType = this.getCalendarType();

                                if (calendarType === TYPE_DATE) {
                                    this._calendar.draw({
                                        date: date,
                                        type: TYPE_MONTH
                                    });
                                } else if (calendarType === TYPE_MONTH) {
                                    this._calendar.draw({
                                        date: date,
                                        type: TYPE_YEAR
                                    });
                                }
                            },

                            /**
                             * Lower calendar type
                             *  - YEAR --> MONTH --> DATE
                             * @param {Date} date - Date
                             */
                            drawLowerCalendar: function(date) {
                                var calendarType = this.getCalendarType();
                                var pickerType = this.getType();
                                var isLast = calendarType === pickerType;

                                if (isLast) {
                                    return;
                                }

                                if (calendarType === TYPE_MONTH) {
                                    this._calendar.draw({
                                        date: date,
                                        type: TYPE_DATE
                                    });
                                } else if (calendarType === TYPE_YEAR) {
                                    this._calendar.draw({
                                        date: date,
                                        type: TYPE_MONTH
                                    });
                                }
                            },

                            /**
                             * Close datepicker
                             * @exmaple
                             * datepicker.close();
                             */
                            close: function() {
                                if (!this.isOpened()) {
                                    return;
                                }
                                this._offDatePickerEvents(document);
                                this._$element.hide();

                                /**
                                 * Close event - DatePicker
                                 * @event DatePicker#close
                                 * @example
                                 * datepicker.on('close', function() {
                                 *     alert('close');
                                 * });
                                 */
                                this.fire('close');
                            },

                            /**
                             * Toggle: open-close
                             * @example
                             * datepicker.toggle();
                             */
                            toggle: function() {
                                var isOpened = this.isOpened();

                                if (isOpened) {
                                    this.close();
                                } else {
                                    this.open();
                                }
                            },

                            /**
                             * Returns date object
                             * @returns {?Date} - Date
                             * @example
                             * // 2015-04-13
                             * datepicker.getDate(); // new Date(2015, 3, 13)
                             */
                            getDate: function() {
                                if (!this._date) {
                                    return null;
                                }

                                return new Date(this._date);
                            },

                            /**
                             * Set date and then fire 'update' custom event
                             * @param {Date|number} date - Date instance or timestamp
                             * @example
                             * datepicker.setDate(new Date()); // Set today
                             */
                            setDate: function(date) { // eslint-disable-line complexity
                                var isValidInput, newDate, shouldUpdate;

                                if (date === null) {
                                    this.setNull();

                                    return;
                                }

                                isValidInput = snippet.isNumber(date) || snippet.isDate(date);
                                newDate = new Date(date);
                                shouldUpdate = isValidInput && this._isChanged(newDate) && this.isSelectable(newDate);

                                if (shouldUpdate) {
                                    newDate = new Date(date);
                                    this._date = newDate;
                                    this._calendar.draw({date: newDate});
                                    if (this._timepicker) {
                                        this._timepicker.setTime(newDate.getHours(), newDate.getMinutes());
                                    }
                                    this._syncToInput();

                                    /**
                                     * Change event
                                     * @event DatePicker#change
                                     * @example
                                     *
                                     * datepicker.on('change', function() {
                                     *     var newDate = datepicker.getDate();
                                     *
                                     *     console.log(newDate);
                                     * });
                                     */
                                    this.fire('change');
                                }
                            },

                            /**
                             * Set null date
                             */
                            setNull: function() {
                                var calendarDate = this._calendar.getDate();
                                var isChagned = this._date !== null;

                                this._date = null;

                                if (this._datepickerInput) {
                                    this._datepickerInput.clearText();
                                }
                                if (this._timepicker) {
                                    this._timepicker.setTime(0, 0);
                                }

                                // View update
                                if (!this.isSelectable(calendarDate)) {
                                    this._calendar.draw({
                                        date: new Date(this._rangeModel.getMinimumValue())
                                    });
                                } else {
                                    this._calendar.draw();
                                }

                                if (isChagned) {
                                    this.fire('change');
                                }
                            },

                            /**
                             * Set or update date-form
                             * @param {String} [format] - date-format
                             * @example
                             * datepicker.setDateFormat('yyyy-MM-dd');
                             * datepicker.setDateFormat('MM-dd, yyyy');
                             * datepicker.setDateFormat('y/M/d');
                             * datepicker.setDateFormat('yy/MM/dd');
                             */
                            setDateFormat: function(format) {
                                this._datepickerInput.setFormat(format);
                                this._syncToInput();
                            },

                            /**
                             * Return whether the datepicker is opened or not
                             * @returns {boolean}
                             * @example
                             * datepicker.close();
                             * datepicker.isOpened(); // false
                             *
                             * datepicker.open();
                             * datepicker.isOpened(); // true
                             */
                            isOpened: function() {
                                return this._$element.css('display') !== 'none';
                            },

                            /**
                             * Returns timepicker instance
                             * @returns {?TimePicker} - TimePicker instance
                             * @example
                             * var timepicker = this.getTimePicker();
                             */
                            getTimePicker: function() {
                                return this._timepicker;
                            },

                            /**
                             * Returns calendar instance
                             * @returns {Calendar}
                             */
                            getCalendar: function() {
                                return this._calendar;
                            },

                            /**
                             * Returns locale text object
                             * @returns {object}
                             */
                            getLocaleText: function() {
                                return localeTexts[this._language] || localeTexts[DEFAULT_LANGUAGE_TYPE];
                            },

                            /**
                             * Set input element
                             * @param {string|jQuery|HTMLElement} element - Input element
                             * @param {object} [options] - Input option
                             * @param {string} [options.format = prevInput.format] - Input text format
                             * @param {boolean} [options.syncFromInput = false] - Set date from input value
                             */
                            setInput: function(element, options) {
                                var prev = this._datepickerInput;
                                var localeText = this.getLocaleText();
                                var prevFormat;
                                options = options || {};

                                if (prev) {
                                    prevFormat = prev.getFormat();
                                    prev.destroy();
                                }

                                this._datepickerInput = new DatePickerInput(element, {
                                    format: options.format || prevFormat,
                                    id: this._id,
                                    localeText: localeText
                                });

                                this._datepickerInput.on({
                                    change: this._onChangeInput,
                                    click: this.open
                                }, this);

                                if (options.syncFromInput) {
                                    this._syncFromInput();
                                } else {
                                    this._syncToInput();
                                }
                            },

                            /**
                             * Enable
                             * @example
                             * datepicker.disable();
                             * datepicker.enable();
                             */
                            enable: function() {
                                if (this._isEnabled) {
                                    return;
                                }
                                this._isEnabled = true;
                                this._datepickerInput.enable();

                                snippet.forEach(this._openers, function(opener) {
                                    $(opener).removeAttr('disabled');
                                    setTouchClickEvent(opener, $.proxy(this.toggle, this), {
                                        namespace: this._id
                                    });
                                }, this);
                            },

                            /**
                             * Disable
                             * @example
                             * datepicker.enable();
                             * datepicker.disable();
                             */
                            disable: function() {
                                if (!this._isEnabled) {
                                    return;
                                }

                                this._isEnabled = false;
                                this.close();
                                this._datepickerInput.disable();

                                this._offDatePickerEvents(this._openers);
                                snippet.forEach(this._openers, function(opener) {
                                    $(opener).attr('disabled', true);
                                }, this);
                            },

                            /**
                             * Returns whether the datepicker is disabled
                             * @returns {boolean}
                             */
                            isDisabled: function() {
                                // @todo this._isEnabled --> this._isDisabled
                                return !this._isEnabled;
                            },

                            /**
                             * Add datepicker css class
                             * @param {string} className - Class name
                             */
                            addCssClass: function(className) {
                                this._$element.addClass(className);
                            },

                            /**
                             * Remove datepicker css class
                             * @param {string} className - Class name
                             */
                            removeCssClass: function(className) {
                                this._$element.removeClass(className);
                            },

                            /**
                             * Returns date elements(jQuery) on calendar
                             * @returns {jQuery}
                             */
                            getDateElements: function() {
                                return this._calendar.getDateElements();
                            },

                            /**
                             * Returns the first overlapped range from the point or range
                             * @param {Date|number} startDate - Start date to find overlapped range
                             * @param {Date|number} endDate - End date to find overlapped range
                             * @returns {Array.<Date>} - [startDate, endDate]
                             */
                            findOverlappedRange: function(startDate, endDate) {
                                var startTimestamp = new Date(startDate).getTime();
                                var endTimestamp = new Date(endDate).getTime();
                                var overlappedRange = this._rangeModel.findOverlappedRange(startTimestamp, endTimestamp);

                                return [new Date(overlappedRange[0]), new Date(overlappedRange[1])];
                            },

                            /**
                             * Change language
                             * @param {string} language - Language
                             * @see {@link DatePicker.localeTexts}
                             */
                            changeLanguage: function(language) {
                                this._language = language;
                                this._calendar.changeLanguage(this._language);
                                this._datepickerInput.changeLocaleTitles(this.getLocaleText().titles);
                                this.setDateFormat(this._datepickerInput.getFormat());

                                if (this._timepicker) {
                                    this._timepicker.changeLanguage(this._language);
                                }
                            },

                            /**
                             * Destroy
                             */
                            destroy: function() {
                                this._offDatePickerEvents(document);
                                this._calendar.destroy();
                                if (this._timepicker) {
                                    this._timepicker.destroy();
                                }
                                if (this._datepickerInput) {
                                    this._datepickerInput.destroy();
                                }
                                this._$element.remove();
                                this.removeAllOpeners();

                                this._calendar
                                    = this._timepicker
                                    = this._datepickerInput
                                    = this._$container
                                    = this._$element
                                    = this._date
                                    = this._rangeModel
                                    = this._openers
                                    = this._isEnabled
                                    = this._id
                                    = null;
                            }
                        });

                        snippet.CustomEvents.mixin(DatePicker);
                        module.exports = DatePicker;


                        /***/ }),
                    /* 2 */
                    /***/ (function(module, exports) {

                        module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

                        /***/ }),
                    /* 3 */
                    /***/ (function(module, exports) {

                        module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

                        /***/ }),
                    /* 4 */
                    /***/ (function(module, exports) {

                        module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

                        /***/ }),
                    /* 5 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(2);
                        var snippet = __webpack_require__(3);

                        var tmpl = __webpack_require__(6);
                        var Header = __webpack_require__(26);
                        var Body = __webpack_require__(32);
                        var localeTexts = __webpack_require__(27);
                        var constants = __webpack_require__(31);
                        var dateUtil = __webpack_require__(30);

                        var DEFAULT_LANGUAGE_TYPE = constants.DEFAULT_LANGUAGE_TYPE;

                        var TYPE_DATE = constants.TYPE_DATE;
                        var TYPE_MONTH = constants.TYPE_MONTH;
                        var TYPE_YEAR = constants.TYPE_YEAR;

                        var CLASS_NAME_PREV_MONTH_BTN = constants.CLASS_NAME_PREV_MONTH_BTN;
                        var CLASS_NAME_PREV_YEAR_BTN = constants.CLASS_NAME_PREV_YEAR_BTN;
                        var CLASS_NAME_NEXT_YEAR_BTN = constants.CLASS_NAME_NEXT_YEAR_BTN;
                        var CLASS_NAME_NEXT_MONTH_BTN = constants.CLASS_NAME_NEXT_MONTH_BTN;

                        var CLASS_NAME_CALENDAR_MONTH = 'tui-calendar-month';
                        var CLASS_NAME_CALENDAR_YEAR = 'tui-calendar-year';

                        var HEADER_SELECTOR = '.tui-calendar-header';
                        var BODY_SELECTOR = '.tui-calendar-body';

                        var util = snippet;
                        /**
                         * Calendar class
                         * @constructor
                         * @param {HTMLElement|jQuery|string} wrapperElement - Wrapper element or selector
                         * @param {Object} [options] - Options for initialize
                         *     @param {string} [options.language = 'en'] - Calendar language - {@link Calendar.localeTexts}
                         *     @param {boolean} [options.showToday] - If true, shows today
                         *     @param {boolean} [options.showJumpButtons] - If true, shows jump buttons (next,prev-year in 'date'-Calendar)
                         *     @param {Date} [options.date = new Date()] - Initial date
                         *     @param {string} [options.type = 'date'] - Calendar types - 'date', 'month', 'year'
                         *     @param {Boolean} [options.usageStatistics=true|false] send hostname to google analytics (default value is true)
                         * @example
                         * var DatePicker = tui.DatePicker; // or require('tui-date-picker');
                         * var calendar = DatePicker.createCalendar('#calendar-wrapper', {
                         *     language: 'en', // There are two supporting types by default - 'en' and 'ko'.
                         *     showToday: true,
                         *     showJumpButtons: false,
                         *     date: new Date(),
                         *     type: 'date'
                         * });
                         *
                         * calendar.on('draw', function(event) {
                         *     console.log(event.date);
                         *     console.log(event.type);
                         *     event.dateElements.each(function() {
                         *         var $el = $(this);
                         *         var date = new Date($el.data('timestamp'));
                         *         console.log(date);
                         *     });
                         * });
                         */
                        var Calendar = util.defineClass(/** @lends Calendar.prototype */ {
                            static: {
                                /**
                                 * Locale text data
                                 * @type {object}
                                 * @memberof Calendar
                                 * @static
                                 * @example
                                 * var DatePicker = tui.DatePicker; // or require('tui-date-picker');
                                 *
                                 * DatePicker.localeTexts['customKey'] = {
                                 *     titles: {
                                 *         // days
                                 *         DD: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                                 *         // daysShort
                                 *         D: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fir', 'Sat'],
                                 *         // months
                                 *         MMMM: [
                                 *             'January', 'February', 'March', 'April', 'May', 'June',
                                 *             'July', 'August', 'September', 'October', 'November', 'December'
                                 *         ],
                                 *         // monthsShort
                                 *         MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
                                 *     },
                                 *     titleFormat: 'MMM yyyy',
                                 *     todayFormat: 'D, MMMM dd, yyyy'
                                 * };
                                 *
                                 * var calendar = DatePicker.createCalendar('#calendar-wrapper', {
                                 *     language: 'customKey',
                                 * });
                                 */
                                localeTexts: localeTexts
                            },
                            init: function(container, options) {
                                options = snippet.extend({
                                    language: DEFAULT_LANGUAGE_TYPE,
                                    showToday: true,
                                    showJumpButtons: false,
                                    date: new Date(),
                                    type: TYPE_DATE,
                                    usageStatistics: true
                                }, options);

                                /**
                                 * Container element
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$container = $(container);

                                /**
                                 * Wrapper element
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$element = $(tmpl(options)).appendTo(this._$container);

                                /**
                                 * Date
                                 * @type {Date}
                                 * @private
                                 */
                                this._date = null;

                                /**
                                 * Layer type
                                 * @type {string}
                                 * @private
                                 */
                                this._type = null;

                                /**
                                 * Header box
                                 * @type {Header}
                                 * @private
                                 */
                                this._header = null;

                                /**
                                 * Body box
                                 * @type {Body}
                                 * @private
                                 */
                                this._body = null;

                                this._initHeader(options);
                                this._initBody(options);
                                this.draw({
                                    date: options.date,
                                    type: options.type
                                });

                                if (options.usageStatistics) {
                                    snippet.sendHostname('date-picker', 'UA-129987462-1');
                                }
                            },

                            /**
                             * Initialize header
                             * @param {object} options - Header options
                             * @private
                             */
                            _initHeader: function(options) {
                                var $headerContainer = this._$element.find(HEADER_SELECTOR);

                                this._header = new Header($headerContainer, options);
                                this._header.on('click', function(ev) {
                                    var $target = $(ev.target);
                                    if ($target.hasClass(CLASS_NAME_PREV_MONTH_BTN)) {
                                        this.drawPrev();
                                    } else if ($target.hasClass(CLASS_NAME_PREV_YEAR_BTN)) {
                                        this._onClickPrevYear();
                                    } else if ($target.hasClass(CLASS_NAME_NEXT_MONTH_BTN)) {
                                        this.drawNext();
                                    } else if ($target.hasClass(CLASS_NAME_NEXT_YEAR_BTN)) {
                                        this._onClickNextYear();
                                    }
                                }, this);
                            },

                            /**
                             * Initialize body
                             * @param {object} options - Body options
                             * @private
                             */
                            _initBody: function(options) {
                                var $bodyContainer = this._$element.find(BODY_SELECTOR);

                                this._body = new Body($bodyContainer, options);
                            },

                            /**
                             * clickHandler - prev year button
                             * @private
                             */
                            _onClickPrevYear: function() {
                                if (this.getType() === TYPE_DATE) {
                                    this.draw({
                                        date: this._getRelativeDate(-12)
                                    });
                                } else {
                                    this.drawPrev();
                                }
                            },

                            /**
                             * clickHandler - next year button
                             * @private
                             */
                            _onClickNextYear: function() {
                                if (this.getType() === TYPE_DATE) {
                                    this.draw({
                                        date: this._getRelativeDate(12)
                                    });
                                } else {
                                    this.drawNext();
                                }
                            },

                            /**
                             * Returns whether the layer type is valid
                             * @param {string} type - Layer type to check
                             * @returns {boolean}
                             * @private
                             */
                            _isValidType: function(type) {
                                return (
                                    type === TYPE_DATE
                                    || type === TYPE_MONTH
                                    || type === TYPE_YEAR
                                );
                            },

                            /**
                             * @param {Date} date - Date to draw
                             * @param {string} type - Layer type to draw
                             * @returns {boolean}
                             * @private
                             */
                            _shouldUpdate: function(date, type) {
                                var prevDate = this._date;

                                if (!dateUtil.isValidDate(date)) {
                                    throw new Error('Invalid date');
                                }

                                if (!this._isValidType(type)) {
                                    throw new Error('Invalid layer type');
                                }

                                return (
                                    !prevDate
                                    || prevDate.getFullYear() !== date.getFullYear()
                                    || prevDate.getMonth() !== date.getMonth()
                                    || this.getType() !== type
                                );
                            },

                            /**
                             * Render header & body elements
                             * @private
                             */
                            _render: function() {
                                var date = this._date;
                                var type = this.getType();

                                this._header.render(date, type);
                                this._body.render(date, type);
                                this._$element.removeClass([CLASS_NAME_CALENDAR_MONTH, CLASS_NAME_CALENDAR_YEAR].join(' '));

                                switch (type) {
                                    case TYPE_MONTH:
                                        this._$element.addClass(CLASS_NAME_CALENDAR_MONTH);
                                        break;
                                    case TYPE_YEAR:
                                        this._$element.addClass(CLASS_NAME_CALENDAR_YEAR);
                                        break;
                                }
                            },

                            /**
                             * Returns relative date
                             * @param {number} step - Month step
                             * @returns {Date}
                             * @private
                             */
                            _getRelativeDate: function(step) {
                                var prev = this._date;

                                return new Date(prev.getFullYear(), prev.getMonth() + step);
                            },

                            /**
                             * Draw calendar
                             * @param {?object} options - Draw options
                             * @example
                             *
                             * calendar.draw();
                             * calendar.draw({
                             *     date: new Date()
                             * });
                             * calendar.draw({
                             *     type: 'month'
                             * });
                             * calendar.draw({
                             *     type: 'month',
                             *     date: new Date()
                             * });
                             */
                            draw: function(options) {
                                var date, type;

                                options = options || {};
                                date = options.date || this._date;
                                type = (options.type || this.getType()).toLowerCase();

                                if (this._shouldUpdate(date, type)) {
                                    this._date = date;
                                    this._type = type;
                                    this._render();
                                }

                                /**
                                 * @event Calendar#draw
                                 * @type {object} evt
                                 * @property {Date} date - Calendar date
                                 * @property {string} type - Calendar type
                                 * @property {jQuery} $dateElements - Calendar date elements
                                 * @example
                                 * calendar.on('draw', function(evt) {
                                 *     console.error(evt.date);
                                 * });
                                 */
                                this.fire('draw', {
                                    date: this._date,
                                    type: type,
                                    $dateElements: this._body.getDateElements()
                                });
                            },

                            /**
                             * Show calendar
                             */
                            show: function() {
                                this._$element.show();
                            },

                            /**
                             * Hide calendar
                             */
                            hide: function() {
                                this._$element.hide();
                            },

                            /**
                             * Draw next page
                             * @example
                             *
                             * calendar.drawNext();
                             */
                            drawNext: function() {
                                this.draw({
                                    date: this.getNextDate()
                                });
                            },

                            /**
                             * Draw previous page
                             *
                             * @example
                             *
                             * calendar.drawPrev();
                             */
                            drawPrev: function() {
                                this.draw({
                                    date: this.getPrevDate()
                                });
                            },

                            /**
                             * Returns next date
                             * @returns {Date}
                             */
                            getNextDate: function() {
                                if (this.getType() === TYPE_DATE) {
                                    return this._getRelativeDate(1);
                                }

                                return this.getNextYearDate();
                            },

                            /**
                             * Returns prev date
                             * @returns {Date}
                             */
                            getPrevDate: function() {
                                if (this.getType() === TYPE_DATE) {
                                    return this._getRelativeDate(-1);
                                }

                                return this.getPrevYearDate();
                            },

                            /**
                             * Returns next year date
                             * @returns {Date}
                             */
                            getNextYearDate: function() {
                                switch (this.getType()) {
                                    case TYPE_DATE:
                                    case TYPE_MONTH:
                                        return this._getRelativeDate(12); // 12 months = 1 year
                                    case TYPE_YEAR:
                                        return this._getRelativeDate(108); // 108 months = 9 years = 12 * 9
                                    default:
                                        throw new Error('Unknown layer type');
                                }
                            },

                            /**
                             * Returns prev year date
                             * @returns {Date}
                             */
                            getPrevYearDate: function() {
                                switch (this.getType()) {
                                    case TYPE_DATE:
                                    case TYPE_MONTH:
                                        return this._getRelativeDate(-12); // 12 months = 1 year
                                    case TYPE_YEAR:
                                        return this._getRelativeDate(-108); // 108 months = 9 years = 12 * 9
                                    default:
                                        throw new Error('Unknown layer type');
                                }
                            },

                            /**
                             * Change language
                             * @param {string} language - Language
                             * @see {@link Calendar.localeTexts}
                             */
                            changeLanguage: function(language) {
                                this._header.changeLanguage(language);
                                this._body.changeLanguage(language);
                                this._render();
                            },

                            /**
                             * Returns rendered date
                             * @returns {Date}
                             */
                            getDate: function() {
                                return new Date(this._date);
                            },

                            /**
                             * Returns rendered layer type
                             * @returns {('date'|'month'|'year')}
                             */
                            getType: function() {
                                return this._type;
                            },

                            /**
                             * Returns date elements(jQuery) on body
                             * @returns {jQuery}
                             */
                            getDateElements: function() {
                                return this._body.getDateElements();
                            },

                            /**
                             * Add calendar css class
                             * @param {string} className - Class name
                             */
                            addCssClass: function(className) {
                                this._$element.addClass(className);
                            },

                            /**
                             * Remove calendar css class
                             * @param {string} className - Class name
                             */
                            removeCssClass: function(className) {
                                this._$element.removeClass(className);
                            },

                            /**
                             * Destroy calendar
                             */
                            destroy: function() {
                                this._header.destroy();
                                this._body.destroy();
                                this._$element.remove();

                                this._type = this._date = this._$container = this._$element = this._header = this._body = null;
                            }
                        });

                        util.CustomEvents.mixin(Calendar);
                        module.exports = Calendar;


                        /***/ }),
                    /* 6 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var Handlebars = __webpack_require__(7);
                        module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
                                return "<div class=\"tui-calendar\">\n    <div class=\"tui-calendar-header\"></div>\n    <div class=\"tui-calendar-body\"></div>\n</div>\n";
                            },"useData":true});

                        /***/ }),
                    /* 7 */
                    /***/ (function(module, exports, __webpack_require__) {

                        // Create a simple path alias to allow browserify to resolve
                        // the runtime on a supported path.
                        module.exports = __webpack_require__(8)['default'];


                        /***/ }),
                    /* 8 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        // istanbul ignore next

                        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

                        var _handlebarsBase = __webpack_require__(9);

                        var base = _interopRequireWildcard(_handlebarsBase);

                        // Each of these augment the Handlebars object. No need to setup here.
                        // (This is done to easily share code between commonjs and browse envs)

                        var _handlebarsSafeString = __webpack_require__(23);

                        var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

                        var _handlebarsException = __webpack_require__(11);

                        var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

                        var _handlebarsUtils = __webpack_require__(10);

                        var Utils = _interopRequireWildcard(_handlebarsUtils);

                        var _handlebarsRuntime = __webpack_require__(24);

                        var runtime = _interopRequireWildcard(_handlebarsRuntime);

                        var _handlebarsNoConflict = __webpack_require__(25);

                        var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

                        // For compatibility and usage outside of module systems, make the Handlebars object a namespace
                        function create() {
                            var hb = new base.HandlebarsEnvironment();

                            Utils.extend(hb, base);
                            hb.SafeString = _handlebarsSafeString2['default'];
                            hb.Exception = _handlebarsException2['default'];
                            hb.Utils = Utils;
                            hb.escapeExpression = Utils.escapeExpression;

                            hb.VM = runtime;
                            hb.template = function (spec) {
                                return runtime.template(spec, hb);
                            };

                            return hb;
                        }

                        var inst = create();
                        inst.create = create;

                        _handlebarsNoConflict2['default'](inst);

                        inst['default'] = inst;

                        exports['default'] = inst;
                        module.exports = exports['default'];



                        /***/ }),
                    /* 9 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        exports.HandlebarsEnvironment = HandlebarsEnvironment;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        var _utils = __webpack_require__(10);

                        var _exception = __webpack_require__(11);

                        var _exception2 = _interopRequireDefault(_exception);

                        var _helpers = __webpack_require__(12);

                        var _decorators = __webpack_require__(20);

                        var _logger = __webpack_require__(22);

                        var _logger2 = _interopRequireDefault(_logger);

                        var VERSION = '4.0.5';
                        exports.VERSION = VERSION;
                        var COMPILER_REVISION = 7;

                        exports.COMPILER_REVISION = COMPILER_REVISION;
                        var REVISION_CHANGES = {
                            1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
                            2: '== 1.0.0-rc.3',
                            3: '== 1.0.0-rc.4',
                            4: '== 1.x.x',
                            5: '== 2.0.0-alpha.x',
                            6: '>= 2.0.0-beta.1',
                            7: '>= 4.0.0'
                        };

                        exports.REVISION_CHANGES = REVISION_CHANGES;
                        var objectType = '[object Object]';

                        function HandlebarsEnvironment(helpers, partials, decorators) {
                            this.helpers = helpers || {};
                            this.partials = partials || {};
                            this.decorators = decorators || {};

                            _helpers.registerDefaultHelpers(this);
                            _decorators.registerDefaultDecorators(this);
                        }

                        HandlebarsEnvironment.prototype = {
                            constructor: HandlebarsEnvironment,

                            logger: _logger2['default'],
                            log: _logger2['default'].log,

                            registerHelper: function registerHelper(name, fn) {
                                if (_utils.toString.call(name) === objectType) {
                                    if (fn) {
                                        throw new _exception2['default']('Arg not supported with multiple helpers');
                                    }
                                    _utils.extend(this.helpers, name);
                                } else {
                                    this.helpers[name] = fn;
                                }
                            },
                            unregisterHelper: function unregisterHelper(name) {
                                delete this.helpers[name];
                            },

                            registerPartial: function registerPartial(name, partial) {
                                if (_utils.toString.call(name) === objectType) {
                                    _utils.extend(this.partials, name);
                                } else {
                                    if (typeof partial === 'undefined') {
                                        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
                                    }
                                    this.partials[name] = partial;
                                }
                            },
                            unregisterPartial: function unregisterPartial(name) {
                                delete this.partials[name];
                            },

                            registerDecorator: function registerDecorator(name, fn) {
                                if (_utils.toString.call(name) === objectType) {
                                    if (fn) {
                                        throw new _exception2['default']('Arg not supported with multiple decorators');
                                    }
                                    _utils.extend(this.decorators, name);
                                } else {
                                    this.decorators[name] = fn;
                                }
                            },
                            unregisterDecorator: function unregisterDecorator(name) {
                                delete this.decorators[name];
                            }
                        };

                        var log = _logger2['default'].log;

                        exports.log = log;
                        exports.createFrame = _utils.createFrame;
                        exports.logger = _logger2['default'];



                        /***/ }),
                    /* 10 */
                    /***/ (function(module, exports) {

                        exports.__esModule = true;
                        exports.extend = extend;
                        exports.indexOf = indexOf;
                        exports.escapeExpression = escapeExpression;
                        exports.isEmpty = isEmpty;
                        exports.createFrame = createFrame;
                        exports.blockParams = blockParams;
                        exports.appendContextPath = appendContextPath;
                        var escape = {
                            '&': '&amp;',
                            '<': '&lt;',
                            '>': '&gt;',
                            '"': '&quot;',
                            "'": '&#x27;',
                            '`': '&#x60;',
                            '=': '&#x3D;'
                        };

                        var badChars = /[&<>"'`=]/g,
                            possible = /[&<>"'`=]/;

                        function escapeChar(chr) {
                            return escape[chr];
                        }

                        function extend(obj /* , ...source */) {
                            for (var i = 1; i < arguments.length; i++) {
                                for (var key in arguments[i]) {
                                    if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                                        obj[key] = arguments[i][key];
                                    }
                                }
                            }

                            return obj;
                        }

                        var toString = Object.prototype.toString;

                        exports.toString = toString;
                        // Sourced from lodash
                        // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
                        /* eslint-disable func-style */
                        var isFunction = function isFunction(value) {
                            return typeof value === 'function';
                        };
                        // fallback for older versions of Chrome and Safari
                        /* istanbul ignore next */
                        if (isFunction(/x/)) {
                            exports.isFunction = isFunction = function (value) {
                                return typeof value === 'function' && toString.call(value) === '[object Function]';
                            };
                        }
                        exports.isFunction = isFunction;

                        /* eslint-enable func-style */

                        /* istanbul ignore next */
                        var isArray = Array.isArray || function (value) {
                            return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
                        };

                        exports.isArray = isArray;
                        // Older IE versions do not directly support indexOf so we must implement our own, sadly.

                        function indexOf(array, value) {
                            for (var i = 0, len = array.length; i < len; i++) {
                                if (array[i] === value) {
                                    return i;
                                }
                            }
                            return -1;
                        }

                        function escapeExpression(string) {
                            if (typeof string !== 'string') {
                                // don't escape SafeStrings, since they're already safe
                                if (string && string.toHTML) {
                                    return string.toHTML();
                                } else if (string == null) {
                                    return '';
                                } else if (!string) {
                                    return string + '';
                                }

                                // Force a string conversion as this will be done by the append regardless and
                                // the regex test will do this transparently behind the scenes, causing issues if
                                // an object's to string has escaped characters in it.
                                string = '' + string;
                            }

                            if (!possible.test(string)) {
                                return string;
                            }
                            return string.replace(badChars, escapeChar);
                        }

                        function isEmpty(value) {
                            if (!value && value !== 0) {
                                return true;
                            } else if (isArray(value) && value.length === 0) {
                                return true;
                            } else {
                                return false;
                            }
                        }

                        function createFrame(object) {
                            var frame = extend({}, object);
                            frame._parent = object;
                            return frame;
                        }

                        function blockParams(params, ids) {
                            params.path = ids;
                            return params;
                        }

                        function appendContextPath(contextPath, id) {
                            return (contextPath ? contextPath + '.' : '') + id;
                        }



                        /***/ }),
                    /* 11 */
                    /***/ (function(module, exports) {

                        exports.__esModule = true;

                        var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

                        function Exception(message, node) {
                            var loc = node && node.loc,
                                line = undefined,
                                column = undefined;
                            if (loc) {
                                line = loc.start.line;
                                column = loc.start.column;

                                message += ' - ' + line + ':' + column;
                            }

                            var tmp = Error.prototype.constructor.call(this, message);

                            // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
                            for (var idx = 0; idx < errorProps.length; idx++) {
                                this[errorProps[idx]] = tmp[errorProps[idx]];
                            }

                            /* istanbul ignore else */
                            if (Error.captureStackTrace) {
                                Error.captureStackTrace(this, Exception);
                            }

                            try {
                                if (loc) {
                                    this.lineNumber = line;

                                    // Work around issue under safari where we can't directly set the column value
                                    /* istanbul ignore next */
                                    if (Object.defineProperty) {
                                        Object.defineProperty(this, 'column', { value: column });
                                    } else {
                                        this.column = column;
                                    }
                                }
                            } catch (nop) {
                                /* Ignore if the browser is very particular */
                            }
                        }

                        Exception.prototype = new Error();

                        exports['default'] = Exception;
                        module.exports = exports['default'];



                        /***/ }),
                    /* 12 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        exports.registerDefaultHelpers = registerDefaultHelpers;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        var _helpersBlockHelperMissing = __webpack_require__(13);

                        var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

                        var _helpersEach = __webpack_require__(14);

                        var _helpersEach2 = _interopRequireDefault(_helpersEach);

                        var _helpersHelperMissing = __webpack_require__(15);

                        var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

                        var _helpersIf = __webpack_require__(16);

                        var _helpersIf2 = _interopRequireDefault(_helpersIf);

                        var _helpersLog = __webpack_require__(17);

                        var _helpersLog2 = _interopRequireDefault(_helpersLog);

                        var _helpersLookup = __webpack_require__(18);

                        var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

                        var _helpersWith = __webpack_require__(19);

                        var _helpersWith2 = _interopRequireDefault(_helpersWith);

                        function registerDefaultHelpers(instance) {
                            _helpersBlockHelperMissing2['default'](instance);
                            _helpersEach2['default'](instance);
                            _helpersHelperMissing2['default'](instance);
                            _helpersIf2['default'](instance);
                            _helpersLog2['default'](instance);
                            _helpersLookup2['default'](instance);
                            _helpersWith2['default'](instance);
                        }



                        /***/ }),
                    /* 13 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;

                        var _utils = __webpack_require__(10);

                        exports['default'] = function (instance) {
                            instance.registerHelper('blockHelperMissing', function (context, options) {
                                var inverse = options.inverse,
                                    fn = options.fn;

                                if (context === true) {
                                    return fn(this);
                                } else if (context === false || context == null) {
                                    return inverse(this);
                                } else if (_utils.isArray(context)) {
                                    if (context.length > 0) {
                                        if (options.ids) {
                                            options.ids = [options.name];
                                        }

                                        return instance.helpers.each(context, options);
                                    } else {
                                        return inverse(this);
                                    }
                                } else {
                                    if (options.data && options.ids) {
                                        var data = _utils.createFrame(options.data);
                                        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
                                        options = { data: data };
                                    }

                                    return fn(context, options);
                                }
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 14 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        var _utils = __webpack_require__(10);

                        var _exception = __webpack_require__(11);

                        var _exception2 = _interopRequireDefault(_exception);

                        exports['default'] = function (instance) {
                            instance.registerHelper('each', function (context, options) {
                                if (!options) {
                                    throw new _exception2['default']('Must pass iterator to #each');
                                }

                                var fn = options.fn,
                                    inverse = options.inverse,
                                    i = 0,
                                    ret = '',
                                    data = undefined,
                                    contextPath = undefined;

                                if (options.data && options.ids) {
                                    contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
                                }

                                if (_utils.isFunction(context)) {
                                    context = context.call(this);
                                }

                                if (options.data) {
                                    data = _utils.createFrame(options.data);
                                }

                                function execIteration(field, index, last) {
                                    if (data) {
                                        data.key = field;
                                        data.index = index;
                                        data.first = index === 0;
                                        data.last = !!last;

                                        if (contextPath) {
                                            data.contextPath = contextPath + field;
                                        }
                                    }

                                    ret = ret + fn(context[field], {
                                        data: data,
                                        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
                                    });
                                }

                                if (context && typeof context === 'object') {
                                    if (_utils.isArray(context)) {
                                        for (var j = context.length; i < j; i++) {
                                            if (i in context) {
                                                execIteration(i, i, i === context.length - 1);
                                            }
                                        }
                                    } else {
                                        var priorKey = undefined;

                                        for (var key in context) {
                                            if (context.hasOwnProperty(key)) {
                                                // We're running the iterations one step out of sync so we can detect
                                                // the last iteration without have to scan the object twice and create
                                                // an itermediate keys array.
                                                if (priorKey !== undefined) {
                                                    execIteration(priorKey, i - 1);
                                                }
                                                priorKey = key;
                                                i++;
                                            }
                                        }
                                        if (priorKey !== undefined) {
                                            execIteration(priorKey, i - 1, true);
                                        }
                                    }
                                }

                                if (i === 0) {
                                    ret = inverse(this);
                                }

                                return ret;
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 15 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        var _exception = __webpack_require__(11);

                        var _exception2 = _interopRequireDefault(_exception);

                        exports['default'] = function (instance) {
                            instance.registerHelper('helperMissing', function () /* [args, ]options */{
                                if (arguments.length === 1) {
                                    // A missing field in a {{foo}} construct.
                                    return undefined;
                                } else {
                                    // Someone is actually trying to call something, blow up.
                                    throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
                                }
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 16 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;

                        var _utils = __webpack_require__(10);

                        exports['default'] = function (instance) {
                            instance.registerHelper('if', function (conditional, options) {
                                if (_utils.isFunction(conditional)) {
                                    conditional = conditional.call(this);
                                }

                                // Default behavior is to render the positive path if the value is truthy and not empty.
                                // The `includeZero` option may be set to treat the condtional as purely not empty based on the
                                // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
                                if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
                                    return options.inverse(this);
                                } else {
                                    return options.fn(this);
                                }
                            });

                            instance.registerHelper('unless', function (conditional, options) {
                                return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 17 */
                    /***/ (function(module, exports) {

                        exports.__esModule = true;

                        exports['default'] = function (instance) {
                            instance.registerHelper('log', function () /* message, options */{
                                var args = [undefined],
                                    options = arguments[arguments.length - 1];
                                for (var i = 0; i < arguments.length - 1; i++) {
                                    args.push(arguments[i]);
                                }

                                var level = 1;
                                if (options.hash.level != null) {
                                    level = options.hash.level;
                                } else if (options.data && options.data.level != null) {
                                    level = options.data.level;
                                }
                                args[0] = level;

                                instance.log.apply(instance, args);
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 18 */
                    /***/ (function(module, exports) {

                        exports.__esModule = true;

                        exports['default'] = function (instance) {
                            instance.registerHelper('lookup', function (obj, field) {
                                return obj && obj[field];
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 19 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;

                        var _utils = __webpack_require__(10);

                        exports['default'] = function (instance) {
                            instance.registerHelper('with', function (context, options) {
                                if (_utils.isFunction(context)) {
                                    context = context.call(this);
                                }

                                var fn = options.fn;

                                if (!_utils.isEmpty(context)) {
                                    var data = options.data;
                                    if (options.data && options.ids) {
                                        data = _utils.createFrame(options.data);
                                        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
                                    }

                                    return fn(context, {
                                        data: data,
                                        blockParams: _utils.blockParams([context], [data && data.contextPath])
                                    });
                                } else {
                                    return options.inverse(this);
                                }
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 20 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        exports.registerDefaultDecorators = registerDefaultDecorators;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        var _decoratorsInline = __webpack_require__(21);

                        var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

                        function registerDefaultDecorators(instance) {
                            _decoratorsInline2['default'](instance);
                        }



                        /***/ }),
                    /* 21 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;

                        var _utils = __webpack_require__(10);

                        exports['default'] = function (instance) {
                            instance.registerDecorator('inline', function (fn, props, container, options) {
                                var ret = fn;
                                if (!props.partials) {
                                    props.partials = {};
                                    ret = function (context, options) {
                                        // Create a new partials stack frame prior to exec.
                                        var original = container.partials;
                                        container.partials = _utils.extend({}, original, props.partials);
                                        var ret = fn(context, options);
                                        container.partials = original;
                                        return ret;
                                    };
                                }

                                props.partials[options.args[0]] = options.fn;

                                return ret;
                            });
                        };

                        module.exports = exports['default'];



                        /***/ }),
                    /* 22 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;

                        var _utils = __webpack_require__(10);

                        var logger = {
                            methodMap: ['debug', 'info', 'warn', 'error'],
                            level: 'info',

                            // Maps a given level value to the `methodMap` indexes above.
                            lookupLevel: function lookupLevel(level) {
                                if (typeof level === 'string') {
                                    var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
                                    if (levelMap >= 0) {
                                        level = levelMap;
                                    } else {
                                        level = parseInt(level, 10);
                                    }
                                }

                                return level;
                            },

                            // Can be overridden in the host environment
                            log: function log(level) {
                                level = logger.lookupLevel(level);

                                if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
                                    var method = logger.methodMap[level];
                                    if (!console[method]) {
                                        // eslint-disable-line no-console
                                        method = 'log';
                                    }

                                    for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                        message[_key - 1] = arguments[_key];
                                    }

                                    console[method].apply(console, message); // eslint-disable-line no-console
                                }
                            }
                        };

                        exports['default'] = logger;
                        module.exports = exports['default'];



                        /***/ }),
                    /* 23 */
                    /***/ (function(module, exports) {

                        exports.__esModule = true;
                        function SafeString(string) {
                            this.string = string;
                        }

                        SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
                            return '' + this.string;
                        };

                        exports['default'] = SafeString;
                        module.exports = exports['default'];



                        /***/ }),
                    /* 24 */
                    /***/ (function(module, exports, __webpack_require__) {

                        exports.__esModule = true;
                        exports.checkRevision = checkRevision;
                        exports.template = template;
                        exports.wrapProgram = wrapProgram;
                        exports.resolvePartial = resolvePartial;
                        exports.invokePartial = invokePartial;
                        exports.noop = noop;
                        // istanbul ignore next

                        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

                        // istanbul ignore next

                        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

                        var _utils = __webpack_require__(10);

                        var Utils = _interopRequireWildcard(_utils);

                        var _exception = __webpack_require__(11);

                        var _exception2 = _interopRequireDefault(_exception);

                        var _base = __webpack_require__(9);

                        function checkRevision(compilerInfo) {
                            var compilerRevision = compilerInfo && compilerInfo[0] || 1,
                                currentRevision = _base.COMPILER_REVISION;

                            if (compilerRevision !== currentRevision) {
                                if (compilerRevision < currentRevision) {
                                    var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
                                        compilerVersions = _base.REVISION_CHANGES[compilerRevision];
                                    throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
                                } else {
                                    // Use the embedded version info since the runtime doesn't know about this revision yet
                                    throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
                                }
                            }
                        }

                        function template(templateSpec, env) {
                            /* istanbul ignore next */
                            if (!env) {
                                throw new _exception2['default']('No environment passed to template');
                            }
                            if (!templateSpec || !templateSpec.main) {
                                throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
                            }

                            templateSpec.main.decorator = templateSpec.main_d;

                            // Note: Using env.VM references rather than local var references throughout this section to allow
                            // for external users to override these as psuedo-supported APIs.
                            env.VM.checkRevision(templateSpec.compiler);

                            function invokePartialWrapper(partial, context, options) {
                                if (options.hash) {
                                    context = Utils.extend({}, context, options.hash);
                                    if (options.ids) {
                                        options.ids[0] = true;
                                    }
                                }

                                partial = env.VM.resolvePartial.call(this, partial, context, options);
                                var result = env.VM.invokePartial.call(this, partial, context, options);

                                if (result == null && env.compile) {
                                    options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
                                    result = options.partials[options.name](context, options);
                                }
                                if (result != null) {
                                    if (options.indent) {
                                        var lines = result.split('\n');
                                        for (var i = 0, l = lines.length; i < l; i++) {
                                            if (!lines[i] && i + 1 === l) {
                                                break;
                                            }

                                            lines[i] = options.indent + lines[i];
                                        }
                                        result = lines.join('\n');
                                    }
                                    return result;
                                } else {
                                    throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
                                }
                            }

                            // Just add water
                            var container = {
                                strict: function strict(obj, name) {
                                    if (!(name in obj)) {
                                        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
                                    }
                                    return obj[name];
                                },
                                lookup: function lookup(depths, name) {
                                    var len = depths.length;
                                    for (var i = 0; i < len; i++) {
                                        if (depths[i] && depths[i][name] != null) {
                                            return depths[i][name];
                                        }
                                    }
                                },
                                lambda: function lambda(current, context) {
                                    return typeof current === 'function' ? current.call(context) : current;
                                },

                                escapeExpression: Utils.escapeExpression,
                                invokePartial: invokePartialWrapper,

                                fn: function fn(i) {
                                    var ret = templateSpec[i];
                                    ret.decorator = templateSpec[i + '_d'];
                                    return ret;
                                },

                                programs: [],
                                program: function program(i, data, declaredBlockParams, blockParams, depths) {
                                    var programWrapper = this.programs[i],
                                        fn = this.fn(i);
                                    if (data || depths || blockParams || declaredBlockParams) {
                                        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
                                    } else if (!programWrapper) {
                                        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
                                    }
                                    return programWrapper;
                                },

                                data: function data(value, depth) {
                                    while (value && depth--) {
                                        value = value._parent;
                                    }
                                    return value;
                                },
                                merge: function merge(param, common) {
                                    var obj = param || common;

                                    if (param && common && param !== common) {
                                        obj = Utils.extend({}, common, param);
                                    }

                                    return obj;
                                },

                                noop: env.VM.noop,
                                compilerInfo: templateSpec.compiler
                            };

                            function ret(context) {
                                var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                                var data = options.data;

                                ret._setup(options);
                                if (!options.partial && templateSpec.useData) {
                                    data = initData(context, data);
                                }
                                var depths = undefined,
                                    blockParams = templateSpec.useBlockParams ? [] : undefined;
                                if (templateSpec.useDepths) {
                                    if (options.depths) {
                                        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
                                    } else {
                                        depths = [context];
                                    }
                                }

                                function main(context /*, options*/) {
                                    return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
                                }
                                main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
                                return main(context, options);
                            }
                            ret.isTop = true;

                            ret._setup = function (options) {
                                if (!options.partial) {
                                    container.helpers = container.merge(options.helpers, env.helpers);

                                    if (templateSpec.usePartial) {
                                        container.partials = container.merge(options.partials, env.partials);
                                    }
                                    if (templateSpec.usePartial || templateSpec.useDecorators) {
                                        container.decorators = container.merge(options.decorators, env.decorators);
                                    }
                                } else {
                                    container.helpers = options.helpers;
                                    container.partials = options.partials;
                                    container.decorators = options.decorators;
                                }
                            };

                            ret._child = function (i, data, blockParams, depths) {
                                if (templateSpec.useBlockParams && !blockParams) {
                                    throw new _exception2['default']('must pass block params');
                                }
                                if (templateSpec.useDepths && !depths) {
                                    throw new _exception2['default']('must pass parent depths');
                                }

                                return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
                            };
                            return ret;
                        }

                        function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
                            function prog(context) {
                                var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                                var currentDepths = depths;
                                if (depths && context != depths[0]) {
                                    currentDepths = [context].concat(depths);
                                }

                                return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
                            }

                            prog = executeDecorators(fn, prog, container, depths, data, blockParams);

                            prog.program = i;
                            prog.depth = depths ? depths.length : 0;
                            prog.blockParams = declaredBlockParams || 0;
                            return prog;
                        }

                        function resolvePartial(partial, context, options) {
                            if (!partial) {
                                if (options.name === '@partial-block') {
                                    var data = options.data;
                                    while (data['partial-block'] === noop) {
                                        data = data._parent;
                                    }
                                    partial = data['partial-block'];
                                    data['partial-block'] = noop;
                                } else {
                                    partial = options.partials[options.name];
                                }
                            } else if (!partial.call && !options.name) {
                                // This is a dynamic partial that returned a string
                                options.name = partial;
                                partial = options.partials[partial];
                            }
                            return partial;
                        }

                        function invokePartial(partial, context, options) {
                            options.partial = true;
                            if (options.ids) {
                                options.data.contextPath = options.ids[0] || options.data.contextPath;
                            }

                            var partialBlock = undefined;
                            if (options.fn && options.fn !== noop) {
                                options.data = _base.createFrame(options.data);
                                partialBlock = options.data['partial-block'] = options.fn;

                                if (partialBlock.partials) {
                                    options.partials = Utils.extend({}, options.partials, partialBlock.partials);
                                }
                            }

                            if (partial === undefined && partialBlock) {
                                partial = partialBlock;
                            }

                            if (partial === undefined) {
                                throw new _exception2['default']('The partial ' + options.name + ' could not be found');
                            } else if (partial instanceof Function) {
                                return partial(context, options);
                            }
                        }

                        function noop() {
                            return '';
                        }

                        function initData(context, data) {
                            if (!data || !('root' in data)) {
                                data = data ? _base.createFrame(data) : {};
                                data.root = context;
                            }
                            return data;
                        }

                        function executeDecorators(fn, prog, container, depths, data, blockParams) {
                            if (fn.decorator) {
                                var props = {};
                                prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
                                Utils.extend(prog, props);
                            }
                            return prog;
                        }



                        /***/ }),
                    /* 25 */
                    /***/ (function(module, exports) {

                        /* WEBPACK VAR INJECTION */(function(global) {/* global window */

                            exports.__esModule = true;

                            exports['default'] = function (Handlebars) {
                                /* istanbul ignore next */
                                var root = typeof global !== 'undefined' ? global : window,
                                    $Handlebars = root.Handlebars;
                                /* istanbul ignore next */
                                Handlebars.noConflict = function () {
                                    if (root.Handlebars === Handlebars) {
                                        root.Handlebars = $Handlebars;
                                    }
                                    return Handlebars;
                                };
                            };

                            module.exports = exports['default'];


                            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())));

                        /***/ }),
                    /* 26 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(2);
                        var snippet = __webpack_require__(3);

                        var localeTexts = __webpack_require__(27);
                        var headerTmpl = __webpack_require__(28);
                        var DateTimeFormatter = __webpack_require__(29);
                        var constants = __webpack_require__(31);

                        var TYPE_DATE = constants.TYPE_DATE;
                        var TYPE_MONTH = constants.TYPE_MONTH;
                        var TYPE_YEAR = constants.TYPE_YEAR;

                        var CLASS_NAME_PREV_MONTH_BTN = constants.CLASS_NAME_PREV_MONTH_BTN;
                        var CLASS_NAME_PREV_YEAR_BTN = constants.CLASS_NAME_PREV_YEAR_BTN;
                        var CLASS_NAME_NEXT_YEAR_BTN = constants.CLASS_NAME_NEXT_YEAR_BTN;
                        var CLASS_NAME_NEXT_MONTH_BTN = constants.CLASS_NAME_NEXT_MONTH_BTN;

                        var CLASS_NAME_TITLE_MONTH = 'tui-calendar-title-month';
                        var CLASS_NAME_TITLE_YEAR = 'tui-calendar-title-year';
                        var CLASS_NAME_TITLE_YEAR_TO_YEAR = 'tui-calendar-title-year-to-year';

                        var YEAR_TITLE_FORMAT = 'yyyy';

                        /**
                         * @ignore
                         * @class
                         * @param {string|Element|jQuery} container - Header container
                         * @param {object} option - Header option
                         * @param {string} option.language - Header language
                         * @param {boolean} option.showToday - Has today box or not.
                         * @param {boolean} option.showJumpButtons - Has jump buttons or not.
                         */
                        var Header = snippet.defineClass(/** @lends Header.prototype */{
                            init: function(container, option) {
                                /**
                                 * Container element
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$container = $(container);

                                /**
                                 * headerElement
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$element = $();

                                /**
                                 * Render today box or not
                                 * @type {boolean}
                                 * @private
                                 */
                                this._showToday = option.showToday;

                                /**
                                 * Render jump buttons or not (next,prev year on date calendar)
                                 * @type {boolean}
                                 * @private
                                 */
                                this._showJumpButtons = option.showJumpButtons;

                                /**
                                 * Year_Month title formatter
                                 * @type {DateTimeFormatter}
                                 * @private
                                 */
                                this._yearMonthTitleFormatter = null;

                                /**
                                 * Year title formatter
                                 * @type {DateTimeFormatter}
                                 * @private
                                 */
                                this._yearTitleFormatter = null;

                                /**
                                 * Today formatter
                                 * @type {DateTimeFormatter}
                                 * @private
                                 */
                                this._todayFormatter = null;

                                this._setFormatters(localeTexts[option.language]);
                                this._setEvents(option);
                            },

                            /**
                             * Set formatters
                             * @param {object} localeText - Locale text
                             * @private
                             */
                            _setFormatters: function(localeText) {
                                this._yearMonthTitleFormatter = new DateTimeFormatter(localeText.titleFormat, localeText.titles);
                                this._yearTitleFormatter = new DateTimeFormatter(YEAR_TITLE_FORMAT, localeText.titles);
                                this._todayFormatter = new DateTimeFormatter(localeText.todayFormat, localeText.titles);
                            },

                            /**
                             * Set events for firing customEvents
                             * @param {object} option - Constructor option
                             * @private
                             */
                            _setEvents: function() {
                                var self = this;
                                var classNames = [
                                    CLASS_NAME_PREV_MONTH_BTN,
                                    CLASS_NAME_PREV_YEAR_BTN,
                                    CLASS_NAME_NEXT_MONTH_BTN,
                                    CLASS_NAME_NEXT_YEAR_BTN
                                ];

                                snippet.forEach(classNames, function(className) {
                                    self._$container.on('touchend.calendar click.calendar', '.' + className, function(ev) {
                                        self.fire('click', ev);
                                        ev.preventDefault(); // To prevent click after touchend
                                    });
                                });
                            },

                            /**
                             * Returns title class
                             * @param {string} type - Calendar type
                             * @returns {string}
                             * @private
                             */
                            _getTitleClass: function(type) {
                                switch (type) {
                                    case TYPE_DATE:
                                        return CLASS_NAME_TITLE_MONTH;
                                    case TYPE_MONTH:
                                        return CLASS_NAME_TITLE_YEAR;
                                    case TYPE_YEAR:
                                        return CLASS_NAME_TITLE_YEAR_TO_YEAR;
                                    default:
                                        return '';
                                }
                            },

                            /**
                             * Returns title text
                             * @param {Date} date - date
                             * @param {string} type - Calendar type
                             * @returns {string}
                             * @private
                             */
                            _getTitleText: function(date, type) {
                                var currentYear, start, end;

                                switch (type) {
                                    case TYPE_DATE:
                                        return this._yearMonthTitleFormatter.format(date);
                                    case TYPE_MONTH:
                                        return this._yearTitleFormatter.format(date);
                                    case TYPE_YEAR:
                                        currentYear = date.getFullYear();
                                        start = new Date(currentYear - 4, 0, 1);
                                        end = new Date(currentYear + 4, 0, 1);

                                        return this._yearTitleFormatter.format(start) + ' - ' + this._yearTitleFormatter.format(end);
                                    default:
                                        return '';
                                }
                            },

                            /**
                             * Change langauge
                             * @param {string} language - Language
                             */
                            changeLanguage: function(language) {
                                this._setFormatters(localeTexts[language]);
                            },

                            /**
                             * Render header
                             * @param {Date} date - date
                             * @param {string} type - Calendar type
                             */
                            render: function(date, type) {
                                var context = {
                                    showToday: this._showToday,
                                    showJumpButtons: this._showJumpButtons,
                                    todayText: this._todayFormatter.format(new Date()),
                                    isDateCalendar: type === TYPE_DATE,
                                    titleClass: this._getTitleClass(type),
                                    title: this._getTitleText(date, type)
                                };

                                this._$element.remove();
                                this._$element = $(headerTmpl(context));
                                this._$element.appendTo(this._$container);
                            },

                            /**
                             * Destroy header
                             */
                            destroy: function() {
                                this.off();
                                this._$container.off('.calendar');
                                this._$element.remove();
                                this._$container
                                    = this._showToday
                                    = this._showJumpButtons
                                    = this._yearMonthTitleFormatter
                                    = this._yearTitleFormatter
                                    = this._todayFormatter
                                    = this._$element
                                    = null;
                            }
                        });

                        snippet.CustomEvents.mixin(Header);
                        module.exports = Header;


                        /***/ }),
                    /* 27 */
                    /***/ (function(module, exports) {

                        module.exports = {
                            en: {
                                titles: {
                                    DD: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                                    D: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                                    MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                                    MMMM: ['January', 'February', 'March', 'April', 'May', 'June',
                                        'July', 'August', 'September', 'October', 'November', 'December']
                                },
                                titleFormat: 'MMMM yyyy',
                                todayFormat: 'To\\d\\ay: DD, MMMM d, yyyy',
                                time: 'Time',
                                date: 'Date'
                            },
                            ko: {
                                titles: {
                                    DD: ['', '', '', '', '', '', ''],
                                    D: ['', '', '', '', '', '', ''],
                                    MMM: ['1', '2', '3', '4', '5', '6',
                                        '7', '8', '9', '10', '11', '12'],
                                    MMMM: ['1', '2', '3', '4', '5', '6',
                                        '7', '8', '9', '10', '11', '12']
                                },
                                titleFormat: 'yyyy.MM',
                                todayFormat: ': yyyy.MM.dd (D)',
                                date: '',
                                time: ''
                            }
                        };


                        /***/ }),
                    /* 28 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var Handlebars = __webpack_require__(7);
                        module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data) {
                                var stack1;

                                return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.showJumpButtons : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
                            },"2":function(container,depth0,helpers,partials,data) {
                                var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

                                return "        <div class=\"tui-calendar-header-inner tui-calendar-has-btns\">\n            <a href=\"#\" class=\"tui-calendar-btn-prev-year\">Prev year</a>\n            <a href=\"#\" class=\"tui-calendar-btn-prev-month\">Prev month</a>\n            <em class=\"tui-calendar-title "
                                    + alias4(((helper = (helper = helpers.titleClass || (depth0 != null ? depth0.titleClass : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"titleClass","hash":{},"data":data}) : helper)))
                                    + "\">"
                                    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
                                    + "</em>\n            <a href=\"#\" class=\"tui-calendar-btn-next-month\">Next month</a>\n            <a href=\"#\" class=\"tui-calendar-btn-next-year\">Next year</a>\n        </div>\n";
                            },"4":function(container,depth0,helpers,partials,data) {
                                var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

                                return "        <div class=\"tui-calendar-header-inner\">\n            <a href=\"#\" class=\"tui-calendar-btn-prev-month\">Prev month</a>\n            <em class=\"tui-calendar-title "
                                    + alias4(((helper = (helper = helpers.titleClass || (depth0 != null ? depth0.titleClass : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"titleClass","hash":{},"data":data}) : helper)))
                                    + "\">"
                                    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
                                    + "</em>\n            <a href=\"#\" class=\"tui-calendar-btn-next-month\">Next month</a>\n        </div>\n";
                            },"6":function(container,depth0,helpers,partials,data) {
                                var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

                                return "    <div class=\"tui-calendar-header-inner\">\n        <a href=\"#\" class=\"tui-calendar-btn-prev-year\">Prev year</a>\n        <em class=\"tui-calendar-title "
                                    + alias4(((helper = (helper = helpers.titleClass || (depth0 != null ? depth0.titleClass : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"titleClass","hash":{},"data":data}) : helper)))
                                    + "\">"
                                    + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
                                    + "</em>\n        <a href=\"#\" class=\"tui-calendar-btn-next-year\">Next year</a>\n    </div>\n";
                            },"8":function(container,depth0,helpers,partials,data) {
                                var helper;

                                return "    <div class=\"tui-calendar-header-info\">\n        <p class=\"tui-calendar-title-today\">"
                                    + container.escapeExpression(((helper = (helper = helpers.todayText || (depth0 != null ? depth0.todayText : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {},{"name":"todayText","hash":{},"data":data}) : helper)))
                                    + "</p>\n    </div>\n";
                            },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
                                var stack1, alias1=depth0 != null ? depth0 : {};

                                return ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isDateCalendar : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(6, data, 0),"data":data})) != null ? stack1 : "")
                                    + "\n"
                                    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.showToday : depth0),{"name":"if","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
                            },"useData":true});

                        /***/ }),
                    /* 29 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var snippet = __webpack_require__(3);

                        var dateUtil = __webpack_require__(30);
                        var constants = __webpack_require__(31);
                        var localeTexts = __webpack_require__(27);

                        var rFormableKeys = /\\?(yyyy|yy|mmmm|mmm|mm|m|dd|d|hh|h|a)/gi;
                        var mapForConverting = {
                            yyyy: {
                                expression: '(\\d{4}|\\d{2})',
                                type: constants.TYPE_YEAR
                            },
                            yy: {
                                expression: '(\\d{4}|\\d{2})',
                                type: constants.TYPE_YEAR
                            },
                            y: {
                                expression: '(\\d{4}|\\d{2})',
                                type: constants.TYPE_YEAR
                            },
                            M: {
                                expression: '(1[012]|0[1-9]|[1-9])',
                                type: constants.TYPE_MONTH
                            },
                            MM: {
                                expression: '(1[012]|0[1-9]|[1-9])',
                                type: constants.TYPE_MONTH
                            },
                            MMM: {
                                expression: '(1[012]|0[1-9]|[1-9])',
                                type: constants.TYPE_MONTH
                            },
                            MMMM: {
                                expression: '(1[012]|0[1-9]|[1-9])',
                                type: constants.TYPE_MONTH
                            },
                            mmm: {
                                expression: '(1[012]|0[1-9]|[1-9])',
                                type: constants.TYPE_MONTH
                            },
                            mmmm: {
                                expression: '(1[012]|0[1-9]|[1-9])',
                                type: constants.TYPE_MONTH
                            },
                            dd: {
                                expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
                                type: constants.TYPE_DATE
                            },
                            d: {
                                expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
                                type: constants.TYPE_DATE
                            },
                            D: {
                                expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
                                type: constants.TYPE_DATE
                            },
                            DD: {
                                expression: '([12]\\d{1}|3[01]|0[1-9]|[1-9])',
                                type: constants.TYPE_DATE
                            },
                            h: {
                                expression: '(d{1}|0\\d{1}|1\\d{1}|2[0123])',
                                type: constants.TYPE_HOUR
                            },
                            hh: {
                                expression: '(d{1}|[01]\\d{1}|2[0123])',
                                type: constants.TYPE_HOUR
                            },
                            H: {
                                expression: '(d{1}|0\\d{1}|1\\d{1}|2[0123])',
                                type: constants.TYPE_HOUR
                            },
                            HH: {
                                expression: '(d{1}|[01]\\d{1}|2[0123])',
                                type: constants.TYPE_HOUR
                            },
                            m: {
                                expression: '(d{1}|[012345]\\d{1})',
                                type: constants.TYPE_MINUTE
                            },
                            mm: {
                                expression: '(d{1}|[012345]\\d{1})',
                                type: constants.TYPE_MINUTE
                            },
                            a: {
                                expression: '([ap]m)',
                                type: constants.TYPE_MERIDIEM
                            },
                            A: {
                                expression: '([ap]m)',
                                type: constants.TYPE_MERIDIEM
                            }
                        };

                        /**
                         * @class
                         * @ignore
                         */
                        var DateTimeFormatter = snippet.defineClass(/** @lends DateTimeFormatter.prototype */{
                            init: function(rawStr, titles) {
                                /**
                                 * @type {string}
                                 * @private
                                 */
                                this._rawStr = rawStr;

                                /**
                                 * @type {Array}
                                 * @private
                                 * @example
                                 *  rawStr = "yyyy-MM-dd" --> keyOrder = ['year', 'month', 'date']
                                 *  rawStr = "MM/dd, yyyy" --> keyOrder = ['month', 'date', 'year']
                                 */
                                this._keyOrder = null;

                                /**
                                 * @type {RegExp}
                                 * @private
                                 */
                                this._regExp = null;

                                /**
                                 * Titles
                                 * @type {object}
                                 * @private
                                 */
                                this._titles = titles || localeTexts.en.titles;

                                this._parseFormat();
                            },

                            /**
                             * Parse initial format and make the keyOrder, regExp
                             * @private
                             */
                            _parseFormat: function() {
                                var regExpStr = '^';
                                var matchedKeys = this._rawStr.match(rFormableKeys);
                                var keyOrder = [];

                                matchedKeys = snippet.filter(matchedKeys, function(key) {
                                    return key[0] !== '\\'; // escape character
                                });

                                snippet.forEach(matchedKeys, function(key, index) {
                                    if (!/m/i.test(key)) {
                                        key = key.toLowerCase();
                                    }

                                    regExpStr += (mapForConverting[key].expression + '[\\D\\s]*');
                                    keyOrder[index] = mapForConverting[key].type;
                                });

                                // This formatter does not allow additional numbers at the end of string.
                                regExpStr += '$';

                                this._keyOrder = keyOrder;

                                this._regExp = new RegExp(regExpStr, 'gi');
                            },

                            /**
                             * Parse string to dateHash
                             * @param {string} str - Date string
                             * @returns {Date}
                             */
                            parse: function(str) {
                                var dateHash = {
                                    year: 0,
                                    month: 1,
                                    date: 1,
                                    hour: 0,
                                    minute: 0
                                };
                                var hasMeridiem = false;
                                var isPM = false;
                                var matched;

                                this._regExp.lastIndex = 0;
                                matched = this._regExp.exec(str);

                                if (!matched) {
                                    throw Error('DateTimeFormatter: Not matched - "' + str + '"');
                                }

                                snippet.forEach(this._keyOrder, function(name, index) { // eslint-disable-line complexity
                                    var value = matched[index + 1];

                                    if (name === constants.TYPE_MERIDIEM && /[ap]m/i.test(value)) {
                                        hasMeridiem = true;
                                        isPM = /pm/i.test(value);
                                    } else {
                                        value = Number(value);

                                        if (value !== 0 && !value) {
                                            throw Error('DateTimeFormatter: Unknown value - ' + matched[index + 1]);
                                        }

                                        if (name === constants.TYPE_YEAR && value < 100) {
                                            value += 2000;
                                        }

                                        dateHash[name] = value;
                                    }
                                });

                                if (hasMeridiem) {
                                    isPM = isPM || dateHash.hour > 12;
                                    dateHash.hour %= 12;
                                    if (isPM) {
                                        dateHash.hour += 12;
                                    }
                                }

                                return new Date(dateHash.year, dateHash.month - 1, dateHash.date, dateHash.hour, dateHash.minute);
                            },

                            /**
                             * Returns raw string of format
                             * @returns {string}
                             */
                            getRawString: function() {
                                return this._rawStr;
                            },

                            /**
                             * Format date to string
                             * @param {Date} dateObj - Date object
                             * @returns {string}
                             */
                            format: function(dateObj) {
                                var year = dateObj.getFullYear();
                                var month = dateObj.getMonth() + 1;
                                var dayInMonth = dateObj.getDate();
                                var day = dateObj.getDay();
                                var hour = dateObj.getHours();
                                var minute = dateObj.getMinutes();
                                var meridiem = 'a'; // Default value for unusing meridiem format
                                var replaceMap;

                                if (snippet.inArray(constants.TYPE_MERIDIEM, this._keyOrder) > -1) {
                                    meridiem = hour >= 12 ? 'pm' : 'am';
                                    hour = dateUtil.getMeridiemHour(hour);
                                }

                                replaceMap = {
                                    yyyy: year,
                                    yy: String(year).substr(2, 2),
                                    M: month,
                                    MM: dateUtil.prependLeadingZero(month),
                                    MMM: this._titles.MMM[month - 1],
                                    MMMM: this._titles.MMMM[month - 1],
                                    d: dayInMonth,
                                    dd: dateUtil.prependLeadingZero(dayInMonth),
                                    D: this._titles.D[day],
                                    DD: this._titles.DD[day],
                                    hh: dateUtil.prependLeadingZero(hour),
                                    h: hour,
                                    mm: dateUtil.prependLeadingZero(minute),
                                    m: minute,
                                    A: meridiem.toUpperCase(),
                                    a: meridiem
                                };

                                return this._rawStr.replace(rFormableKeys, function(key) {
                                    if (key[0] === '\\') {
                                        return key.substr(1);
                                    }

                                    return replaceMap[key] || replaceMap[key.toLowerCase()] || '';
                                });
                            }
                        });

                        module.exports = DateTimeFormatter;


                        /***/ }),
                    /* 30 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var snippet = __webpack_require__(3);

                        var constants = __webpack_require__(31);

                        var TYPE_DATE = constants.TYPE_DATE;
                        var TYPE_MONTH = constants.TYPE_MONTH;
                        var TYPE_YEAR = constants.TYPE_YEAR;

                        /**
                         * Utils of calendar
                         * @namespace dateUtil
                         * @ignore
                         */
                        var utils = {
                            /**
                             * Get weeks count by paramenter
                             * @param {number} year A year
                             * @param {number} month A month
                             * @returns {number} Weeks count (4~6)
                             **/
                            getWeeksCount: function(year, month) {
                                var firstDay = utils.getFirstDay(year, month),
                                    lastDate = utils.getLastDayInMonth(year, month);

                                return Math.ceil((firstDay + lastDate) / 7);
                            },

                            /**
                             * @param {Date} date - Date instance
                             * @returns {boolean}
                             */
                            isValidDate: function(date) {
                                return snippet.isDate(date) && !isNaN(date.getTime());
                            },

                            /**
                             * Get which day is first by parameters that include year and month information.
                             * @param {number} year A year
                             * @param {number} month A month
                             * @returns {number} (0~6)
                             */
                            getFirstDay: function(year, month) {
                                return new Date(year, month - 1, 1).getDay();
                            },

                            /**
                             * Get last date by parameters that include year and month information.
                             * @param {number} year A year
                             * @param {number} month A month
                             * @returns {number} (1~31)
                             */
                            getLastDayInMonth: function(year, month) {
                                return new Date(year, month, 0).getDate();
                            },

                            /**
                             * Chagne number 0~9 to '00~09'
                             * @param {number} number number
                             * @returns {string}
                             * @example
                             *  dateUtil.prependLeadingZero(0); //  '00'
                             *  dateUtil.prependLeadingZero(9); //  '09'
                             *  dateUtil.prependLeadingZero(12); //  '12'
                             */
                            prependLeadingZero: function(number) {
                                var prefix = '';

                                if (number < 10) {
                                    prefix = '0';
                                }

                                return prefix + number;
                            },

                            /**
                             * Get meridiem hour
                             * @param {number} hour - Original hour
                             * @returns {number} Converted meridiem hour
                             */
                            getMeridiemHour: function(hour) {
                                hour %= 12;

                                if (hour === 0) {
                                    hour = 12;
                                }

                                return hour;
                            },

                            /**
                             * Returns number or default
                             * @param {*} any - Any value
                             * @param {number} defaultNumber - Default number
                             * @throws Will throw an error if the defaultNumber is invalid.
                             * @returns {number}
                             */
                            getSafeNumber: function(any, defaultNumber) {
                                if (isNaN(defaultNumber) || !snippet.isNumber(defaultNumber)) {
                                    throw Error('The defaultNumber must be a valid number.');
                                }
                                if (isNaN(any)) {
                                    return defaultNumber;
                                }

                                return Number(any);
                            },

                            /**
                             * Return date of the week
                             * @param {number} year - Year
                             * @param {number} month - Month
                             * @param {number} weekNumber - Week number (0~5)
                             * @param {number} dayNumber - Day number (0: sunday, 1: monday, ....)
                             * @returns {number}
                             */
                            getDateOfWeek: function(year, month, weekNumber, dayNumber) {
                                var firstDayOfMonth = new Date(year, month - 1).getDay();
                                var dateOffset = firstDayOfMonth - dayNumber - 1;

                                return new Date(year, month - 1, (weekNumber * 7) - dateOffset);
                            },

                            /**
                             * Returns range arr
                             * @param {number} start - Start value
                             * @param {number} end - End value
                             * @returns {Array}
                             */
                            getRangeArr: function(start, end) {
                                var arr = [];
                                var i;

                                if (start > end) {
                                    for (i = end; i >= start; i -= 1) {
                                        arr.push(i);
                                    }
                                } else {
                                    for (i = start; i <= end; i += 1) {
                                        arr.push(i);
                                    }
                                }

                                return arr;
                            },

                            /**
                             * Returns cloned date with the start of a unit of time
                             * @param {Date|number} date - Original date
                             * @param {string} [type = TYPE_DATE] - Unit type
                             * @throws {Error}
                             * @returns {Date}
                             */
                            cloneWithStartOf: function(date, type) {
                                type = type || TYPE_DATE;
                                date = new Date(date);

                                // Does not consider time-level yet.
                                date.setHours(0, 0, 0, 0);

                                switch (type) {
                                    case TYPE_DATE:
                                        break;
                                    case TYPE_MONTH:
                                        date.setDate(1);
                                        break;
                                    case TYPE_YEAR:
                                        date.setMonth(0, 1);
                                        break;
                                    default:
                                        throw Error('Unsupported type: ' + type);
                                }

                                return date;
                            },

                            /**
                             * Returns cloned date with the end of a unit of time
                             * @param {Date|number} date - Original date
                             * @param {string} [type = TYPE_DATE] - Unit type
                             * @throws {Error}
                             * @returns {Date}
                             */
                            cloneWithEndOf: function(date, type) {
                                type = type || TYPE_DATE;
                                date = new Date(date);

                                // Does not consider time-level yet.
                                date.setHours(23, 59, 59, 999);

                                switch (type) {
                                    case TYPE_DATE:
                                        break;
                                    case TYPE_MONTH:
                                        date.setMonth(date.getMonth() + 1, 0);
                                        break;
                                    case TYPE_YEAR:
                                        date.setMonth(11, 31);
                                        break;
                                    default:
                                        throw Error('Unsupported type: ' + type);
                                }

                                return date;
                            },

                            /**
                             * Compare two dates
                             * @param {Date|number} dateA - Date
                             * @param {Date|number} dateB - Date
                             * @param {string} [cmpLevel] - Comparing level
                             * @returns {number}
                             */
                            compare: function(dateA, dateB, cmpLevel) {
                                var aTimestamp, bTimestamp;

                                if (!(utils.isValidDate(dateA) && utils.isValidDate(dateB))) {
                                    return NaN;
                                }

                                if (!cmpLevel) {
                                    aTimestamp = dateA.getTime();
                                    bTimestamp = dateB.getTime();
                                } else {
                                    aTimestamp = utils.cloneWithStartOf(dateA, cmpLevel).getTime();
                                    bTimestamp = utils.cloneWithStartOf(dateB, cmpLevel).getTime();
                                }

                                if (aTimestamp > bTimestamp) {
                                    return 1;
                                }

                                return aTimestamp === bTimestamp ? 0 : -1;
                            },

                            /**
                             * Returns whether two dates are same
                             * @param {Date|number} dateA - Date
                             * @param {Date|number} dateB - Date
                             * @param {string} [cmpLevel] - Comparing level
                             * @returns {boolean}
                             */
                            isSame: function(dateA, dateB, cmpLevel) {
                                return utils.compare(dateA, dateB, cmpLevel) === 0;
                            },

                            /**
                             * Returns whether the target is in range
                             * @param {Date|number} start - Range start
                             * @param {Date|number} end - Range end
                             * @param {Date|number} target - Target
                             * @param {string} [cmpLevel = TYPE_DATE] - Comparing level
                             * @returns {boolean}
                             */
                            inRange: function(start, end, target, cmpLevel) {
                                return utils.compare(start, target, cmpLevel) < 1 && utils.compare(end, target, cmpLevel) > -1;
                            }
                        };

                        module.exports = utils;


                        /***/ }),
                    /* 31 */
                    /***/ (function(module, exports) {

                        module.exports = {
                            TYPE_DATE: 'date',
                            TYPE_MONTH: 'month',
                            TYPE_YEAR: 'year',
                            TYPE_HOUR: 'hour',
                            TYPE_MINUTE: 'minute',
                            TYPE_MERIDIEM: 'meridiem',
                            MIN_DATE: new Date(1900, 0, 1),
                            MAX_DATE: new Date(2999, 11, 31),

                            DEFAULT_LANGUAGE_TYPE: 'en',

                            CLASS_NAME_SELECTED: 'tui-is-selected',

                            CLASS_NAME_PREV_MONTH_BTN: 'tui-calendar-btn-prev-month',
                            CLASS_NAME_PREV_YEAR_BTN: 'tui-calendar-btn-prev-year',
                            CLASS_NAME_NEXT_YEAR_BTN: 'tui-calendar-btn-next-year',
                            CLASS_NAME_NEXT_MONTH_BTN: 'tui-calendar-btn-next-month'
                        };


                        /***/ }),
                    /* 32 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(2);
                        var snippet = __webpack_require__(3);

                        var DateLayer = __webpack_require__(33);
                        var MonthLayer = __webpack_require__(38);
                        var YearLayer = __webpack_require__(41);
                        var constants = __webpack_require__(31);

                        var TYPE_DATE = constants.TYPE_DATE;
                        var TYPE_MONTH = constants.TYPE_MONTH;
                        var TYPE_YEAR = constants.TYPE_YEAR;

                        /**
                         * @ignore
                         * @class
                         */
                        var Body = snippet.defineClass(/** @lends Body.prototype */{
                            init: function(bodyContainer, option) {
                                var language = option.language;

                                /**
                                 * Body container element
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$container = $(bodyContainer);

                                /**
                                 * DateLayer
                                 * @type {DateLayer}
                                 * @private
                                 */
                                this._dateLayer = new DateLayer(language);

                                /**
                                 * MonthLayer
                                 * @type {MonthLayer}
                                 * @private
                                 */
                                this._monthLayer = new MonthLayer(language);

                                /**
                                 * YearLayer
                                 * @type {YearLayer}
                                 * @private
                                 */
                                this._yearLayer = new YearLayer(language);

                                /**
                                 * Current Layer
                                 * @type {DateLayer|MonthLayer|YearLayer}
                                 * @private
                                 */
                                this._currentLayer = this._dateLayer;
                            },

                            /**
                             * Returns matched layer
                             * @param {string} type - Layer type
                             * @returns {Base} - Layer
                             * @private
                             */
                            _getLayer: function(type) {
                                switch (type) {
                                    case TYPE_DATE:
                                        return this._dateLayer;
                                    case TYPE_MONTH:
                                        return this._monthLayer;
                                    case TYPE_YEAR:
                                        return this._yearLayer;
                                    default:
                                        return this._currentLayer;
                                }
                            },

                            /**
                             * Iterate each layer
                             * @param {Function} fn - function
                             * @private
                             */
                            _eachLayer: function(fn) {
                                snippet.forEach([this._dateLayer, this._monthLayer, this._yearLayer], fn);
                            },

                            /**
                             * Change language
                             * @param {string} language - Language
                             */
                            changeLanguage: function(language) {
                                this._eachLayer(function(layer) {
                                    layer.changeLanguage(language);
                                });
                            },

                            /**
                             * Render body
                             * @param {Date} date - date
                             * @param {string} type - Layer type
                             */
                            render: function(date, type) {
                                var nextLayer = this._getLayer(type);
                                var prevLayer = this._currentLayer;

                                prevLayer.remove();
                                nextLayer.render(date);
                                nextLayer.appendTo(this._$container);

                                this._currentLayer = nextLayer;
                            },

                            /**
                             * Returns date jQuery elements
                             * @returns {jQuery}
                             */
                            getDateElements: function() {
                                return this._currentLayer.getDateElements();
                            },

                            /**
                             * Destory
                             */
                            destroy: function() {
                                this._eachLayer(function(layer) {
                                    layer.remove();
                                });

                                this._$container = this._currentLayer = this._dateLayer = this._monthLayer = this._yearLayer = null;
                            }
                        });

                        module.exports = Body;


                        /***/ }),
                    /* 33 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(2);
                        var snippet = __webpack_require__(3);

                        var bodyTmpl = __webpack_require__(34);
                        var LayerBase = __webpack_require__(37);
                        var TYPE_DATE = __webpack_require__(31).TYPE_DATE;

                        var DATE_SELECTOR = '.tui-calendar-date';

                        /**
                         * @ignore
                         * @class
                         * @extends LayerBase
                         * @param {string} language - Initial language
                         */
                        var DateLayer = snippet.defineClass(LayerBase, /** @lends DateLayer.prototype */{
                            init: function(language) {
                                LayerBase.call(this, language);
                            },

                            /**
                             * Layer type
                             * @type {string}
                             * @private
                             */
                            _type: TYPE_DATE,

                            /**
                             * @override
                             * @private
                             * @returns {object} Template context
                             */
                            _makeContext: function(date) {
                                var daysShort = this._localeText.titles.D;
                                var year, month;

                                date = date || new Date();
                                year = date.getFullYear();
                                month = date.getMonth() + 1;

                                return {
                                    Sun: daysShort[0],
                                    Mon: daysShort[1],
                                    Tue: daysShort[2],
                                    Wed: daysShort[3],
                                    Thu: daysShort[4],
                                    Fri: daysShort[5],
                                    Sat: daysShort[6],
                                    year: year,
                                    month: month
                                };
                            },

                            /**
                             * Render date-layer
                             * @override
                             * @param {Date} date - Date to render
                             */
                            render: function(date) {
                                var context = this._makeContext(date);

                                this._$element = $(bodyTmpl(context));
                            },

                            /**
                             * Retunrs date elements
                             * @override
                             * @returns {jQuery}
                             */
                            getDateElements: function() {
                                return this._$element.find(DATE_SELECTOR);
                            }
                        });

                        module.exports = DateLayer;


                        /***/ }),
                    /* 34 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var Handlebars = __webpack_require__(7);
                        function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
                        module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data) {
                                var stack1;

                                return "            <tr class=\"tui-calendar-week\">\n"
                                    + ((stack1 = __default(__webpack_require__(35)).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.year : depth0),(depth0 != null ? depth0.month : depth0),(depth0 != null ? depth0.dates : depth0),{"name":"../helpers/week","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
                                    + "            </tr>\n";
                            },"2":function(container,depth0,helpers,partials,data) {
                                var alias1=container.lambda, alias2=container.escapeExpression;

                                return "                    <td class=\""
                                    + alias2(alias1((depth0 != null ? depth0.className : depth0), depth0))
                                    + "\" data-timestamp=\""
                                    + alias2(alias1((depth0 != null ? depth0.timestamp : depth0), depth0))
                                    + "\">"
                                    + alias2(alias1((depth0 != null ? depth0.dayInMonth : depth0), depth0))
                                    + "</td>\n";
                            },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
                                var stack1, alias1=container.lambda, alias2=container.escapeExpression;

                                return "<table class=\"tui-calendar-body-inner\" cellspacing=\"0\" cellpadding=\"0\">\n    <caption><span>Dates</span></caption>\n    <thead class=\"tui-calendar-body-header\">\n        <tr>\n            <th class=\"tui-sun\" scope=\"col\">"
                                    + alias2(alias1((depth0 != null ? depth0.Sun : depth0), depth0))
                                    + "</th>\n            <th scope=\"col\">"
                                    + alias2(alias1((depth0 != null ? depth0.Mon : depth0), depth0))
                                    + "</th>\n            <th scope=\"col\">"
                                    + alias2(alias1((depth0 != null ? depth0.Tue : depth0), depth0))
                                    + "</th>\n            <th scope=\"col\">"
                                    + alias2(alias1((depth0 != null ? depth0.Wed : depth0), depth0))
                                    + "</th>\n            <th scope=\"col\">"
                                    + alias2(alias1((depth0 != null ? depth0.Thu : depth0), depth0))
                                    + "</th>\n            <th scope=\"col\">"
                                    + alias2(alias1((depth0 != null ? depth0.Fri : depth0), depth0))
                                    + "</th>\n            <th class=\"tui-sat\" scope=\"col\">"
                                    + alias2(alias1((depth0 != null ? depth0.Sat : depth0), depth0))
                                    + "</th>\n        </tr>\n    </thead>\n    <tbody>\n"
                                    + ((stack1 = __default(__webpack_require__(36)).call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.year : depth0),(depth0 != null ? depth0.month : depth0),{"name":"../helpers/weeks","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
                                    + "    </tbody>\n</table>\n";
                            },"useData":true});

                        /***/ }),
                    /* 35 */
                    /***/ (function(module, exports) {

                        module.exports = function(currentYear, currentMonth, dates, options) {
                            var firstDateOfCurrentMonth = new Date(currentYear, currentMonth - 1, 1);
                            var lastDateOfCurrentMonth = new Date(currentYear, currentMonth, 0);
                            var out = '';
                            var i = 0;
                            var length = dates.length;
                            var date, className;

                            for (; i < length; i += 1) {
                                className = 'tui-calendar-date';
                                date = dates[i];

                                if (date < firstDateOfCurrentMonth) {
                                    className += ' tui-calendar-prev-month';
                                }

                                if (date > lastDateOfCurrentMonth) {
                                    className += ' tui-calendar-next-month';
                                }

                                switch (date.getDay()) {
                                    case 0:
                                        className += ' tui-calendar-sun';
                                        break;
                                    case 6:
                                        className += ' tui-calendar-sat';
                                        break;
                                }

                                out += options.fn({
                                    dayInMonth: date.getDate(),
                                    className: className,
                                    timestamp: date.getTime()
                                });
                            }

                            return out;
                        };


                        /***/ }),
                    /* 36 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var dateUtil = __webpack_require__(30);

                        module.exports = function(year, month, options) {
                            var weekNumber = 0;
                            var weeksCount = 6; // Fix for no changing height
                            var out = '';
                            var weekContext;

                            for (; weekNumber < weeksCount; weekNumber += 1) {
                                weekContext = {
                                    year: year,
                                    month: month,
                                    dates: [
                                        dateUtil.getDateOfWeek(year, month, weekNumber, 0),
                                        dateUtil.getDateOfWeek(year, month, weekNumber, 1),
                                        dateUtil.getDateOfWeek(year, month, weekNumber, 2),
                                        dateUtil.getDateOfWeek(year, month, weekNumber, 3),
                                        dateUtil.getDateOfWeek(year, month, weekNumber, 4),
                                        dateUtil.getDateOfWeek(year, month, weekNumber, 5),
                                        dateUtil.getDateOfWeek(year, month, weekNumber, 6)
                                    ]
                                };
                                out += options.fn(weekContext);
                            }

                            return out;
                        };


                        /***/ }),
                    /* 37 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var snippet = __webpack_require__(3);

                        var localeText = __webpack_require__(27);
                        var DEFAULT_LANGUAGE_TYPE = __webpack_require__(31).DEFAULT_LANGUAGE_TYPE;

                        /**
                         * @abstract
                         * @class
                         * @ignore
                         * @param {string} language - Initial language
                         * Layer base
                         */
                        var LayerBase = snippet.defineClass(/** @lends LayerBase.prototype */{
                            init: function(language) {
                                language = language || DEFAULT_LANGUAGE_TYPE;

                                /**
                                 * Layer element
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$element = null;

                                /**
                                 * Language type
                                 * @type {string}
                                 * @private
                                 */
                                this._localeText = localeText[language];

                                /**
                                 * Layer type
                                 * @type {string}
                                 * @private
                                 */
                                this._type = 'base';
                            },

                            /**
                             * Make context
                             * @abstract
                             * @throws {Error}
                             * @returns {object}
                             * @private
                             */
                            _makeContext: function() {
                                throwOverrideError(this.getType(), '_makeContext');
                            },

                            /**
                             * Render the layer element
                             * @abstract
                             * @throws {Error}
                             */
                            render: function() {
                                throwOverrideError(this.getType(), 'render');
                            },

                            /**
                             * Returns date elements
                             * @abstract
                             * @throws {Error}
                             * @returns {jQuery}
                             */
                            getDateElements: function() {
                                throwOverrideError(this.getType(), 'getDateElements');
                            },

                            /**
                             * Returns layer type
                             * @returns {string}
                             */
                            getType: function() {
                                return this._type;
                            },

                            /**
                             * Set language
                             * @param {string} language - Language name
                             */
                            changeLanguage: function(language) {
                                this._localeText = localeText[language];
                            },

                            /**
                             * Append to parent element
                             * @param {string|HTMLElement|jQuery} parent - Parent element
                             * @returns {jQuery}
                             */
                            appendTo: function(parent) {
                                return this._$element.appendTo(parent);
                            },

                            /**
                             * Remove elements
                             */
                            remove: function() {
                                if (this._$element) {
                                    this._$element.remove();
                                }
                                this._$element = null;
                            }
                        });

                        /**
                         * Throw - method override error
                         * @ignore
                         * @param {string} layerType - Layer type
                         * @param {string} methodName - Method name
                         * @throws {Error}
                         */
                        function throwOverrideError(layerType, methodName) {
                            throw new Error(layerType + ' layer does not have the "' + methodName + '" method.');
                        }

                        module.exports = LayerBase;


                        /***/ }),
                    /* 38 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(2);
                        var snippet = __webpack_require__(3);

                        var bodyTmpl = __webpack_require__(39);
                        var LayerBase = __webpack_require__(37);
                        var TYPE_MONTH = __webpack_require__(31).TYPE_MONTH;

                        var DATE_SELECTOR = '.tui-calendar-month';

                        /**
                         * @class
                         * @extends LayerBase
                         * @param {string} language - Initial language
                         * @ignore
                         */
                        var MonthLayer = snippet.defineClass(LayerBase, /** @lends MonthLayer.prototype */{
                            init: function(language) {
                                LayerBase.call(this, language);
                            },

                            /**
                             * Layer type
                             * @type {string}
                             * @private
                             */
                            _type: TYPE_MONTH,

                            /**
                             * @override
                             * @returns {object} Template context
                             * @private
                             */
                            _makeContext: function(date) {
                                var monthsShort = this._localeText.titles.MMM;

                                return {
                                    year: date.getFullYear(),
                                    Jan: monthsShort[0],
                                    Feb: monthsShort[1],
                                    Mar: monthsShort[2],
                                    Apr: monthsShort[3],
                                    May: monthsShort[4],
                                    Jun: monthsShort[5],
                                    Jul: monthsShort[6],
                                    Aug: monthsShort[7],
                                    Sep: monthsShort[8],
                                    Oct: monthsShort[9],
                                    Nov: monthsShort[10],
                                    Dec: monthsShort[11]
                                };
                            },

                            /**
                             * Render month-layer element
                             * @override
                             */
                            render: function(date) {
                                var context = this._makeContext(date);

                                this._$element = $(bodyTmpl(context));
                            },

                            /**
                             * Returns month elements
                             * @override
                             * @returns {jQuery}
                             */
                            getDateElements: function() {
                                return this._$element.find(DATE_SELECTOR);
                            }
                        });

                        module.exports = MonthLayer;


                        /***/ }),
                    /* 39 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var Handlebars = __webpack_require__(7);
                        function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
                        module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
                                var alias1=depth0 != null ? depth0 : {}, alias2=container.escapeExpression, alias3=container.lambda;

                                return "<table class=\"tui-calendar-body-inner\">\n    <caption><span>Months</span></caption>\n    <tbody>\n    <tr class=\"tui-calendar-month-group\">\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),0,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Jan : depth0), depth0))
                                    + "</td>\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),1,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Feb : depth0), depth0))
                                    + "</td>\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),2,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Mar : depth0), depth0))
                                    + "</td>\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),3,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Apr : depth0), depth0))
                                    + "</td>\n    </tr>\n    <tr class=\"tui-calendar-month-group\">\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),4,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.May : depth0), depth0))
                                    + "</td>\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),5,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Jun : depth0), depth0))
                                    + "</td>\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),6,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Jul : depth0), depth0))
                                    + "</td>\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),7,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Aug : depth0), depth0))
                                    + "</td>\n    </tr>\n    <tr class=\"tui-calendar-month-group\">\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),8,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Sep : depth0), depth0))
                                    + "</td>\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),9,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Oct : depth0), depth0))
                                    + "</td>\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),10,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Nov : depth0), depth0))
                                    + "</td>\n        <td class=\"tui-calendar-month\" data-timestamp="
                                    + alias2(__default(__webpack_require__(40)).call(alias1,(depth0 != null ? depth0.year : depth0),11,{"name":"../helpers/timestamp","hash":{},"data":data}))
                                    + ">"
                                    + alias2(alias3((depth0 != null ? depth0.Dec : depth0), depth0))
                                    + "</td>\n    </tr>\n    </tbody>\n</table>\n";
                            },"useData":true});

                        /***/ }),
                    /* 40 */
                    /***/ (function(module, exports) {

                        /**
                         * Return timestamp
                         * @param {number} year - Year
                         * @param {number} month - Month
                         * @returns {number}
                         */
                        module.exports = function(year, month) {
                            return new Date(year, month, 1).getTime();
                        };


                        /***/ }),
                    /* 41 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(2);
                        var snippet = __webpack_require__(3);

                        var bodyTmpl = __webpack_require__(42);
                        var LayerBase = __webpack_require__(37);
                        var TYPE_YEAR = __webpack_require__(31).TYPE_YEAR;
                        var dateUtil = __webpack_require__(30);

                        var DATE_SELECTOR = '.tui-calendar-year';

                        /**
                         * @class
                         * @extends LayerBase
                         * @param {string} language - Initial language
                         * @ignore
                         */
                        var YearLayer = snippet.defineClass(LayerBase, /** @lends YearLayer.prototype */{
                            init: function(language) {
                                LayerBase.call(this, language);
                            },

                            /**
                             * Layer type
                             * @type {string}
                             * @private
                             */
                            _type: TYPE_YEAR,

                            /**
                             * @override
                             * @returns {object} Template context
                             * @private
                             */
                            _makeContext: function(date) {
                                var year = date.getFullYear();

                                return {
                                    yearGroups: [
                                        dateUtil.getRangeArr(year - 4, year - 2),
                                        dateUtil.getRangeArr(year - 1, year + 1),
                                        dateUtil.getRangeArr(year + 2, year + 4)
                                    ]
                                };
                            },

                            /**
                             * Render month-layer element
                             * @override
                             */
                            render: function(date) {
                                var context = this._makeContext(date);

                                this._$element = $(bodyTmpl(context));
                            },

                            /**
                             * Returns year elements
                             * @override
                             * @returns {jQuery}
                             */
                            getDateElements: function() {
                                return this._$element.find(DATE_SELECTOR);
                            }
                        });

                        module.exports = YearLayer;


                        /***/ }),
                    /* 42 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var Handlebars = __webpack_require__(7);
                        function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
                        module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data,blockParams) {
                                var stack1;

                                return "            <tr class=\"tui-calendar-year-group\">\n"
                                    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},blockParams[0][0],{"name":"each","hash":{},"fn":container.program(2, data, 1, blockParams),"inverse":container.noop,"data":data,"blockParams":blockParams})) != null ? stack1 : "")
                                    + "            </tr>\n";
                            },"2":function(container,depth0,helpers,partials,data,blockParams) {
                                var alias1=container.escapeExpression;

                                return "                    <td class=\"tui-calendar-year\" data-timestamp="
                                    + alias1(__default(__webpack_require__(40)).call(depth0 != null ? depth0 : {},blockParams[0][0],0,{"name":"../helpers/timestamp","hash":{},"data":data,"blockParams":blockParams}))
                                    + ">\n                        "
                                    + alias1(container.lambda(blockParams[0][0], depth0))
                                    + "\n                    </td>\n";
                            },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data,blockParams) {
                                var stack1;

                                return "<table class=\"tui-calendar-body-inner\">\n    <caption><span>Years</span></caption>\n    <tbody>\n"
                                    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.yearGroups : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 1, blockParams),"inverse":container.noop,"data":data,"blockParams":blockParams})) != null ? stack1 : "")
                                    + "    </tbody>\n</table>\n";
                            },"useData":true,"useBlockParams":true});

                        /***/ }),
                    /* 43 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var snippet = __webpack_require__(3);

                        var Range = __webpack_require__(44);

                        /**
                         * @class
                         * @ignore
                         * @param {Array.<Array.<number>>} ranges - Ranges
                         */
                        var RangeModel = snippet.defineClass(/** @lends RangeModel.prototype */{
                            init: function(ranges) {
                                ranges = ranges || [];

                                /**
                                 * @type {Array.<Range>}
                                 * @private
                                 */
                                this._ranges = [];

                                snippet.forEach(ranges, function(range) {
                                    this.add(range[0], range[1]);
                                }, this);
                            },

                            /**
                             * Whether the ranges contain a time or time-range
                             * @param {number} start - Start
                             * @param {number} [end] - End
                             * @returns {boolean}
                             */
                            contains: function(start, end) {
                                var i = 0;
                                var length = this._ranges.length;
                                var range;

                                for (; i < length; i += 1) {
                                    range = this._ranges[i];
                                    if (range.contains(start, end)) {
                                        return true;
                                    }
                                }

                                return false;
                            },

                            /**
                             * Whether overlaps with a point or range
                             * @param {number} start - Start
                             * @param {number} [end] - End
                             * @returns {boolean}
                             */
                            hasOverlap: function(start, end) {
                                var i = 0;
                                var length = this._ranges.length;
                                var range;

                                for (; i < length; i += 1) {
                                    range = this._ranges[i];
                                    if (range.isOverlapped(start, end)) {
                                        return true;
                                    }
                                }

                                return false;
                            },

                            /**
                             * Add range
                             * @param {number} start - Start
                             * @param {number} [end] - End
                             */
                            add: function(start, end) {
                                var overlapped = false;
                                var i = 0;
                                var len = this._ranges.length;
                                var range;

                                for (; i < len; i += 1) {
                                    range = this._ranges[i];
                                    overlapped = range.isOverlapped(start, end);

                                    if (overlapped) {
                                        range.merge(start, end);
                                        break;
                                    }

                                    if (start < range.start) {
                                        break;
                                    }
                                }

                                if (!overlapped) {
                                    this._ranges.splice(i, 0, new Range(start, end));
                                }
                            },

                            /**
                             * Returns minimum value in ranges
                             * @returns {number}
                             */
                            getMinimumValue: function() {
                                return this._ranges[0].start;
                            },

                            /**
                             * Returns maximum value in ranges
                             * @returns {number}
                             */
                            getMaximumValue: function() {
                                var length = this._ranges.length;

                                return this._ranges[length - 1].end;
                            },

                            /**
                             * @param {number} start - Start
                             * @param {number} [end] - End
                             */
                            exclude: function(start, end) {
                                if (!snippet.isNumber(end)) {
                                    end = start;
                                }

                                snippet.forEach(this._ranges, function(range) {
                                    var rangeEnd;

                                    if (range.isOverlapped(start, end)) {
                                        rangeEnd = range.end; // Save before excluding
                                        range.exclude(start, end);

                                        if (end + 1 <= rangeEnd) {
                                            this.add(end + 1, rangeEnd); // Add split range
                                        }
                                    }
                                }, this);

                                // Reduce empty ranges
                                this._ranges = snippet.filter(this._ranges, function(range) {
                                    return !range.isEmpty();
                                });
                            },

                            /**
                             * Returns the first overlapped range from the point or range
                             * @param {number} start - Start
                             * @param {number} end - End
                             * @returns {Array.<number>} - [start, end]
                             */
                            findOverlappedRange: function(start, end) {
                                var i = 0;
                                var len = this._ranges.length;
                                var range;

                                for (; i < len; i += 1) {
                                    range = this._ranges[i];
                                    if (range.isOverlapped(start, end)) {
                                        return [range.start, range.end];
                                    }
                                }

                                return null;
                            }
                        });

                        module.exports = RangeModel;


                        /***/ }),
                    /* 44 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var snippet = __webpack_require__(3);

                        var isNumber = snippet.isNumber;

                        /**
                         * @class
                         * @ignore
                         * @param {number} start - Start of range
                         * @param {number} [end] - End of range
                         */
                        var Range = snippet.defineClass(/** @lends Range.prototype */{
                            init: function(start, end) {
                                this.setRange(start, end);
                            },

                            /**
                             * Set range
                             * @param {number} start - Start number
                             * @param {number} [end] - End number
                             */
                            setRange: function(start, end) {
                                if (!isNumber(end)) {
                                    end = start;
                                }

                                this.start = Math.min(start, end);
                                this.end = Math.max(start, end);
                            },

                            /**
                             * Merge range
                             * @param {number} start - Start
                             * @param {number} [end] - End
                             */
                            merge: function(start, end) {
                                if (!isNumber(start) || !isNumber(end) || !this.isOverlapped(start, end)) {
                                    return;
                                }

                                this.start = Math.min(start, this.start);
                                this.end = Math.max(end, this.end);
                            },

                            /**
                             * Whether being empty.
                             * @returns {boolean}
                             */
                            isEmpty: function() {
                                return !isNumber(this.start) || !isNumber(this.end);
                            },

                            /**
                             * Set empty
                             */
                            setEmpty: function() {
                                this.start = this.end = null;
                            },

                            /**
                             * Whether containing a range.
                             * @param {number} start - Start
                             * @param {number} [end] - End
                             * @returns {boolean}
                             */
                            contains: function(start, end) {
                                if (!isNumber(end)) {
                                    end = start;
                                }

                                return this.start <= start && end <= this.end;
                            },

                            /**
                             * Whether overlaps with a range
                             * @param {number} start - Start
                             * @param {number} [end] - End
                             * @returns {boolean}
                             */
                            isOverlapped: function(start, end) {
                                if (!isNumber(end)) {
                                    end = start;
                                }

                                return this.start <= end && this.end >= start;
                            },

                            /**
                             * Exclude a range
                             * @param {number} start - Start
                             * @param {number} end - End
                             */
                            exclude: function(start, end) {
                                if (start <= this.start && end >= this.end) {
                                    // Excluding range contains this
                                    this.setEmpty();
                                } else if (this.contains(start)) {
                                    this.setRange(this.start, start - 1);
                                } else if (this.contains(end)) {
                                    this.setRange(end + 1, this.end);
                                }
                            }
                        });

                        module.exports = Range;


                        /***/ }),
                    /* 45 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(2);

                        /**
                         * Detect mobile browser
                         * @private
                         * @returns {boolean} Whether using Mobile browser
                         */
                        function isMobile() {
                            return /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);
                        }

                        /**
                         * For using one - Touch or Mouse Events
                         * @param {jQuery|string|Element} target - Target element
                         * @param {Function} handler - Handler
                         * @param {object} [option] - Option
                         * @param {string} option.selector - Selector
                         * @param {string} option.namespace - Event namespace
                         */
                        module.exports = function(target, handler, option) {
                            var $target = $(target);
                            var eventType = isMobile() ? 'touchend' : 'click';
                            var selector, namespace;

                            option = option || {};
                            selector = option.selector || null;
                            namespace = option.namespace || '';

                            if (namespace) {
                                eventType = eventType + '.' + namespace;
                            }

                            $target.on(eventType, selector, handler);
                        };


                        /***/ }),
                    /* 46 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var Handlebars = __webpack_require__(7);
                        function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
                        module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data) {
                                var stack1, alias1=depth0 != null ? depth0 : {};

                                return ((stack1 = helpers["if"].call(alias1,__default(__webpack_require__(47)).call(alias1,((stack1 = (depth0 != null ? depth0.timepicker : depth0)) != null ? stack1.layoutType : stack1),"tab",{"name":"../helpers/equals","hash":{},"data":data}),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
                            },"2":function(container,depth0,helpers,partials,data) {
                                var stack1, alias1=container.lambda, alias2=container.escapeExpression;

                                return "            <div class=\"tui-datepicker-selector\">\n                <button type=\"button\" class=\"tui-datepicker-selector-button tui-is-checked\" aria-label=\"selected\">\n                    <span class=\"tui-ico-date\"></span>"
                                    + alias2(alias1(((stack1 = (depth0 != null ? depth0.localeText : depth0)) != null ? stack1.date : stack1), depth0))
                                    + "\n                </button>\n                <button type=\"button\" class=\"tui-datepicker-selector-button\">\n                    <span class=\"tui-ico-time\"></span>"
                                    + alias2(alias1(((stack1 = (depth0 != null ? depth0.localeText : depth0)) != null ? stack1.time : stack1), depth0))
                                    + "\n                </button>\n            </div>\n            <div class=\"tui-datepicker-body\"></div>\n";
                            },"4":function(container,depth0,helpers,partials,data) {
                                return "            <div class=\"tui-datepicker-body\"></div>\n            <div class=\"tui-datepicker-footer\"></div>\n";
                            },"6":function(container,depth0,helpers,partials,data) {
                                return "        <div class=\"tui-datepicker-body\"></div>\n";
                            },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
                                var stack1;

                                return "<div class=\"tui-datepicker\">\n"
                                    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},(depth0 != null ? depth0.timepicker : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(6, data, 0),"data":data})) != null ? stack1 : "")
                                    + "</div>\n";
                            },"useData":true});

                        /***/ }),
                    /* 47 */
                    /***/ (function(module, exports) {

                        /**
                         * @param {*} a - Anything
                         * @param {*} b - Anything
                         * @returns {boolean}
                         */
                        module.exports = function(a, b) {
                            return a === b;
                        };


                        /***/ }),
                    /* 48 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(2);
                        var snippet = __webpack_require__(3);

                        var DateTimeFormatter = __webpack_require__(29);
                        var setTouchClickEvent = __webpack_require__(45);

                        var DEFAULT_FORMAT = 'yyyy-MM-dd';

                        /**
                         * DatePicker Input
                         * @ignore
                         * @class
                         * @param {string|jQuery|HTMLElement} inputElement - Input element
                         * @param {object} option - Option
                         * @param {string} option.id - Id
                         * @param {string} option.format - Text format
                         */
                        var DatePickerInput = snippet.defineClass(/** @lends DatePickerInput.prototype */{
                            init: function(inputElement, option) {
                                option.format = option.format || DEFAULT_FORMAT;

                                /**
                                 * Input element
                                 * @type {jQuery}
                                 * @private
                                 */
                                this._$input = $(inputElement);

                                /**
                                 * Id
                                 * @type {string}
                                 * @private
                                 */
                                this._id = option.id;

                                /**
                                 * LocaleText titles
                                 * @type {Object}
                                 * @private
                                 */
                                this._titles = option.localeText.titles;

                                /**
                                 * Text<->DateTime Formatter
                                 * @type {DateTimeFormatter}
                                 * @private
                                 */
                                this._formatter = new DateTimeFormatter(option.format, this._titles);

                                this._setEvents();
                            },

                            /**
                             * Change locale titles
                             * @param {object} titles - locale text in format
                             */
                            changeLocaleTitles: function(titles) {
                                this._titles = titles;
                            },

                            /**
                             * Set input 'click', 'change' event
                             * @private
                             */
                            _setEvents: function() {
                                this._$input.on('change.' + this._id, $.proxy(this.fire, this, 'change'));

                                setTouchClickEvent(this._$input, $.proxy(this.fire, this, 'click'), {
                                    namespace: this._id
                                });
                            },

                            /**
                             * @see {@link http://api.jquery.com/is/}
                             * @param {string|jQuery|HTMLElement|function} el - To check matched set of elements
                             * @returns {boolean}
                             */
                            is: function(el) {
                                return this._$input.is(el);
                            },

                            /**
                             * Enable input
                             */
                            enable: function() {
                                this._$input.removeAttr('disabled');
                            },

                            /**
                             * Disable input
                             */
                            disable: function() {
                                this._$input.attr('disabled', true);
                            },

                            /**
                             * Return format
                             * @returns {string}
                             */
                            getFormat: function() {
                                return this._formatter.getRawString();
                            },

                            /**
                             * Set format
                             * @param {string} format - Format
                             */
                            setFormat: function(format) {
                                if (!format) {
                                    return;
                                }

                                this._formatter = new DateTimeFormatter(format, this._titles);
                            },

                            /**
                             * Clear text
                             */
                            clearText: function() {
                                this._$input.val('');
                            },

                            /**
                             * Set value from date
                             * @param {Date} date - Date
                             */
                            setDate: function(date) {
                                this._$input.val(this._formatter.format(date));
                            },

                            /**
                             * Returns date from input-text
                             * @returns {Date}
                             * @throws {Error}
                             */
                            getDate: function() {
                                var value = this._$input.val();

                                return this._formatter.parse(value);
                            },

                            /**
                             * Destroy
                             */
                            destroy: function() {
                                var evNamespace = '.' + this._id;

                                this.off();
                                this._$input.off(evNamespace);

                                this._$input
                                    = this._id
                                    = this._formatter
                                    = null;
                            }
                        });

                        snippet.CustomEvents.mixin(DatePickerInput);
                        module.exports = DatePickerInput;


                        /***/ }),
                    /* 49 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var $ = __webpack_require__(2);
                        var snippet = __webpack_require__(3);

                        var DatePicker = __webpack_require__(1);
                        var dateUtil = __webpack_require__(30);
                        var constants = __webpack_require__(31);

                        var CLASS_NAME_RANGE_PICKER = 'tui-rangepicker';
                        var CLASS_NAME_SELECTED = constants.CLASS_NAME_SELECTED;
                        var CLASS_NAME_SELECTED_RANGE = 'tui-is-selected-range';

                        /**
                         * @class
                         * @param {object} options - Date-Range picker options
                         *     @param {object} options.startpicker - Startpicker options
                         *     @param {Element|jQuery|string} options.startpicker.input - Startpicker input element
                         *     @param {Element|jQuery|string} options.startpicker.container - Startpicker container element
                         *     @param {object} options.endpicker - Endpicker options
                         *     @param {Element|jQuery|string} options.endpicker.input - Endpicker input element
                         *     @param {Element|jQuery|string} options.endpicker.container - Endpicker container element
                         *     @param {string} options.format - Input date-string format
                         *     @param {string} [options.type = 'date'] - DatePicker type - ('date' | 'month' | 'year')
                         *     @param {string} [options.language='en'] - Language key
                         *     @param {object|boolean} [options.timePicker] -
                         *                             [TimePicker]{@link https://nhn.github.io/tui.time-picker/latest} options
                         *     @param {object} [options.calendar] - {@link Calendar} options
                         *     @param {Array.<Array.<Date|number>>} [options.selectableRanges] - Selectable ranges
                         *     @param {boolean} [options.showAlways = false] - Whether the datepicker shows always
                         *     @param {boolean} [options.autoClose = true] - Close after click a date
                         *     @param {Boolean} [options.usageStatistics=true|false] send hostname to google analytics [default value is true]
                         * @example
                         * var DatePicker = tui.DatePicker; // or require('tui-date-picker');
                         * var rangepicker = DatePicker.createRangePicker({
                         *     startpicker: {
                         *         input: '#start-input',
                         *         container: '#start-container'
                         *     },
                         *     endpicker: {
                         *         input: '#end-input',
                         *         container: '#end-container'
                         *     },
                         *     type: 'date',
                         *     format: 'yyyy-MM-dd'
                         *     selectableRanges: [
                         *         [new Date(2017, 3, 1), new Date(2017, 5, 1)],
                         *         [new Date(2017, 6, 3), new Date(2017, 10, 5)]
                         *     ]
                         * });
                         */
                        var DateRangePicker = snippet.defineClass(/** @lends DateRangePicker.prototype */{
                            init: function(options) {
                                var startpickerOpt, endpickerOpt;

                                options = options || {};
                                startpickerOpt = options.startpicker;
                                endpickerOpt = options.endpicker;

                                if (!startpickerOpt) {
                                    throw new Error('The "startpicker" option is required.');
                                }
                                if (!endpickerOpt) {
                                    throw new Error('The "endpicker" option is required.');
                                }

                                /**
                                 * Start picker
                                 * @type {DatePicker}
                                 * @private
                                 */
                                this._startpicker = null;

                                /**
                                 * End picker
                                 * @type {DatePicker}
                                 * @private
                                 */
                                this._endpicker = null;

                                this._initializePickers(options);
                                this.setStartDate(startpickerOpt.date);
                                this.setEndDate(endpickerOpt.date);
                                this._syncRangesToEndpicker();
                            },

                            /**
                             * Create picker
                             * @param {Object} options - DatePicker options
                             * @private
                             */
                            _initializePickers: function(options) {
                                var $startpickerContainer = $(options.startpicker.container);
                                var $endpickerContainer = $(options.endpicker.container);
                                var $startInput = $(options.startpicker.input);
                                var $endInput = $(options.endpicker.input);

                                var startpickerOpt = snippet.extend({}, options, {
                                    input: {
                                        element: $startInput,
                                        format: options.format
                                    }
                                });
                                var endpickerOpt = snippet.extend({}, options, {
                                    input: {
                                        element: $endInput,
                                        format: options.format
                                    }
                                });

                                this._startpicker = new DatePicker($startpickerContainer, startpickerOpt);
                                this._startpicker.addCssClass(CLASS_NAME_RANGE_PICKER);
                                this._startpicker.on('change', this._onChangeStartpicker, this);
                                this._startpicker.on('draw', this._onDrawPicker, this);

                                this._endpicker = new DatePicker($endpickerContainer, endpickerOpt);
                                this._endpicker.addCssClass(CLASS_NAME_RANGE_PICKER);
                                this._endpicker.on('change', this._onChangeEndpicker, this);
                                this._endpicker.on('draw', this._onDrawPicker, this);
                            },

                            /**
                             * Set selection-class to elements after calendar drawing
                             * @param {Object} eventData - Event data {@link DatePicker#event:draw}
                             * @private
                             */
                            _onDrawPicker: function(eventData) {
                                var self = this;
                                var calendarType = eventData.type;
                                var $dateElements = eventData.$dateElements;
                                var startDate = this._startpicker.getDate();
                                var endDate = this._endpicker.getDate();

                                if (!startDate) {
                                    return;
                                }

                                if (!endDate) {
                                    // Convert null to invaild date.
                                    endDate = new Date(NaN);
                                }

                                $dateElements.each(function(idx, el) {
                                    var $el = $(el);
                                    var elDate = new Date($el.data('timestamp'));
                                    var isInRange = dateUtil.inRange(startDate, endDate, elDate, calendarType);
                                    var isSelected = (
                                        dateUtil.isSame(startDate, elDate, calendarType)
                                        || dateUtil.isSame(endDate, elDate, calendarType)
                                    );

                                    self._setRangeClass($el, isInRange);
                                    self._setSelectedClass($el, isSelected);
                                });
                            },

                            /**
                             * Set range class to element
                             * @param {jQuery} $el - Element
                             * @param {boolean} isInRange - In range
                             * @private
                             */
                            _setRangeClass: function($el, isInRange) {
                                if (isInRange) {
                                    $el.addClass(CLASS_NAME_SELECTED_RANGE);
                                } else {
                                    $el.removeClass(CLASS_NAME_SELECTED_RANGE);
                                }
                            },

                            /**
                             * Set selected class to element
                             * @param {jQuery} $el - Element
                             * @param {boolean} isSelected - Is selected
                             * @private
                             */
                            _setSelectedClass: function($el, isSelected) {
                                if (isSelected) {
                                    $el.addClass(CLASS_NAME_SELECTED);
                                } else {
                                    $el.removeClass(CLASS_NAME_SELECTED);
                                }
                            },

                            /**
                             * Sync ranges to endpicker
                             * @private
                             */
                            _syncRangesToEndpicker: function() {
                                var startDate = this._startpicker.getDate();
                                var overlappedRange;

                                if (startDate) {
                                    overlappedRange = this._startpicker.findOverlappedRange(
                                        dateUtil.cloneWithStartOf(startDate).getTime(),
                                        dateUtil.cloneWithEndOf(startDate).getTime()
                                    );

                                    this._endpicker.enable();
                                    this._endpicker.setRanges([
                                        [startDate.getTime(), overlappedRange[1].getTime()]
                                    ]);
                                } else {
                                    this._endpicker.setNull();
                                    this._endpicker.disable();
                                }
                            },

                            /**
                             * After change on start-picker
                             * @private
                             */
                            _onChangeStartpicker: function() {
                                this._syncRangesToEndpicker();
                                /**
                                 * @event DateRangePicker#change:start
                                 * @example
                                 *
                                 * rangepicker.on('change:start', function() {
                                 *     console.log(rangepicker.getStartDate());
                                 * });
                                 */
                                this.fire('change:start');
                            },

                            /**
                             * After change on end-picker
                             * @private
                             */
                            _onChangeEndpicker: function() {
                                /**
                                 * @event DateRangePicker#change:end
                                 * @example
                                 *
                                 * rangepicker.on('change:end', function() {
                                 *     console.log(rangepicker.getEndDate());
                                 * });
                                 */
                                this.fire('change:end');
                            },

                            /**
                             * Returns start-datepicker
                             * @returns {DatePicker}
                             */
                            getStartpicker: function() {
                                return this._startpicker;
                            },

                            /**
                             * Returns end-datepicker
                             * @returns {DatePicker}
                             */
                            getEndpicker: function() {
                                return this._endpicker;
                            },

                            /**
                             * Set start date
                             * @param {Date} date - Start date
                             */
                            setStartDate: function(date) {
                                this._startpicker.setDate(date);
                            },

                            /**
                             * Returns start-date
                             * @returns {?Date}
                             */
                            getStartDate: function() {
                                return this._startpicker.getDate();
                            },

                            /**
                             * Returns end-date
                             * @returns {?Date}
                             */
                            getEndDate: function() {
                                return this._endpicker.getDate();
                            },

                            /**
                             * Set end date
                             * @param {Date} date - End date
                             */
                            setEndDate: function(date) {
                                this._endpicker.setDate(date);
                            },

                            /**
                             * Set selectable ranges
                             * @param {Array.<Array.<number|Date>>} ranges - Selectable ranges
                             * @see DatePicker#setRanges
                             */
                            setRanges: function(ranges) {
                                this._startpicker.setRanges(ranges);
                                this._syncRangesToEndpicker();
                            },

                            /**
                             * Add a range
                             * @param {Date|number} start - startDate
                             * @param {Date|number} end - endDate
                             * @see DatePicker#addRange
                             */
                            addRange: function(start, end) {
                                this._startpicker.addRange(start, end);
                                this._syncRangesToEndpicker();
                            },

                            /**
                             * Remove a range
                             * @param {Date|number} start - startDate
                             * @param {Date|number} end - endDate
                             * @param {null|'date'|'month'|'year'} type - Range type, If falsy -> Use strict timestamp;
                             * @see DatePicker#removeRange
                             */
                            removeRange: function(start, end, type) {
                                this._startpicker.removeRange(start, end, type);
                                this._syncRangesToEndpicker();
                            },

                            /**
                             * Change language
                             * @param {string} language - Language
                             * @see {@link DatePicker.localeTexts}
                             */
                            changeLanguage: function(language) {
                                this._startpicker.changeLanguage(language);
                                this._endpicker.changeLanguage(language);
                            },

                            /**
                             * Destroy date-range picker
                             */
                            destroy: function() {
                                this.off();
                                this._startpicker.destroy();
                                this._endpicker.destroy();
                                this._startpicker
                                    = this._endpicker
                                    = null;
                            }
                        });

                        snippet.CustomEvents.mixin(DateRangePicker);
                        module.exports = DateRangePicker;


                        /***/ }),
                    /* 50 */
                    /***/ (function(module, exports) {

                        // removed by extract-text-webpack-plugin

                        /***/ })
                    /******/ ])
        });
    });

    var tuiPagination = createCommonjsModule(function (module, exports) {
        /*!
     * TOAST UI Pagination
     * @version 3.4.0
     * @author NHN FE Development Team <dl_javascript@nhn.com>
     * @license MIT
     */
        (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory();
        })(window, function() {
            return /******/ (function(modules) { // webpackBootstrap
                /******/ 	// The module cache
                /******/ 	var installedModules = {};
                /******/
                /******/ 	// The require function
                /******/ 	function __webpack_require__(moduleId) {
                    /******/
                    /******/ 		// Check if module is in cache
                    /******/ 		if(installedModules[moduleId]) {
                        /******/ 			return installedModules[moduleId].exports;
                        /******/ 		}
                    /******/ 		// Create a new module (and put it into the cache)
                    /******/ 		var module = installedModules[moduleId] = {
                        /******/ 			i: moduleId,
                        /******/ 			l: false,
                        /******/ 			exports: {}
                        /******/ 		};
                    /******/
                    /******/ 		// Execute the module function
                    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                    /******/
                    /******/ 		// Flag the module as loaded
                    /******/ 		module.l = true;
                    /******/
                    /******/ 		// Return the exports of the module
                    /******/ 		return module.exports;
                    /******/ 	}
                /******/
                /******/
                /******/ 	// expose the modules object (__webpack_modules__)
                /******/ 	__webpack_require__.m = modules;
                /******/
                /******/ 	// expose the module cache
                /******/ 	__webpack_require__.c = installedModules;
                /******/
                /******/ 	// define getter function for harmony exports
                /******/ 	__webpack_require__.d = function(exports, name, getter) {
                    /******/ 		if(!__webpack_require__.o(exports, name)) {
                        /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
                        /******/ 		}
                    /******/ 	};
                /******/
                /******/ 	// define __esModule on exports
                /******/ 	__webpack_require__.r = function(exports) {
                    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                        /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
                        /******/ 		}
                    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
                    /******/ 	};
                /******/
                /******/ 	// create a fake namespace object
                /******/ 	// mode & 1: value is a module id, require it
                /******/ 	// mode & 2: merge all properties of value into the ns
                /******/ 	// mode & 4: return value when already ns object
                /******/ 	// mode & 8|1: behave like require
                /******/ 	__webpack_require__.t = function(value, mode) {
                    /******/ 		if(mode & 1) value = __webpack_require__(value);
                    /******/ 		if(mode & 8) return value;
                    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
                    /******/ 		var ns = Object.create(null);
                    /******/ 		__webpack_require__.r(ns);
                    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
                    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
                    /******/ 		return ns;
                    /******/ 	};
                /******/
                /******/ 	// getDefaultExport function for compatibility with non-harmony modules
                /******/ 	__webpack_require__.n = function(module) {
                    /******/ 		var getter = module && module.__esModule ?
                        /******/ 			function getDefault() { return module['default']; } :
                        /******/ 			function getModuleExports() { return module; };
                    /******/ 		__webpack_require__.d(getter, 'a', getter);
                    /******/ 		return getter;
                    /******/ 	};
                /******/
                /******/ 	// Object.prototype.hasOwnProperty.call
                /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
                /******/
                /******/ 	// __webpack_public_path__
                /******/ 	__webpack_require__.p = "dist";
                /******/
                /******/
                /******/ 	// Load entry module and return exports
                /******/ 	return __webpack_require__(__webpack_require__.s = 10);
                /******/ })
                /************************************************************************/
                /******/ ([
                    /* 0 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Extend the target object from other objects.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * @module object
                         */

                        /**
                         * Extend the target object from other objects.
                         * @param {object} target - Object that will be extended
                         * @param {...object} objects - Objects as sources
                         * @returns {object} Extended object
                         * @memberof module:object
                         */
                        function extend(target, objects) { // eslint-disable-line no-unused-vars
                            var hasOwnProp = Object.prototype.hasOwnProperty;
                            var source, prop, i, len;

                            for (i = 1, len = arguments.length; i < len; i += 1) {
                                source = arguments[i];
                                for (prop in source) {
                                    if (hasOwnProp.call(source, prop)) {
                                        target[prop] = source[prop];
                                    }
                                }
                            }

                            return target;
                        }

                        module.exports = extend;


                        /***/ }),
                    /* 1 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Check whether the given variable is undefined or not.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Check whether the given variable is undefined or not.
                         * If the given variable is undefined, returns true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is undefined?
                         * @memberof module:type
                         */
                        function isUndefined(obj) {
                            return obj === undefined; // eslint-disable-line no-undefined
                        }

                        module.exports = isUndefined;


                        /***/ }),
                    /* 2 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Check whether the given variable is an instance of Array or not.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Check whether the given variable is an instance of Array or not.
                         * If the given variable is an instance of Array, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is array instance?
                         * @memberof module:type
                         */
                        function isArray(obj) {
                            return obj instanceof Array;
                        }

                        module.exports = isArray;


                        /***/ }),
                    /* 3 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var isArray = __webpack_require__(2);
                        var forEachArray = __webpack_require__(17);
                        var forEachOwnProperties = __webpack_require__(6);

                        /**
                         * @module collection
                         */

                        /**
                         * Execute the provided callback once for each property of object(or element of array) which actually exist.
                         * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
                         * If the callback function returns false, the loop will be stopped.
                         * Callback function(iteratee) is invoked with three arguments:
                         *  1) The value of the property(or The value of the element)
                         *  2) The name of the property(or The index of the element)
                         *  3) The object being traversed
                         * @param {Object} obj The object that will be traversed
                         * @param {function} iteratee Callback function
                         * @param {Object} [context] Context(this) of callback function
                         * @memberof module:collection
                         * @example
                         * var forEach = require('tui-code-snippet/collection/forEach'); // node, commonjs
                         *
                         * var sum = 0;
                         *
                         * forEach([1,2,3], function(value){
                         *     sum += value;
                         * });
                         * alert(sum); // 6
                         *
                         * // In case of Array-like object
                         * var array = Array.prototype.slice.call(arrayLike); // change to array
                         * forEach(array, function(value){
                         *     sum += value;
                         * });
                         */
                        function forEach(obj, iteratee, context) {
                            if (isArray(obj)) {
                                forEachArray(obj, iteratee, context);
                            } else {
                                forEachOwnProperties(obj, iteratee, context);
                            }
                        }

                        module.exports = forEach;


                        /***/ }),
                    /* 4 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Check whether the given variable is a string or not.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Check whether the given variable is a string or not.
                         * If the given variable is a string, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is string?
                         * @memberof module:type
                         */
                        function isString(obj) {
                            return typeof obj === 'string' || obj instanceof String;
                        }

                        module.exports = isString;


                        /***/ }),
                    /* 5 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Check whether the given variable is a function or not.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Check whether the given variable is a function or not.
                         * If the given variable is a function, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is function?
                         * @memberof module:type
                         */
                        function isFunction(obj) {
                            return obj instanceof Function;
                        }

                        module.exports = isFunction;


                        /***/ }),
                    /* 6 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Execute the provided callback once for each property of object which actually exist.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Execute the provided callback once for each property of object which actually exist.
                         * If the callback function returns false, the loop will be stopped.
                         * Callback function(iteratee) is invoked with three arguments:
                         *  1) The value of the property
                         *  2) The name of the property
                         *  3) The object being traversed
                         * @param {Object} obj The object that will be traversed
                         * @param {function} iteratee  Callback function
                         * @param {Object} [context] Context(this) of callback function
                         * @memberof module:collection
                         * @example
                         * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
                         *
                         * var sum = 0;
                         *
                         * forEachOwnProperties({a:1,b:2,c:3}, function(value){
                         *     sum += value;
                         * });
                         * alert(sum); // 6
                         */
                        function forEachOwnProperties(obj, iteratee, context) {
                            var key;

                            context = context || null;

                            for (key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    if (iteratee.call(context, obj[key], key, obj) === false) {
                                        break;
                                    }
                                }
                            }
                        }

                        module.exports = forEachOwnProperties;


                        /***/ }),
                    /* 7 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview
                         * This module provides a function to make a constructor
                         * that can inherit from the other constructors like the CLASS easily.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var inherit = __webpack_require__(18);
                        var extend = __webpack_require__(0);

                        /**
                         * @module defineClass
                         */

                        /**
                         * Help a constructor to be defined and to inherit from the other constructors
                         * @param {*} [parent] Parent constructor
                         * @param {Object} props Members of constructor
                         *  @param {Function} props.init Initialization method
                         *  @param {Object} [props.static] Static members of constructor
                         * @returns {*} Constructor
                         * @memberof module:defineClass
                         * @example
                         * var defineClass = require('tui-code-snippet/defineClass/defineClass'); // node, commonjs
                         *
                         * //-- #2. Use property --//
                         * var Parent = defineClass({
                         *     init: function() { // constuructor
                         *         this.name = 'made by def';
                         *     },
                         *     method: function() {
                         *         // ...
                         *     },
                         *     static: {
                         *         staticMethod: function() {
                         *              // ...
                         *         }
                         *     }
                         * });
                         *
                         * var Child = defineClass(Parent, {
                         *     childMethod: function() {}
                         * });
                         *
                         * Parent.staticMethod();
                         *
                         * var parentInstance = new Parent();
                         * console.log(parentInstance.name); //made by def
                         * parentInstance.staticMethod(); // Error
                         *
                         * var childInstance = new Child();
                         * childInstance.method();
                         * childInstance.childMethod();
                         */
                        function defineClass(parent, props) {
                            var obj;

                            if (!props) {
                                props = parent;
                                parent = null;
                            }

                            obj = props.init || function() {};

                            if (parent) {
                                inherit(obj, parent);
                            }

                            if (props.hasOwnProperty('static')) {
                                extend(obj, props['static']);
                                delete props['static'];
                            }

                            extend(obj.prototype, props);

                            return obj;
                        }

                        module.exports = defineClass;


                        /***/ }),
                    /* 8 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /* eslint-disable complexity */
                        /**
                         * @fileoverview Returns the first index at which a given element can be found in the array.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var isArray = __webpack_require__(2);

                        /**
                         * @module array
                         */

                        /**
                         * Returns the first index at which a given element can be found in the array
                         * from start index(default 0), or -1 if it is not present.
                         * It compares searchElement to elements of the Array using strict equality
                         * (the same method used by the ===, or triple-equals, operator).
                         * @param {*} searchElement Element to locate in the array
                         * @param {Array} array Array that will be traversed.
                         * @param {number} startIndex Start index in array for searching (default 0)
                         * @returns {number} the First index at which a given element, or -1 if it is not present
                         * @memberof module:array
                         * @example
                         * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
                         *
                         * var arr = ['one', 'two', 'three', 'four'];
                         * var idx1 = inArray('one', arr, 3); // -1
                         * var idx2 = inArray('one', arr); // 0
                         */
                        function inArray(searchElement, array, startIndex) {
                            var i;
                            var length;
                            startIndex = startIndex || 0;

                            if (!isArray(array)) {
                                return -1;
                            }

                            if (Array.prototype.indexOf) {
                                return Array.prototype.indexOf.call(array, searchElement, startIndex);
                            }

                            length = array.length;
                            for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
                                if (array[i] === searchElement) {
                                    return i;
                                }
                            }

                            return -1;
                        }

                        module.exports = inArray;


                        /***/ }),
                    /* 9 */
                    /***/ (function(module, exports, __webpack_require__) {


                        var template = __webpack_require__(29);
                        var sendHostname = __webpack_require__(30);
                        var isFunction = __webpack_require__(5);

                        var util = {
                            /**
                             * Capitalize first letter
                             * @param {string} str - String to change
                             * @returns {string} Changed string
                             */
                            capitalizeFirstLetter: function(str) {
                                return str.substring(0, 1).toUpperCase() + str.substring(1, str.length);
                            },

                            /**
                             * Check the element is contained
                             * @param {HTMLElement} find - Target element
                             * @param {HTMLElement} parent - Wrapper element
                             * @returns {boolean} Whether contained or not
                             */
                            isContained: function(find, parent) {
                                if (!parent) {
                                    return false;
                                }

                                return find === parent ? true : parent.contains(find);
                            },

                            /**
                             * Create an new element by template literals.
                             * @param {string|function} tmpl - template
                             * @param {Object} context - context
                             * @returns {HTMLElement}
                             */
                            createElementByTemplate: function(tmpl, context) {
                                var parent = document.createElement('div');
                                var html = isFunction(tmpl) ? tmpl(context) : template(tmpl, context);
                                parent.innerHTML = html;

                                return parent.firstChild;
                            },

                            /**
                             * Create a new function that, when called, has its this keyword set to the provided value.
                             * @param {function} fn A original function before binding
                             * @param {*} obj context of function in arguments[0]
                             * @returns {function} A new bound function with context that is in arguments[1]
                             */
                            bind: function(fn, obj) {
                                var slice = Array.prototype.slice;
                                var args;

                                if (fn.bind) {
                                    return fn.bind.apply(fn, slice.call(arguments, 1));
                                }

                                args = slice.call(arguments, 2);

                                return function() {
                                    return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
                                };
                            },

                            /**
                             * Send hostname for GA
                             * @ignore
                             */
                            sendHostName: function() {
                                sendHostname('pagination', 'UA-129987462-1');
                            }
                        };

                        module.exports = util;


                        /***/ }),
                    /* 10 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview The entry file of Pagination components
                         * @author NHN. FE Development Lab <dl_javascript@nhn.com>
                         */



                        __webpack_require__(11);

                        module.exports = __webpack_require__(12);


                        /***/ }),
                    /* 11 */
                    /***/ (function(module, exports, __webpack_require__) {

                        // extracted by mini-css-extract-plugin

                        /***/ }),
                    /* 12 */
                    /***/ (function(module, exports, __webpack_require__) {


                        var CustomEvents = __webpack_require__(13);
                        var defineClass = __webpack_require__(7);
                        var extend = __webpack_require__(0);
                        var isUndefined = __webpack_require__(1);

                        var View = __webpack_require__(20);
                        var util = __webpack_require__(9);

                        var defaultOption = {
                            totalItems: 10,
                            itemsPerPage: 10,
                            visiblePages: 10,
                            page: 1,
                            centerAlign: false,
                            firstItemClassName: 'tui-first-child',
                            lastItemClassName: 'tui-last-child',
                            usageStatistics: true
                        };

                        /**
                         * Pagination class
                         * @class Pagination
                         * @param {string|HTMLElement|jQueryObject} container - Container element or selector.
                         * In case of a string, it is considered as an id selector and find the element by id.
                         * If there is no element, it is considered as a selector and find the element by querySelector().
                         * Passing jQueryObject and considering an id selector at first will be deprecated in v4.0.0.
                         * @param {object} options - Option object
                         *     @param {number} [options.totalItems=10] Total item count
                         *     @param {number} [options.itemsPerPage=10] Item count per page
                         *     @param {number} [options.visiblePages=10] Display page link count
                         *     @param {number} [options.page=1] Display page after pagination draw.
                         *     @param {boolean}[options.centerAlign=false] Whether current page keep center or not
                         *     @param {string} [options.firstItemClassName='first-child'] The class name of the first item
                         *     @param {string} [options.lastItemClassName='last-child'] The class name of the last item
                         *     @param {object} [options.template] A markup string set to make element. Refer to {@link https://github.com/nhn/tui.pagination/blob/master/docs/getting-started.md#how-to-use-template Getting Started: How to use template}.
                         *         @param {string|function} [options.template.page] HTML template
                         *         @param {string|function} [options.template.currentPage] HTML template
                         *         @param {string|function} [options.template.moveButton] HTML template
                         *         @param {string|function} [options.template.disabledMoveButton] HTML template
                         *         @param {string|function} [options.template.moreButton] HTML template
                         *     @param {boolean} [options.usageStatistics=true] Send the hostname to google analytics.
                         *         If you do not want to send the hostname, this option set to false.
                         * @example
                         * var Pagination = tui.Pagination; // or require('tui-pagination')
                         *
                         * var container = document.getElementById('pagination');
                         * var options = { // below default value of options
                         *      totalItems: 10,
                         *      itemsPerPage: 10,
                         *      visiblePages: 10,
                         *      page: 1,
                         *      centerAlign: false,
                         *      firstItemClassName: 'tui-first-child',
                         *      lastItemClassName: 'tui-last-child',
                         *      template: {
                         *          page: '<a href="#" class="tui-page-btn">{{page}}</a>',
                         *          currentPage: '<strong class="tui-page-btn tui-is-selected">{{page}}</strong>',
                         *          moveButton:
                         *              '<a href="#" class="tui-page-btn tui-{{type}}">' +
                         *                  '<span class="tui-ico-{{type}}">{{type}}</span>' +
                         *              '</a>',
                         *          disabledMoveButton:
                         *              '<span class="tui-page-btn tui-is-disabled tui-{{type}}">' +
                         *                  '<span class="tui-ico-{{type}}">{{type}}</span>' +
                         *              '</span>',
                         *          moreButton:
                         *              '<a href="#" class="tui-page-btn tui-{{type}}-is-ellip">' +
                         *                  '<span class="tui-ico-ellip">...</span>' +
                         *              '</a>'
                         *      }
                         * };
                         * var pagination = new Pagination(container, options);
                         */
                        var Pagination = defineClass(
                            /** @lends Pagination.prototype */ {
                                init: function(container, options) {
                                    /**
                                     * Option object
                                     * @type {object}
                                     * @private
                                     */
                                    this._options = extend({}, defaultOption, options);

                                    /**
                                     * Current page number
                                     * @type {number}
                                     * @private
                                     */
                                    this._currentPage = 0;

                                    /**
                                     * View instance
                                     * @type {View}
                                     * @private
                                     */
                                    this._view = new View(container, this._options, util.bind(this._onClickHandler, this));

                                    this._paginate();

                                    if (this._options.usageStatistics) {
                                        util.sendHostName();
                                    }
                                },

                                /**
                                 * Set current page
                                 * @param {number} page - Current page
                                 * @private
                                 */
                                _setCurrentPage: function(page) {
                                    this._currentPage = page || this._options.page;
                                },

                                /**
                                 * Get last page number
                                 * @returns {number} Last page number
                                 * @private
                                 */
                                _getLastPage: function() {
                                    var lastPage = Math.ceil(this._options.totalItems / this._options.itemsPerPage);

                                    return !lastPage ? 1 : lastPage;
                                },

                                /**
                                 * Index of list in total lists
                                 * @param {number} pageNumber - Page number
                                 * @returns {number} Page index or number
                                 * @private
                                 */
                                _getPageIndex: function(pageNumber) {
                                    var left, pageIndex;

                                    if (this._options.centerAlign) {
                                        left = Math.floor(this._options.visiblePages / 2);
                                        pageIndex = pageNumber - left;
                                        pageIndex = Math.max(pageIndex, 1);
                                        pageIndex = Math.min(pageIndex, this._getLastPage() - this._options.visiblePages + 1);

                                        return pageIndex;
                                    }

                                    return Math.ceil(pageNumber / this._options.visiblePages);
                                },

                                /**
                                 * Get relative page
                                 * @param {string} moveType - Move type ('prev' or 'next')
                                 * @returns {number} Relative page number
                                 * @private
                                 */
                                _getRelativePage: function(moveType) {
                                    var isPrevMove = moveType === 'prev';
                                    var currentPage = this.getCurrentPage();

                                    return isPrevMove ? currentPage - 1 : currentPage + 1;
                                },

                                /**
                                 * Get more page index
                                 * @param {string} moveType - Move type ('prev' or 'next')
                                 * @returns {number} Page index
                                 * @private
                                 */
                                _getMorePageIndex: function(moveType) {
                                    var currentPageIndex = this._getPageIndex(this.getCurrentPage());
                                    var pageCount = this._options.visiblePages;
                                    var isPrevMove = moveType === 'prev';
                                    var pageIndex;

                                    if (this._options.centerAlign) {
                                        pageIndex = isPrevMove ? currentPageIndex - 1 : currentPageIndex + pageCount;
                                    } else {
                                        pageIndex = isPrevMove
                                            ? (currentPageIndex - 1) * pageCount
                                            : currentPageIndex * pageCount + 1;
                                    }

                                    return pageIndex;
                                },
                                /* eslint-enable complexity */

                                /**
                                 * Get available page number from over number
                                 * If total page is 23, but input number is 30 => return 23
                                 * @param {number} page - Page number
                                 * @returns {number} Replaced pgae number
                                 * @private
                                 */
                                _convertToValidPage: function(page) {
                                    var lastPageNumber = this._getLastPage();
                                    page = Math.max(page, 1);
                                    page = Math.min(page, lastPageNumber);

                                    return page;
                                },

                                /**
                                 * Create require view set, notify view to update
                                 * @param {number} page - Page number
                                 * @private
                                 */
                                _paginate: function(page) {
                                    var viewData = this._makeViewData(page || this._options.page);
                                    this._setCurrentPage(page);
                                    this._view.update(viewData);
                                },

                                /**
                                 * Create and get view data
                                 * @param {number} page - Page number
                                 * @returns {object} view data
                                 * @private
                                 */
                                _makeViewData: function(page) {
                                    var viewData = {};
                                    var lastPage = this._getLastPage();
                                    var currentPageIndex = this._getPageIndex(page);
                                    var lastPageListIndex = this._getPageIndex(lastPage);
                                    var edges = this._getEdge(page);

                                    viewData.leftPageNumber = edges.left;
                                    viewData.rightPageNumber = edges.right;

                                    viewData.prevMore = currentPageIndex > 1;
                                    viewData.nextMore = currentPageIndex < lastPageListIndex;

                                    viewData.page = page;
                                    viewData.currentPageIndex = page;
                                    viewData.lastPage = lastPage;
                                    viewData.lastPageListIndex = lastPage;

                                    return viewData;
                                },

                                /**
                                 * Get each edge page
                                 * @param {object} page - Page number
                                 * @returns {{left: number, right: number}} Edge page numbers
                                 * @private
                                 */
                                _getEdge: function(page) {
                                    var leftPageNumber, rightPageNumber, left;
                                    var lastPage = this._getLastPage();
                                    var visiblePages = this._options.visiblePages;
                                    var currentPageIndex = this._getPageIndex(page);

                                    if (this._options.centerAlign) {
                                        left = Math.floor(visiblePages / 2);
                                        leftPageNumber = Math.max(page - left, 1);
                                        rightPageNumber = leftPageNumber + visiblePages - 1;

                                        if (rightPageNumber > lastPage) {
                                            leftPageNumber = Math.max(lastPage - visiblePages + 1, 1);
                                            rightPageNumber = lastPage;
                                        }
                                    } else {
                                        leftPageNumber = (currentPageIndex - 1) * visiblePages + 1;
                                        rightPageNumber = currentPageIndex * visiblePages;
                                        rightPageNumber = Math.min(rightPageNumber, lastPage);
                                    }

                                    return {
                                        left: leftPageNumber,
                                        right: rightPageNumber
                                    };
                                },

                                /**
                                 * Pagelist click event hadnler
                                 * @param {?string} buttonType - Button type
                                 * @param {?number} page - Page number
                                 * @private
                                 */
                                /* eslint-disable complexity */
                                _onClickHandler: function(buttonType, page) {
                                    switch (buttonType) {
                                        case 'first':
                                            page = 1;
                                            break;
                                        case 'prev':
                                            page = this._getRelativePage('prev');
                                            break;
                                        case 'next':
                                            page = this._getRelativePage('next');
                                            break;
                                        case 'prevMore':
                                            page = this._getMorePageIndex('prev');
                                            break;
                                        case 'nextMore':
                                            page = this._getMorePageIndex('next');
                                            break;
                                        case 'last':
                                            page = this._getLastPage();
                                            break;
                                        default:
                                            if (!page) {
                                                return;
                                            }
                                    }

                                    this.movePageTo(page);
                                },
                                /* eslint-enable complexity */

                                /**
                                 * Reset pagination
                                 * @param {*} totalItems - Redraw page item count
                                 * @example
                                 * pagination.reset();
                                 * pagination.reset(100);
                                 */
                                reset: function(totalItems) {
                                    if (isUndefined(totalItems)) {
                                        totalItems = this._options.totalItems;
                                    }

                                    this._options.totalItems = totalItems;
                                    this._paginate(1);
                                },

                                /**
                                 * Move to specific page, redraw list.
                                 * Before move fire beforeMove event, After move fire afterMove event.
                                 * @param {Number} targetPage - Target page
                                 * @example
                                 * pagination.movePageTo(10);
                                 */
                                movePageTo: function(targetPage) {
                                    targetPage = this._convertToValidPage(targetPage);

                                    /**
                                     * @event Pagination#beforeMove
                                     * @type {object} evt - Custom event object
                                     * @property {number} page - Moved page
                                     * @example
                                     * paganation.on('beforeMove', function(evt) {
                                     *     var currentPage = evt.page;
                                     *
                                     *     if (currentPage === 10) {
                                     *         return false;
                                     *         // return true;
                                     *     }
                                     * });
                                     */
                                    if (!this.invoke('beforeMove', { page: targetPage })) {
                                        return;
                                    }

                                    this._paginate(targetPage);

                                    /**
                                     * @event Pagination#afterMove
                                     * @type {object} evt - Custom event object
                                     * @property {number} page - Moved page
                                     * @example
                                     * paganation.on('afterMove', function(evt) {
                                     *      var currentPage = evt.page;
                                     *      console.log(currentPage);
                                     * });
                                     */
                                    this.fire('afterMove', { page: targetPage });
                                },

                                /**
                                 * Set total count of items
                                 * @param {number} itemCount - Total item count
                                 */
                                setTotalItems: function(itemCount) {
                                    this._options.totalItems = itemCount;
                                },

                                /**
                                 * Set count of items per page
                                 * @param {number} itemCount - Item count
                                 */
                                setItemsPerPage: function(itemCount) {
                                    this._options.itemsPerPage = itemCount;
                                },

                                /**
                                 * Get current page
                                 * @returns {number} Current page
                                 */
                                getCurrentPage: function() {
                                    return this._currentPage || this._options.page;
                                }
                            }
                        );

                        CustomEvents.mixin(Pagination);

                        module.exports = Pagination;


                        /***/ }),
                    /* 13 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview This module provides some functions for custom events. And it is implemented in the observer design pattern.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var extend = __webpack_require__(0);
                        var isExisty = __webpack_require__(14);
                        var isString = __webpack_require__(4);
                        var isObject = __webpack_require__(16);
                        var isArray = __webpack_require__(2);
                        var isFunction = __webpack_require__(5);
                        var forEach = __webpack_require__(3);

                        var R_EVENTNAME_SPLIT = /\s+/g;

                        /**
                         * @class
                         * @example
                         * // node, commonjs
                         * var CustomEvents = require('tui-code-snippet/customEvents/customEvents');
                         */
                        function CustomEvents() {
                            /**
                             * @type {HandlerItem[]}
                             */
                            this.events = null;

                            /**
                             * only for checking specific context event was binded
                             * @type {object[]}
                             */
                            this.contexts = null;
                        }

                        /**
                         * Mixin custom events feature to specific constructor
                         * @param {function} func - constructor
                         * @example
                         * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
                         *
                         * var model;
                         * function Model() {
                         *     this.name = '';
                         * }
                         * CustomEvents.mixin(Model);
                         *
                         * model = new Model();
                         * model.on('change', function() { this.name = 'model'; }, this);
                         * model.fire('change');
                         * alert(model.name); // 'model';
                         */
                        CustomEvents.mixin = function(func) {
                            extend(func.prototype, CustomEvents.prototype);
                        };

                        /**
                         * Get HandlerItem object
                         * @param {function} handler - handler function
                         * @param {object} [context] - context for handler
                         * @returns {HandlerItem} HandlerItem object
                         * @private
                         */
                        CustomEvents.prototype._getHandlerItem = function(handler, context) {
                            var item = {handler: handler};

                            if (context) {
                                item.context = context;
                            }

                            return item;
                        };

                        /**
                         * Get event object safely
                         * @param {string} [eventName] - create sub event map if not exist.
                         * @returns {(object|array)} event object. if you supplied `eventName`
                         *  parameter then make new array and return it
                         * @private
                         */
                        CustomEvents.prototype._safeEvent = function(eventName) {
                            var events = this.events;
                            var byName;

                            if (!events) {
                                events = this.events = {};
                            }

                            if (eventName) {
                                byName = events[eventName];

                                if (!byName) {
                                    byName = [];
                                    events[eventName] = byName;
                                }

                                events = byName;
                            }

                            return events;
                        };

                        /**
                         * Get context array safely
                         * @returns {array} context array
                         * @private
                         */
                        CustomEvents.prototype._safeContext = function() {
                            var context = this.contexts;

                            if (!context) {
                                context = this.contexts = [];
                            }

                            return context;
                        };

                        /**
                         * Get index of context
                         * @param {object} ctx - context that used for bind custom event
                         * @returns {number} index of context
                         * @private
                         */
                        CustomEvents.prototype._indexOfContext = function(ctx) {
                            var context = this._safeContext();
                            var index = 0;

                            while (context[index]) {
                                if (ctx === context[index][0]) {
                                    return index;
                                }

                                index += 1;
                            }

                            return -1;
                        };

                        /**
                         * Memorize supplied context for recognize supplied object is context or
                         *  name: handler pair object when off()
                         * @param {object} ctx - context object to memorize
                         * @private
                         */
                        CustomEvents.prototype._memorizeContext = function(ctx) {
                            var context, index;

                            if (!isExisty(ctx)) {
                                return;
                            }

                            context = this._safeContext();
                            index = this._indexOfContext(ctx);

                            if (index > -1) {
                                context[index][1] += 1;
                            } else {
                                context.push([ctx, 1]);
                            }
                        };

                        /**
                         * Forget supplied context object
                         * @param {object} ctx - context object to forget
                         * @private
                         */
                        CustomEvents.prototype._forgetContext = function(ctx) {
                            var context, contextIndex;

                            if (!isExisty(ctx)) {
                                return;
                            }

                            context = this._safeContext();
                            contextIndex = this._indexOfContext(ctx);

                            if (contextIndex > -1) {
                                context[contextIndex][1] -= 1;

                                if (context[contextIndex][1] <= 0) {
                                    context.splice(contextIndex, 1);
                                }
                            }
                        };

                        /**
                         * Bind event handler
                         * @param {(string|{name:string, handler:function})} eventName - custom
                         *  event name or an object {eventName: handler}
                         * @param {(function|object)} [handler] - handler function or context
                         * @param {object} [context] - context for binding
                         * @private
                         */
                        CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
                            var events = this._safeEvent(eventName);
                            this._memorizeContext(context);
                            events.push(this._getHandlerItem(handler, context));
                        };

                        /**
                         * Bind event handlers
                         * @param {(string|{name:string, handler:function})} eventName - custom
                         *  event name or an object {eventName: handler}
                         * @param {(function|object)} [handler] - handler function or context
                         * @param {object} [context] - context for binding
                         * //-- #1. Get Module --//
                         * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
                         *
                         * //-- #2. Use method --//
                         * // # 2.1 Basic Usage
                         * CustomEvents.on('onload', handler);
                         *
                         * // # 2.2 With context
                         * CustomEvents.on('onload', handler, myObj);
                         *
                         * // # 2.3 Bind by object that name, handler pairs
                         * CustomEvents.on({
                         *     'play': handler,
                         *     'pause': handler2
                         * });
                         *
                         * // # 2.4 Bind by object that name, handler pairs with context object
                         * CustomEvents.on({
                         *     'play': handler
                         * }, myObj);
                         */
                        CustomEvents.prototype.on = function(eventName, handler, context) {
                            var self = this;

                            if (isString(eventName)) {
                                // [syntax 1, 2]
                                eventName = eventName.split(R_EVENTNAME_SPLIT);
                                forEach(eventName, function(name) {
                                    self._bindEvent(name, handler, context);
                                });
                            } else if (isObject(eventName)) {
                                // [syntax 3, 4]
                                context = handler;
                                forEach(eventName, function(func, name) {
                                    self.on(name, func, context);
                                });
                            }
                        };

                        /**
                         * Bind one-shot event handlers
                         * @param {(string|{name:string,handler:function})} eventName - custom
                         *  event name or an object {eventName: handler}
                         * @param {function|object} [handler] - handler function or context
                         * @param {object} [context] - context for binding
                         */
                        CustomEvents.prototype.once = function(eventName, handler, context) {
                            var self = this;

                            if (isObject(eventName)) {
                                context = handler;
                                forEach(eventName, function(func, name) {
                                    self.once(name, func, context);
                                });

                                return;
                            }

                            function onceHandler() { // eslint-disable-line require-jsdoc
                                handler.apply(context, arguments);
                                self.off(eventName, onceHandler, context);
                            }

                            this.on(eventName, onceHandler, context);
                        };

                        /**
                         * Splice supplied array by callback result
                         * @param {array} arr - array to splice
                         * @param {function} predicate - function return boolean
                         * @private
                         */
                        CustomEvents.prototype._spliceMatches = function(arr, predicate) {
                            var i = 0;
                            var len;

                            if (!isArray(arr)) {
                                return;
                            }

                            for (len = arr.length; i < len; i += 1) {
                                if (predicate(arr[i]) === true) {
                                    arr.splice(i, 1);
                                    len -= 1;
                                    i -= 1;
                                }
                            }
                        };

                        /**
                         * Get matcher for unbind specific handler events
                         * @param {function} handler - handler function
                         * @returns {function} handler matcher
                         * @private
                         */
                        CustomEvents.prototype._matchHandler = function(handler) {
                            var self = this;

                            return function(item) {
                                var needRemove = handler === item.handler;

                                if (needRemove) {
                                    self._forgetContext(item.context);
                                }

                                return needRemove;
                            };
                        };

                        /**
                         * Get matcher for unbind specific context events
                         * @param {object} context - context
                         * @returns {function} object matcher
                         * @private
                         */
                        CustomEvents.prototype._matchContext = function(context) {
                            var self = this;

                            return function(item) {
                                var needRemove = context === item.context;

                                if (needRemove) {
                                    self._forgetContext(item.context);
                                }

                                return needRemove;
                            };
                        };

                        /**
                         * Get matcher for unbind specific hander, context pair events
                         * @param {function} handler - handler function
                         * @param {object} context - context
                         * @returns {function} handler, context matcher
                         * @private
                         */
                        CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
                            var self = this;

                            return function(item) {
                                var matchHandler = (handler === item.handler);
                                var matchContext = (context === item.context);
                                var needRemove = (matchHandler && matchContext);

                                if (needRemove) {
                                    self._forgetContext(item.context);
                                }

                                return needRemove;
                            };
                        };

                        /**
                         * Unbind event by event name
                         * @param {string} eventName - custom event name to unbind
                         * @param {function} [handler] - handler function
                         * @private
                         */
                        CustomEvents.prototype._offByEventName = function(eventName, handler) {
                            var self = this;
                            var andByHandler = isFunction(handler);
                            var matchHandler = self._matchHandler(handler);

                            eventName = eventName.split(R_EVENTNAME_SPLIT);

                            forEach(eventName, function(name) {
                                var handlerItems = self._safeEvent(name);

                                if (andByHandler) {
                                    self._spliceMatches(handlerItems, matchHandler);
                                } else {
                                    forEach(handlerItems, function(item) {
                                        self._forgetContext(item.context);
                                    });

                                    self.events[name] = [];
                                }
                            });
                        };

                        /**
                         * Unbind event by handler function
                         * @param {function} handler - handler function
                         * @private
                         */
                        CustomEvents.prototype._offByHandler = function(handler) {
                            var self = this;
                            var matchHandler = this._matchHandler(handler);

                            forEach(this._safeEvent(), function(handlerItems) {
                                self._spliceMatches(handlerItems, matchHandler);
                            });
                        };

                        /**
                         * Unbind event by object(name: handler pair object or context object)
                         * @param {object} obj - context or {name: handler} pair object
                         * @param {function} handler - handler function
                         * @private
                         */
                        CustomEvents.prototype._offByObject = function(obj, handler) {
                            var self = this;
                            var matchFunc;

                            if (this._indexOfContext(obj) < 0) {
                                forEach(obj, function(func, name) {
                                    self.off(name, func);
                                });
                            } else if (isString(handler)) {
                                matchFunc = this._matchContext(obj);

                                self._spliceMatches(this._safeEvent(handler), matchFunc);
                            } else if (isFunction(handler)) {
                                matchFunc = this._matchHandlerAndContext(handler, obj);

                                forEach(this._safeEvent(), function(handlerItems) {
                                    self._spliceMatches(handlerItems, matchFunc);
                                });
                            } else {
                                matchFunc = this._matchContext(obj);

                                forEach(this._safeEvent(), function(handlerItems) {
                                    self._spliceMatches(handlerItems, matchFunc);
                                });
                            }
                        };

                        /**
                         * Unbind custom events
                         * @param {(string|object|function)} eventName - event name or context or
                         *  {name: handler} pair object or handler function
                         * @param {(function)} handler - handler function
                         * @example
                         * //-- #1. Get Module --//
                         * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
                         *
                         * //-- #2. Use method --//
                         * // # 2.1 off by event name
                         * CustomEvents.off('onload');
                         *
                         * // # 2.2 off by event name and handler
                         * CustomEvents.off('play', handler);
                         *
                         * // # 2.3 off by handler
                         * CustomEvents.off(handler);
                         *
                         * // # 2.4 off by context
                         * CustomEvents.off(myObj);
                         *
                         * // # 2.5 off by context and handler
                         * CustomEvents.off(myObj, handler);
                         *
                         * // # 2.6 off by context and event name
                         * CustomEvents.off(myObj, 'onload');
                         *
                         * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
                         * CustomEvents.off({
                         *   'play': handler,
                         *   'pause': handler2
                         * });
                         *
                         * // # 2.8 off the all events
                         * CustomEvents.off();
                         */
                        CustomEvents.prototype.off = function(eventName, handler) {
                            if (isString(eventName)) {
                                // [syntax 1, 2]
                                this._offByEventName(eventName, handler);
                            } else if (!arguments.length) {
                                // [syntax 8]
                                this.events = {};
                                this.contexts = [];
                            } else if (isFunction(eventName)) {
                                // [syntax 3]
                                this._offByHandler(eventName);
                            } else if (isObject(eventName)) {
                                // [syntax 4, 5, 6]
                                this._offByObject(eventName, handler);
                            }
                        };

                        /**
                         * Fire custom event
                         * @param {string} eventName - name of custom event
                         */
                        CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
                            this.invoke.apply(this, arguments);
                        };

                        /**
                         * Fire a event and returns the result of operation 'boolean AND' with all
                         *  listener's results.
                         *
                         * So, It is different from {@link CustomEvents#fire}.
                         *
                         * In service code, use this as a before event in component level usually
                         *  for notifying that the event is cancelable.
                         * @param {string} eventName - Custom event name
                         * @param {...*} data - Data for event
                         * @returns {boolean} The result of operation 'boolean AND'
                         * @example
                         * var map = new Map();
                         * map.on({
                         *     'beforeZoom': function() {
                         *         // It should cancel the 'zoom' event by some conditions.
                         *         if (that.disabled && this.getState()) {
                         *             return false;
                         *         }
                         *         return true;
                         *     }
                         * });
                         *
                         * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
                         *     // if true,
                         *     // doSomething
                         * }
                         */
                        CustomEvents.prototype.invoke = function(eventName) {
                            var events, args, index, item;

                            if (!this.hasListener(eventName)) {
                                return true;
                            }

                            events = this._safeEvent(eventName);
                            args = Array.prototype.slice.call(arguments, 1);
                            index = 0;

                            while (events[index]) {
                                item = events[index];

                                if (item.handler.apply(item.context, args) === false) {
                                    return false;
                                }

                                index += 1;
                            }

                            return true;
                        };

                        /**
                         * Return whether at least one of the handlers is registered in the given
                         *  event name.
                         * @param {string} eventName - Custom event name
                         * @returns {boolean} Is there at least one handler in event name?
                         */
                        CustomEvents.prototype.hasListener = function(eventName) {
                            return this.getListenerLength(eventName) > 0;
                        };

                        /**
                         * Return a count of events registered.
                         * @param {string} eventName - Custom event name
                         * @returns {number} number of event
                         */
                        CustomEvents.prototype.getListenerLength = function(eventName) {
                            var events = this._safeEvent(eventName);

                            return events.length;
                        };

                        module.exports = CustomEvents;


                        /***/ }),
                    /* 14 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Check whether the given variable is existing or not.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var isUndefined = __webpack_require__(1);
                        var isNull = __webpack_require__(15);

                        /**
                         * Check whether the given variable is existing or not.
                         * If the given variable is not null and not undefined, returns true.
                         * @param {*} param - Target for checking
                         * @returns {boolean} Is existy?
                         * @memberof module:type
                         * @example
                         * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
                         *
                         * isExisty(''); //true
                         * isExisty(0); //true
                         * isExisty([]); //true
                         * isExisty({}); //true
                         * isExisty(null); //false
                         * isExisty(undefined); //false
                         */
                        function isExisty(param) {
                            return !isUndefined(param) && !isNull(param);
                        }

                        module.exports = isExisty;


                        /***/ }),
                    /* 15 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Check whether the given variable is null or not.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Check whether the given variable is null or not.
                         * If the given variable(arguments[0]) is null, returns true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is null?
                         * @memberof module:type
                         */
                        function isNull(obj) {
                            return obj === null;
                        }

                        module.exports = isNull;


                        /***/ }),
                    /* 16 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Check whether the given variable is an object or not.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Check whether the given variable is an object or not.
                         * If the given variable is an object, return true.
                         * @param {*} obj - Target for checking
                         * @returns {boolean} Is object?
                         * @memberof module:type
                         */
                        function isObject(obj) {
                            return obj === Object(obj);
                        }

                        module.exports = isObject;


                        /***/ }),
                    /* 17 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Execute the provided callback once for each element present
                         * in the array(or Array-like object) in ascending order.
                         * If the callback function returns false, the loop will be stopped.
                         * Callback function(iteratee) is invoked with three arguments:
                         *  1) The value of the element
                         *  2) The index of the element
                         *  3) The array(or Array-like object) being traversed
                         * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
                         * @param {function} iteratee Callback function
                         * @param {Object} [context] Context(this) of callback function
                         * @memberof module:collection
                         * @example
                         * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
                         *
                         * var sum = 0;
                         *
                         * forEachArray([1,2,3], function(value){
                         *     sum += value;
                         * });
                         * alert(sum); // 6
                         */
                        function forEachArray(arr, iteratee, context) {
                            var index = 0;
                            var len = arr.length;

                            context = context || null;

                            for (; index < len; index += 1) {
                                if (iteratee.call(context, arr[index], index, arr) === false) {
                                    break;
                                }
                            }
                        }

                        module.exports = forEachArray;


                        /***/ }),
                    /* 18 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Provide a simple inheritance in prototype-oriented.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var createObject = __webpack_require__(19);

                        /**
                         * Provide a simple inheritance in prototype-oriented.
                         * Caution :
                         *  Don't overwrite the prototype of child constructor.
                         *
                         * @param {function} subType Child constructor
                         * @param {function} superType Parent constructor
                         * @memberof module:inheritance
                         * @example
                         * var inherit = require('tui-code-snippet/inheritance/inherit'); // node, commonjs
                         *
                         * // Parent constructor
                         * function Animal(leg) {
                         *     this.leg = leg;
                         * }
                         * Animal.prototype.growl = function() {
                         *     // ...
                         * };
                         *
                         * // Child constructor
                         * function Person(name) {
                         *     this.name = name;
                         * }
                         *
                         * // Inheritance
                         * inherit(Person, Animal);
                         *
                         * // After this inheritance, please use only the extending of property.
                         * // Do not overwrite prototype.
                         * Person.prototype.walk = function(direction) {
                         *     // ...
                         * };
                         */
                        function inherit(subType, superType) {
                            var prototype = createObject(superType.prototype);
                            prototype.constructor = subType;
                            subType.prototype = prototype;
                        }

                        module.exports = inherit;


                        /***/ }),
                    /* 19 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Create a new object with the specified prototype object and properties.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * @module inheritance
                         */

                        /**
                         * Create a new object with the specified prototype object and properties.
                         * @param {Object} obj This object will be a prototype of the newly-created object.
                         * @returns {Object}
                         * @memberof module:inheritance
                         */
                        function createObject(obj) {
                            function F() {} // eslint-disable-line require-jsdoc
                            F.prototype = obj;

                            return new F();
                        }

                        module.exports = createObject;


                        /***/ }),
                    /* 20 */
                    /***/ (function(module, exports, __webpack_require__) {


                        var forEach = __webpack_require__(3);
                        var defineClass = __webpack_require__(7);
                        var getTarget = __webpack_require__(21);
                        var on = __webpack_require__(22);
                        var preventDefault = __webpack_require__(24);
                        var addClass = __webpack_require__(25);
                        var extend = __webpack_require__(0);
                        var isString = __webpack_require__(4);
                        var isHTMLNode = __webpack_require__(28);

                        var util = __webpack_require__(9);

                        var defaultTemplate = {
                            page: '<a href="#" class="tui-page-btn">{{page}}</a>',
                            currentPage: '<strong class="tui-page-btn tui-is-selected">{{page}}</strong>',
                            moveButton:
                                '<a href="#" class="tui-page-btn tui-{{type}}">' +
                                '<span class="tui-ico-{{type}}">{{type}}</span>' +
                                '</a>',
                            disabledMoveButton:
                                '<span class="tui-page-btn tui-is-disabled tui-{{type}}">' +
                                '<span class="tui-ico-{{type}}">{{type}}</span>' +
                                '</span>',
                            moreButton:
                                '<a href="#" class="tui-page-btn tui-{{type}}-is-ellip">' +
                                '<span class="tui-ico-ellip">...</span>' +
                                '</a>'
                        };
                        var moveButtons = ['first', 'prev', 'next', 'last'];
                        var moreButtons = ['prev', 'next'];

                        var INVALID_CONTAINER_ELEMENT = 'The container element is invalid.';

                        /**
                         * Pagination view class
                         * @class View
                         * @param {string|HTMLElement|jQueryObject} container - Container element or id selector
                         * @param {object} options - Option object
                         *     @param {number} [options.totalItems=10] Total item count
                         *     @param {number} [options.itemsPerPage=10] Item count per page
                         *     @param {number} [options.visiblePages=10] Display page link count
                         *     @param {number} [options.page=1] Display page after pagination draw.
                         *     @param {boolean}[options.centerAlign=false] Whether current page keep center or not
                         *     @param {string} [options.firstItemClassName='first-child'] The class name of the first item
                         *     @param {string} [options.lastItemClassName='last-child'] The class name of the last item
                         *     @param {object} [options.template] A markup string set to make element
                         *         @param {string|function} [options.template.page] HTML template
                         *         @param {string|function} [options.template.currentPage] HTML template
                         *         @param {string|function} [options.template.moveButton] HTML template
                         *         @param {string|function} [options.template.disabledMoveButton] HTML template
                         *         @param {string|function} [options.template.moreButton] HTML template
                         * @param {function} handler - Event handler
                         * @ignore
                         */
                        var View = defineClass(
                            /** @lends View.prototype */ {
                                init: function(container, options, handler) {
                                    /**
                                     * Root element
                                     * @type {HTMLElement}
                                     * @private
                                     */
                                    this._containerElement = null;

                                    /**
                                     * First item's class name
                                     * @type {string}
                                     * @private
                                     */
                                    this._firstItemClassName = options.firstItemClassName;

                                    /**
                                     * Last item's class name
                                     * @type {string}
                                     * @private
                                     */
                                    this._lastItemClassName = options.lastItemClassName;

                                    /**
                                     * Default template
                                     * @type {object.<string, string|function>}
                                     * @private
                                     */
                                    this._template = extend({}, defaultTemplate, options.template);

                                    /**
                                     * Map of buttons
                                     * @type {object.<string, HTMLElement>}
                                     * @private
                                     */
                                    this._buttons = {};

                                    /**
                                     * Enabled page elements list
                                     * @type {array}
                                     * @private
                                     */

                                    this._enabledPageElements = [];

                                    this._setRootElement(container);
                                    this._setMoveButtons();
                                    this._setDisabledMoveButtons();
                                    this._setMoreButtons();
                                    this._attachClickEvent(handler);
                                },
                                /* eslint-enable complexity */

                                /**
                                 * Set root element
                                 * @param {string|HTMLElement|jQueryObject} container - Container element or id selector
                                 * @private
                                 */
                                _setRootElement: function(container) {
                                    if (isString(container)) {
                                        container = document.getElementById(container) || document.querySelector(container);
                                    } else if (container.jquery) {
                                        container = container[0];
                                    }

                                    if (!isHTMLNode(container)) {
                                        throw new Error(INVALID_CONTAINER_ELEMENT);
                                    }

                                    this._containerElement = container;
                                },

                                /**
                                 * Assign move buttons to option
                                 * @private
                                 */
                                _setMoveButtons: function() {
                                    forEach(
                                        moveButtons,
                                        function(type) {
                                            this._buttons[type] = util.createElementByTemplate(this._template.moveButton, {
                                                type: type
                                            });
                                        },
                                        this
                                    );
                                },

                                /**
                                 * Assign disabled move buttons to option
                                 * @private
                                 */
                                _setDisabledMoveButtons: function() {
                                    forEach(
                                        moveButtons,
                                        function(type) {
                                            var key = 'disabled' + util.capitalizeFirstLetter(type);
                                            this._buttons[key] = util.createElementByTemplate(this._template.disabledMoveButton, {
                                                type: type
                                            });
                                        },
                                        this
                                    );
                                },

                                /**
                                 * Assign more buttons to option
                                 * @private
                                 */
                                _setMoreButtons: function() {
                                    forEach(
                                        moreButtons,
                                        function(type) {
                                            var key = type + 'More';
                                            this._buttons[key] = util.createElementByTemplate(this._template.moreButton, {
                                                type: type
                                            });
                                        },
                                        this
                                    );
                                },
                                /* eslint-enable camelcase */

                                /**
                                 * Get container element
                                 * @returns {HTMLElement} Container element
                                 * @private
                                 */
                                _getContainerElement: function() {
                                    return this._containerElement;
                                },

                                /**
                                 * Append first button on container element
                                 * @param {object} viewData - View data to render pagination
                                 * @private
                                 */
                                _appendFirstButton: function(viewData) {
                                    var button;

                                    if (viewData.page > 1) {
                                        button = this._buttons.first;
                                    } else {
                                        button = this._buttons.disabledFirst;
                                    }

                                    this._getContainerElement().appendChild(button);
                                },

                                /**
                                 * Append previous button on container element
                                 * @param {object} viewData - View data to render pagination
                                 * @private
                                 */
                                _appendPrevButton: function(viewData) {
                                    var button;

                                    if (viewData.currentPageIndex > 1) {
                                        button = this._buttons.prev;
                                    } else {
                                        button = this._buttons.disabledPrev;
                                    }

                                    this._getContainerElement().appendChild(button);
                                },

                                /**
                                 * Append next button on container element
                                 * @param {object} viewData - View data to render pagination
                                 * @private
                                 */
                                _appendNextButton: function(viewData) {
                                    var button;

                                    if (viewData.currentPageIndex < viewData.lastPageListIndex) {
                                        button = this._buttons.next;
                                    } else {
                                        button = this._buttons.disabledNext;
                                    }

                                    this._getContainerElement().appendChild(button);
                                },

                                /**
                                 * Append last button on container element
                                 * @param {object} viewData - View data to render pagination
                                 * @private
                                 */
                                _appendLastButton: function(viewData) {
                                    var button;

                                    if (viewData.page < viewData.lastPage) {
                                        button = this._buttons.last;
                                    } else {
                                        button = this._buttons.disabledLast;
                                    }

                                    this._getContainerElement().appendChild(button);
                                },

                                /**
                                 * Append previous more button on container element
                                 * @param {object} viewData - View data to render pagination
                                 * @private
                                 */
                                _appendPrevMoreButton: function(viewData) {
                                    var button;

                                    if (viewData.prevMore) {
                                        button = this._buttons.prevMore;
                                        addClass(button, this._firstItemClassName);
                                        this._getContainerElement().appendChild(button);
                                    }
                                },

                                /**
                                 * Append next more button on container element
                                 * @param {object} viewData - View data to render pagination
                                 * @private
                                 */
                                _appendNextMoreButton: function(viewData) {
                                    var button;

                                    if (viewData.nextMore) {
                                        button = this._buttons.nextMore;
                                        addClass(button, this._lastItemClassName);
                                        this._getContainerElement().appendChild(button);
                                    }
                                },

                                /**
                                 * Append page number elements on container element
                                 * @param {object} viewData - View data to render pagination
                                 * @private
                                 */
                                // eslint-disable-next-line complexity
                                _appendPages: function(viewData) {
                                    var firstPage = viewData.leftPageNumber;
                                    var lastPage = viewData.rightPageNumber;
                                    var pageItem, i;

                                    for (i = firstPage; i <= lastPage; i += 1) {
                                        if (i === viewData.page) {
                                            pageItem = util.createElementByTemplate(this._template.currentPage, { page: i });
                                        } else {
                                            pageItem = util.createElementByTemplate(this._template.page, { page: i });
                                            this._enabledPageElements.push(pageItem);
                                        }

                                        if (i === firstPage && !viewData.prevMore) {
                                            addClass(pageItem, this._firstItemClassName);
                                        }
                                        if (i === lastPage && !viewData.nextMore) {
                                            addClass(pageItem, this._lastItemClassName);
                                        }
                                        this._getContainerElement().appendChild(pageItem);
                                    }
                                },

                                /**
                                 * Attach click event
                                 * @param {function} callback - Callback function
                                 * @private
                                 */
                                _attachClickEvent: function(callback) {
                                    var rootElement = this._getContainerElement();

                                    on(
                                        rootElement,
                                        'click',
                                        function(ev) {
                                            var target = getTarget(ev);
                                            var page, buttonType;

                                            preventDefault(ev);

                                            buttonType = this._getButtonType(target);

                                            if (!buttonType) {
                                                page = this._getPageNumber(target);
                                            }

                                            callback(buttonType, page);
                                        },
                                        this
                                    );
                                },

                                /**
                                 * Get button type to move button elements
                                 * @param {HTMLElement} targetElement - Each move button element
                                 * @returns {?string} Button type
                                 * @private
                                 */
                                _getButtonType: function(targetElement) {
                                    var buttonType;
                                    var buttons = this._buttons;

                                    forEach(
                                        buttons,
                                        function(button, type) {
                                            if (util.isContained(targetElement, button)) {
                                                buttonType = type;

                                                return false;
                                            }

                                            return true;
                                        },
                                        this
                                    );

                                    return buttonType;
                                },
                                /* eslint-enable no-lonely-if */

                                /**
                                 * Get number to page elements
                                 * @param {HTMLElement} targetElement - Each page element
                                 * @returns {?number} Page number
                                 * @private
                                 */
                                _getPageNumber: function(targetElement) {
                                    var targetPage = this._findPageElement(targetElement);
                                    var page;

                                    if (targetPage) {
                                        page = parseInt(targetPage.innerText, 10);
                                    }

                                    return page;
                                },

                                /**
                                 * Find target element from page elements
                                 * @param {HTMLElement} targetElement - Each page element
                                 * @returns {HTMLElement} Found element
                                 * @ignore
                                 */
                                _findPageElement: function(targetElement) {
                                    var i = 0;
                                    var length = this._enabledPageElements.length;
                                    var pickedItem;

                                    for (; i < length; i += 1) {
                                        pickedItem = this._enabledPageElements[i];

                                        if (util.isContained(targetElement, pickedItem)) {
                                            return pickedItem;
                                        }
                                    }

                                    return null;
                                },

                                /**
                                 * Reset container element
                                 * @private
                                 */
                                _empty: function() {
                                    this._enabledPageElements = [];

                                    forEach(
                                        this._buttons,
                                        function(buttonElement, type) {
                                            this._buttons[type] = buttonElement.cloneNode(true);
                                        },
                                        this
                                    );

                                    this._getContainerElement().innerHTML = '';
                                },

                                /**
                                 * Update view
                                 * @param {object} viewData - View data to render pagination
                                 * @ignore
                                 */
                                update: function(viewData) {
                                    this._empty();
                                    this._appendFirstButton(viewData);
                                    this._appendPrevButton(viewData);
                                    this._appendPrevMoreButton(viewData);
                                    this._appendPages(viewData);
                                    this._appendNextMoreButton(viewData);
                                    this._appendNextButton(viewData);
                                    this._appendLastButton(viewData);
                                }
                            }
                        );

                        module.exports = View;


                        /***/ }),
                    /* 21 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Get a target element from an event object.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Get a target element from an event object.
                         * @param {Event} e - event object
                         * @returns {HTMLElement} - target element
                         * @memberof module:domEvent
                         */
                        function getTarget(e) {
                            return e.target || e.srcElement;
                        }

                        module.exports = getTarget;


                        /***/ }),
                    /* 22 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Bind DOM events
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var isString = __webpack_require__(4);
                        var forEach = __webpack_require__(3);

                        var safeEvent = __webpack_require__(23);

                        /**
                         * Bind DOM events.
                         * @param {HTMLElement} element - element to bind events
                         * @param {(string|object)} types - Space splitted events names or eventName:handler object
                         * @param {(function|object)} handler - handler function or context for handler method
                         * @param {object} [context] context - context for handler method.
                         * @memberof module:domEvent
                         * @example
                         * var div = document.querySelector('div');
                         *
                         * // Bind one event to an element.
                         * on(div, 'click', toggle);
                         *
                         * // Bind multiple events with a same handler to multiple elements at once.
                         * // Use event names splitted by a space.
                         * on(div, 'mouseenter mouseleave', changeColor);
                         *
                         * // Bind multiple events with different handlers to an element at once.
                         * // Use an object which of key is an event name and value is a handler function.
                         * on(div, {
                         *   keydown: highlight,
                         *   keyup: dehighlight
                         * });
                         *
                         * // Set a context for handler method.
                         * var name = 'global';
                         * var repository = {name: 'CodeSnippet'};
                         * on(div, 'drag', function() {
                         *  console.log(this.name);
                         * }, repository);
                         * // Result when you drag a div: "CodeSnippet"
                         */
                        function on(element, types, handler, context) {
                            if (isString(types)) {
                                forEach(types.split(/\s+/g), function(type) {
                                    bindEvent(element, type, handler, context);
                                });

                                return;
                            }

                            forEach(types, function(func, type) {
                                bindEvent(element, type, func, handler);
                            });
                        }

                        /**
                         * Bind DOM events
                         * @param {HTMLElement} element - element to bind events
                         * @param {string} type - events name
                         * @param {function} handler - handler function or context for handler method
                         * @param {object} [context] context - context for handler method.
                         * @private
                         */
                        function bindEvent(element, type, handler, context) {
                            /**
                             * Event handler
                             * @param {Event} e - event object
                             */
                            function eventHandler(e) {
                                handler.call(context || element, e || window.event);
                            }

                            if ('addEventListener' in element) {
                                element.addEventListener(type, eventHandler);
                            } else if ('attachEvent' in element) {
                                element.attachEvent('on' + type, eventHandler);
                            }
                            memorizeHandler(element, type, handler, eventHandler);
                        }

                        /**
                         * Memorize DOM event handler for unbinding.
                         * @param {HTMLElement} element - element to bind events
                         * @param {string} type - events name
                         * @param {function} handler - handler function that user passed at on() use
                         * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features
                         * @private
                         */
                        function memorizeHandler(element, type, handler, wrappedHandler) {
                            var events = safeEvent(element, type);
                            var existInEvents = false;

                            forEach(events, function(obj) {
                                if (obj.handler === handler) {
                                    existInEvents = true;

                                    return false;
                                }

                                return true;
                            });

                            if (!existInEvents) {
                                events.push({
                                    handler: handler,
                                    wrappedHandler: wrappedHandler
                                });
                            }
                        }

                        module.exports = on;


                        /***/ }),
                    /* 23 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Get event collection for specific HTML element
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var EVENT_KEY = '_feEventKey';

                        /**
                         * Get event collection for specific HTML element
                         * @param {HTMLElement} element - HTML element
                         * @param {string} type - event type
                         * @returns {array}
                         * @private
                         */
                        function safeEvent(element, type) {
                            var events = element[EVENT_KEY];
                            var handlers;

                            if (!events) {
                                events = element[EVENT_KEY] = {};
                            }

                            handlers = events[type];
                            if (!handlers) {
                                handlers = events[type] = [];
                            }

                            return handlers;
                        }

                        module.exports = safeEvent;


                        /***/ }),
                    /* 24 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Prevent default action
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Prevent default action
                         * @param {Event} e - event object
                         * @memberof module:domEvent
                         */
                        function preventDefault(e) {
                            if (e.preventDefault) {
                                e.preventDefault();

                                return;
                            }

                            e.returnValue = false;
                        }

                        module.exports = preventDefault;


                        /***/ }),
                    /* 25 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Add css class to element
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var forEach = __webpack_require__(3);
                        var inArray = __webpack_require__(8);
                        var getClass = __webpack_require__(26);
                        var setClassName = __webpack_require__(27);

                        /**
                         * domUtil module
                         * @module domUtil
                         */

                        /**
                         * Add css class to element
                         * @param {(HTMLElement|SVGElement)} element - target element
                         * @param {...string} cssClass - css classes to add
                         * @memberof module:domUtil
                         */
                        function addClass(element) {
                            var cssClass = Array.prototype.slice.call(arguments, 1);
                            var classList = element.classList;
                            var newClass = [];
                            var origin;

                            if (classList) {
                                forEach(cssClass, function(name) {
                                    element.classList.add(name);
                                });

                                return;
                            }

                            origin = getClass(element);

                            if (origin) {
                                cssClass = [].concat(origin.split(/\s+/), cssClass);
                            }

                            forEach(cssClass, function(cls) {
                                if (inArray(cls, newClass) < 0) {
                                    newClass.push(cls);
                                }
                            });

                            setClassName(element, newClass);
                        }

                        module.exports = addClass;


                        /***/ }),
                    /* 26 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Get HTML element's design classes.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var isUndefined = __webpack_require__(1);

                        /**
                         * Get HTML element's design classes.
                         * @param {(HTMLElement|SVGElement)} element target element
                         * @returns {string} element css class name
                         * @memberof module:domUtil
                         */
                        function getClass(element) {
                            if (!element || !element.className) {
                                return '';
                            }

                            if (isUndefined(element.className.baseVal)) {
                                return element.className;
                            }

                            return element.className.baseVal;
                        }

                        module.exports = getClass;


                        /***/ }),
                    /* 27 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Set className value
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var isArray = __webpack_require__(2);
                        var isUndefined = __webpack_require__(1);

                        /**
                         * Set className value
                         * @param {(HTMLElement|SVGElement)} element - target element
                         * @param {(string|string[])} cssClass - class names
                         * @private
                         */
                        function setClassName(element, cssClass) {
                            cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

                            cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

                            if (isUndefined(element.className.baseVal)) {
                                element.className = cssClass;

                                return;
                            }

                            element.className.baseVal = cssClass;
                        }

                        module.exports = setClassName;


                        /***/ }),
                    /* 28 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Check whether the given variable is a instance of HTMLNode or not.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        /**
                         * Check whether the given variable is a instance of HTMLNode or not.
                         * If the given variables is a instance of HTMLNode, return true.
                         * @param {*} html - Target for checking
                         * @returns {boolean} Is HTMLNode ?
                         * @memberof module:type
                         */
                        function isHTMLNode(html) {
                            if (typeof HTMLElement === 'object') {
                                return (html && (html instanceof HTMLElement || !!html.nodeType));
                            }

                            return !!(html && html.nodeType);
                        }

                        module.exports = isHTMLNode;


                        /***/ }),
                    /* 29 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Convert text by binding expressions with context.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var inArray = __webpack_require__(8);
                        var forEach = __webpack_require__(3);
                        var isArray = __webpack_require__(2);
                        var isString = __webpack_require__(4);
                        var extend = __webpack_require__(0);

                        // IE8 does not support capture groups.
                        var EXPRESSION_REGEXP = /{{\s?|\s?}}/g;
                        var BRACKET_NOTATION_REGEXP = /^[a-zA-Z0-9_@]+\[[a-zA-Z0-9_@"']+\]$/;
                        var BRACKET_REGEXP = /\[\s?|\s?\]/;
                        var DOT_NOTATION_REGEXP = /^[a-zA-Z_]+\.[a-zA-Z_]+$/;
                        var DOT_REGEXP = /\./;
                        var STRING_NOTATION_REGEXP = /^["']\w+["']$/;
                        var STRING_REGEXP = /"|'/g;
                        var NUMBER_REGEXP = /^-?\d+\.?\d*$/;

                        var EXPRESSION_INTERVAL = 2;

                        var BLOCK_HELPERS = {
                            'if': handleIf,
                            'each': handleEach,
                            'with': handleWith
                        };

                        var isValidSplit = 'a'.split(/a/).length === 3;

                        /**
                         * Split by RegExp. (Polyfill for IE8)
                         * @param {string} text - text to be splitted\
                         * @param {RegExp} regexp - regular expression
                         * @returns {Array.<string>}
                         */
                        var splitByRegExp = (function() {
                            if (isValidSplit) {
                                return function(text, regexp) {
                                    return text.split(regexp);
                                };
                            }

                            return function(text, regexp) {
                                var result = [];
                                var prevIndex = 0;
                                var match, index;

                                if (!regexp.global) {
                                    regexp = new RegExp(regexp, 'g');
                                }

                                match = regexp.exec(text);
                                while (match !== null) {
                                    index = match.index;
                                    result.push(text.slice(prevIndex, index));

                                    prevIndex = index + match[0].length;
                                    match = regexp.exec(text);
                                }
                                result.push(text.slice(prevIndex));

                                return result;
                            };
                        })();

                        /**
                         * Find value in the context by an expression.
                         * @param {string} exp - an expression
                         * @param {object} context - context
                         * @returns {*}
                         * @private
                         */
                        // eslint-disable-next-line complexity
                        function getValueFromContext(exp, context) {
                            var splitedExps;
                            var value = context[exp];

                            if (exp === 'true') {
                                value = true;
                            } else if (exp === 'false') {
                                value = false;
                            } else if (STRING_NOTATION_REGEXP.test(exp)) {
                                value = exp.replace(STRING_REGEXP, '');
                            } else if (BRACKET_NOTATION_REGEXP.test(exp)) {
                                splitedExps = exp.split(BRACKET_REGEXP);
                                value = getValueFromContext(splitedExps[0], context)[getValueFromContext(splitedExps[1], context)];
                            } else if (DOT_NOTATION_REGEXP.test(exp)) {
                                splitedExps = exp.split(DOT_REGEXP);
                                value = getValueFromContext(splitedExps[0], context)[splitedExps[1]];
                            } else if (NUMBER_REGEXP.test(exp)) {
                                value = parseFloat(exp);
                            }

                            return value;
                        }

                        /**
                         * Extract elseif and else expressions.
                         * @param {Array.<string>} ifExps - args of if expression
                         * @param {Array.<string>} sourcesInsideBlock - sources inside if block
                         * @returns {object} - exps: expressions of if, elseif, and else / sourcesInsideIf: sources inside if, elseif, and else block.
                         * @private
                         */
                        function extractElseif(ifExps, sourcesInsideBlock) {
                            var exps = [ifExps];
                            var sourcesInsideIf = [];
                            var otherIfCount = 0;
                            var start = 0;

                            // eslint-disable-next-line complexity
                            forEach(sourcesInsideBlock, function(source, index) {
                                if (source.indexOf('if') === 0) {
                                    otherIfCount += 1;
                                } else if (source === '/if') {
                                    otherIfCount -= 1;
                                } else if (!otherIfCount && (source.indexOf('elseif') === 0 || source === 'else')) {
                                    exps.push(source === 'else' ? ['true'] : source.split(' ').slice(1));
                                    sourcesInsideIf.push(sourcesInsideBlock.slice(start, index));
                                    start = index + 1;
                                }
                            });

                            sourcesInsideIf.push(sourcesInsideBlock.slice(start));

                            return {
                                exps: exps,
                                sourcesInsideIf: sourcesInsideIf
                            };
                        }

                        /**
                         * Helper function for "if".
                         * @param {Array.<string>} exps - array of expressions split by spaces
                         * @param {Array.<string>} sourcesInsideBlock - array of sources inside the if block
                         * @param {object} context - context
                         * @returns {string}
                         * @private
                         */
                        function handleIf(exps, sourcesInsideBlock, context) {
                            var analyzed = extractElseif(exps, sourcesInsideBlock);
                            var result = false;
                            var compiledSource = '';

                            forEach(analyzed.exps, function(exp, index) {
                                result = handleExpression(exp, context);
                                if (result) {
                                    compiledSource = compile(analyzed.sourcesInsideIf[index], context);
                                }

                                return !result;
                            });

                            return compiledSource;
                        }

                        /**
                         * Helper function for "each".
                         * @param {Array.<string>} exps - array of expressions split by spaces
                         * @param {Array.<string>} sourcesInsideBlock - array of sources inside the each block
                         * @param {object} context - context
                         * @returns {string}
                         * @private
                         */
                        function handleEach(exps, sourcesInsideBlock, context) {
                            var collection = handleExpression(exps, context);
                            var additionalKey = isArray(collection) ? '@index' : '@key';
                            var additionalContext = {};
                            var result = '';

                            forEach(collection, function(item, key) {
                                additionalContext[additionalKey] = key;
                                additionalContext['@this'] = item;
                                extend(context, additionalContext);

                                result += compile(sourcesInsideBlock.slice(), context);
                            });

                            return result;
                        }

                        /**
                         * Helper function for "with ... as"
                         * @param {Array.<string>} exps - array of expressions split by spaces
                         * @param {Array.<string>} sourcesInsideBlock - array of sources inside the with block
                         * @param {object} context - context
                         * @returns {string}
                         * @private
                         */
                        function handleWith(exps, sourcesInsideBlock, context) {
                            var asIndex = inArray('as', exps);
                            var alias = exps[asIndex + 1];
                            var result = handleExpression(exps.slice(0, asIndex), context);

                            var additionalContext = {};
                            additionalContext[alias] = result;

                            return compile(sourcesInsideBlock, extend(context, additionalContext)) || '';
                        }

                        /**
                         * Extract sources inside block in place.
                         * @param {Array.<string>} sources - array of sources
                         * @param {number} start - index of start block
                         * @param {number} end - index of end block
                         * @returns {Array.<string>}
                         * @private
                         */
                        function extractSourcesInsideBlock(sources, start, end) {
                            var sourcesInsideBlock = sources.splice(start + 1, end - start);
                            sourcesInsideBlock.pop();

                            return sourcesInsideBlock;
                        }

                        /**
                         * Handle block helper function
                         * @param {string} helperKeyword - helper keyword (ex. if, each, with)
                         * @param {Array.<string>} sourcesToEnd - array of sources after the starting block
                         * @param {object} context - context
                         * @returns {Array.<string>}
                         * @private
                         */
                        function handleBlockHelper(helperKeyword, sourcesToEnd, context) {
                            var executeBlockHelper = BLOCK_HELPERS[helperKeyword];
                            var helperCount = 1;
                            var startBlockIndex = 0;
                            var endBlockIndex;
                            var index = startBlockIndex + EXPRESSION_INTERVAL;
                            var expression = sourcesToEnd[index];

                            while (helperCount && isString(expression)) {
                                if (expression.indexOf(helperKeyword) === 0) {
                                    helperCount += 1;
                                } else if (expression.indexOf('/' + helperKeyword) === 0) {
                                    helperCount -= 1;
                                    endBlockIndex = index;
                                }

                                index += EXPRESSION_INTERVAL;
                                expression = sourcesToEnd[index];
                            }

                            if (helperCount) {
                                throw Error(helperKeyword + ' needs {{/' + helperKeyword + '}} expression.');
                            }

                            sourcesToEnd[startBlockIndex] = executeBlockHelper(
                                sourcesToEnd[startBlockIndex].split(' ').slice(1),
                                extractSourcesInsideBlock(sourcesToEnd, startBlockIndex, endBlockIndex),
                                context
                            );

                            return sourcesToEnd;
                        }

                        /**
                         * Helper function for "custom helper".
                         * If helper is not a function, return helper itself.
                         * @param {Array.<string>} exps - array of expressions split by spaces (first element: helper)
                         * @param {object} context - context
                         * @returns {string}
                         * @private
                         */
                        function handleExpression(exps, context) {
                            var result = getValueFromContext(exps[0], context);

                            if (result instanceof Function) {
                                return executeFunction(result, exps.slice(1), context);
                            }

                            return result;
                        }

                        /**
                         * Execute a helper function.
                         * @param {Function} helper - helper function
                         * @param {Array.<string>} argExps - expressions of arguments
                         * @param {object} context - context
                         * @returns {string} - result of executing the function with arguments
                         * @private
                         */
                        function executeFunction(helper, argExps, context) {
                            var args = [];
                            forEach(argExps, function(exp) {
                                args.push(getValueFromContext(exp, context));
                            });

                            return helper.apply(null, args);
                        }

                        /**
                         * Get a result of compiling an expression with the context.
                         * @param {Array.<string>} sources - array of sources split by regexp of expression.
                         * @param {object} context - context
                         * @returns {Array.<string>} - array of sources that bind with its context
                         * @private
                         */
                        function compile(sources, context) {
                            var index = 1;
                            var expression = sources[index];
                            var exps, firstExp, result;

                            while (isString(expression)) {
                                exps = expression.split(' ');
                                firstExp = exps[0];

                                if (BLOCK_HELPERS[firstExp]) {
                                    result = handleBlockHelper(firstExp, sources.splice(index, sources.length - index), context);
                                    sources = sources.concat(result);
                                } else {
                                    sources[index] = handleExpression(exps, context);
                                }

                                index += EXPRESSION_INTERVAL;
                                expression = sources[index];
                            }

                            return sources.join('');
                        }

                        /**
                         * Convert text by binding expressions with context.
                         * <br>
                         * If expression exists in the context, it will be replaced.
                         * ex) '{{title}}' with context {title: 'Hello!'} is converted to 'Hello!'.
                         * An array or object can be accessed using bracket and dot notation.
                         * ex) '{{odds\[2\]}}' with context {odds: \[1, 3, 5\]} is converted to '5'.
                         * ex) '{{evens\[first\]}}' with context {evens: \[2, 4\], first: 0} is converted to '2'.
                         * ex) '{{project\["name"\]}}' and '{{project.name}}' with context {project: {name: 'CodeSnippet'}} is converted to 'CodeSnippet'.
                         * <br>
                         * If replaced expression is a function, next expressions will be arguments of the function.
                         * ex) '{{add 1 2}}' with context {add: function(a, b) {return a + b;}} is converted to '3'.
                         * <br>
                         * It has 3 predefined block helpers '{{helper ...}} ... {{/helper}}': 'if', 'each', 'with ... as ...'.
                         * 1) 'if' evaluates conditional statements. It can use with 'elseif' and 'else'.
                         * 2) 'each' iterates an array or object. It provides '@index'(array), '@key'(object), and '@this'(current element).
                         * 3) 'with ... as ...' provides an alias.
                         * @param {string} text - text with expressions
                         * @param {object} context - context
                         * @returns {string} - text that bind with its context
                         * @memberof module:domUtil
                         * @example
                         * var template = require('tui-code-snippet/domUtil/template');
                         *
                         * var source =
                         *     '<h1>'
                         *   +   '{{if isValidNumber title}}'
                         *   +     '{{title}}th'
                         *   +   '{{elseif isValidDate title}}'
                         *   +     'Date: {{title}}'
                         *   +   '{{/if}}'
                         *   + '</h1>'
                         *   + '{{each list}}'
                         *   +   '{{with addOne @index as idx}}'
                         *   +     '<p>{{idx}}: {{@this}}</p>'
                         *   +   '{{/with}}'
                         *   + '{{/each}}';
                         *
                         * var context = {
                         *   isValidDate: function(text) {
                         *     return /^\d{4}-(0|1)\d-(0|1|2|3)\d$/.test(text);
                         *   },
                         *   isValidNumber: function(text) {
                         *     return /^\d+$/.test(text);
                         *   }
                         *   title: '2019-11-25',
                         *   list: ['Clean the room', 'Wash the dishes'],
                         *   addOne: function(num) {
                         *     return num + 1;
                         *   }
                         * };
                         *
                         * var result = template(source, context);
                         * console.log(result); // <h1>Date: 2019-11-25</h1><p>1: Clean the room</p><p>2: Wash the dishes</p>
                         */
                        function template(text, context) {
                            return compile(splitByRegExp(text, EXPRESSION_REGEXP), context);
                        }

                        module.exports = template;


                        /***/ }),
                    /* 30 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Send hostname on DOMContentLoaded.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var isUndefined = __webpack_require__(1);
                        var imagePing = __webpack_require__(31);

                        var ms7days = 7 * 24 * 60 * 60 * 1000;

                        /**
                         * Check if the date has passed 7 days
                         * @param {number} date - milliseconds
                         * @returns {boolean}
                         * @private
                         */
                        function isExpired(date) {
                            var now = new Date().getTime();

                            return now - date > ms7days;
                        }

                        /**
                         * Send hostname on DOMContentLoaded.
                         * To prevent hostname set tui.usageStatistics to false.
                         * @param {string} appName - application name
                         * @param {string} trackingId - GA tracking ID
                         * @ignore
                         */
                        function sendHostname(appName, trackingId) {
                            var url = 'https://www.google-analytics.com/collect';
                            var hostname = location.hostname;
                            var hitType = 'event';
                            var eventCategory = 'use';
                            var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
                            var date = window.localStorage.getItem(applicationKeyForStorage);

                            // skip if the flag is defined and is set to false explicitly
                            if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
                                return;
                            }

                            // skip if not pass seven days old
                            if (date && !isExpired(date)) {
                                return;
                            }

                            window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

                            setTimeout(function() {
                                if (document.readyState === 'interactive' || document.readyState === 'complete') {
                                    imagePing(url, {
                                        v: 1,
                                        t: hitType,
                                        tid: trackingId,
                                        cid: hostname,
                                        dp: hostname,
                                        dh: appName,
                                        el: appName,
                                        ec: eventCategory
                                    });
                                }
                            }, 1000);
                        }

                        module.exports = sendHostname;


                        /***/ }),
                    /* 31 */
                    /***/ (function(module, exports, __webpack_require__) {
                        /**
                         * @fileoverview Request image ping.
                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                         */



                        var forEachOwnProperties = __webpack_require__(6);

                        /**
                         * @module request
                         */

                        /**
                         * Request image ping.
                         * @param {String} url url for ping request
                         * @param {Object} trackingInfo infos for make query string
                         * @returns {HTMLElement}
                         * @memberof module:request
                         * @example
                         * var imagePing = require('tui-code-snippet/request/imagePing'); // node, commonjs
                         *
                         * imagePing('https://www.google-analytics.com/collect', {
                         *     v: 1,
                         *     t: 'event',
                         *     tid: 'trackingid',
                         *     cid: 'cid',
                         *     dp: 'dp',
                         *     dh: 'dh'
                         * });
                         */
                        function imagePing(url, trackingInfo) {
                            var trackingElement = document.createElement('img');
                            var queryString = '';
                            forEachOwnProperties(trackingInfo, function(value, key) {
                                queryString += '&' + key + '=' + value;
                            });
                            queryString = queryString.substring(1);

                            trackingElement.src = url + '?' + queryString;

                            trackingElement.style.display = 'none';
                            document.body.appendChild(trackingElement);
                            document.body.removeChild(trackingElement);

                            return trackingElement;
                        }

                        module.exports = imagePing;


                        /***/ })
                    /******/ ]);
        });
    });

    var tuiGrid$1 = createCommonjsModule(function (module, exports) {
        /*!
     * TOAST UI Grid
     * @version 4.15.3 | Fri Nov 13 2020
     * @author NHN. FE Development Lab
     * @license MIT
     */
        (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory(tuiDatePicker, tuiPagination);
        })(window, function(__WEBPACK_EXTERNAL_MODULE__40__, __WEBPACK_EXTERNAL_MODULE__112__) {
            return /******/ (function(modules) { // webpackBootstrap
                /******/ 	// The module cache
                /******/ 	var installedModules = {};
                /******/
                /******/ 	// The require function
                /******/ 	function __webpack_require__(moduleId) {
                    /******/
                    /******/ 		// Check if module is in cache
                    /******/ 		if(installedModules[moduleId]) {
                        /******/ 			return installedModules[moduleId].exports;
                        /******/ 		}
                    /******/ 		// Create a new module (and put it into the cache)
                    /******/ 		var module = installedModules[moduleId] = {
                        /******/ 			i: moduleId,
                        /******/ 			l: false,
                        /******/ 			exports: {}
                        /******/ 		};
                    /******/
                    /******/ 		// Execute the module function
                    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                    /******/
                    /******/ 		// Flag the module as loaded
                    /******/ 		module.l = true;
                    /******/
                    /******/ 		// Return the exports of the module
                    /******/ 		return module.exports;
                    /******/ 	}
                /******/
                /******/
                /******/ 	// expose the modules object (__webpack_modules__)
                /******/ 	__webpack_require__.m = modules;
                /******/
                /******/ 	// expose the module cache
                /******/ 	__webpack_require__.c = installedModules;
                /******/
                /******/ 	// define getter function for harmony exports
                /******/ 	__webpack_require__.d = function(exports, name, getter) {
                    /******/ 		if(!__webpack_require__.o(exports, name)) {
                        /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
                        /******/ 		}
                    /******/ 	};
                /******/
                /******/ 	// define __esModule on exports
                /******/ 	__webpack_require__.r = function(exports) {
                    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                        /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
                        /******/ 		}
                    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
                    /******/ 	};
                /******/
                /******/ 	// create a fake namespace object
                /******/ 	// mode & 1: value is a module id, require it
                /******/ 	// mode & 2: merge all properties of value into the ns
                /******/ 	// mode & 4: return value when already ns object
                /******/ 	// mode & 8|1: behave like require
                /******/ 	__webpack_require__.t = function(value, mode) {
                    /******/ 		if(mode & 1) value = __webpack_require__(value);
                    /******/ 		if(mode & 8) return value;
                    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
                    /******/ 		var ns = Object.create(null);
                    /******/ 		__webpack_require__.r(ns);
                    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
                    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
                    /******/ 		return ns;
                    /******/ 	};
                /******/
                /******/ 	// getDefaultExport function for compatibility with non-harmony modules
                /******/ 	__webpack_require__.n = function(module) {
                    /******/ 		var getter = module && module.__esModule ?
                        /******/ 			function getDefault() { return module['default']; } :
                        /******/ 			function getModuleExports() { return module; };
                    /******/ 		__webpack_require__.d(getter, 'a', getter);
                    /******/ 		return getter;
                    /******/ 	};
                /******/
                /******/ 	// Object.prototype.hasOwnProperty.call
                /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
                /******/
                /******/ 	// __webpack_public_path__
                /******/ 	__webpack_require__.p = "/dist";
                /******/
                /******/
                /******/ 	// Load entry module and return exports
                /******/ 	return __webpack_require__(__webpack_require__.s = 55);
                /******/ })
                /************************************************************************/
                /******/ ([
                    /* 0 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.silentSplice = exports.convertTextToData = exports.endsWith = exports.startsWith = exports.uniqByProp = exports.uniq = exports.pick = exports.omit = exports.pruneObject = exports.debounce = exports.convertToNumber = exports.fromArray = exports.isEmpty = exports.isNil = exports.isString = exports.isNumber = exports.isBoolean = exports.isNull = exports.isUndefined = exports.isBlank = exports.last = exports.range = exports.clamp = exports.setDefaultProp = exports.encodeHTMLEntity = exports.hasOwnProp = exports.forEachObject = exports.isObject = exports.isFunction = exports.createMapFromArray = exports.removeArrayItem = exports.assign = exports.deepCopy = exports.deepCopyArray = exports.deepMergedCopy = exports.mapProp = exports.findOffsetIndex = exports.findPrevIndex = exports.findIndexes = exports.findPropIndex = exports.findIndex = exports.someProp = exports.some = exports.findProp = exports.find = exports.includes = exports.pipe = exports.sum = exports.arrayEqual = exports.shallowEqual = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var CUSTOM_LF_SUBCHAR = '___tui_grid_lf___';
                        var CUSTOM_CR_SUBCHAR = '___tui_grid_cr___';
                        var LF = '\n';
                        var CR = '\r';
                        var CUSTOM_LF_REGEXP = new RegExp(CUSTOM_LF_SUBCHAR, 'g');
                        var CUSTOM_CR_REGEXP = new RegExp(CUSTOM_CR_SUBCHAR, 'g');
                        function shallowEqual(o1, o2) {
                            for (var key in o1) {
                                if (o1[key] !== o2[key]) {
                                    return false;
                                }
                            }
                            for (var key in o2) {
                                if (!(key in o1)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        exports.shallowEqual = shallowEqual;
                        function arrayEqual(a1, a2) {
                            if (a1.length !== a2.length) {
                                return false;
                            }
                            for (var i = 0, len = a1.length; i < len; i += 1) {
                                if (a1[i] !== a2[i]) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        exports.arrayEqual = arrayEqual;
                        function sum(nums) {
                            return nums.reduce(function (acc, num) { return acc + num; }, 0);
                        }
                        exports.sum = sum;
                        function pipe(initVal) {
                            var args = [];
                            for (var _i = 1; _i < arguments.length; _i++) {
                                args[_i - 1] = arguments[_i];
                            }
                            return args.reduce(function (acc, fn) { return fn(acc); }, initVal);
                        }
                        exports.pipe = pipe;
                        function includes(arr, searchItem, searchIndex) {
                            if (typeof searchIndex === 'number' && arr[searchIndex] !== searchItem) {
                                return false;
                            }
                            for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
                                var item = arr_1[_i];
                                if (item === searchItem) {
                                    return true;
                                }
                            }
                            return false;
                        }
                        exports.includes = includes;
                        // eslint-disable-next-line consistent-return
                        function find(predicate, arr) {
                            for (var _i = 0, arr_2 = arr; _i < arr_2.length; _i++) {
                                var item = arr_2[_i];
                                if (predicate(item)) {
                                    return item;
                                }
                            }
                        }
                        exports.find = find;
                        function findProp(propName, value, arr) {
                            return find(function (item) { return item[propName] === value; }, arr);
                        }
                        exports.findProp = findProp;
                        function some(predicate, arr) {
                            return !!find(predicate, arr);
                        }
                        exports.some = some;
                        function someProp(propName, value, arr) {
                            return !!findProp(propName, value, arr);
                        }
                        exports.someProp = someProp;
                        function findIndex(predicate, arr) {
                            for (var i = 0, len = arr.length; i < len; i += 1) {
                                if (predicate(arr[i])) {
                                    return i;
                                }
                            }
                            return -1;
                        }
                        exports.findIndex = findIndex;
                        function findPropIndex(propName, value, arr) {
                            return findIndex(function (item) { return item[propName] === value; }, arr);
                        }
                        exports.findPropIndex = findPropIndex;
                        function findIndexes(predicate, arr) {
                            return arr.reduce(function (acc, v, idx) { return (predicate(v) ? tslib_1.__spreadArrays(acc, [idx]) : acc); }, []);
                        }
                        exports.findIndexes = findIndexes;
                        function findPrevIndex(arr, predicate) {
                            var index = findIndex(predicate, arr);
                            var positiveIndex = index <= 0 ? 0 : index - 1;
                            return index >= 0 ? positiveIndex : arr.length - 1;
                        }
                        exports.findPrevIndex = findPrevIndex;
                        function findOffsetIndex(offsets, targetOffset) {
                            return findPrevIndex(offsets, function (offset) { return offset > targetOffset; });
                        }
                        exports.findOffsetIndex = findOffsetIndex;
                        function mapProp(propName, arr) {
                            return arr.map(function (item) { return item[propName]; });
                        }
                        exports.mapProp = mapProp;
                        function deepMergedCopy(targetObj, obj) {
                            var resultObj = tslib_1.__assign({}, targetObj);
                            Object.keys(obj).forEach(function (prop) {
                                if (isObject(resultObj[prop])) {
                                    if (Array.isArray(obj[prop])) {
                                        resultObj[prop] = deepCopyArray(obj[prop]);
                                    }
                                    else if (resultObj.hasOwnProperty(prop)) {
                                        resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);
                                    }
                                    else {
                                        resultObj[prop] = deepCopy(obj[prop]);
                                    }
                                }
                                else {
                                    resultObj[prop] = obj[prop];
                                }
                            });
                            return resultObj;
                        }
                        exports.deepMergedCopy = deepMergedCopy;
                        function deepCopyArray(items) {
                            return items.map(function (item) {
                                if (isObject(item)) {
                                    return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);
                                }
                                return item;
                            });
                        }
                        exports.deepCopyArray = deepCopyArray;
                        function deepCopy(obj) {
                            var resultObj = {};
                            var keys = Object.keys(obj);
                            if (!keys.length) {
                                return obj;
                            }
                            keys.forEach(function (prop) {
                                if (isObject(obj[prop])) {
                                    resultObj[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);
                                }
                                else {
                                    resultObj[prop] = obj[prop];
                                }
                            });
                            return resultObj;
                        }
                        exports.deepCopy = deepCopy;
                        function assign(targetObj, obj) {
                            Object.keys(obj).forEach(function (prop) {
                                if (targetObj.hasOwnProperty(prop) && typeof targetObj[prop] === 'object') {
                                    if (Array.isArray(obj[prop])) {
                                        targetObj[prop] = obj[prop];
                                    }
                                    else {
                                        assign(targetObj[prop], obj[prop]);
                                    }
                                }
                                else {
                                    targetObj[prop] = obj[prop];
                                }
                            });
                        }
                        exports.assign = assign;
                        function removeArrayItem(targetItem, arr) {
                            var targetIdx = findIndex(function (item) { return item === targetItem; }, arr);
                            if (targetIdx !== -1) {
                                arr.splice(targetIdx, 1);
                            }
                            return arr;
                        }
                        exports.removeArrayItem = removeArrayItem;
                        function createMapFromArray(arr, propName) {
                            var resultMap = {};
                            arr.forEach(function (item) {
                                var key = String(item[propName]);
                                resultMap[key] = item;
                            });
                            return resultMap;
                        }
                        exports.createMapFromArray = createMapFromArray;
                        function isFunction(obj) {
                            return typeof obj === 'function';
                        }
                        exports.isFunction = isFunction;
                        function isObject(obj) {
                            return typeof obj === 'object' && obj !== null;
                        }
                        exports.isObject = isObject;
                        function forEachObject(fn, obj) {
                            for (var key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    fn(obj[key], key, obj);
                                }
                            }
                        }
                        exports.forEachObject = forEachObject;
                        function hasOwnProp(obj, key) {
                            return obj.hasOwnProperty(key);
                        }
                        exports.hasOwnProp = hasOwnProp;
                        function encodeHTMLEntity(html) {
                            var entities = {
                                '"': 'quot',
                                '&': 'amp',
                                '<': 'lt',
                                '>': 'gt',
                                "'": '#39',
                            };
                            return html.replace(/[<>&"']/g, function (match) { return "&" + entities[match] + ";"; });
                        }
                        exports.encodeHTMLEntity = encodeHTMLEntity;
                        function setDefaultProp(obj, key, defValue) {
                            if (isUndefined(obj[key]) || isNull(obj[key])) {
                                obj[key] = defValue;
                            }
                        }
                        exports.setDefaultProp = setDefaultProp;
                        /**
                         * Returns a number whose value is limited to the given range.
                         * @param value - A number to force within given min-max range
                         * @param min - The lower boundary of the output range
                         * @param max - The upper boundary of the output range
                         * @returns A number in the range [min, max]
                         * @example
                         *      // limit the output of this computation to between 0 and 255
                         *      value = clamp(value, 0, 255);
                         */
                        function clamp(value, min, max) {
                            var _a;
                            if (min > max) {
                                _a = [min, max], max = _a[0], min = _a[1];
                            }
                            return Math.max(min, Math.min(value, max));
                        }
                        exports.clamp = clamp;
                        function range(end) {
                            var arr = [];
                            for (var i = 0; i < end; i += 1) {
                                arr.push(i);
                            }
                            return arr;
                        }
                        exports.range = range;
                        function last(arr) {
                            return arr[arr.length - 1];
                        }
                        exports.last = last;
                        function isBlank(value) {
                            if (typeof value === 'string') {
                                return !value.length;
                            }
                            return typeof value === 'undefined' || value === null;
                        }
                        exports.isBlank = isBlank;
                        function isUndefined(value) {
                            return typeof value === 'undefined';
                        }
                        exports.isUndefined = isUndefined;
                        function isNull(value) {
                            return value === null;
                        }
                        exports.isNull = isNull;
                        function isBoolean(value) {
                            return typeof value === 'boolean';
                        }
                        exports.isBoolean = isBoolean;
                        function isNumber(value) {
                            return typeof value === 'number';
                        }
                        exports.isNumber = isNumber;
                        function isString(value) {
                            return typeof value === 'string';
                        }
                        exports.isString = isString;
                        function isNil(value) {
                            return isUndefined(value) || isNull(value);
                        }
                        exports.isNil = isNil;
                        /**
                         * check the emptiness(included null) of object or array. if obj parameter is null or undefind, return true
                         * @param obj - target object or array
                         * @returns the emptiness of obj
                         */
                        function isEmpty(obj) {
                            return (isNull(obj) ||
                                isUndefined(obj) ||
                                (!isUndefined(obj.length) && obj.length === 0) ||
                                Object.keys(obj).length === 0);
                        }
                        exports.isEmpty = isEmpty;
                        function fromArray(value) {
                            return Array.prototype.slice.call(value);
                        }
                        exports.fromArray = fromArray;
                        function convertToNumber(value) {
                            if (typeof value === 'number' || isNaN(value) || isBlank(value)) {
                                return value;
                            }
                            return Number(value);
                        }
                        exports.convertToNumber = convertToNumber;
                        function debounce(fn, wait, immediate) {
                            if (immediate === void 0) { immediate = false; }
                            var timeout = null;
                            return function () {
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                var later = function () {
                                    timeout = -1;
                                    if (!immediate) {
                                        fn.apply(void 0, args);
                                    }
                                };
                                var callNow = immediate && !timeout;
                                if (timeout) {
                                    clearTimeout(timeout);
                                }
                                timeout = window.setTimeout(later, wait);
                                if (callNow) {
                                    fn.apply(void 0, args);
                                }
                            };
                        }
                        exports.debounce = debounce;
                        function pruneObject(obj) {
                            var pruned = {};
                            forEachObject(function (value, key) {
                                if (!isUndefined(value) && !isNull(value)) {
                                    pruned[key] = value;
                                }
                            }, obj);
                            return pruned;
                        }
                        exports.pruneObject = pruneObject;
                        function omit(obj) {
                            var propNames = [];
                            for (var _i = 1; _i < arguments.length; _i++) {
                                propNames[_i - 1] = arguments[_i];
                            }
                            var resultMap = {};
                            Object.keys(obj).forEach(function (key) {
                                if (!includes(propNames, key)) {
                                    resultMap[key] = obj[key];
                                }
                            });
                            return resultMap;
                        }
                        exports.omit = omit;
                        function pick(obj) {
                            var propNames = [];
                            for (var _i = 1; _i < arguments.length; _i++) {
                                propNames[_i - 1] = arguments[_i];
                            }
                            var resultMap = {};
                            Object.keys(obj).forEach(function (key) {
                                if (includes(propNames, key)) {
                                    resultMap[key] = obj[key];
                                }
                            });
                            return resultMap;
                        }
                        exports.pick = pick;
                        function uniq(arr) {
                            return arr.filter(function (name, index) { return arr.indexOf(name) === index; });
                        }
                        exports.uniq = uniq;
                        function uniqByProp(propName, arr) {
                            return arr.filter(function (obj, index) { return findPropIndex(propName, obj[propName], arr) === index; });
                        }
                        exports.uniqByProp = uniqByProp;
                        function startsWith(str, targetStr) {
                            return targetStr.slice(0, str.length) === str;
                        }
                        exports.startsWith = startsWith;
                        function endsWith(str, targetStr) {
                            var index = targetStr.lastIndexOf(str);
                            return index !== -1 && index + str.length === targetStr.length;
                        }
                        exports.endsWith = endsWith;
                        function removeDoubleQuotes(text) {
                            if (text.match(CUSTOM_LF_REGEXP)) {
                                return text.substring(1, text.length - 1).replace(/""/g, '"');
                            }
                            return text;
                        }
                        function replaceNewlineToSubchar(text) {
                            return text.replace(/"([^"]|"")*"/g, function (value) {
                                return value.replace(LF, CUSTOM_LF_SUBCHAR).replace(CR, CUSTOM_CR_SUBCHAR);
                            });
                        }
                        function convertTextToData(text) {
                            // Each newline cell data is wrapping double quotes in the text and
                            // newline characters should be replaced with substitution characters temporarily
                            // before spliting the text by newline characters.
                            text = replaceNewlineToSubchar(text);
                            return text
                                .split(/\r?\n/)
                                .map(function (row) {
                                    return row
                                        .split('\t')
                                        .map(function (column) {
                                            return removeDoubleQuotes(column).replace(CUSTOM_LF_REGEXP, LF).replace(CUSTOM_CR_REGEXP, CR);
                                        });
                                });
                        }
                        exports.convertTextToData = convertTextToData;
                        function silentSplice(arr, start, deleteCount) {
                            var _a;
                            var items = [];
                            for (var _i = 3; _i < arguments.length; _i++) {
                                items[_i - 3] = arguments[_i];
                            }
                            return (_a = Array.prototype.splice).call.apply(_a, tslib_1.__spreadArrays([arr, start, deleteCount], items));
                        }
                        exports.silentSplice = silentSplice;


                        /***/ }),
                    /* 1 */
                    /***/ (function(module, __webpack_exports__, __webpack_require__) {
                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
                        /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
                        /* global Reflect, Promise */

                        var extendStatics = function(d, b) {
                            extendStatics = Object.setPrototypeOf ||
                                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                            return extendStatics(d, b);
                        };

                        function __extends(d, b) {
                            extendStatics(d, b);
                            function __() { this.constructor = d; }
                            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                        }

                        var __assign = function() {
                            __assign = Object.assign || function __assign(t) {
                                for (var s, i = 1, n = arguments.length; i < n; i++) {
                                    s = arguments[i];
                                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                                }
                                return t;
                            };
                            return __assign.apply(this, arguments);
                        };

                        function __rest(s, e) {
                            var t = {};
                            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                                t[p] = s[p];
                            if (s != null && typeof Object.getOwnPropertySymbols === "function")
                                for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                                    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                                        t[p[i]] = s[p[i]];
                                }
                            return t;
                        }

                        function __decorate(decorators, target, key, desc) {
                            var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                            if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                            else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                            return c > 3 && r && Object.defineProperty(target, key, r), r;
                        }

                        function __param(paramIndex, decorator) {
                            return function (target, key) { decorator(target, key, paramIndex); }
                        }

                        function __metadata(metadataKey, metadataValue) {
                            if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
                        }

                        function __awaiter(thisArg, _arguments, P, generator) {
                            function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                            return new (P || (P = Promise))(function (resolve, reject) {
                                function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
                                function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
                                function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                                step((generator = generator.apply(thisArg, _arguments || [])).next());
                            });
                        }

                        function __generator(thisArg, body) {
                            var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
                            return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
                            function verb(n) { return function (v) { return step([n, v]); }; }
                            function step(op) {
                                if (f) throw new TypeError("Generator is already executing.");
                                while (_) try {
                                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                                    if (y = 0, t) op = [op[0] & 2, t.value];
                                    switch (op[0]) {
                                        case 0: case 1: t = op; break;
                                        case 4: _.label++; return { value: op[1], done: false };
                                        case 5: _.label++; y = op[1]; op = [0]; continue;
                                        case 7: op = _.ops.pop(); _.trys.pop(); continue;
                                        default:
                                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                                            if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                                            if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                                            if (t[2]) _.ops.pop();
                                            _.trys.pop(); continue;
                                    }
                                    op = body.call(thisArg, _);
                                } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
                                if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
                            }
                        }

                        function __exportStar(m, exports) {
                            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
                        }

                        function __values(o) {
                            var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
                            if (m) return m.call(o);
                            if (o && typeof o.length === "number") return {
                                next: function () {
                                    if (o && i >= o.length) o = void 0;
                                    return { value: o && o[i++], done: !o };
                                }
                            };
                            throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
                        }

                        function __read(o, n) {
                            var m = typeof Symbol === "function" && o[Symbol.iterator];
                            if (!m) return o;
                            var i = m.call(o), r, ar = [], e;
                            try {
                                while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
                            }
                            catch (error) { e = { error: error }; }
                            finally {
                                try {
                                    if (r && !r.done && (m = i["return"])) m.call(i);
                                }
                                finally { if (e) throw e.error; }
                            }
                            return ar;
                        }

                        function __spread() {
                            for (var ar = [], i = 0; i < arguments.length; i++)
                                ar = ar.concat(__read(arguments[i]));
                            return ar;
                        }

                        function __spreadArrays() {
                            for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
                            for (var r = Array(s), k = 0, i = 0; i < il; i++)
                                for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                                    r[k] = a[j];
                            return r;
                        }
                        function __await(v) {
                            return this instanceof __await ? (this.v = v, this) : new __await(v);
                        }

                        function __asyncGenerator(thisArg, _arguments, generator) {
                            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                            var g = generator.apply(thisArg, _arguments || []), i, q = [];
                            return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
                            function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
                            function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
                            function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
                            function fulfill(value) { resume("next", value); }
                            function reject(value) { resume("throw", value); }
                            function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
                        }

                        function __asyncDelegator(o) {
                            var i, p;
                            return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
                            function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
                        }

                        function __asyncValues(o) {
                            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                            var m = o[Symbol.asyncIterator], i;
                            return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
                            function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
                            function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
                        }

                        function __makeTemplateObject(cooked, raw) {
                            if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
                            return cooked;
                        }
                        function __importStar(mod) {
                            if (mod && mod.__esModule) return mod;
                            var result = {};
                            if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
                            result.default = mod;
                            return result;
                        }

                        function __importDefault(mod) {
                            return (mod && mod.__esModule) ? mod : { default: mod };
                        }

                        function __classPrivateFieldGet(receiver, privateMap) {
                            if (!privateMap.has(receiver)) {
                                throw new TypeError("attempted to get private field on non-instance");
                            }
                            return privateMap.get(receiver);
                        }

                        function __classPrivateFieldSet(receiver, privateMap, value) {
                            if (!privateMap.has(receiver)) {
                                throw new TypeError("attempted to set private field on non-instance");
                            }
                            privateMap.set(receiver, value);
                            return value;
                        }


                        /***/ }),
                    /* 2 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getComputedFontStyle = exports.getTextWidth = exports.setClipboardSelection = exports.isSupportWindowClipboardData = exports.convertTableToData = exports.getCoordinateWithOffset = exports.setCursorStyle = exports.appendStyleElement = exports.getCellAddress = exports.findParent = exports.findParentByTagName = exports.hasClass = exports.isDatePickerElement = exports.cls = exports.dataAttr = void 0;
                        var common_1 = __webpack_require__(0);
                        var CLS_PREFIX = 'tui-grid-';
                        exports.dataAttr = {
                            ROW_KEY: 'data-row-key',
                            COLUMN_NAME: 'data-column-name',
                            COLUMN_INDEX: 'data-column-index',
                            GRID_ID: 'data-grid-id',
                        };
                        function cls() {
                            var names = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                names[_i] = arguments[_i];
                            }
                            var result = [];
                            for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {
                                var name = names_1[_a];
                                var className = void 0;
                                if (Array.isArray(name)) {
                                    className = name[0] ? name[1] : null;
                                }
                                else {
                                    className = name;
                                }
                                if (className) {
                                    result.push("" + CLS_PREFIX + className);
                                }
                            }
                            return result.join(' ');
                        }
                        exports.cls = cls;
                        function isSvgElement(el) {
                            var _a;
                            return ((_a = el.namespaceURI) === null || _a === void 0 ? void 0 : _a.indexOf('svg')) !== -1;
                        }
                        function isDatePickerElement(el) {
                            var currentEl = el;
                            if (isSvgElement(el)) {
                                return false;
                            }
                            while (currentEl && currentEl.className.split(' ').indexOf('tui-datepicker') === -1) {
                                currentEl = currentEl.parentElement;
                            }
                            return !!currentEl;
                        }
                        exports.isDatePickerElement = isDatePickerElement;
                        function hasClass(el, className) {
                            return !isSvgElement(el) && el.className.split(' ').indexOf(cls(className)) !== -1;
                        }
                        exports.hasClass = hasClass;
                        function findParentByTagName(el, tagName) {
                            var currentEl = el;
                            while (currentEl && currentEl.tagName.toLowerCase() !== tagName) {
                                currentEl = currentEl.parentElement;
                            }
                            return currentEl;
                        }
                        exports.findParentByTagName = findParentByTagName;
                        function findParent(el, className) {
                            var currentEl = el;
                            while (currentEl && !hasClass(currentEl, className)) {
                                currentEl = currentEl.parentElement;
                            }
                            return currentEl;
                        }
                        exports.findParent = findParent;
                        function getCellAddress(el) {
                            var cellElement = findParentByTagName(el, 'td');
                            if (!cellElement) {
                                return null;
                            }
                            var rowKey = cellElement.getAttribute(exports.dataAttr.ROW_KEY);
                            var columnName = cellElement.getAttribute(exports.dataAttr.COLUMN_NAME);
                            if (common_1.isNull(rowKey)) {
                                return null;
                            }
                            return {
                                rowKey: Number(rowKey),
                                columnName: columnName,
                            };
                        }
                        exports.getCellAddress = getCellAddress;
                        /**
                         * create style element and append it into the head element.
                         * @param {String} id - element id
                         * @param {String} cssString - css string
                         */
                        function appendStyleElement(id, cssString) {
                            var style = document.createElement('style');
                            style.type = 'text/css';
                            style.id = id;
                            style.appendChild(document.createTextNode(cssString));
                            document.getElementsByTagName('head')[0].appendChild(style);
                        }
                        exports.appendStyleElement = appendStyleElement;
                        function setCursorStyle(type) {
                            document.body.style.cursor = type;
                        }
                        exports.setCursorStyle = setCursorStyle;
                        function getCoordinateWithOffset(pageX, pageY) {
                            var pageXWithOffset = pageX - window.pageXOffset;
                            var pageYWithOffset = pageY - window.pageYOffset;
                            return [pageXWithOffset, pageYWithOffset];
                        }
                        exports.getCoordinateWithOffset = getCoordinateWithOffset;
                        function setDataInSpanRange(value, data, colspanRange, rowspanRange) {
                            var startColspan = colspanRange[0], endColspan = colspanRange[1];
                            var startRowspan = rowspanRange[0], endRowspan = rowspanRange[1];
                            for (var rowIdx = startRowspan; rowIdx < endRowspan; rowIdx += 1) {
                                for (var columnIdx = startColspan; columnIdx < endColspan; columnIdx += 1) {
                                    data[rowIdx][columnIdx] = startRowspan === rowIdx && startColspan === columnIdx ? value : ' ';
                                }
                            }
                        }
                        function convertTableToData(rows) {
                            var data = [];
                            var colspanRange, rowspanRange;
                            for (var index = 0; index < rows.length; index += 1) {
                                data[index] = [];
                            }
                            common_1.fromArray(rows).forEach(function (tr, rowIndex) {
                                var columnIndex = 0;
                                common_1.fromArray(tr.cells).forEach(function (td) {
                                    var text = td.textContent || td.innerText;
                                    while (data[rowIndex][columnIndex]) {
                                        columnIndex += 1;
                                    }
                                    colspanRange = [columnIndex, columnIndex + (td.colSpan || 1)];
                                    rowspanRange = [rowIndex, rowIndex + (td.rowSpan || 1)];
                                    setDataInSpanRange(text, data, colspanRange, rowspanRange);
                                    columnIndex = colspanRange[1];
                                });
                            });
                            return data;
                        }
                        exports.convertTableToData = convertTableToData;
                        function isSupportWindowClipboardData() {
                            return !!window.clipboardData;
                        }
                        exports.isSupportWindowClipboardData = isSupportWindowClipboardData;
                        function setClipboardSelection(node) {
                            if (node) {
                                var range = document.createRange();
                                var selection = window.getSelection();
                                selection.removeAllRanges();
                                range.selectNodeContents(node);
                                selection.addRange(range);
                            }
                        }
                        exports.setClipboardSelection = setClipboardSelection;
                        function getTextWidth(text, font) {
                            var context = document.createElement('canvas').getContext('2d');
                            context.font = font;
                            var width = context.measureText(String(text)).width;
                            return Math.ceil(width);
                        }
                        exports.getTextWidth = getTextWidth;
                        function getComputedFontStyle(selector) {
                            var firstCellNode = document.querySelector("." + cls(selector));
                            var walker = document.createTreeWalker(firstCellNode, 4);
                            var node = firstCellNode;
                            while (walker.nextNode()) {
                                node = walker.currentNode;
                                if (node.nodeType === 3) {
                                    node = node.parentElement;
                                    break;
                                }
                            }
                            var compStyle = getComputedStyle(node);
                            var fontSize = compStyle.getPropertyValue('font-size');
                            var fontWeight = compStyle.getPropertyValue('font-weight');
                            var fontFamily = compStyle.getPropertyValue('font-family');
                            return fontWeight + " " + fontSize + " " + fontFamily;
                        }
                        exports.getComputedFontStyle = getComputedFontStyle;


                        /***/ }),
                    /* 3 */
                    /***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {
                        __webpack_require__.r(__webpack_exports__);
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return h; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return h; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return cloneElement; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return createRef; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rerender", function() { return rerender; });
                        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "options", function() { return options; });
                        var VNode = function VNode() {};

                        var options = {};

                        var stack = [];

                        var EMPTY_CHILDREN = [];

                        function h(nodeName, attributes) {
                            var children = EMPTY_CHILDREN,
                                lastSimple,
                                child,
                                simple,
                                i;
                            for (i = arguments.length; i-- > 2;) {
                                stack.push(arguments[i]);
                            }
                            if (attributes && attributes.children != null) {
                                if (!stack.length) stack.push(attributes.children);
                                delete attributes.children;
                            }
                            while (stack.length) {
                                if ((child = stack.pop()) && child.pop !== undefined) {
                                    for (i = child.length; i--;) {
                                        stack.push(child[i]);
                                    }
                                } else {
                                    if (typeof child === 'boolean') child = null;

                                    if (simple = typeof nodeName !== 'function') {
                                        if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
                                    }

                                    if (simple && lastSimple) {
                                        children[children.length - 1] += child;
                                    } else if (children === EMPTY_CHILDREN) {
                                        children = [child];
                                    } else {
                                        children.push(child);
                                    }

                                    lastSimple = simple;
                                }
                            }

                            var p = new VNode();
                            p.nodeName = nodeName;
                            p.children = children;
                            p.attributes = attributes == null ? undefined : attributes;
                            p.key = attributes == null ? undefined : attributes.key;

                            if (options.vnode !== undefined) options.vnode(p);

                            return p;
                        }

                        function extend(obj, props) {
                            for (var i in props) {
                                obj[i] = props[i];
                            }return obj;
                        }

                        function applyRef(ref, value) {
                            if (ref != null) {
                                if (typeof ref == 'function') ref(value);else ref.current = value;
                            }
                        }

                        var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

                        function cloneElement(vnode, props) {
                            return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
                        }

                        var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

                        var items = [];

                        function enqueueRender(component) {
                            if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
                                (options.debounceRendering || defer)(rerender);
                            }
                        }

                        function rerender() {
                            var p;
                            while (p = items.pop()) {
                                if (p._dirty) renderComponent(p);
                            }
                        }

                        function isSameNodeType(node, vnode, hydrating) {
                            if (typeof vnode === 'string' || typeof vnode === 'number') {
                                return node.splitText !== undefined;
                            }
                            if (typeof vnode.nodeName === 'string') {
                                return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
                            }
                            return hydrating || node._componentConstructor === vnode.nodeName;
                        }

                        function isNamedNode(node, nodeName) {
                            return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
                        }

                        function getNodeProps(vnode) {
                            var props = extend({}, vnode.attributes);
                            props.children = vnode.children;

                            var defaultProps = vnode.nodeName.defaultProps;
                            if (defaultProps !== undefined) {
                                for (var i in defaultProps) {
                                    if (props[i] === undefined) {
                                        props[i] = defaultProps[i];
                                    }
                                }
                            }

                            return props;
                        }

                        function createNode(nodeName, isSvg) {
                            var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
                            node.normalizedNodeName = nodeName;
                            return node;
                        }

                        function removeNode(node) {
                            var parentNode = node.parentNode;
                            if (parentNode) parentNode.removeChild(node);
                        }

                        function setAccessor(node, name, old, value, isSvg) {
                            if (name === 'className') name = 'class';

                            if (name === 'key') ; else if (name === 'ref') {
                                applyRef(old, null);
                                applyRef(value, node);
                            } else if (name === 'class' && !isSvg) {
                                node.className = value || '';
                            } else if (name === 'style') {
                                if (!value || typeof value === 'string' || typeof old === 'string') {
                                    node.style.cssText = value || '';
                                }
                                if (value && typeof value === 'object') {
                                    if (typeof old !== 'string') {
                                        for (var i in old) {
                                            if (!(i in value)) node.style[i] = '';
                                        }
                                    }
                                    for (var i in value) {
                                        node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
                                    }
                                }
                            } else if (name === 'dangerouslySetInnerHTML') {
                                if (value) node.innerHTML = value.__html || '';
                            } else if (name[0] == 'o' && name[1] == 'n') {
                                var useCapture = name !== (name = name.replace(/Capture$/, ''));
                                name = name.toLowerCase().substring(2);
                                if (value) {
                                    if (!old) node.addEventListener(name, eventProxy, useCapture);
                                } else {
                                    node.removeEventListener(name, eventProxy, useCapture);
                                }
                                (node._listeners || (node._listeners = {}))[name] = value;
                            } else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
                                try {
                                    node[name] = value == null ? '' : value;
                                } catch (e) {}
                                if ((value == null || value === false) && name != 'spellcheck') node.removeAttribute(name);
                            } else {
                                var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));

                                if (value == null || value === false) {
                                    if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
                                } else if (typeof value !== 'function') {
                                    if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
                                }
                            }
                        }

                        function eventProxy(e) {
                            return this._listeners[e.type](options.event && options.event(e) || e);
                        }

                        var mounts = [];

                        var diffLevel = 0;

                        var isSvgMode = false;

                        var hydrating = false;

                        function flushMounts() {
                            var c;
                            while (c = mounts.shift()) {
                                if (options.afterMount) options.afterMount(c);
                                if (c.componentDidMount) c.componentDidMount();
                            }
                        }

                        function diff(dom, vnode, context, mountAll, parent, componentRoot) {
                            if (!diffLevel++) {
                                isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

                                hydrating = dom != null && !('__preactattr_' in dom);
                            }

                            var ret = idiff(dom, vnode, context, mountAll, componentRoot);

                            if (parent && ret.parentNode !== parent) parent.appendChild(ret);

                            if (! --diffLevel) {
                                hydrating = false;

                                if (!componentRoot) flushMounts();
                            }

                            return ret;
                        }

                        function idiff(dom, vnode, context, mountAll, componentRoot) {
                            var out = dom,
                                prevSvgMode = isSvgMode;

                            if (vnode == null || typeof vnode === 'boolean') vnode = '';

                            if (typeof vnode === 'string' || typeof vnode === 'number') {
                                if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
                                    if (dom.nodeValue != vnode) {
                                        dom.nodeValue = vnode;
                                    }
                                } else {
                                    out = document.createTextNode(vnode);
                                    if (dom) {
                                        if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                                        recollectNodeTree(dom, true);
                                    }
                                }

                                out['__preactattr_'] = true;

                                return out;
                            }

                            var vnodeName = vnode.nodeName;
                            if (typeof vnodeName === 'function') {
                                return buildComponentFromVNode(dom, vnode, context, mountAll);
                            }

                            isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

                            vnodeName = String(vnodeName);
                            if (!dom || !isNamedNode(dom, vnodeName)) {
                                out = createNode(vnodeName, isSvgMode);

                                if (dom) {
                                    while (dom.firstChild) {
                                        out.appendChild(dom.firstChild);
                                    }
                                    if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

                                    recollectNodeTree(dom, true);
                                }
                            }

                            var fc = out.firstChild,
                                props = out['__preactattr_'],
                                vchildren = vnode.children;

                            if (props == null) {
                                props = out['__preactattr_'] = {};
                                for (var a = out.attributes, i = a.length; i--;) {
                                    props[a[i].name] = a[i].value;
                                }
                            }

                            if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
                                if (fc.nodeValue != vchildren[0]) {
                                    fc.nodeValue = vchildren[0];
                                }
                            } else if (vchildren && vchildren.length || fc != null) {
                                innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
                            }

                            diffAttributes(out, vnode.attributes, props);

                            isSvgMode = prevSvgMode;

                            return out;
                        }

                        function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
                            var originalChildren = dom.childNodes,
                                children = [],
                                keyed = {},
                                keyedLen = 0,
                                min = 0,
                                len = originalChildren.length,
                                childrenLen = 0,
                                vlen = vchildren ? vchildren.length : 0,
                                j,
                                c,
                                f,
                                vchild,
                                child;

                            if (len !== 0) {
                                for (var i = 0; i < len; i++) {
                                    var _child = originalChildren[i],
                                        props = _child['__preactattr_'],
                                        key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
                                    if (key != null) {
                                        keyedLen++;
                                        keyed[key] = _child;
                                    } else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
                                        children[childrenLen++] = _child;
                                    }
                                }
                            }

                            if (vlen !== 0) {
                                for (var i = 0; i < vlen; i++) {
                                    vchild = vchildren[i];
                                    child = null;

                                    var key = vchild.key;
                                    if (key != null) {
                                        if (keyedLen && keyed[key] !== undefined) {
                                            child = keyed[key];
                                            keyed[key] = undefined;
                                            keyedLen--;
                                        }
                                    } else if (min < childrenLen) {
                                        for (j = min; j < childrenLen; j++) {
                                            if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
                                                child = c;
                                                children[j] = undefined;
                                                if (j === childrenLen - 1) childrenLen--;
                                                if (j === min) min++;
                                                break;
                                            }
                                        }
                                    }

                                    child = idiff(child, vchild, context, mountAll);

                                    f = originalChildren[i];
                                    if (child && child !== dom && child !== f) {
                                        if (f == null) {
                                            dom.appendChild(child);
                                        } else if (child === f.nextSibling) {
                                            removeNode(f);
                                        } else {
                                            dom.insertBefore(child, f);
                                        }
                                    }
                                }
                            }

                            if (keyedLen) {
                                for (var i in keyed) {
                                    if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
                                }
                            }

                            while (min <= childrenLen) {
                                if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
                            }
                        }

                        function recollectNodeTree(node, unmountOnly) {
                            var component = node._component;
                            if (component) {
                                unmountComponent(component);
                            } else {
                                if (node['__preactattr_'] != null) applyRef(node['__preactattr_'].ref, null);

                                if (unmountOnly === false || node['__preactattr_'] == null) {
                                    removeNode(node);
                                }

                                removeChildren(node);
                            }
                        }

                        function removeChildren(node) {
                            node = node.lastChild;
                            while (node) {
                                var next = node.previousSibling;
                                recollectNodeTree(node, true);
                                node = next;
                            }
                        }

                        function diffAttributes(dom, attrs, old) {
                            var name;

                            for (name in old) {
                                if (!(attrs && attrs[name] != null) && old[name] != null) {
                                    setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
                                }
                            }

                            for (name in attrs) {
                                if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
                                    setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
                                }
                            }
                        }

                        var recyclerComponents = [];

                        function createComponent(Ctor, props, context) {
                            var inst,
                                i = recyclerComponents.length;

                            if (Ctor.prototype && Ctor.prototype.render) {
                                inst = new Ctor(props, context);
                                Component.call(inst, props, context);
                            } else {
                                inst = new Component(props, context);
                                inst.constructor = Ctor;
                                inst.render = doRender;
                            }

                            while (i--) {
                                if (recyclerComponents[i].constructor === Ctor) {
                                    inst.nextBase = recyclerComponents[i].nextBase;
                                    recyclerComponents.splice(i, 1);
                                    return inst;
                                }
                            }

                            return inst;
                        }

                        function doRender(props, state, context) {
                            return this.constructor(props, context);
                        }

                        function setComponentProps(component, props, renderMode, context, mountAll) {
                            if (component._disable) return;
                            component._disable = true;

                            component.__ref = props.ref;
                            component.__key = props.key;
                            delete props.ref;
                            delete props.key;

                            if (typeof component.constructor.getDerivedStateFromProps === 'undefined') {
                                if (!component.base || mountAll) {
                                    if (component.componentWillMount) component.componentWillMount();
                                } else if (component.componentWillReceiveProps) {
                                    component.componentWillReceiveProps(props, context);
                                }
                            }

                            if (context && context !== component.context) {
                                if (!component.prevContext) component.prevContext = component.context;
                                component.context = context;
                            }

                            if (!component.prevProps) component.prevProps = component.props;
                            component.props = props;

                            component._disable = false;

                            if (renderMode !== 0) {
                                if (renderMode === 1 || options.syncComponentUpdates !== false || !component.base) {
                                    renderComponent(component, 1, mountAll);
                                } else {
                                    enqueueRender(component);
                                }
                            }

                            applyRef(component.__ref, component);
                        }

                        function renderComponent(component, renderMode, mountAll, isChild) {
                            if (component._disable) return;

                            var props = component.props,
                                state = component.state,
                                context = component.context,
                                previousProps = component.prevProps || props,
                                previousState = component.prevState || state,
                                previousContext = component.prevContext || context,
                                isUpdate = component.base,
                                nextBase = component.nextBase,
                                initialBase = isUpdate || nextBase,
                                initialChildComponent = component._component,
                                skip = false,
                                snapshot = previousContext,
                                rendered,
                                inst,
                                cbase;

                            if (component.constructor.getDerivedStateFromProps) {
                                state = extend(extend({}, state), component.constructor.getDerivedStateFromProps(props, state));
                                component.state = state;
                            }

                            if (isUpdate) {
                                component.props = previousProps;
                                component.state = previousState;
                                component.context = previousContext;
                                if (renderMode !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
                                    skip = true;
                                } else if (component.componentWillUpdate) {
                                    component.componentWillUpdate(props, state, context);
                                }
                                component.props = props;
                                component.state = state;
                                component.context = context;
                            }

                            component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
                            component._dirty = false;

                            if (!skip) {
                                rendered = component.render(props, state, context);

                                if (component.getChildContext) {
                                    context = extend(extend({}, context), component.getChildContext());
                                }

                                if (isUpdate && component.getSnapshotBeforeUpdate) {
                                    snapshot = component.getSnapshotBeforeUpdate(previousProps, previousState);
                                }

                                var childComponent = rendered && rendered.nodeName,
                                    toUnmount,
                                    base;

                                if (typeof childComponent === 'function') {

                                    var childProps = getNodeProps(rendered);
                                    inst = initialChildComponent;

                                    if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
                                        setComponentProps(inst, childProps, 1, context, false);
                                    } else {
                                        toUnmount = inst;

                                        component._component = inst = createComponent(childComponent, childProps, context);
                                        inst.nextBase = inst.nextBase || nextBase;
                                        inst._parentComponent = component;
                                        setComponentProps(inst, childProps, 0, context, false);
                                        renderComponent(inst, 1, mountAll, true);
                                    }

                                    base = inst.base;
                                } else {
                                    cbase = initialBase;

                                    toUnmount = initialChildComponent;
                                    if (toUnmount) {
                                        cbase = component._component = null;
                                    }

                                    if (initialBase || renderMode === 1) {
                                        if (cbase) cbase._component = null;
                                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
                                    }
                                }

                                if (initialBase && base !== initialBase && inst !== initialChildComponent) {
                                    var baseParent = initialBase.parentNode;
                                    if (baseParent && base !== baseParent) {
                                        baseParent.replaceChild(base, initialBase);

                                        if (!toUnmount) {
                                            initialBase._component = null;
                                            recollectNodeTree(initialBase, false);
                                        }
                                    }
                                }

                                if (toUnmount) {
                                    unmountComponent(toUnmount);
                                }

                                component.base = base;
                                if (base && !isChild) {
                                    var componentRef = component,
                                        t = component;
                                    while (t = t._parentComponent) {
                                        (componentRef = t).base = base;
                                    }
                                    base._component = componentRef;
                                    base._componentConstructor = componentRef.constructor;
                                }
                            }

                            if (!isUpdate || mountAll) {
                                mounts.push(component);
                            } else if (!skip) {

                                if (component.componentDidUpdate) {
                                    component.componentDidUpdate(previousProps, previousState, snapshot);
                                }
                                if (options.afterUpdate) options.afterUpdate(component);
                            }

                            while (component._renderCallbacks.length) {
                                component._renderCallbacks.pop().call(component);
                            }if (!diffLevel && !isChild) flushMounts();
                        }

                        function buildComponentFromVNode(dom, vnode, context, mountAll) {
                            var c = dom && dom._component,
                                originalComponent = c,
                                oldDom = dom,
                                isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
                                isOwner = isDirectOwner,
                                props = getNodeProps(vnode);
                            while (c && !isOwner && (c = c._parentComponent)) {
                                isOwner = c.constructor === vnode.nodeName;
                            }

                            if (c && isOwner && (!mountAll || c._component)) {
                                setComponentProps(c, props, 3, context, mountAll);
                                dom = c.base;
                            } else {
                                if (originalComponent && !isDirectOwner) {
                                    unmountComponent(originalComponent);
                                    dom = oldDom = null;
                                }

                                c = createComponent(vnode.nodeName, props, context);
                                if (dom && !c.nextBase) {
                                    c.nextBase = dom;

                                    oldDom = null;
                                }
                                setComponentProps(c, props, 1, context, mountAll);
                                dom = c.base;

                                if (oldDom && dom !== oldDom) {
                                    oldDom._component = null;
                                    recollectNodeTree(oldDom, false);
                                }
                            }

                            return dom;
                        }

                        function unmountComponent(component) {
                            if (options.beforeUnmount) options.beforeUnmount(component);

                            var base = component.base;

                            component._disable = true;

                            if (component.componentWillUnmount) component.componentWillUnmount();

                            component.base = null;

                            var inner = component._component;
                            if (inner) {
                                unmountComponent(inner);
                            } else if (base) {
                                if (base['__preactattr_'] != null) applyRef(base['__preactattr_'].ref, null);

                                component.nextBase = base;

                                removeNode(base);
                                recyclerComponents.push(component);

                                removeChildren(base);
                            }

                            applyRef(component.__ref, null);
                        }

                        function Component(props, context) {
                            this._dirty = true;

                            this.context = context;

                            this.props = props;

                            this.state = this.state || {};

                            this._renderCallbacks = [];
                        }

                        extend(Component.prototype, {
                            setState: function setState(state, callback) {
                                if (!this.prevState) this.prevState = this.state;
                                this.state = extend(extend({}, this.state), typeof state === 'function' ? state(this.state, this.props) : state);
                                if (callback) this._renderCallbacks.push(callback);
                                enqueueRender(this);
                            },
                            forceUpdate: function forceUpdate(callback) {
                                if (callback) this._renderCallbacks.push(callback);
                                renderComponent(this, 2);
                            },
                            render: function render() {}
                        });

                        function render(vnode, parent, merge) {
                            return diff(merge, vnode, {}, false, parent, false);
                        }

                        function createRef() {
                            return {};
                        }

                        var preact = {
                            h: h,
                            createElement: h,
                            cloneElement: cloneElement,
                            createRef: createRef,
                            Component: Component,
                            render: render,
                            rerender: rerender,
                            options: options
                        };

                        /* harmony default export */ __webpack_exports__["default"] = (preact);




                        /***/ }),
                    /* 4 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.connect = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var observable_1 = __webpack_require__(5);
                        function connect(selector, forceUpdate) {
                            return function (WrappedComponent) {
                                var _a;
                                return _a = /** @class */ (function (_super) {
                                    tslib_1.__extends(class_1, _super);
                                    function class_1() {
                                        return _super !== null && _super.apply(this, arguments) || this;
                                    }
                                    class_1.prototype.setStateUsingSelector = function (ownProps) {
                                        if (selector) {
                                            this.setState(selector(this.context.store, ownProps));
                                            if (forceUpdate) {
                                                this.forceUpdate();
                                            }
                                        }
                                    };
                                    class_1.prototype.componentWillMount = function () {
                                        var _this = this;
                                        if (selector) {
                                            this.unobserve = observable_1.observe(function () {
                                                _this.setStateUsingSelector(_this.props);
                                            });
                                        }
                                    };
                                    class_1.prototype.componentWillReceiveProps = function (nextProps) {
                                        this.setStateUsingSelector(nextProps);
                                    };
                                    class_1.prototype.componentWillUnmount = function () {
                                        if (this.unobserve) {
                                            this.unobserve();
                                        }
                                    };
                                    class_1.prototype.render = function () {
                                        var _a = this, props = _a.props, state = _a.state;
                                        var dispatch = this.context.dispatch;
                                        return preact_1.h(WrappedComponent, tslib_1.__assign({}, props, state, { dispatch: dispatch }));
                                    };
                                    return class_1;
                                }(preact_1.Component)),
                                    _a.displayName = "Connect:" + WrappedComponent.name,
                                    _a;
                            };
                        }
                        exports.connect = connect;


                        /***/ }),
                    /* 5 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.asyncInvokeObserver = exports.batchObserver = exports.unobservedInvoke = exports.getOriginObject = exports.notify = exports.observable = exports.partialObservable = exports.observe = exports.isObservable = exports.getRunningObservers = exports.observerInfoMap = void 0;
                        var common_1 = __webpack_require__(0);
                        var array_1 = __webpack_require__(58);
                        var generateObserverId = (function () {
                            var lastId = 0;
                            return function () {
                                lastId += 1;
                                return "@observer" + lastId;
                            };
                        })();
                        // store all observer info
                        exports.observerInfoMap = {};
                        // observerId stack for managing recursive observing calls
                        var observerIdStack = [];
                        var queue = [];
                        var observerIdMap = {};
                        var pending = false;
                        var paused = false;
                        function batchUpdate(observerId) {
                            if (!observerIdMap[observerId]) {
                                observerIdMap[observerId] = true;
                                queue.push(observerId);
                            }
                            if (!pending) {
                                flush();
                            }
                        }
                        function clearQueue() {
                            queue = [];
                            observerIdMap = {};
                            pending = false;
                        }
                        function getRunningObservers() {
                            return queue.map(function (id) { return exports.observerInfoMap[id].name; }).filter(function (name) { return name; });
                        }
                        exports.getRunningObservers = getRunningObservers;
                        function callObserver(observerId) {
                            observerIdStack.push(observerId);
                            exports.observerInfoMap[observerId].fn();
                            observerIdStack.pop();
                        }
                        function flush() {
                            pending = true;
                            for (var index = 0; index < queue.length; index += 1) {
                                var observerId = queue[index];
                                observerIdMap[observerId] = false;
                                callObserver(observerId);
                            }
                            clearQueue();
                        }
                        function run(observerId) {
                            var sync = exports.observerInfoMap[observerId].sync;
                            if (sync) {
                                callObserver(observerId);
                            }
                            else {
                                batchUpdate(observerId);
                            }
                        }
                        function setValue(storage, resultObj, observerIdSet, key, value) {
                            if (storage[key] !== value) {
                                if (Array.isArray(value)) {
                                    array_1.patchArrayMethods(value, resultObj, key);
                                }
                                storage[key] = value;
                                Object.keys(observerIdSet).forEach(function (observerId) {
                                    run(observerId);
                                });
                            }
                        }
                        function isObservable(resultObj) {
                            return common_1.isObject(resultObj) && common_1.hasOwnProp(resultObj, '__storage__');
                        }
                        exports.isObservable = isObservable;
                        function observe(fn, sync, name) {
                            if (sync === void 0) { sync = false; }
                            if (name === void 0) { name = ''; }
                            var observerId = generateObserverId();
                            exports.observerInfoMap[observerId] = { fn: fn, targetObserverIdSets: [], sync: sync, name: name };
                            run(observerId);
                            // return unobserve function
                            return function () {
                                exports.observerInfoMap[observerId].targetObserverIdSets.forEach(function (idSet) {
                                    delete idSet[observerId];
                                });
                                delete exports.observerInfoMap[observerId];
                            };
                        }
                        exports.observe = observe;
                        // eslint-disable-next-line max-params
                        function makeObservableData(obj, resultObj, key, storage, propObserverIdSetMap, sync) {
                            var getter = (Object.getOwnPropertyDescriptor(obj, key) || {}).get;
                            var observerIdSet = (propObserverIdSetMap[key] = {});
                            Object.defineProperty(resultObj, key, {
                                configurable: true,
                                enumerable: true,
                                get: function () {
                                    var observerId = common_1.last(observerIdStack);
                                    if (!paused && observerId && !observerIdSet[observerId]) {
                                        observerIdSet[observerId] = true;
                                        exports.observerInfoMap[observerId].targetObserverIdSets.push(observerIdSet);
                                    }
                                    return storage[key];
                                },
                            });
                            if (common_1.isFunction(getter)) {
                                observe(function () {
                                    var value = getter.call(resultObj);
                                    setValue(storage, resultObj, observerIdSet, key, value);
                                }, sync);
                            }
                            else {
                                // has to add 'as' type assertion and refer the below typescript issue
                                // In general, the constraint Record<string, XXX> doesn't actually ensure that an argument has a string index signature,
                                // it merely ensures that the properties of the argument are assignable to type XXX.
                                // So, in the example above you could effectively pass any object and the function could write to any property without any checks.
                                // https://github.com/microsoft/TypeScript/issues/31661
                                storage[key] = obj[key];
                                if (Array.isArray(storage[key])) {
                                    array_1.patchArrayMethods(storage[key], resultObj, key);
                                }
                                Object.defineProperty(resultObj, key, {
                                    set: function (value) {
                                        setValue(storage, resultObj, observerIdSet, key, value);
                                    },
                                });
                            }
                        }
                        function partialObservable(obj, key) {
                            var storage = obj.__storage__;
                            var propObserverIdSetMap = obj.__propObserverIdSetMap__;
                            makeObservableData(obj, obj, key, storage, propObserverIdSetMap);
                        }
                        exports.partialObservable = partialObservable;
                        function observable(obj, sync) {
                            if (sync === void 0) { sync = false; }
                            if (Array.isArray(obj)) {
                                throw new Error('Array object cannot be Reactive');
                            }
                            if (isObservable(obj)) {
                                return obj;
                            }
                            var storage = {};
                            var propObserverIdSetMap = {};
                            var resultObj = {};
                            Object.defineProperties(resultObj, {
                                __storage__: { value: storage },
                                __propObserverIdSetMap__: { value: propObserverIdSetMap },
                            });
                            Object.keys(obj).forEach(function (key) {
                                makeObservableData(obj, resultObj, key, storage, propObserverIdSetMap, sync);
                            });
                            return resultObj;
                        }
                        exports.observable = observable;
                        function notifyUnit(obj, key) {
                            Object.keys(obj.__propObserverIdSetMap__[key]).forEach(function (observerId) {
                                run(observerId);
                            });
                        }
                        function notify(obj) {
                            var keys = [];
                            for (var _i = 1; _i < arguments.length; _i++) {
                                keys[_i - 1] = arguments[_i];
                            }
                            if (isObservable(obj)) {
                                keys.forEach(function (key) { return notifyUnit(obj, key); });
                            }
                        }
                        exports.notify = notify;
                        function getOriginObject(obj) {
                            var result = {};
                            common_1.forEachObject(function (value, key) {
                                result[key] = isObservable(value) ? getOriginObject(value) : value;
                            }, obj.__storage__);
                            return common_1.isEmpty(result) ? obj : result;
                        }
                        exports.getOriginObject = getOriginObject;
                        function unobservedInvoke(fn) {
                            paused = true;
                            fn();
                            paused = false;
                        }
                        exports.unobservedInvoke = unobservedInvoke;
                        function batchObserver(fn) {
                            pending = true;
                            fn();
                            pending = false;
                        }
                        exports.batchObserver = batchObserver;
                        var asyncTimer = null;
                        function asyncInvokeObserver(fn) {
                            if (common_1.isNull(asyncTimer)) {
                                asyncTimer = setTimeout(function () {
                                    fn();
                                    asyncTimer = null;
                                });
                            }
                        }
                        exports.asyncInvokeObserver = asyncInvokeObserver;


                        /***/ }),
                    /* 6 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.changeRawDataToOriginDataForTree = exports.getOmittedInternalProp = exports.createChangeInfo = exports.getFormattedValue = exports.getRowKeyByIndexWithPageRange = exports.getRowIndexPerPage = exports.isClientPagination = exports.isScrollPagination = exports.getMaxRowKey = exports.isFiltered = exports.isSorted = exports.getCreatedRowInfo = exports.getRemovedClassName = exports.getAddedClassName = exports.getLoadingState = exports.getRowHeight = exports.isInitialSortState = exports.isSortable = exports.getUniqColumnData = exports.findRowByRowKey = exports.findIndexByRowKey = exports.getConditionalRows = exports.getCheckedRowInfoList = exports.isEditableCell = exports.getCellAddressByIndex = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var instance_1 = __webpack_require__(7);
                        var rowSpan_1 = __webpack_require__(11);
                        var column_1 = __webpack_require__(12);
                        var data_1 = __webpack_require__(13);
                        var data_2 = __webpack_require__(25);
                        var data_3 = __webpack_require__(14);
                        var validation_1 = __webpack_require__(24);
                        var observable_1 = __webpack_require__(5);
                        function getCellAddressByIndex(_a, rowIndex, columnIndex) {
                            var data = _a.data, column = _a.column;
                            return {
                                rowKey: data.filteredViewData[rowIndex].rowKey,
                                columnName: column.visibleColumns[columnIndex].name,
                            };
                        }
                        exports.getCellAddressByIndex = getCellAddressByIndex;
                        function isEditableCell(data, column, rowIndex, columnName) {
                            var _a = data.filteredViewData[rowIndex].valueMap[columnName], disabled = _a.disabled, editable = _a.editable;
                            return !column_1.isHiddenColumn(column, columnName) && editable && !disabled;
                        }
                        exports.isEditableCell = isEditableCell;
                        function getCheckedRowInfoList(_a) {
                            var data = _a.data;
                            var targetRows = {
                                rowIndexes: [],
                                rows: [],
                                nextRows: [],
                            };
                            data.rawData.reduce(function (acc, row, index) {
                                if (row._attributes.checked) {
                                    acc.rowIndexes.push(index);
                                    acc.rows.push(row);
                                    acc.nextRows.push(data.rawData[index + 1]);
                                }
                                return acc;
                            }, targetRows);
                            return targetRows;
                        }
                        exports.getCheckedRowInfoList = getCheckedRowInfoList;
                        function getConditionalRows(_a, conditions) {
                            var data = _a.data;
                            var rawData = data.rawData;
                            if (common_1.isFunction(conditions)) {
                                return rawData.filter(conditions);
                            }
                            var result = rawData;
                            Object.keys(conditions).forEach(function (key) {
                                result = result.filter(function (row) { return row[key] === conditions[key]; });
                            });
                            return result;
                        }
                        exports.getConditionalRows = getConditionalRows;
                        function findIndexByRowKey(data, column, id, rowKey, filtered) {
                            if (filtered === void 0) { filtered = true; }
                            if (common_1.isNil(rowKey)) {
                                return -1;
                            }
                            var filteredRawData = data.filteredRawData, rawData = data.rawData, sortState = data.sortState;
                            var targetData = filtered ? filteredRawData : rawData;
                            var dataManager = instance_1.getDataManager(id);
                            var modified = dataManager ? dataManager.isMixedOrder() : false;
                            if (!rowSpan_1.isRowSpanEnabled(sortState) || column.keyColumnName || modified) {
                                return common_1.findPropIndex('rowKey', rowKey, targetData);
                            }
                            var start = 0;
                            var end = targetData.length - 1;
                            while (start <= end) {
                                var mid = Math.floor((start + end) / 2);
                                var comparedRowKey = targetData[mid].rowKey;
                                if (rowKey > comparedRowKey) {
                                    start = mid + 1;
                                }
                                else if (rowKey < comparedRowKey) {
                                    end = mid - 1;
                                }
                                else {
                                    return mid;
                                }
                            }
                            return -1;
                        }
                        exports.findIndexByRowKey = findIndexByRowKey;
                        function findRowByRowKey(data, column, id, rowKey, filtered) {
                            if (filtered === void 0) { filtered = true; }
                            var targetData = filtered ? data.filteredRawData : data.rawData;
                            return targetData[findIndexByRowKey(data, column, id, rowKey, filtered)];
                        }
                        exports.findRowByRowKey = findRowByRowKey;
                        function getUniqColumnData(targetData, column, columnName) {
                            var columnInfo = column.allColumnMap[columnName];
                            var uniqColumnData = common_1.uniqByProp(columnName, targetData);
                            return uniqColumnData.map(function (row) {
                                var value = row[columnName];
                                var formatterProps = {
                                    row: row,
                                    value: value,
                                    column: columnInfo,
                                };
                                var relationListItems = row._relationListItemMap[columnName];
                                return data_2.getFormattedValue(formatterProps, columnInfo.formatter, value, relationListItems);
                            });
                        }
                        exports.getUniqColumnData = getUniqColumnData;
                        function isSortable(sortState, column, columnName) {
                            if (columnName === 'sortKey') {
                                return true;
                            }
                            var _a = column.allColumnMap[columnName], sortable = _a.sortable, hidden = _a.hidden;
                            return sortState.useClient && !hidden && sortable;
                        }
                        exports.isSortable = isSortable;
                        function isInitialSortState(_a) {
                            var columns = _a.columns;
                            return columns.length === 1 && columns[0].columnName === 'sortKey';
                        }
                        exports.isInitialSortState = isInitialSortState;
                        function getRowHeight(row, defaultRowHeight) {
                            var _a = row._attributes, height = _a.height, tree = _a.tree;
                            var rowHeight = tree && tree.hidden ? 0 : height;
                            return common_1.isNumber(rowHeight) ? rowHeight : defaultRowHeight;
                        }
                        exports.getRowHeight = getRowHeight;
                        function getLoadingState(rawData) {
                            return rawData.length ? 'DONE' : 'EMPTY';
                        }
                        exports.getLoadingState = getLoadingState;
                        function getAddedClassName(className, prevClassNames) {
                            var classNames = className.split(' ');
                            var columnClassNames = prevClassNames ? prevClassNames : [];
                            return common_1.uniq(tslib_1.__spreadArrays(classNames, columnClassNames));
                        }
                        exports.getAddedClassName = getAddedClassName;
                        function getRemovedClassName(className, prevClassNames) {
                            var classNames = className.split(' ');
                            var removedClassNames = prevClassNames;
                            classNames.forEach(function (clsName) {
                                common_1.removeArrayItem(clsName, removedClassNames);
                            });
                            return removedClassNames;
                        }
                        exports.getRemovedClassName = getRemovedClassName;
                        function getCreatedRowInfo(store, rowIndex, row, rowKey) {
                            data_1.generateDataCreationKey();
                            var data = store.data, column = store.column, id = store.id;
                            var rawData = data.rawData;
                            var prevRow = rawData[rowIndex - 1];
                            var options = { prevRow: prevRow, lazyObservable: true };
                            if (!common_1.isUndefined(rowKey)) {
                                row.rowKey = rowKey;
                            }
                            var index = getMaxRowKey(data);
                            var rawRow = data_1.createRawRow(id, tslib_1.__assign(tslib_1.__assign({}, column.emptyRow), row), index, column, options);
                            var viewRow = { rowKey: row.rowKey, sortKey: row.sortKey, uniqueKey: row.uniqueKey };
                            return { rawRow: rawRow, viewRow: viewRow, prevRow: prevRow };
                        }
                        exports.getCreatedRowInfo = getCreatedRowInfo;
                        function isSorted(data) {
                            return data.sortState.columns[0].columnName !== 'sortKey';
                        }
                        exports.isSorted = isSorted;
                        function isFiltered(data) {
                            return !common_1.isNull(data.filters);
                        }
                        exports.isFiltered = isFiltered;
                        function getMaxRowKey(data) {
                            return Math.max.apply(Math, tslib_1.__spreadArrays([-1], common_1.mapProp('rowKey', data.rawData))) + 1;
                        }
                        exports.getMaxRowKey = getMaxRowKey;
                        function isScrollPagination(_a, useClient) {
                            var pageOptions = _a.pageOptions;
                            if (common_1.isUndefined(useClient)) {
                                return pageOptions.type === 'scroll';
                            }
                            return useClient && pageOptions.type === 'scroll';
                        }
                        exports.isScrollPagination = isScrollPagination;
                        function isClientPagination(_a) {
                            var pageOptions = _a.pageOptions;
                            return !common_1.isEmpty(pageOptions) && pageOptions.useClient && pageOptions.type === 'pagination';
                        }
                        exports.isClientPagination = isClientPagination;
                        function getRowIndexPerPage(data, rowIndex) {
                            return isClientPagination(data) ? rowIndex % data.pageOptions.perPage : rowIndex;
                        }
                        exports.getRowIndexPerPage = getRowIndexPerPage;
                        function getRowKeyByIndexWithPageRange(data, rowIndex) {
                            if (isClientPagination(data)) {
                                rowIndex += data.pageRowRange[0];
                            }
                            return data.filteredRawData[rowIndex].rowKey;
                        }
                        exports.getRowKeyByIndexWithPageRange = getRowKeyByIndexWithPageRange;
                        function getFormattedValue(store, rowKey, columnName) {
                            var data = store.data, column = store.column, id = store.id;
                            var rowIndex = findIndexByRowKey(data, column, id, rowKey, false);
                            var viewData = data.viewData;
                            if (rowIndex !== -1) {
                                data_3.makeObservable(store, rowIndex);
                                var viewCell = viewData[rowIndex].valueMap[columnName];
                                return viewCell ? viewCell.formattedValue : null;
                            }
                            return null;
                        }
                        exports.getFormattedValue = getFormattedValue;
                        function createChangeInfo(store, row, columnName, pastingValue, index) {
                            var id = store.id, column = store.column;
                            var rowKey = row.rowKey;
                            var prevChange = { rowKey: rowKey, columnName: columnName, value: row[columnName], nextValue: pastingValue };
                            var nextChange = { rowKey: rowKey, columnName: columnName, prevValue: row[columnName], value: pastingValue };
                            var changeValue = function () {
                                var value = prevChange.value, nextValue = prevChange.nextValue;
                                validation_1.replaceColumnUniqueInfoMap(id, column, {
                                    rowKey: rowKey,
                                    columnName: columnName,
                                    prevValue: value,
                                    value: nextValue,
                                });
                                nextChange.value = nextValue;
                                row[columnName] = nextValue;
                                return index;
                            };
                            return { prevChange: prevChange, nextChange: nextChange, changeValue: changeValue };
                        }
                        exports.createChangeInfo = createChangeInfo;
                        function getOmittedInternalProp(row) {
                            var additaional = [];
                            for (var _i = 1; _i < arguments.length; _i++) {
                                additaional[_i - 1] = arguments[_i];
                            }
                            return common_1.omit.apply(void 0, tslib_1.__spreadArrays([observable_1.getOriginObject(row), 'sortKey',
                                'uniqueKey',
                                'rowSpanMap',
                                '_relationListItemMap',
                                '_disabledPriority'], additaional));
                        }
                        exports.getOmittedInternalProp = getOmittedInternalProp;
                        function changeRowToOriginRowForTree(row) {
                            var originRow = getOmittedInternalProp(row, 'rowKey', '_attributes');
                            if (originRow._children) {
                                originRow._children = originRow._children.map(function (childRow) {
                                    return changeRowToOriginRowForTree(childRow);
                                });
                            }
                            return originRow;
                        }
                        function changeRawDataToOriginDataForTree(rawData) {
                            return rawData
                                .filter(function (row) { var _a, _b; return common_1.isNil((_b = (_a = row._attributes) === null || _a === void 0 ? void 0 : _a.tree) === null || _b === void 0 ? void 0 : _b.parentRowKey); })
                                .map(function (row) { return changeRowToOriginRowForTree(row); });
                        }
                        exports.changeRawDataToOriginDataForTree = changeRawDataToOriginDataForTree;


                        /***/ }),
                    /* 7 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getPaginationManager = exports.getDataManager = exports.getDataProvider = exports.getInstance = exports.registerDataSources = exports.register = void 0;
                        var common_1 = __webpack_require__(0);
                        var currentId = 0;
                        var instanceMap = {};
                        function generateId() {
                            currentId += 1;
                            return currentId;
                        }
                        function register(instance) {
                            var id = generateId();
                            if (!common_1.isObject(instanceMap[id])) {
                                instanceMap[id] = {};
                            }
                            instanceMap[id].grid = instance;
                            return id;
                        }
                        exports.register = register;
                        function registerDataSources(id, dataProvider, dataManager, paginationManager) {
                            instanceMap[id].dataProvider = dataProvider;
                            instanceMap[id].dataManager = dataManager;
                            instanceMap[id].paginationManager = paginationManager;
                        }
                        exports.registerDataSources = registerDataSources;
                        function getInstance(id) {
                            return instanceMap[id].grid;
                        }
                        exports.getInstance = getInstance;
                        function getDataProvider(id) {
                            return instanceMap[id].dataProvider;
                        }
                        exports.getDataProvider = getDataProvider;
                        function getDataManager(id) {
                            return instanceMap[id].dataManager;
                        }
                        exports.getDataManager = getDataManager;
                        function getPaginationManager(id) {
                            return instanceMap[id].paginationManager;
                        }
                        exports.getPaginationManager = getPaginationManager;


                        /***/ }),
                    /* 8 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getEventBus = exports.createEventBus = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var instance_1 = __webpack_require__(7);
                        var eventBusMap = {};
                        function createEventBus(id) {
                            var listenersMap = {};
                            eventBusMap[id] = {
                                on: function (eventName, func) {
                                    var listeners = listenersMap[eventName];
                                    listenersMap[eventName] = listeners ? tslib_1.__spreadArrays(listeners, [func]) : [func];
                                },
                                off: function (eventName, func) {
                                    var listeners = listenersMap[eventName];
                                    if (listeners) {
                                        if (func) {
                                            listenersMap[eventName] = common_1.removeArrayItem(func, listeners);
                                        }
                                        else {
                                            delete listenersMap[eventName];
                                        }
                                    }
                                },
                                trigger: function (eventName, gridEvent) {
                                    if (listenersMap[eventName]) {
                                        var instance = instance_1.getInstance(id);
                                        gridEvent.setInstance(instance);
                                        listenersMap[eventName].forEach(function (func) {
                                            func(gridEvent);
                                        });
                                    }
                                },
                            };
                            return eventBusMap[id];
                        }
                        exports.createEventBus = createEventBus;
                        function getEventBus(id) {
                            return eventBusMap[id];
                        }
                        exports.getEventBus = getEventBus;


                        /***/ }),
                    /* 9 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        var tslib_1 = __webpack_require__(1);
                        var dom_1 = __webpack_require__(2);
                        var common_1 = __webpack_require__(0);
                        var column_1 = __webpack_require__(10);
                        function getTargetInfo(nativeEvent) {
                            var targetType = 'etc';
                            var target = nativeEvent.target;
                            var cell = dom_1.findParentByTagName(target, 'td');
                            var rowKey, columnName;
                            if (cell) {
                                var address = dom_1.getCellAddress(cell);
                                if (address) {
                                    rowKey = address.rowKey;
                                    columnName = address.columnName;
                                    targetType = column_1.isRowHeader(address.columnName) ? 'rowHeader' : 'cell';
                                }
                                else {
                                    targetType = 'dummy';
                                }
                            }
                            else {
                                cell = dom_1.findParentByTagName(target, 'th');
                                if (cell) {
                                    columnName = cell.getAttribute(dom_1.dataAttr.COLUMN_NAME);
                                    targetType = 'columnHeader';
                                }
                            }
                            return common_1.pruneObject({
                                nativeEvent: nativeEvent,
                                targetType: targetType,
                                rowKey: rowKey,
                                columnName: columnName,
                            });
                        }
                        /**
                         * Event class for public event of Grid
                         * @module event/gridEvent
                         * @param {Object} data - Event data for handler
                         */
                        var GridEvent = /** @class */ (function () {
                            function GridEvent(_a) {
                                if (_a === void 0) { _a = {}; }
                                var event = _a.event, props = tslib_1.__rest(_a, ["event"]);
                                this.stopped = false;
                                if (event) {
                                    this.assignData(getTargetInfo(event));
                                }
                                if (props) {
                                    this.assignData(props);
                                }
                            }
                            /**
                             * Stops propogation of this event.
                             * @memberof event/gridEvent
                             */
                            GridEvent.prototype.stop = function () {
                                this.stopped = true;
                            };
                            GridEvent.prototype.isStopped = function () {
                                return this.stopped;
                            };
                            GridEvent.prototype.assignData = function (data) {
                                common_1.assign(this, data);
                            };
                            GridEvent.prototype.setInstance = function (instance) {
                                common_1.assign(this, { instance: instance });
                            };
                            return GridEvent;
                        }());
                        exports.default = GridEvent;


                        /***/ }),
                    /* 10 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.isCheckboxColumn = exports.isRowNumColumn = exports.isRowHeader = void 0;
                        function isRowHeader(columnName) {
                            return ['_number', '_checked'].indexOf(columnName) > -1;
                        }
                        exports.isRowHeader = isRowHeader;
                        function isRowNumColumn(columnName) {
                            return columnName === '_number';
                        }
                        exports.isRowNumColumn = isRowNumColumn;
                        function isCheckboxColumn(columnName) {
                            return columnName === '_checked';
                        }
                        exports.isCheckboxColumn = isCheckboxColumn;


                        /***/ }),
                    /* 11 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.isRowSpanEnabled = exports.getMaxRowSpanCount = exports.getRowSpanByRowKey = exports.getRowSpanBottomIndex = exports.getRowSpanTopIndex = exports.getRowSpan = exports.getVerticalPosWithRowSpan = exports.getRowRangeWithRowSpan = exports.getMaxRowSpanRange = void 0;
                        var common_1 = __webpack_require__(0);
                        var selection_1 = __webpack_require__(19);
                        function getMainRowSpan(columnName, rowSpan, data) {
                            var mainRow = rowSpan.mainRow, mainRowKey = rowSpan.mainRowKey;
                            if (mainRow) {
                                return rowSpan;
                            }
                            var mainRowIndex = common_1.findPropIndex('rowKey', mainRowKey, data);
                            return data[mainRowIndex].rowSpanMap[columnName];
                        }
                        function getRowSpanRange(rowRange, colRange, visibleColumns, data) {
                            var startColumnIndex = colRange[0], endColumnIndex = colRange[1];
                            var startRowIndex = rowRange[0], endRowIndex = rowRange[1];
                            for (var index = startColumnIndex; index <= endColumnIndex; index += 1) {
                                var rawData = data.rawData;
                                var startRowSpanMap = rawData[startRowIndex].rowSpanMap;
                                var endRowSpanMap = rawData[endRowIndex].rowSpanMap;
                                var columnName = visibleColumns[index].name;
                                // get top row index of topmost rowSpan
                                if (startRowSpanMap[columnName]) {
                                    var mainRowKey = startRowSpanMap[columnName].mainRowKey;
                                    var topRowSpanIndex = common_1.findPropIndex('rowKey', mainRowKey, rawData);
                                    startRowIndex = startRowIndex > topRowSpanIndex ? topRowSpanIndex : startRowIndex;
                                }
                                // get bottom row index of bottommost rowSpan
                                if (endRowSpanMap[columnName]) {
                                    var _a = endRowSpanMap[columnName], mainRowKey = _a.mainRowKey, spanCount = _a.spanCount;
                                    var bottomRowSpanIndex = common_1.findPropIndex('rowKey', mainRowKey, rawData) + spanCount - 1;
                                    endRowIndex = endRowIndex < bottomRowSpanIndex ? bottomRowSpanIndex : endRowIndex;
                                }
                            }
                            return startRowIndex !== rowRange[0] || endRowIndex !== rowRange[1]
                                ? getRowSpanRange([startRowIndex, endRowIndex], colRange, visibleColumns, data)
                                : [startRowIndex, endRowIndex];
                        }
                        function getMaxRowSpanRange(rowRange, colRange, visibleColumns, focusRowIndex, data) {
                            var sortedColRange = selection_1.getSortedRange(colRange);
                            var endRowIndex = rowRange[1];
                            var startRowIndex = rowRange[0];
                            // if start row index is different from focused index,
                            // change start row index to focused row index for getting proper row range
                            startRowIndex =
                                !common_1.isNull(focusRowIndex) && startRowIndex !== focusRowIndex ? focusRowIndex : startRowIndex;
                            var sortedRowRange = selection_1.getSortedRange([startRowIndex, endRowIndex]);
                            var _a = getRowSpanRange(sortedRowRange, sortedColRange, visibleColumns, data), startRowSpanIndex = _a[0], endRowSpanIndex = _a[1];
                            return startRowIndex > endRowIndex
                                ? [endRowSpanIndex, startRowSpanIndex]
                                : [startRowSpanIndex, endRowSpanIndex];
                        }
                        exports.getMaxRowSpanRange = getMaxRowSpanRange;
                        function getRowRangeWithRowSpan(rowRange, colRange, visibleColumnsWithRowHeader, rowIndex, data) {
                            if (isRowSpanEnabled(data.sortState)) {
                                return getMaxRowSpanRange(rowRange, colRange, visibleColumnsWithRowHeader, rowIndex, data);
                            }
                            return rowRange;
                        }
                        exports.getRowRangeWithRowSpan = getRowRangeWithRowSpan;
                        function getVerticalPosWithRowSpan(columnName, rowSpan, rowCoords, data) {
                            var mainRowSpan = getMainRowSpan(columnName, rowSpan, data);
                            var mainRowIndex = common_1.findPropIndex('rowKey', mainRowSpan.mainRowKey, data);
                            var spanCount = mainRowSpan.spanCount;
                            var top = rowCoords.offsets[mainRowIndex];
                            var bottom = top;
                            for (var count = 0; count < spanCount; count += 1) {
                                bottom += rowCoords.heights[mainRowIndex + count];
                            }
                            return [top, bottom];
                        }
                        exports.getVerticalPosWithRowSpan = getVerticalPosWithRowSpan;
                        function getRowSpan(rowIndex, columnName, data) {
                            var rowSpanMap = data[rowIndex].rowSpanMap;
                            return rowSpanMap[columnName];
                        }
                        exports.getRowSpan = getRowSpan;
                        /*
     * get top row index of specific rowSpan cell
     */
                        function getRowSpanTopIndex(rowIndex, columnName, data) {
                            var rowSpan = getRowSpan(rowIndex, columnName, data);
                            if (!rowSpan) {
                                return rowIndex;
                            }
                            return common_1.findPropIndex('rowKey', rowSpan.mainRowKey, data);
                        }
                        exports.getRowSpanTopIndex = getRowSpanTopIndex;
                        /*
     * get bottom row index of specific rowSpan cell
     */
                        function getRowSpanBottomIndex(rowIndex, columnName, data) {
                            var rowSpan = getRowSpan(rowIndex, columnName, data);
                            if (!rowSpan) {
                                return rowIndex;
                            }
                            var mainRowIndex = common_1.findPropIndex('rowKey', rowSpan.mainRowKey, data);
                            return mainRowIndex + rowSpan.spanCount - 1;
                        }
                        exports.getRowSpanBottomIndex = getRowSpanBottomIndex;
                        function getRowSpanByRowKey(rowKey, columnName, data) {
                            var rowIndex = common_1.findPropIndex('rowKey', rowKey, data);
                            if (rowIndex === -1) {
                                return null;
                            }
                            return getRowSpan(rowIndex, columnName, data) || null;
                        }
                        exports.getRowSpanByRowKey = getRowSpanByRowKey;
                        /*
     * get max rowSpan count in all columns that have rowSpan
     */
                        function getMaxRowSpanCount(rowIndex, data) {
                            var _a;
                            var rowSpanMap = (_a = data[rowIndex]) === null || _a === void 0 ? void 0 : _a.rowSpanMap;
                            if (common_1.isEmpty(rowSpanMap)) {
                                return 0;
                            }
                            return Object.keys(rowSpanMap).reduce(function (acc, columnName) { return Math.max(acc, rowSpanMap[columnName].spanCount); }, 0);
                        }
                        exports.getMaxRowSpanCount = getMaxRowSpanCount;
                        function isRowSpanEnabled(sortState) {
                            return sortState.columns[0].columnName === 'sortKey';
                        }
                        exports.isRowSpanEnabled = isRowSpanEnabled;


                        /***/ }),
                    /* 12 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getColumnSide = exports.getChildHeaderCount = exports.getHierarchyMaxRowCount = exports.getComplexColumnsHierarchy = exports.getRemovedHiddenChildColumns = exports.getColumnHierarchy = exports.isComplexHeader = exports.isHiddenColumn = exports.isParentColumnHeader = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        function isParentColumnHeader(complexColumnHeaders, name) {
                            return !!complexColumnHeaders.length && common_1.some(function (item) { return item.name === name; }, complexColumnHeaders);
                        }
                        exports.isParentColumnHeader = isParentColumnHeader;
                        function isHiddenColumn(column, columnName) {
                            return column.allColumnMap[columnName].hidden;
                        }
                        exports.isHiddenColumn = isHiddenColumn;
                        function isComplexHeader(column, columnName) {
                            return common_1.some(function (_a) {
                                var name = _a.name, hideChildHeaders = _a.hideChildHeaders, childNames = _a.childNames;
                                return !!(name === columnName || (hideChildHeaders && common_1.includes(childNames, columnName)));
                            }, column.complexColumnHeaders);
                        }
                        exports.isComplexHeader = isComplexHeader;
                        function getColumnHierarchy(column, complexColumnHeaders, mergedComplexColumns) {
                            var complexColumns = mergedComplexColumns || [];
                            if (column) {
                                complexColumns.push(column);
                                if (complexColumnHeaders) {
                                    complexColumnHeaders.forEach(function (complexColumnHeader) {
                                        if (common_1.includes(complexColumnHeader.childNames, column.name)) {
                                            getColumnHierarchy(complexColumnHeader, complexColumnHeaders, complexColumns);
                                        }
                                    });
                                }
                            }
                            return complexColumns;
                        }
                        exports.getColumnHierarchy = getColumnHierarchy;
                        function getRemovedHiddenChildColumns(hierarchies) {
                            return hierarchies.map(function (columns) {
                                if (columns.length > 1) {
                                    // The hideChildHeaders option always exists in the second column to last.
                                    var hideChildHeaders = columns[columns.length - 2].hideChildHeaders;
                                    if (hideChildHeaders) {
                                        columns.pop();
                                    }
                                }
                                return columns;
                            });
                        }
                        exports.getRemovedHiddenChildColumns = getRemovedHiddenChildColumns;
                        function getComplexColumnsHierarchy(columns, complexColumnHeaders) {
                            return getRemovedHiddenChildColumns(columns.map(function (column) { return getColumnHierarchy(column, complexColumnHeaders).reverse(); }));
                        }
                        exports.getComplexColumnsHierarchy = getComplexColumnsHierarchy;
                        function getHierarchyMaxRowCount(hierarchies) {
                            return Math.max.apply(Math, tslib_1.__spreadArrays([0], common_1.mapProp('length', hierarchies)));
                        }
                        exports.getHierarchyMaxRowCount = getHierarchyMaxRowCount;
                        function getChildHeaderCount(columns, complexColumns, name) {
                            var count = 0;
                            var leafColumn = common_1.someProp('name', name, columns);
                            if (!leafColumn) {
                                var complexColumn = common_1.findProp('name', name, complexColumns);
                                if (complexColumn) {
                                    complexColumn.childNames.forEach(function (childName) {
                                        var leafChildColumn = common_1.someProp('name', childName, columns);
                                        count += leafChildColumn ? 1 : getChildHeaderCount(columns, complexColumns, childName);
                                    });
                                }
                            }
                            return count;
                        }
                        exports.getChildHeaderCount = getChildHeaderCount;
                        function getColumnSide(column, columnName) {
                            return common_1.someProp('name', columnName, column.visibleColumnsBySideWithRowHeader.R) ? 'R' : 'L';
                        }
                        exports.getColumnSide = getColumnSide;


                        /***/ }),
                    /* 13 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = exports.createData = exports.createRawRow = exports.setRowRelationListItems = exports.createViewRow = exports.createRowSpan = exports.generateDataCreationKey = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var observable_1 = __webpack_require__(5);
                        var column_1 = __webpack_require__(10);
                        var common_1 = __webpack_require__(0);
                        var tree_1 = __webpack_require__(20);
                        var validation_1 = __webpack_require__(24);
                        var data_1 = __webpack_require__(6);
                        var data_2 = __webpack_require__(25);
                        var dataCreationKey = '';
                        function generateDataCreationKey() {
                            dataCreationKey = "@dataKey" + Date.now();
                            return dataCreationKey;
                        }
                        exports.generateDataCreationKey = generateDataCreationKey;
                        function getRelationCbResult(fn, relationParams) {
                            var result = common_1.isFunction(fn) ? fn(relationParams) : null;
                            return common_1.isUndefined(result) ? null : result;
                        }
                        function getEditable(fn, relationParams) {
                            var result = getRelationCbResult(fn, relationParams);
                            return result === null ? true : result;
                        }
                        function getDisabled(fn, relationParams) {
                            var result = getRelationCbResult(fn, relationParams);
                            return result === null ? false : result;
                        }
                        function getListItems(fn, relationParams) {
                            return getRelationCbResult(fn, relationParams) || [];
                        }
                        function getRowHeaderValue(row, columnName) {
                            if (column_1.isRowNumColumn(columnName)) {
                                return row._attributes.rowNum;
                            }
                            if (column_1.isCheckboxColumn(columnName)) {
                                return row._attributes.checked;
                            }
                            return '';
                        }
                        function createRowSpan(mainRow, rowKey, count, spanCount) {
                            return { mainRow: mainRow, mainRowKey: rowKey, count: count, spanCount: spanCount };
                        }
                        exports.createRowSpan = createRowSpan;
                        function createViewCell(id, row, column, relationInfo) {
                            if (relationInfo === void 0) { relationInfo = {}; }
                            var _a = relationInfo.relationMatched, relationMatched = _a === void 0 ? true : _a, relationListItems = relationInfo.relationListItems;
                            var name = column.name, formatter = column.formatter, editor = column.editor, validation = column.validation, defaultValue = column.defaultValue;
                            var value = column_1.isRowHeader(name) ? getRowHeaderValue(row, name) : row[name];
                            if (common_1.isNil(value) && !common_1.isNil(defaultValue)) {
                                value = defaultValue;
                            }
                            if (!relationMatched) {
                                value = '';
                            }
                            var formatterProps = { row: row, column: column, value: value };
                            var _b = row._attributes, disabled = _b.disabled, checkDisabled = _b.checkDisabled, classNameAttr = _b.className;
                            var columnDisabled = !!column.disabled;
                            var rowDisabled = column_1.isCheckboxColumn(name) ? checkDisabled : disabled;
                            var columnClassName = common_1.isUndefined(classNameAttr.column[name]) ? [] : classNameAttr.column[name];
                            var className = tslib_1.__spreadArrays(classNameAttr.row, columnClassName).join(' ');
                            var cellDisabled = rowDisabled || columnDisabled;
                            if (!common_1.isUndefined(row._disabledPriority[name])) {
                                cellDisabled = row._disabledPriority[name] === 'COLUMN' ? columnDisabled : rowDisabled;
                            }
                            return {
                                editable: !!editor,
                                className: className,
                                disabled: cellDisabled,
                                invalidStates: validation_1.getValidationCode({ id: id, value: row[name], row: row, validation: validation, columnName: name }),
                                formattedValue: data_2.getFormattedValue(formatterProps, formatter, value, relationListItems),
                                value: value,
                            };
                        }
                        function createRelationViewCell(id, name, row, _a) {
                            var columnMap = _a.columnMap, valueMap = _a.valueMap;
                            var _b = valueMap[name], editable = _b.editable, disabled = _b.disabled, value = _b.value;
                            var _c = columnMap[name].relationMap, relationMap = _c === void 0 ? {} : _c;
                            Object.keys(relationMap).forEach(function (targetName) {
                                var _a = relationMap[targetName], editableCallback = _a.editable, disabledCallback = _a.disabled, listItemsCallback = _a.listItems;
                                var relationCbParams = { value: value, editable: editable, disabled: disabled, row: row };
                                var targetEditable = getEditable(editableCallback, relationCbParams);
                                var targetDisabled = getDisabled(disabledCallback, relationCbParams);
                                var targetListItems = getListItems(listItemsCallback, relationCbParams);
                                var targetValue = row[targetName];
                                var targetEditor = columnMap[targetName].editor;
                                var targetEditorOptions = targetEditor === null || targetEditor === void 0 ? void 0 : targetEditor.options;
                                var relationMatched = common_1.isFunction(listItemsCallback)
                                    ? common_1.someProp('value', targetValue, targetListItems)
                                    : true;
                                var cellData = createViewCell(id, row, columnMap[targetName], {
                                    relationMatched: relationMatched,
                                    relationListItems: targetListItems,
                                });
                                if (!targetEditable) {
                                    cellData.editable = false;
                                }
                                if (targetDisabled) {
                                    cellData.disabled = true;
                                }
                                // should set the relation list to relationListItemMap for preventing to share relation list in other rows
                                if (targetEditorOptions) {
                                    targetEditorOptions.relationListItemMap = targetEditorOptions.relationListItemMap || {};
                                    targetEditorOptions.relationListItemMap[row.rowKey] = targetListItems;
                                }
                                valueMap[targetName] = cellData;
                            });
                        }
                        function createViewRow(id, row, rawData, column) {
                            var rowKey = row.rowKey, sortKey = row.sortKey, rowSpanMap = row.rowSpanMap, uniqueKey = row.uniqueKey;
                            var columnMap = column.columnMapWithRelation;
                            var _a = column.treeColumnName, treeColumnName = _a === void 0 ? '' : _a, _b = column.treeIcon, treeIcon = _b === void 0 ? true : _b;
                            var initValueMap = {};
                            Object.keys(columnMap).forEach(function (name) {
                                initValueMap[name] = null;
                            });
                            var valueMap = observable_1.observable(initValueMap);
                            var __unobserveFns__ = [];
                            Object.keys(columnMap).forEach(function (name) {
                                var _a = columnMap[name], related = _a.related, relationMap = _a.relationMap, className = _a.className;
                                if (className) {
                                    row._attributes.className.column[name] = className.split(' ');
                                }
                                // add condition expression to prevent to call watch function recursively
                                if (!related) {
                                    __unobserveFns__.push(observable_1.observe(function () {
                                        valueMap[name] = createViewCell(id, row, columnMap[name]);
                                    }));
                                }
                                if (relationMap && Object.keys(relationMap).length) {
                                    __unobserveFns__.push(observable_1.observe(function () {
                                        createRelationViewCell(id, name, row, { columnMap: columnMap, valueMap: valueMap });
                                    }));
                                }
                            });
                            return tslib_1.__assign({ rowKey: rowKey,
                                sortKey: sortKey,
                                uniqueKey: uniqueKey,
                                rowSpanMap: rowSpanMap,
                                valueMap: valueMap,
                                __unobserveFns__: __unobserveFns__ }, (treeColumnName && { treeInfo: tree_1.createTreeCellInfo(rawData, row, treeIcon) }));
                        }
                        exports.createViewRow = createViewRow;
                        function getAttributes(row, index, lazyObservable, disabled) {
                            var defaultAttr = {
                                rowNum: index + 1,
                                checked: false,
                                disabled: disabled,
                                checkDisabled: disabled,
                                className: {
                                    row: [],
                                    column: {},
                                },
                            };
                            if (row._attributes) {
                                if (common_1.isBoolean(row._attributes.disabled) && common_1.isUndefined(row._attributes.checkDisabled)) {
                                    row._attributes.checkDisabled = row._attributes.disabled;
                                }
                                if (!common_1.isUndefined(row._attributes.className)) {
                                    row._attributes.className = tslib_1.__assign({ row: [], column: {} }, row._attributes.className);
                                }
                            }
                            var attributes = tslib_1.__assign(tslib_1.__assign({}, defaultAttr), row._attributes);
                            return lazyObservable ? attributes : observable_1.observable(attributes);
                        }
                        function createRelationListItems(name, row, columnMap) {
                            var _a = columnMap[name], _b = _a.relationMap, relationMap = _b === void 0 ? {} : _b, editor = _a.editor;
                            var _c = row._attributes, checkDisabled = _c.checkDisabled, rowDisabled = _c.disabled;
                            var editable = !!editor;
                            var disabled = column_1.isCheckboxColumn(name) ? checkDisabled : rowDisabled;
                            var value = row[name];
                            var relationCbParams = { value: value, editable: editable, disabled: disabled, row: row };
                            var relationListItemMap = {};
                            Object.keys(relationMap).forEach(function (targetName) {
                                relationListItemMap[targetName] = getListItems(relationMap[targetName].listItems, relationCbParams);
                            });
                            return relationListItemMap;
                        }
                        function setRowRelationListItems(row, columnMap) {
                            var relationListItemMap = tslib_1.__assign({}, row._relationListItemMap);
                            Object.keys(columnMap).forEach(function (name) {
                                common_1.assign(relationListItemMap, createRelationListItems(name, row, columnMap));
                            });
                            row._relationListItemMap = relationListItemMap;
                        }
                        exports.setRowRelationListItems = setRowRelationListItems;
                        function createMainRowSpanMap(rowSpan, rowKey) {
                            var mainRowSpanMap = {};
                            if (!rowSpan) {
                                return mainRowSpanMap;
                            }
                            Object.keys(rowSpan).forEach(function (columnName) {
                                var spanCount = rowSpan[columnName];
                                mainRowSpanMap[columnName] = createRowSpan(true, rowKey, spanCount, spanCount);
                            });
                            return mainRowSpanMap;
                        }
                        function createSubRowSpan(prevRowSpanMap) {
                            var subRowSpanMap = {};
                            Object.keys(prevRowSpanMap).forEach(function (columnName) {
                                var prevRowSpan = prevRowSpanMap[columnName];
                                var mainRowKey = prevRowSpan.mainRowKey, count = prevRowSpan.count, spanCount = prevRowSpan.spanCount;
                                if (spanCount > 1 - count) {
                                    var subRowCount = count >= 0 ? -1 : count - 1;
                                    subRowSpanMap[columnName] = createRowSpan(false, mainRowKey, subRowCount, spanCount);
                                }
                            });
                            return subRowSpanMap;
                        }
                        function createRowSpanMap(row, rowSpan, prevRow) {
                            var rowKey = row.rowKey;
                            var mainRowSpanMap = {};
                            var subRowSpanMap = {};
                            if (!common_1.isEmpty(rowSpan)) {
                                mainRowSpanMap = createMainRowSpanMap(rowSpan, rowKey);
                            }
                            if (prevRow) {
                                var prevRowSpanMap = prevRow.rowSpanMap;
                                if (!common_1.isEmpty(prevRowSpanMap)) {
                                    subRowSpanMap = createSubRowSpan(prevRowSpanMap);
                                }
                            }
                            return tslib_1.__assign(tslib_1.__assign({}, mainRowSpanMap), subRowSpanMap);
                        }
                        function createRawRow(id, row, index, column, options) {
                            if (options === void 0) { options = {}; }
                            // this rowSpan variable is attribute option before creating rowSpanDataMap
                            var rowSpan;
                            var keyColumnName = options.keyColumnName, prevRow = options.prevRow, _a = options.lazyObservable, lazyObservable = _a === void 0 ? false : _a, _b = options.disabled, disabled = _b === void 0 ? false : _b;
                            if (row._attributes) {
                                rowSpan = row._attributes.rowSpan;
                            }
                            if (keyColumnName) {
                                row.rowKey = row[keyColumnName];
                            }
                            else if (common_1.isUndefined(row.rowKey)) {
                                row.rowKey = index;
                            }
                            row.sortKey = common_1.isNumber(row.sortKey) ? row.sortKey : index;
                            row.uniqueKey = dataCreationKey + "-" + row.rowKey;
                            row._attributes = getAttributes(row, index, lazyObservable, disabled);
                            row._attributes.rowSpan = rowSpan;
                            row._disabledPriority = row._disabledPriority || {};
                            row.rowSpanMap = createRowSpanMap(row, rowSpan, prevRow);
                            setRowRelationListItems(row, column.columnMapWithRelation);
                            if (column.autoResizingColumn.length) {
                                data_2.setMaxTextMap(column, row);
                            }
                            if (lazyObservable) {
                                validation_1.addUniqueInfoMap(id, row, column);
                            }
                            return (lazyObservable ? row : observable_1.observable(row));
                        }
                        exports.createRawRow = createRawRow;
                        function createData(id, data, column, _a) {
                            var _b = _a.lazyObservable, lazyObservable = _b === void 0 ? false : _b, prevRows = _a.prevRows, _c = _a.disabled, disabled = _c === void 0 ? false : _c;
                            generateDataCreationKey();
                            var keyColumnName = column.keyColumnName, _d = column.treeColumnName, treeColumnName = _d === void 0 ? '' : _d;
                            var rawData;
                            if (treeColumnName) {
                                rawData = tree_1.createTreeRawData({
                                    id: id,
                                    data: data,
                                    column: column,
                                    keyColumnName: keyColumnName,
                                    lazyObservable: lazyObservable,
                                    disabled: disabled,
                                });
                            }
                            else {
                                rawData = data.map(function (row, index, rows) {
                                    return createRawRow(id, row, index, column, {
                                        keyColumnName: keyColumnName,
                                        prevRow: prevRows ? prevRows[index] : rows[index - 1],
                                        lazyObservable: lazyObservable,
                                        disabled: disabled,
                                    });
                                });
                            }
                            var viewData = rawData.map(function (row) {
                                return lazyObservable
                                    ? { rowKey: row.rowKey, sortKey: row.sortKey, uniqueKey: row.uniqueKey }
                                    : createViewRow(id, row, rawData, column);
                            });
                            return { rawData: rawData, viewData: viewData };
                        }
                        exports.createData = createData;
                        var cachedFilteredIndex = {};
                        function applyFilterToRawData(rawData, filters, columnMap) {
                            var data = rawData;
                            cachedFilteredIndex = {};
                            if (filters) {
                                data = filters.reduce(function (acc, filter) {
                                    var conditionFn = filter.conditionFn, columnName = filter.columnName;
                                    var formatter = columnMap[columnName].formatter;
                                    return acc.filter(function (row, index) {
                                        var value = row[columnName];
                                        var relationListItems = row._relationListItemMap[columnName];
                                        var formatterProps = { row: row, column: columnMap[columnName], value: value };
                                        var filtered = conditionFn(data_2.getFormattedValue(formatterProps, formatter, value, relationListItems));
                                        // cache the filtered index for performance
                                        if (acc === rawData && filtered) {
                                            cachedFilteredIndex[row.rowKey] = index;
                                        }
                                        else if (!filtered) {
                                            cachedFilteredIndex[row.rowKey] = null;
                                        }
                                        return filtered;
                                    });
                                }, rawData);
                            }
                            return data;
                        }
                        function createPageOptions(userPageOptions, rawData) {
                            var pageOptions = (common_1.isEmpty(userPageOptions)
                                ? {}
                                : tslib_1.__assign(tslib_1.__assign({ useClient: false, page: 1, perPage: 20, type: 'pagination' }, userPageOptions), { totalCount: userPageOptions.useClient ? rawData.length : userPageOptions.totalCount }));
                            if (pageOptions.type === 'pagination') {
                                pageOptions.position = pageOptions.position || 'bottom';
                                pageOptions.visiblePages = pageOptions.visiblePages || 10;
                            }
                            return pageOptions;
                        }
                        function create(_a) {
                            var data = _a.data, column = _a.column, userPageOptions = _a.pageOptions, useClientSort = _a.useClientSort, disabled = _a.disabled, id = _a.id;
                            var _b = createData(id, data, column, { lazyObservable: true, disabled: disabled }), rawData = _b.rawData, viewData = _b.viewData;
                            var sortState = {
                                useClient: useClientSort,
                                columns: [
                                    {
                                        columnName: 'sortKey',
                                        ascending: true,
                                    },
                                ],
                            };
                            var pageOptions = createPageOptions(userPageOptions, rawData);
                            return observable_1.observable({
                                rawData: rawData,
                                viewData: viewData,
                                sortState: sortState,
                                pageOptions: pageOptions,
                                checkedAllRows: rawData.length ? !rawData.some(function (row) { return !row._attributes.checked; }) : false,
                                disabledAllCheckbox: disabled,
                                filters: null,
                                loadingState: rawData.length ? 'DONE' : 'EMPTY',
                                get filteredRawData() {
                                    var _a;
                                    if (this.filters) {
                                        // should filter the sliced data which is displayed in viewport in case of client infinite scrolling
                                        var targetData = data_1.isScrollPagination(this, true)
                                            ? (_a = this.rawData).slice.apply(_a, this.pageRowRange) : this.rawData;
                                        return applyFilterToRawData(targetData, this.filters, column.allColumnMap);
                                    }
                                    return this.rawData;
                                },
                                get filteredIndex() {
                                    var _a = this, filteredRawData = _a.filteredRawData, filters = _a.filters;
                                    return filters
                                        ? filteredRawData
                                            .filter(function (row) { return !common_1.isNull(cachedFilteredIndex[row.rowKey]); })
                                            .map(function (row) { return cachedFilteredIndex[row.rowKey]; })
                                        : null;
                                },
                                get filteredViewData() {
                                    var _this = this;
                                    return this.filters
                                        ? this.filteredIndex.map(function (index) { return _this.viewData[index]; })
                                        : this.viewData;
                                },
                                get pageRowRange() {
                                    var _a = this.pageOptions, useClient = _a.useClient, type = _a.type, page = _a.page, perPage = _a.perPage;
                                    var start = 0;
                                    // should calculate the range through all rawData in case of client infinite scrolling
                                    var end = data_1.isScrollPagination(this, true) ? this.rawData.length : this.filteredViewData.length;
                                    if (useClient) {
                                        var pageRowLastIndex = page * perPage;
                                        if (type === 'pagination') {
                                            start = (page - 1) * perPage;
                                        }
                                        end = pageRowLastIndex > 0 && pageRowLastIndex < end ? pageRowLastIndex : end;
                                    }
                                    return [start, end];
                                },
                            });
                        }
                        exports.create = create;


                        /***/ }),
                    /* 14 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.removeRows = exports.appendRows = exports.scrollToNext = exports.moveRow = exports.setRow = exports.updateRowNumber = exports.setCheckedAllRows = exports.setLoadingState = exports.removeColumnClassName = exports.addColumnClassName = exports.removeCellClassName = exports.addCellClassName = exports.removeRowClassName = exports.addRowClassName = exports.resetData = exports.clearData = exports.removeRow = exports.appendRow = exports.setRowCheckDisabled = exports.setColumnDisabled = exports.setRowDisabled = exports.setDisabled = exports.setDisabledAllCheckbox = exports.uncheckAll = exports.checkAll = exports.uncheck = exports.check = exports.setColumnValues = exports.setAllRowAttribute = exports.setRowAttribute = exports.isUpdatableRowAttr = exports.setValue = exports.makeObservable = exports.updateHeights = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var data_1 = __webpack_require__(13);
                        var observable_1 = __webpack_require__(5);
                        var selection_1 = __webpack_require__(15);
                        var eventBus_1 = __webpack_require__(8);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var instance_1 = __webpack_require__(7);
                        var tree_1 = __webpack_require__(29);
                        var rowSpan_1 = __webpack_require__(11);
                        var focus_1 = __webpack_require__(18);
                        var tree_2 = __webpack_require__(20);
                        var sort_1 = __webpack_require__(27);
                        var data_2 = __webpack_require__(6);
                        var summary_1 = __webpack_require__(23);
                        var filter_1 = __webpack_require__(33);
                        var viewport_1 = __webpack_require__(22);
                        var column_1 = __webpack_require__(10);
                        var pagination_1 = __webpack_require__(34);
                        var rowSpan_2 = __webpack_require__(72);
                        var lazyObservable_1 = __webpack_require__(26);
                        var validation_1 = __webpack_require__(24);
                        var column_2 = __webpack_require__(30);
                        function updateHeightsWithFilteredData(store) {
                            if (store.data.filters) {
                                focus_1.initFocus(store);
                            }
                            updateHeights(store);
                        }
                        function updateHeights(store) {
                            var data = store.data, rowCoords = store.rowCoords, dimension = store.dimension;
                            var pageOptions = data.pageOptions, pageRowRange = data.pageRowRange, filteredRawData = data.filteredRawData;
                            var rowHeight = dimension.rowHeight;
                            rowCoords.heights = pageOptions.useClient
                                ? filteredRawData.slice.apply(filteredRawData, pageRowRange).map(function (row) { return data_2.getRowHeight(row, rowHeight); })
                                : filteredRawData.map(function (row) { return data_2.getRowHeight(row, rowHeight); });
                        }
                        exports.updateHeights = updateHeights;
                        function makeObservable(store, rowIndex) {
                            var data = store.data, column = store.column, id = store.id;
                            var rawData = data.rawData, viewData = data.viewData;
                            var treeColumnName = column.treeColumnName;
                            var rawRow = rawData[rowIndex];
                            if (observable_1.isObservable(rawRow)) {
                                return;
                            }
                            if (treeColumnName) {
                                var parentRow = data_2.findRowByRowKey(data, column, id, rawRow._attributes.tree.parentRowKey);
                                rawData[rowIndex] = tree_2.createTreeRawRow(id, rawRow, parentRow || null, column);
                            }
                            else {
                                rawData[rowIndex] = data_1.createRawRow(id, rawRow, rowIndex, column);
                            }
                            viewData[rowIndex] = data_1.createViewRow(id, rawData[rowIndex], rawData, column);
                            observable_1.notify(data, 'rawData', 'filteredRawData', 'viewData', 'filteredViewData');
                        }
                        exports.makeObservable = makeObservable;
                        function setValue(store, rowKey, columnName, value, checkCellState) {
                            if (checkCellState === void 0) { checkCellState = false; }
                            var gridEvent;
                            var column = store.column, data = store.data, id = store.id;
                            var eventBus = eventBus_1.getEventBus(id);
                            var rawData = data.rawData, viewData = data.viewData, sortState = data.sortState;
                            var allColumnMap = column.allColumnMap, columnsWithoutRowHeader = column.columnsWithoutRowHeader;
                            var rowIndex = data_2.findIndexByRowKey(data, column, id, rowKey, false);
                            var targetRow = rawData[rowIndex];
                            if (!targetRow || targetRow[columnName] === value) {
                                return;
                            }
                            if (checkCellState) {
                                makeObservable(store, rowIndex);
                                var _a = viewData[rowIndex].valueMap[columnName], disabled = _a.disabled, editable = _a.editable;
                                if (disabled || !editable) {
                                    return;
                                }
                            }
                            var targetColumn = common_1.findProp('name', columnName, columnsWithoutRowHeader);
                            var orgValue = targetRow[columnName];
                            // @TODO: 'onBeforeChange' event is deprecated. This event will be replaced with 'beforeChange' event
                            if (targetColumn && targetColumn.onBeforeChange) {
                                gridEvent = new gridEvent_1.default({ rowKey: rowKey, columnName: columnName, value: orgValue, nextValue: value });
                                targetColumn.onBeforeChange(gridEvent);
                                if (gridEvent.isStopped()) {
                                    return;
                                }
                            }
                            var change = { rowKey: rowKey, columnName: columnName, value: orgValue, nextValue: value };
                            gridEvent = new gridEvent_1.default({ origin: 'cell', changes: [change] });
                            /**
                             * Occurs before one or more cells is changed
                             * @event Grid#beforeChange
                             * @property {string} origin - The type of change('paste', 'delete', 'cell')
                             * @property {Array.<object>} changes - rowKey, column name, original values and next values before changing the values
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('beforeChange', gridEvent);
                            if (gridEvent.isStopped()) {
                                return;
                            }
                            value = change.nextValue;
                            var rowSpanMap = targetRow.rowSpanMap;
                            var columns = sortState.columns;
                            var index = common_1.findPropIndex('columnName', columnName, columns);
                            validation_1.replaceColumnUniqueInfoMap(id, column, { rowKey: rowKey, columnName: columnName, prevValue: orgValue, value: value });
                            targetRow[columnName] = value;
                            data_1.setRowRelationListItems(targetRow, allColumnMap);
                            if (index !== -1) {
                                sort_1.sort(store, columnName, columns[index].ascending, true, false);
                            }
                            updateHeightsWithFilteredData(store);
                            summary_1.updateSummaryValueByCell(store, columnName, { orgValue: orgValue, value: value });
                            instance_1.getDataManager(id).push('UPDATE', targetRow);
                            if (!common_1.isEmpty(rowSpanMap) && rowSpanMap[columnName] && rowSpan_1.isRowSpanEnabled(sortState)) {
                                var spanCount = rowSpanMap[columnName].spanCount;
                                // update sub rows value
                                for (var count = 1; count < spanCount; count += 1) {
                                    rawData[rowIndex + count][columnName] = value;
                                    summary_1.updateSummaryValueByCell(store, columnName, { orgValue: orgValue, value: value });
                                    instance_1.getDataManager(id).push('UPDATE', rawData[rowIndex + count]);
                                }
                            }
                            column_2.setAutoResizingColumnWidths(store);
                            // @TODO: 'onAfterChange' event is deprecated. This event will be replaced with 'afterChange' event
                            if (targetColumn && targetColumn.onAfterChange) {
                                gridEvent = new gridEvent_1.default({ rowKey: rowKey, columnName: columnName, value: value, prevValue: orgValue });
                                targetColumn.onAfterChange(gridEvent);
                            }
                            gridEvent = new gridEvent_1.default({
                                origin: 'cell',
                                changes: [{ rowKey: rowKey, columnName: columnName, value: value, prevValue: orgValue }],
                            });
                            /**
                             * Occurs after one or more cells is changed
                             * @event Grid#afterChange
                             * @property {string} origin - The type of change('paste', 'delete', 'cell')
                             * @property {Array.<object>} changes - rowKey, column name, previous values and changed values after changing the values
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('afterChange', gridEvent);
                        }
                        exports.setValue = setValue;
                        function isUpdatableRowAttr(name, checkDisabled) {
                            return !(name === 'checked' && checkDisabled);
                        }
                        exports.isUpdatableRowAttr = isUpdatableRowAttr;
                        function setRowAttribute(_a, rowKey, attrName, value) {
                            var data = _a.data, column = _a.column, id = _a.id;
                            var targetRow = data_2.findRowByRowKey(data, column, id, rowKey, false);
                            // https://github.com/microsoft/TypeScript/issues/34293
                            if (targetRow && isUpdatableRowAttr(attrName, targetRow._attributes.checkDisabled)) {
                                targetRow._attributes[attrName] = value;
                            }
                        }
                        exports.setRowAttribute = setRowAttribute;
                        function setAllRowAttribute(_a, attrName, value, allPage) {
                            var data = _a.data;
                            if (allPage === void 0) { allPage = true; }
                            var filteredRawData = data.filteredRawData;
                            var range = allPage ? [0, filteredRawData.length] : data.pageRowRange;
                            filteredRawData.slice.apply(filteredRawData, range).forEach(function (row) {
                                if (isUpdatableRowAttr(attrName, row._attributes.checkDisabled)) {
                                    // https://github.com/microsoft/TypeScript/issues/34293
                                    row._attributes[attrName] = value;
                                }
                            });
                        }
                        exports.setAllRowAttribute = setAllRowAttribute;
                        function setColumnValues(store, columnName, value, checkCellState) {
                            if (checkCellState === void 0) { checkCellState = false; }
                            if (checkCellState) {
                                // @TODO: find more practical way to make observable
                                lazyObservable_1.createObservableData(store, true);
                            }
                            var id = store.id, data = store.data, column = store.column;
                            data.rawData.forEach(function (targetRow, index) {
                                var valid = true;
                                if (checkCellState) {
                                    var _a = data.viewData[index].valueMap[columnName], disabled = _a.disabled, editable = _a.editable;
                                    valid = !disabled && editable;
                                }
                                if (targetRow[columnName] !== value && valid) {
                                    validation_1.replaceColumnUniqueInfoMap(id, column, {
                                        rowKey: targetRow.rowKey,
                                        columnName: columnName,
                                        prevValue: targetRow[columnName],
                                        value: value,
                                    });
                                    targetRow[columnName] = value;
                                    instance_1.getDataManager(id).push('UPDATE', targetRow);
                                }
                            });
                            summary_1.updateSummaryValueByColumn(store, columnName, { value: value });
                            validation_1.forceValidateUniquenessOfColumn(data.rawData, column, columnName);
                            column_2.setAutoResizingColumnWidths(store);
                        }
                        exports.setColumnValues = setColumnValues;
                        function check(store, rowKey) {
                            var id = store.id, column = store.column;
                            var allColumnMap = column.allColumnMap, _a = column.treeColumnName, treeColumnName = _a === void 0 ? '' : _a;
                            var eventBus = eventBus_1.getEventBus(id);
                            var gridEvent = new gridEvent_1.default({ rowKey: rowKey });
                            setRowAttribute(store, rowKey, 'checked', true);
                            if (allColumnMap[treeColumnName]) {
                                tree_1.changeTreeRowsCheckedState(store, rowKey, true);
                            }
                            observable_1.asyncInvokeObserver(function () {
                                setCheckedAllRows(store);
                            });
                            /**
                             * Occurs when a checkbox in row header is checked
                             * @event Grid#check
                             * @property {number | string} rowKey - rowKey of the checked row
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('check', gridEvent);
                        }
                        exports.check = check;
                        function uncheck(store, rowKey) {
                            var id = store.id, column = store.column;
                            var allColumnMap = column.allColumnMap, _a = column.treeColumnName, treeColumnName = _a === void 0 ? '' : _a;
                            var eventBus = eventBus_1.getEventBus(id);
                            var gridEvent = new gridEvent_1.default({ rowKey: rowKey });
                            setRowAttribute(store, rowKey, 'checked', false);
                            if (allColumnMap[treeColumnName]) {
                                tree_1.changeTreeRowsCheckedState(store, rowKey, false);
                            }
                            observable_1.asyncInvokeObserver(function () {
                                setCheckedAllRows(store);
                            });
                            /**
                             * Occurs when a checkbox in row header is unchecked
                             * @event Grid#uncheck
                             * @property {number | string} rowKey - rowKey of the unchecked row
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('uncheck', gridEvent);
                        }
                        exports.uncheck = uncheck;
                        function checkAll(store, allPage) {
                            var id = store.id;
                            setAllRowAttribute(store, 'checked', true, allPage);
                            setCheckedAllRows(store);
                            var eventBus = eventBus_1.getEventBus(id);
                            var gridEvent = new gridEvent_1.default();
                            /**
                             * Occurs when a checkbox in header is checked(checked all checkbox in row header)
                             * @event Grid#checkAll
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('checkAll', gridEvent);
                        }
                        exports.checkAll = checkAll;
                        function uncheckAll(store, allPage) {
                            var id = store.id;
                            setAllRowAttribute(store, 'checked', false, allPage);
                            setCheckedAllRows(store);
                            var eventBus = eventBus_1.getEventBus(id);
                            var gridEvent = new gridEvent_1.default();
                            /**
                             * Occurs when a checkbox in header is unchecked(unchecked all checkbox in row header)
                             * @event Grid#uncheckAll
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('uncheckAll', gridEvent);
                        }
                        exports.uncheckAll = uncheckAll;
                        function setDisabledAllCheckbox(_a) {
                            var data = _a.data;
                            var rawData = data.rawData;
                            data.disabledAllCheckbox =
                                !!rawData.length && rawData.every(function (row) { return row._attributes.checkDisabled; });
                        }
                        exports.setDisabledAllCheckbox = setDisabledAllCheckbox;
                        function setRowOrColumnDisabled(target, disabled) {
                            if (target.disabled === disabled) {
                                observable_1.notify(target, 'disabled');
                            }
                            else {
                                target.disabled = disabled;
                            }
                        }
                        // @TODO consider the client pagination with disabled
                        function setDisabled(store, disabled) {
                            var data = store.data, column = store.column;
                            data.rawData.forEach(function (row) {
                                row._disabledPriority = {};
                                setAllRowAttribute(store, 'disabled', disabled);
                                setAllRowAttribute(store, 'checkDisabled', disabled);
                            });
                            column.columnsWithoutRowHeader.forEach(function (columnInfo) {
                                columnInfo.disabled = disabled;
                            });
                            data.disabledAllCheckbox = disabled;
                        }
                        exports.setDisabled = setDisabled;
                        function setRowDisabled(store, disabled, rowKey, withCheckbox) {
                            var data = store.data, column = store.column, id = store.id;
                            var row = data_2.findRowByRowKey(data, column, id, rowKey, false);
                            if (row) {
                                var _attributes = row._attributes, _disabledPriority_1 = row._disabledPriority;
                                column.allColumns.forEach(function (columnInfo) {
                                    _disabledPriority_1[columnInfo.name] = 'ROW';
                                });
                                if (withCheckbox) {
                                    _attributes.checkDisabled = disabled;
                                    setDisabledAllCheckbox(store);
                                }
                                setRowOrColumnDisabled(_attributes, disabled);
                            }
                        }
                        exports.setRowDisabled = setRowDisabled;
                        function setColumnDisabled(_a, disabled, columnName) {
                            var data = _a.data, column = _a.column;
                            if (column_1.isRowHeader(columnName)) {
                                return;
                            }
                            data.rawData.forEach(function (row) {
                                row._disabledPriority[columnName] = 'COLUMN';
                            });
                            setRowOrColumnDisabled(column.allColumnMap[columnName], disabled);
                        }
                        exports.setColumnDisabled = setColumnDisabled;
                        function setRowCheckDisabled(store, disabled, rowKey) {
                            var data = store.data, column = store.column, id = store.id;
                            var row = data_2.findRowByRowKey(data, column, id, rowKey, false);
                            if (row) {
                                row._attributes.checkDisabled = disabled;
                                setDisabledAllCheckbox(store);
                            }
                        }
                        exports.setRowCheckDisabled = setRowCheckDisabled;
                        function appendRow(store, row, options) {
                            var data = store.data, id = store.id;
                            var rawData = data.rawData, viewData = data.viewData, sortState = data.sortState, pageOptions = data.pageOptions;
                            var _a = options.at, at = _a === void 0 ? rawData.length : _a;
                            var _b = data_2.getCreatedRowInfo(store, at, row), rawRow = _b.rawRow, viewRow = _b.viewRow, prevRow = _b.prevRow;
                            var inserted = at !== rawData.length;
                            common_1.silentSplice(rawData, at, 0, rawRow);
                            common_1.silentSplice(viewData, at, 0, viewRow);
                            makeObservable(store, at);
                            pagination_1.updatePageOptions(store, { totalCount: pageOptions.totalCount + 1 });
                            updateHeights(store);
                            if (inserted) {
                                sort_1.updateSortKey(data, at);
                            }
                            sort_1.sortByCurrentState(store);
                            if (prevRow && rowSpan_1.isRowSpanEnabled(sortState)) {
                                rowSpan_2.updateRowSpanWhenAppending(rawData, prevRow, options.extendPrevRowSpan || false);
                            }
                            instance_1.getDataManager(id).push('CREATE', rawRow, inserted);
                            summary_1.updateSummaryValueByRow(store, rawRow, { type: 'APPEND' });
                            postUpdateAfterManipulation(store, at, 'DONE', [rawRow]);
                        }
                        exports.appendRow = appendRow;
                        function removeRow(store, rowKey, options) {
                            var data = store.data, id = store.id, focus = store.focus, column = store.column;
                            var rawData = data.rawData, viewData = data.viewData, sortState = data.sortState;
                            var rowIndex = data_2.findIndexByRowKey(data, column, id, rowKey, false);
                            if (rowIndex === -1) {
                                return;
                            }
                            var removedRow = {};
                            var nextRow = rawData[rowIndex + 1];
                            pagination_1.updatePageWhenRemovingRow(store, 1);
                            validation_1.removeUniqueInfoMap(id, rawData[rowIndex], column);
                            observable_1.batchObserver(function () {
                                removedRow = rawData.splice(rowIndex, 1)[0];
                            });
                            viewData.splice(rowIndex, 1);
                            updateHeights(store);
                            if (!common_1.someProp('rowKey', focus.rowKey, rawData)) {
                                focus_1.initFocus(store);
                            }
                            selection_1.initSelection(store);
                            if (nextRow && rowSpan_1.isRowSpanEnabled(sortState)) {
                                rowSpan_2.updateRowSpanWhenRemoving(rawData, removedRow, nextRow, options.keepRowSpanData || false);
                            }
                            if (rowIndex !== rawData.length) {
                                sort_1.updateSortKey(data, removedRow.sortKey + 1, false);
                            }
                            instance_1.getDataManager(id).push('DELETE', removedRow);
                            summary_1.updateSummaryValueByRow(store, removedRow, { type: 'REMOVE' });
                            postUpdateAfterManipulation(store, rowIndex, data_2.getLoadingState(rawData));
                        }
                        exports.removeRow = removeRow;
                        function clearData(store) {
                            var data = store.data, id = store.id, rowCoords = store.rowCoords;
                            validation_1.createNewValidationMap(id);
                            viewport_1.initScrollPosition(store);
                            focus_1.initFocus(store);
                            selection_1.initSelection(store);
                            sort_1.initSortState(data);
                            filter_1.initFilter(store);
                            rowCoords.heights = [];
                            data.rawData = [];
                            data.viewData = [];
                            pagination_1.updatePageOptions(store, { totalCount: 0, page: 1 }, true);
                            summary_1.updateAllSummaryValues(store);
                            setLoadingState(store, 'EMPTY');
                            setCheckedAllRows(store);
                            instance_1.getDataManager(id).clearAll();
                        }
                        exports.clearData = clearData;
                        function resetData(store, inputData, options) {
                            var data = store.data, column = store.column, id = store.id;
                            var sortState = options.sortState, filterState = options.filterState, pageState = options.pageState;
                            validation_1.createNewValidationMap(id);
                            var _a = data_1.createData(id, inputData, column, { lazyObservable: true }), rawData = _a.rawData, viewData = _a.viewData;
                            var eventBus = eventBus_1.getEventBus(id);
                            var gridEvent = new gridEvent_1.default();
                            viewport_1.initScrollPosition(store);
                            focus_1.initFocus(store);
                            selection_1.initSelection(store);
                            sort_1.resetSortState(store, sortState);
                            filter_1.resetFilterState(store, filterState);
                            pagination_1.resetPageState(store, rawData.length, pageState);
                            data.rawData = rawData;
                            data.viewData = viewData;
                            updateHeights(store);
                            summary_1.updateAllSummaryValues(store);
                            setLoadingState(store, data_2.getLoadingState(rawData));
                            setCheckedAllRows(store);
                            instance_1.getDataManager(id).setOriginData(inputData);
                            instance_1.getDataManager(id).clearAll();
                            column_2.setColumnWidthsByText(store);
                            setTimeout(function () {
                                /**
                                 * Occurs when the grid data is updated and the grid is rendered onto the DOM
                                 * The event occurs only in the following API as below.
                                 * 'resetData', 'restore', 'reloadData', 'readData', 'setPerPage' with 'dataSource', using 'dataSource'
                                 * @event Grid#onGridUpdated
                                 * @property {Grid} instance - Current grid instance
                                 */
                                eventBus.trigger('onGridUpdated', gridEvent);
                            });
                        }
                        exports.resetData = resetData;
                        function addRowClassName(store, rowKey, className) {
                            var data = store.data, column = store.column, id = store.id;
                            var row = data_2.findRowByRowKey(data, column, id, rowKey, false);
                            if (row) {
                                var rowClassMap = row._attributes.className.row;
                                var isExist = common_1.includes(rowClassMap, className);
                                if (!isExist) {
                                    rowClassMap.push(className);
                                    observable_1.notify(row._attributes, 'className');
                                }
                            }
                        }
                        exports.addRowClassName = addRowClassName;
                        function removeRowClassName(store, rowKey, className) {
                            var data = store.data, column = store.column, id = store.id;
                            var row = data_2.findRowByRowKey(data, column, id, rowKey, false);
                            if (row) {
                                common_1.removeArrayItem(className, row._attributes.className.row);
                                observable_1.notify(row._attributes, 'className');
                            }
                        }
                        exports.removeRowClassName = removeRowClassName;
                        function addClassNameToAttribute(row, columnName, className) {
                            var columnClassNames = row._attributes.className.column[columnName];
                            row._attributes.className.column[columnName] = data_2.getAddedClassName(className, columnClassNames);
                            observable_1.notify(row._attributes, 'className');
                        }
                        function removeClassNameToAttribute(row, columnName, className) {
                            var columnClassNames = row._attributes.className.column[columnName];
                            if (columnClassNames) {
                                row._attributes.className.column[columnName] = data_2.getRemovedClassName(className, columnClassNames);
                            }
                            observable_1.notify(row._attributes, 'className');
                        }
                        function addCellClassName(store, rowKey, columnName, className) {
                            var data = store.data, column = store.column, id = store.id;
                            var row = data_2.findRowByRowKey(data, column, id, rowKey, false);
                            if (row) {
                                addClassNameToAttribute(row, columnName, className);
                            }
                        }
                        exports.addCellClassName = addCellClassName;
                        function removeCellClassName(store, rowKey, columnName, className) {
                            var data = store.data, column = store.column, id = store.id;
                            var row = data_2.findRowByRowKey(data, column, id, rowKey);
                            if (row) {
                                removeClassNameToAttribute(row, columnName, className);
                            }
                        }
                        exports.removeCellClassName = removeCellClassName;
                        function addColumnClassName(_a, columnName, className) {
                            var data = _a.data;
                            var rawData = data.rawData;
                            rawData.forEach(function (row) {
                                addClassNameToAttribute(row, columnName, className);
                            });
                        }
                        exports.addColumnClassName = addColumnClassName;
                        function removeColumnClassName(_a, columnName, className) {
                            var data = _a.data;
                            var rawData = data.rawData;
                            rawData.forEach(function (row) {
                                removeClassNameToAttribute(row, columnName, className);
                            });
                        }
                        exports.removeColumnClassName = removeColumnClassName;
                        function setLoadingState(_a, state) {
                            var data = _a.data;
                            data.loadingState = state;
                        }
                        exports.setLoadingState = setLoadingState;
                        function setCheckedAllRows(_a) {
                            var data = _a.data;
                            var filteredRawData = data.filteredRawData, pageRowRange = data.pageRowRange;
                            var result = false;
                            if (filteredRawData.length) {
                                var enableCheckRows = filteredRawData
                                    .slice.apply(filteredRawData, pageRowRange).filter(function (row) { return !row._attributes.checkDisabled; });
                                result = !!enableCheckRows.length && enableCheckRows.every(function (row) { return row._attributes.checked; });
                            }
                            data.checkedAllRows = result;
                        }
                        exports.setCheckedAllRows = setCheckedAllRows;
                        function updateRowNumber(_a, startIndex) {
                            var data = _a.data;
                            var rawData = data.rawData;
                            for (var idx = startIndex; idx < rawData.length; idx += 1) {
                                rawData[idx]._attributes.rowNum = idx + 1;
                            }
                        }
                        exports.updateRowNumber = updateRowNumber;
                        function setRow(store, rowIndex, row) {
                            var data = store.data, id = store.id, column = store.column;
                            var rawData = data.rawData, viewData = data.viewData, sortState = data.sortState;
                            var orgRow = rawData[rowIndex];
                            if (!orgRow) {
                                return;
                            }
                            validation_1.removeUniqueInfoMap(id, orgRow, column);
                            row.sortKey = orgRow.sortKey;
                            var _a = data_2.getCreatedRowInfo(store, rowIndex, row, orgRow.rowKey), rawRow = _a.rawRow, viewRow = _a.viewRow, prevRow = _a.prevRow;
                            common_1.silentSplice(rawData, rowIndex, 1, rawRow);
                            common_1.silentSplice(viewData, rowIndex, 1, viewRow);
                            makeObservable(store, rowIndex);
                            sort_1.sortByCurrentState(store);
                            if (prevRow && rowSpan_1.isRowSpanEnabled(sortState)) {
                                rowSpan_2.updateRowSpanWhenAppending(rawData, prevRow, false);
                            }
                            instance_1.getDataManager(id).push('UPDATE', rawRow);
                            updateHeightsWithFilteredData(store);
                            summary_1.updateSummaryValueByRow(store, rawRow, { type: 'SET', orgRow: orgRow });
                            postUpdateAfterManipulation(store, rowIndex, 'DONE');
                        }
                        exports.setRow = setRow;
                        function moveRow(store, rowKey, targetIndex) {
                            var data = store.data, column = store.column, id = store.id;
                            var rawData = data.rawData, viewData = data.viewData;
                            if (!rawData[targetIndex] || data_2.isSorted(data) || data_2.isFiltered(data)) {
                                return;
                            }
                            var currentIndex = data_2.findIndexByRowKey(data, column, id, rowKey, false);
                            if (currentIndex === -1) {
                                return;
                            }
                            var minIndex = Math.min(currentIndex, targetIndex);
                            var rawRow = common_1.silentSplice(rawData, currentIndex, 1)[0];
                            var viewRow = common_1.silentSplice(viewData, currentIndex, 1)[0];
                            observable_1.batchObserver(function () {
                                rawData.splice(targetIndex, 0, rawRow);
                            });
                            viewData.splice(targetIndex, 0, viewRow);
                            sort_1.resetSortKey(data, minIndex);
                            updateRowNumber(store, minIndex);
                            instance_1.getDataManager(id).push('UPDATE', rawRow, true);
                        }
                        exports.moveRow = moveRow;
                        function scrollToNext(store) {
                            var data = store.data, id = store.id;
                            var _a = data.pageOptions, page = _a.page, totalCount = _a.totalCount, perPage = _a.perPage, useClient = _a.useClient;
                            if (data_2.isScrollPagination(data)) {
                                if (useClient) {
                                    data.pageOptions.page += 1;
                                    observable_1.notify(data, 'pageOptions');
                                    sort_1.sortByCurrentState(store);
                                    updateHeights(store);
                                    setCheckedAllRows(store);
                                }
                                else if (page * perPage < totalCount) {
                                    data.pageOptions.page += 1;
                                    instance_1.getDataProvider(id).readData(data.pageOptions.page);
                                }
                            }
                        }
                        exports.scrollToNext = scrollToNext;
                        function appendRows(store, inputData) {
                            var data = store.data, column = store.column, id = store.id;
                            if (!column.keyColumnName) {
                                var rowKey_1 = data_2.getMaxRowKey(data);
                                inputData.forEach(function (row, index) {
                                    row.rowKey = rowKey_1 + index;
                                });
                            }
                            var startIndex = data.rawData.length;
                            var _a = data_1.createData(id, inputData, column, { lazyObservable: true }), rawData = _a.rawData, viewData = _a.viewData;
                            data.rawData = data.rawData.concat(rawData);
                            data.viewData = data.viewData.concat(viewData);
                            sort_1.resetSortKey(data, startIndex);
                            sort_1.sortByCurrentState(store);
                            updateHeights(store);
                            postUpdateAfterManipulation(store, startIndex, 'DONE', rawData);
                        }
                        exports.appendRows = appendRows;
                        function removeRows(store, targetRows) {
                            var data = store.data, id = store.id, focus = store.focus, column = store.column;
                            var sortState = data.sortState, viewData = data.viewData, rawData = data.rawData;
                            var rowIndexes = targetRows.rowIndexes, rows = targetRows.rows, nextRows = targetRows.nextRows;
                            var deletedCount = rowIndexes.length;
                            pagination_1.updatePageWhenRemovingRow(store, deletedCount);
                            rowIndexes.forEach(function (rowIndex, i) {
                                var nextRow = nextRows[i];
                                var removedRow = common_1.silentSplice(rawData, rowIndex - i, 1)[0];
                                common_1.silentSplice(viewData, rowIndex - i, 1);
                                validation_1.removeUniqueInfoMap(id, removedRow, column);
                                if (nextRow) {
                                    if (rowSpan_1.isRowSpanEnabled(sortState)) {
                                        rowSpan_2.updateRowSpanWhenRemoving(rawData, removedRow, nextRow, false);
                                    }
                                }
                                instance_1.getDataManager(id).push('DELETE', removedRow);
                                sort_1.updateSortKey(data, removedRow.sortKey + 1, false);
                            });
                            observable_1.notify(data, 'rawData', 'filteredRawData', 'viewData', 'filteredViewData');
                            updateHeights(store);
                            if (common_1.someProp('rowKey', focus.rowKey, rows)) {
                                focus_1.initFocus(store);
                            }
                            selection_1.initSelection(store);
                            summary_1.updateAllSummaryValues(store);
                            postUpdateAfterManipulation(store, rowIndexes[0], data_2.getLoadingState(rawData));
                        }
                        exports.removeRows = removeRows;
                        function postUpdateAfterManipulation(store, rowIndex, state, rows) {
                            setLoadingState(store, state);
                            updateRowNumber(store, rowIndex);
                            setDisabledAllCheckbox(store);
                            setCheckedAllRows(store);
                            validation_1.forceValidateUniquenessOfColumns(store.data.rawData, store.column);
                            column_2.setAutoResizingColumnWidths(store, rows);
                        }


                        /***/ }),
                    /* 15 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.initSelection = exports.setSelection = exports.changeSelectionRange = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var eventBus_1 = __webpack_require__(8);
                        var selection_1 = __webpack_require__(19);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var rowSpan_1 = __webpack_require__(11);
                        function changeSelectionRange(selection, inputRange, id) {
                            if (!selection_1.isSameInputRange(selection.inputRange, inputRange)) {
                                selection.inputRange = inputRange;
                                var eventBus = eventBus_1.getEventBus(id);
                                var gridEvent = new gridEvent_1.default({ range: selection.rangeWithRowHeader });
                                /**
                                 * Occurs when selecting cells
                                 * @event Grid#selection
                                 * @property {Object} range - Range of selection
                                 * @property {Array} range.start - Info of start cell (ex: [rowKey, columnName])
                                 * @property {Array} range.end - Info of end cell (ex: [rowKey, columnName])
                                 * @property {Grid} instance - Current grid instance
                                 */
                                eventBus.trigger('selection', gridEvent);
                            }
                        }
                        exports.changeSelectionRange = changeSelectionRange;
                        function setSelection(store, range) {
                            var _a;
                            var selection = store.selection, data = store.data, _b = store.column, visibleColumnsWithRowHeader = _b.visibleColumnsWithRowHeader, rowHeaderCount = _b.rowHeaderCount, id = store.id;
                            var viewData = data.viewData;
                            var rowLength = viewData.length;
                            var columnLength = visibleColumnsWithRowHeader.length;
                            var startRowIndex = common_1.clamp(range.start[0], 0, rowLength - 1);
                            var endRowIndex = common_1.clamp(range.end[0], 0, rowLength - 1);
                            var startColumnIndex = common_1.clamp(range.start[1] + rowHeaderCount, rowHeaderCount, columnLength - 1);
                            var endColumnIndex = common_1.clamp(range.end[1] + rowHeaderCount, rowHeaderCount, columnLength - 1);
                            _a = rowSpan_1.getRowRangeWithRowSpan([startRowIndex, endRowIndex], [startColumnIndex, endColumnIndex], visibleColumnsWithRowHeader, null, data), startRowIndex = _a[0], endRowIndex = _a[1];
                            var inputRange = {
                                row: [startRowIndex, endRowIndex],
                                column: [startColumnIndex, endColumnIndex],
                            };
                            changeSelectionRange(selection, inputRange, id);
                        }
                        exports.setSelection = setSelection;
                        function initSelection(store) {
                            store.selection.inputRange = null;
                        }
                        exports.initSelection = initSelection;


                        /***/ }),
                    /* 16 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.TREE_CELL_HORIZONTAL_PADDING = exports.TREE_INDENT_WIDTH = exports.FILTER_DEBOUNCE_TIME = void 0;
                        exports.FILTER_DEBOUNCE_TIME = 50;
                        exports.TREE_INDENT_WIDTH = 22;
                        exports.TREE_CELL_HORIZONTAL_PADDING = 19;


                        /***/ }),
                    /* 17 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.isArrowKey = exports.isNonPrintableKey = exports.keyEventGenerate = exports.getKeyStrokeString = exports.keyStrokeCommandMap = exports.keyboardEventCommandMap = exports.keyboardEventTypeMap = exports.keyNameMap = void 0;
                        var common_1 = __webpack_require__(0);
                        exports.keyNameMap = {
                            8: 'backspace',
                            9: 'tab',
                            13: 'enter',
                            16: 'shift',
                            17: 'ctrl',
                            27: 'esc',
                            37: 'left',
                            38: 'up',
                            39: 'right',
                            40: 'down',
                            65: 'a',
                            67: 'c',
                            86: 'v',
                            32: 'space',
                            33: 'pageUp',
                            34: 'pageDown',
                            36: 'home',
                            35: 'end',
                            46: 'del',
                        };
                        exports.keyboardEventTypeMap = {
                            move: 'move',
                            edit: 'edit',
                            remove: 'remove',
                            select: 'select',
                            clipboard: 'clipboard',
                        };
                        exports.keyboardEventCommandMap = {
                            up: 'up',
                            down: 'down',
                            left: 'left',
                            right: 'right',
                            pageUp: 'pageUp',
                            pageDown: 'pageDown',
                            firstColumn: 'firstColumn',
                            lastColumn: 'lastColumn',
                            currentCell: 'currentCell',
                            nextCell: 'nextCell',
                            prevCell: 'prevCell',
                            firstCell: 'firstCell',
                            lastCell: 'lastCell',
                            all: 'all',
                            copy: 'copy',
                            paste: 'paste',
                        };
                        /**
                         * K-V object for matching keystroke and event command
                         * K: keystroke (order : ctrl -> shift -> keyName)
                         * V: [key event type, command]
                         * @type {Object}
                         * @ignore
                         */
                        exports.keyStrokeCommandMap = {
                            up: ['move', 'up'],
                            down: ['move', 'down'],
                            left: ['move', 'left'],
                            right: ['move', 'right'],
                            pageUp: ['move', 'pageUp'],
                            pageDown: ['move', 'pageDown'],
                            home: ['move', 'firstColumn'],
                            end: ['move', 'lastColumn'],
                            enter: ['edit', 'currentCell'],
                            space: ['edit', 'currentCell'],
                            tab: ['edit', 'nextCell'],
                            backspace: ['remove'],
                            del: ['remove'],
                            'shift-tab': ['edit', 'prevCell'],
                            'shift-up': ['select', 'up'],
                            'shift-down': ['select', 'down'],
                            'shift-left': ['select', 'left'],
                            'shift-right': ['select', 'right'],
                            'shift-pageUp': ['select', 'pageUp'],
                            'shift-pageDown': ['select', 'pageDown'],
                            'shift-home': ['select', 'firstColumn'],
                            'shift-end': ['select', 'lastColumn'],
                            'ctrl-a': ['select', 'all'],
                            'ctrl-c': ['clipboard', 'copy'],
                            'ctrl-v': ['clipboard', 'paste'],
                            'ctrl-home': ['move', 'firstCell'],
                            'ctrl-end': ['move', 'lastCell'],
                            'ctrl-shift-home': ['select', 'firstCell'],
                            'ctrl-shift-end': ['select', 'lastCell'],
                        };
                        /**
                         * Returns the keyStroke string
                         * @param {Event} ev - Keyboard event
                         * @returns {String}
                         * @ignore
                         */
                        function getKeyStrokeString(ev) {
                            var keys = [];
                            var keyCode = ev.keyCode, ctrlKey = ev.ctrlKey, metaKey = ev.metaKey, shiftKey = ev.shiftKey;
                            if (ctrlKey || metaKey) {
                                keys.push('ctrl');
                            }
                            if (shiftKey) {
                                keys.push('shift');
                            }
                            if (keyCode in exports.keyNameMap) {
                                keys.push(exports.keyNameMap[keyCode]);
                            }
                            return keys.join('-');
                        }
                        exports.getKeyStrokeString = getKeyStrokeString;
                        function keyEventGenerate(ev) {
                            var keyStroke = getKeyStrokeString(ev);
                            var commandInfo = exports.keyStrokeCommandMap[keyStroke];
                            return commandInfo
                                ? {
                                    type: commandInfo[0],
                                    command: commandInfo[1],
                                }
                                : {};
                        }
                        exports.keyEventGenerate = keyEventGenerate;
                        function isNonPrintableKey(keyCode) {
                            var keys = [
                                'shift',
                                'ctrl',
                                'esc',
                                'left',
                                'up',
                                'right',
                                'down',
                                'pageUp',
                                'pageDown',
                                'end',
                                'home',
                            ];
                            var key = exports.keyNameMap[keyCode];
                            return common_1.includes(keys, key);
                        }
                        exports.isNonPrintableKey = isNonPrintableKey;
                        function isArrowKey(keyName) {
                            return common_1.includes(['up', 'down', 'left', 'right'], keyName);
                        }
                        exports.isArrowKey = isArrowKey;


                        /***/ }),
                    /* 18 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.setFocusInfo = exports.saveAndFinishEditing = exports.initFocus = exports.changeFocus = exports.finishEditing = exports.startEditing = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var eventBus_1 = __webpack_require__(8);
                        var data_1 = __webpack_require__(6);
                        var focus_1 = __webpack_require__(69);
                        var rowSpan_1 = __webpack_require__(11);
                        var data_2 = __webpack_require__(14);
                        var common_1 = __webpack_require__(0);
                        var column_1 = __webpack_require__(12);
                        function startEditing(store, rowKey, columnName) {
                            var data = store.data, focus = store.focus, column = store.column, id = store.id;
                            var filteredRawData = data.filteredRawData;
                            var foundIndex = data_1.findIndexByRowKey(data, column, id, rowKey);
                            if (foundIndex === -1) {
                                return;
                            }
                            // makes the data observable to judge editable, disable of the cell
                            data_2.makeObservable(store, data_1.findIndexByRowKey(data, column, id, rowKey, false));
                            if (!data_1.isEditableCell(data, column, foundIndex, columnName)) {
                                return;
                            }
                            var eventBus = eventBus_1.getEventBus(id);
                            var gridEvent = new gridEvent_1.default({
                                rowKey: rowKey,
                                columnName: columnName,
                                value: filteredRawData[foundIndex][columnName],
                            });
                            /**
                             * Occurs when editing the cell is started
                             * @event Grid#editingStart
                             * @property {number} rowKey - rowKey of the target cell
                             * @property {number} columnName - columnName of the target cell
                             * @property {number | string | boolean | null | undefined} value - value of the editing cell
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('editingStart', gridEvent);
                            if (!gridEvent.isStopped()) {
                                focus.forcedDestroyEditing = false;
                                focus.navigating = false;
                                focus.editingAddress = { rowKey: rowKey, columnName: columnName };
                            }
                        }
                        exports.startEditing = startEditing;
                        function finishEditing(_a, rowKey, columnName, value) {
                            var focus = _a.focus, id = _a.id;
                            var eventBus = eventBus_1.getEventBus(id);
                            var gridEvent = new gridEvent_1.default({ rowKey: rowKey, columnName: columnName, value: value });
                            /**
                             * Occurs when editing the cell is finished
                             * @event Grid#editingFinish
                             * @property {number} rowKey - rowKey of the target cell
                             * @property {number} columnName - columnName of the target cell
                             * @property {number | string | boolean | null | undefined} value - value of the editing cell
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('editingFinish', gridEvent);
                            if (!gridEvent.isStopped()) {
                                if (focus_1.isEditingCell(focus, rowKey, columnName)) {
                                    focus.editingAddress = null;
                                    focus.navigating = true;
                                }
                            }
                        }
                        exports.finishEditing = finishEditing;
                        function changeFocus(store, rowKey, columnName, id) {
                            var data = store.data, focus = store.focus, column = store.column;
                            if (focus_1.isFocusedCell(focus, rowKey, columnName) ||
                                (columnName && column_1.isHiddenColumn(column, columnName))) {
                                return;
                            }
                            var rawData = data.rawData, sortState = data.sortState;
                            var eventBus = eventBus_1.getEventBus(id);
                            var gridEvent = new gridEvent_1.default({
                                rowKey: rowKey,
                                columnName: columnName,
                                prevColumnName: focus.columnName,
                                prevRowKey: focus.rowKey,
                            });
                            /**
                             * Occurs when focused cell is about to change
                             * @event Grid#focusChange
                             * @property {number} rowKey - rowKey of the target cell
                             * @property {number} columnName - columnName of the target cell
                             * @property {number} prevRowKey - rowKey of the currently focused cell
                             * @property {number} prevColumnName - columnName of the currently focused cell
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('focusChange', gridEvent);
                            if (!gridEvent.isStopped()) {
                                var focusRowKey = rowKey;
                                if (rowKey && columnName && rowSpan_1.isRowSpanEnabled(sortState)) {
                                    var rowSpan = rowSpan_1.getRowSpanByRowKey(rowKey, columnName, rawData);
                                    if (rowSpan) {
                                        focusRowKey = rowSpan.mainRowKey;
                                    }
                                }
                                focus.prevColumnName = focus.columnName;
                                focus.prevRowKey = focus.rowKey;
                                focus.columnName = columnName;
                                focus.rowKey = focusRowKey;
                            }
                        }
                        exports.changeFocus = changeFocus;
                        function initFocus(_a) {
                            var focus = _a.focus;
                            focus.editingAddress = null;
                            focus.navigating = false;
                            focus.rowKey = null;
                            focus.columnName = null;
                            focus.prevRowKey = null;
                            focus.prevColumnName = null;
                        }
                        exports.initFocus = initFocus;
                        function saveAndFinishEditing(store, value) {
                            // @TODO: remove 'value' paramter
                            // saveAndFinishEditing(store: Store)
                            var focus = store.focus, data = store.data, column = store.column, id = store.id;
                            var editingAddress = focus.editingAddress;
                            if (!editingAddress) {
                                return;
                            }
                            var rowKey = editingAddress.rowKey, columnName = editingAddress.columnName;
                            // makes the data observable to judge editable, disable of the cell.
                            data_2.makeObservable(store, data_1.findIndexByRowKey(data, column, id, rowKey, false));
                            // if value is 'undefined', editing result is saved and finished.
                            if (common_1.isUndefined(value)) {
                                focus.forcedDestroyEditing = true;
                                focus.editingAddress = null;
                                focus.navigating = true;
                                return;
                            }
                            data_2.setValue(store, rowKey, columnName, value);
                            finishEditing(store, rowKey, columnName, value);
                        }
                        exports.saveAndFinishEditing = saveAndFinishEditing;
                        function setFocusInfo(store, rowKey, columnName, navigating) {
                            var focus = store.focus, id = store.id;
                            focus.navigating = navigating;
                            changeFocus(store, rowKey, columnName, id);
                        }
                        exports.setFocusInfo = setFocusInfo;


                        /***/ }),
                    /* 19 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getSelectionRange = exports.isSameInputRange = exports.getSortedRange = exports.getChildColumnRange = exports.getLeafChildColumnNames = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var column_1 = __webpack_require__(12);
                        function sortByVisibleColumns(visibleColumnsWithRowHeader, childNames) {
                            var result = [];
                            visibleColumnsWithRowHeader.forEach(function (column) {
                                if (common_1.includes(childNames, column.name)) {
                                    result.push(column.name);
                                }
                            });
                            return result;
                        }
                        function getLeafChildColumnNames(complexColumnHeaders, name) {
                            var column = common_1.findProp('name', name, complexColumnHeaders);
                            if (!column) {
                                return [name];
                            }
                            var result = [];
                            column.childNames.forEach(function (childName) {
                                if (column_1.isParentColumnHeader(complexColumnHeaders, childName)) {
                                    result = tslib_1.__spreadArrays(result, getLeafChildColumnNames(complexColumnHeaders, childName));
                                }
                                else {
                                    result = tslib_1.__spreadArrays(result, [childName]);
                                }
                            });
                            return result;
                        }
                        exports.getLeafChildColumnNames = getLeafChildColumnNames;
                        function getChildColumnRange(visibleColumnsWithRowHeader, complexColumnHeaders, name) {
                            var unsortedChildNames = getLeafChildColumnNames(complexColumnHeaders, name);
                            var childNames = sortByVisibleColumns(visibleColumnsWithRowHeader, unsortedChildNames);
                            var startIndex = common_1.findPropIndex('name', childNames[0], visibleColumnsWithRowHeader);
                            var endIndex = common_1.findPropIndex('name', childNames[childNames.length - 1], visibleColumnsWithRowHeader);
                            return [startIndex, endIndex];
                        }
                        exports.getChildColumnRange = getChildColumnRange;
                        function getSortedRange(range) {
                            return range[0] > range[1] ? [range[1], range[0]] : range;
                        }
                        exports.getSortedRange = getSortedRange;
                        function isSameInputRange(inp1, inp2) {
                            if (common_1.isNull(inp1) || common_1.isNull(inp2)) {
                                return inp1 === inp2;
                            }
                            return (inp1.column[0] === inp2.column[0] &&
                                inp1.column[1] === inp2.column[1] &&
                                inp1.row[0] === inp2.row[0] &&
                                inp1.row[1] === inp2.row[1]);
                        }
                        exports.isSameInputRange = isSameInputRange;
                        function getSelectionRange(range, pageOptions) {
                            if (!common_1.isEmpty(pageOptions)) {
                                var row = range.row, column = range.column;
                                var perPage = pageOptions.perPage, page = pageOptions.page;
                                var prevPageRowCount = (page - 1) * perPage;
                                return {
                                    row: [row[0] - prevPageRowCount, row[1] - prevPageRowCount],
                                    column: column,
                                };
                            }
                            return range;
                        }
                        exports.getSelectionRange = getSelectionRange;


                        /***/ }),
                    /* 20 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getTreeIndentWidth = exports.createTreeCellInfo = exports.createTreeRawData = exports.flattenTreeData = exports.createTreeRawRow = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var data_1 = __webpack_require__(13);
                        var tree_1 = __webpack_require__(21);
                        var observable_1 = __webpack_require__(5);
                        var common_1 = __webpack_require__(0);
                        var constant_1 = __webpack_require__(16);
                        var treeRowKey = -1;
                        function generateTreeRowKey() {
                            treeRowKey += 1;
                            return treeRowKey;
                        }
                        function addChildRowKey(row, rowKey) {
                            var tree = row._attributes.tree;
                            if (tree && !common_1.includes(tree.childRowKeys, rowKey)) {
                                tree.childRowKeys.push(rowKey);
                            }
                        }
                        function insertChildRowKey(row, rowKey, offset) {
                            var tree = row._attributes.tree;
                            if (tree && !common_1.includes(tree.childRowKeys, rowKey)) {
                                tree.childRowKeys.splice(offset, 0, rowKey);
                            }
                        }
                        function getTreeCellInfo(rawData, row, useIcon) {
                            var depth = tree_1.getDepth(rawData, row);
                            var indentWidth = getTreeIndentWidth(depth, useIcon);
                            return {
                                depth: depth,
                                indentWidth: indentWidth,
                                leaf: tree_1.isLeaf(row),
                                expanded: tree_1.isExpanded(row),
                            };
                        }
                        function createTreeRawRow(id, row, parentRow, column, options) {
                            if (options === void 0) { options = {}; }
                            var childRowKeys = [];
                            if (row._attributes && row._attributes.tree) {
                                childRowKeys = row._attributes.tree.childRowKeys;
                            }
                            var keyColumnName = options.keyColumnName, offset = options.offset, _a = options.lazyObservable, lazyObservable = _a === void 0 ? false : _a, _b = options.disabled, disabled = _b === void 0 ? false : _b;
                            // generate new tree rowKey when row doesn't have rowKey
                            var targetTreeRowKey = common_1.isUndefined(row.rowKey) ? generateTreeRowKey() : Number(row.rowKey);
                            var rawRow = data_1.createRawRow(id, row, targetTreeRowKey, column, {
                                keyColumnName: keyColumnName,
                                lazyObservable: lazyObservable,
                                disabled: disabled,
                            });
                            var rowKey = rawRow.rowKey;
                            var defaultAttributes = {
                                parentRowKey: parentRow ? parentRow.rowKey : null,
                                childRowKeys: childRowKeys,
                                hidden: parentRow ? !tree_1.isExpanded(parentRow) || tree_1.isHidden(parentRow) : false,
                            };
                            if (parentRow) {
                                if (!common_1.isUndefined(offset)) {
                                    insertChildRowKey(parentRow, rowKey, offset);
                                }
                                else {
                                    addChildRowKey(parentRow, rowKey);
                                }
                            }
                            var tree = tslib_1.__assign(tslib_1.__assign({}, defaultAttributes), ((Array.isArray(row._children) || childRowKeys.length) && {
                                expanded: !!row._attributes.expanded,
                            }));
                            rawRow._attributes.tree = lazyObservable ? tree : observable_1.observable(tree);
                            return rawRow;
                        }
                        exports.createTreeRawRow = createTreeRawRow;
                        function flattenTreeData(id, data, parentRow, column, options) {
                            var flattenedRows = [];
                            data.forEach(function (row) {
                                var rawRow = createTreeRawRow(id, row, parentRow, column, options);
                                flattenedRows.push(rawRow);
                                if (Array.isArray(row._children)) {
                                    if (row._children.length) {
                                        flattenedRows.push.apply(flattenedRows, flattenTreeData(id, row._children, rawRow, column, options));
                                    }
                                }
                            });
                            return flattenedRows;
                        }
                        exports.flattenTreeData = flattenTreeData;
                        function createTreeRawData(_a) {
                            var id = _a.id, data = _a.data, column = _a.column, keyColumnName = _a.keyColumnName, _b = _a.lazyObservable, lazyObservable = _b === void 0 ? false : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c;
                            // only reset the rowKey on lazy observable data
                            if (lazyObservable) {
                                treeRowKey = -1;
                            }
                            return flattenTreeData(id, data, null, column, {
                                keyColumnName: keyColumnName,
                                lazyObservable: lazyObservable,
                                disabled: disabled,
                            });
                        }
                        exports.createTreeRawData = createTreeRawData;
                        function createTreeCellInfo(rawData, row, useIcon, lazyObservable) {
                            if (lazyObservable === void 0) { lazyObservable = false; }
                            var treeCellInfo = getTreeCellInfo(rawData, row, useIcon);
                            var treeInfo = lazyObservable ? treeCellInfo : observable_1.observable(treeCellInfo);
                            if (!lazyObservable) {
                                observable_1.observe(function () {
                                    treeInfo.expanded = tree_1.isExpanded(row);
                                    treeInfo.leaf = tree_1.isLeaf(row);
                                });
                            }
                            return treeInfo;
                        }
                        exports.createTreeCellInfo = createTreeCellInfo;
                        function getTreeIndentWidth(depth, showIcon) {
                            return depth * constant_1.TREE_INDENT_WIDTH + (showIcon ? constant_1.TREE_INDENT_WIDTH : 0);
                        }
                        exports.getTreeIndentWidth = getTreeIndentWidth;


                        /***/ }),
                    /* 21 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getRootParentRow = exports.traverseDescendantRows = exports.traverseAncestorRows = exports.getDepth = exports.isRootChildRow = exports.isExpanded = exports.isLeaf = exports.isHidden = exports.getChildRowKeys = exports.getParentRowKey = exports.getStartIndexToAppendRow = exports.getDescendantRows = exports.getAncestorRows = exports.getChildRows = exports.getParentRow = void 0;
                        var observable_1 = __webpack_require__(5);
                        var data_1 = __webpack_require__(6);
                        var common_1 = __webpack_require__(0);
                        function getParentRow(store, rowKey, plainObj) {
                            var data = store.data, column = store.column, id = store.id;
                            var row = data_1.findRowByRowKey(data, column, id, rowKey);
                            if (row) {
                                var parentRowKey = getParentRowKey(row);
                                var parentRow = data_1.findRowByRowKey(data, column, id, parentRowKey);
                                if (parentRow) {
                                    return plainObj ? observable_1.getOriginObject(parentRow) : parentRow;
                                }
                            }
                            return null;
                        }
                        exports.getParentRow = getParentRow;
                        function getChildRows(store, rowKey, plainObj) {
                            var data = store.data, column = store.column, id = store.id;
                            var row = data_1.findRowByRowKey(data, column, id, rowKey);
                            if (row) {
                                var childRowKeys = getChildRowKeys(row);
                                return childRowKeys.map(function (childRowKey) {
                                    var childRow = data_1.findRowByRowKey(data, column, id, childRowKey);
                                    return plainObj ? observable_1.getOriginObject(childRow) : childRow;
                                });
                            }
                            return [];
                        }
                        exports.getChildRows = getChildRows;
                        function getAncestorRows(store, rowKey) {
                            var data = store.data, column = store.column, id = store.id;
                            var rawData = data.rawData;
                            var row = data_1.findRowByRowKey(data, column, id, rowKey);
                            var ancestorRows = [];
                            if (row) {
                                traverseAncestorRows(rawData, row, function (parentRow) {
                                    ancestorRows.unshift(observable_1.getOriginObject(parentRow));
                                });
                            }
                            return ancestorRows;
                        }
                        exports.getAncestorRows = getAncestorRows;
                        function getDescendantRows(store, rowKey) {
                            var data = store.data, column = store.column, id = store.id;
                            var rawData = data.rawData;
                            var row = data_1.findRowByRowKey(data, column, id, rowKey);
                            var childRows = [];
                            if (row) {
                                traverseDescendantRows(rawData, row, function (childRow) {
                                    childRows.push(observable_1.getOriginObject(childRow));
                                });
                            }
                            return childRows;
                        }
                        exports.getDescendantRows = getDescendantRows;
                        function getStartIndexToAppendRow(store, parentRow, offset) {
                            var data = store.data, column = store.column, id = store.id;
                            var rawData = data.rawData;
                            var startIdx;
                            if (parentRow) {
                                if (offset) {
                                    var childRowKeys = getChildRowKeys(parentRow);
                                    var prevChildRowKey = childRowKeys[offset - 1];
                                    var prevChildRowIdx = data_1.findIndexByRowKey(data, column, id, prevChildRowKey);
                                    var descendantRowsCount = getDescendantRows(store, prevChildRowKey).length;
                                    startIdx = prevChildRowIdx + descendantRowsCount + 1;
                                }
                                else {
                                    startIdx = data_1.findIndexByRowKey(data, column, id, parentRow.rowKey) + 1;
                                    if (common_1.isUndefined(offset)) {
                                        startIdx += getDescendantRows(store, parentRow.rowKey).length;
                                    }
                                }
                            }
                            else {
                                startIdx = common_1.isUndefined(offset) ? rawData.length : offset;
                            }
                            return startIdx;
                        }
                        exports.getStartIndexToAppendRow = getStartIndexToAppendRow;
                        function getParentRowKey(row) {
                            var tree = row._attributes.tree;
                            return tree && tree.parentRowKey !== row.rowKey ? tree.parentRowKey : null;
                        }
                        exports.getParentRowKey = getParentRowKey;
                        function getChildRowKeys(row) {
                            var tree = row._attributes.tree;
                            return tree ? tree.childRowKeys.slice() : [];
                        }
                        exports.getChildRowKeys = getChildRowKeys;
                        function isHidden(row) {
                            var tree = row._attributes.tree;
                            return !!(tree && tree.hidden);
                        }
                        exports.isHidden = isHidden;
                        function isLeaf(row) {
                            var tree = row._attributes.tree;
                            return !!tree && !tree.childRowKeys.length && common_1.isUndefined(tree.expanded);
                        }
                        exports.isLeaf = isLeaf;
                        function isExpanded(row) {
                            var tree = row._attributes.tree;
                            return !!(tree && tree.expanded);
                        }
                        exports.isExpanded = isExpanded;
                        function isRootChildRow(row) {
                            var tree = row._attributes.tree;
                            return !!tree && common_1.isNull(tree.parentRowKey);
                        }
                        exports.isRootChildRow = isRootChildRow;
                        function getDepth(rawData, row) {
                            var parentRow = row;
                            var depth = 0;
                            do {
                                depth += 1;
                                parentRow = common_1.findProp('rowKey', getParentRowKey(parentRow), rawData);
                            } while (parentRow);
                            return depth;
                        }
                        exports.getDepth = getDepth;
                        function traverseAncestorRows(rawData, row, iteratee) {
                            var parentRowKey = getParentRowKey(row);
                            var parentRow;
                            while (!common_1.isNull(parentRowKey)) {
                                parentRow = common_1.findProp('rowKey', parentRowKey, rawData);
                                iteratee(parentRow);
                                parentRowKey = parentRow ? getParentRowKey(parentRow) : null;
                            }
                        }
                        exports.traverseAncestorRows = traverseAncestorRows;
                        function traverseDescendantRows(rawData, row, iteratee) {
                            var childRowKeys = getChildRowKeys(row);
                            var rowKey, childRow;
                            while (childRowKeys.length) {
                                rowKey = childRowKeys.shift();
                                childRow = common_1.findProp('rowKey', rowKey, rawData);
                                iteratee(childRow);
                                if (childRow) {
                                    childRowKeys = childRowKeys.concat(getChildRowKeys(childRow));
                                }
                            }
                        }
                        exports.traverseDescendantRows = traverseDescendantRows;
                        function getRootParentRow(rawData, row) {
                            var rootParentRow = row;
                            do {
                                var parentRow = common_1.findProp('rowKey', getParentRowKey(rootParentRow), rawData);
                                if (!parentRow) {
                                    break;
                                }
                                rootParentRow = parentRow;
                            } while (rootParentRow);
                            return rootParentRow;
                        }
                        exports.getRootParentRow = getRootParentRow;


                        /***/ }),
                    /* 22 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.initScrollPosition = exports.setScrollTop = exports.setScrollLeft = exports.setScrollToSelection = exports.setScrollToFocus = void 0;
                        var viewport_1 = __webpack_require__(71);
                        function setScrollPosition(viewport, changedScrollTop, changedScrollLeft) {
                            if (changedScrollLeft !== null) {
                                viewport.scrollLeft = changedScrollLeft;
                            }
                            if (changedScrollTop !== null) {
                                viewport.scrollTop = changedScrollTop;
                            }
                        }
                        function setScrollToFocus(store) {
                            var _a = store.focus, cellPosRect = _a.cellPosRect, side = _a.side, viewport = store.viewport;
                            if (cellPosRect === null || side === null) {
                                return;
                            }
                            var _b = viewport_1.getChangedScrollPosition(store, side), changedScrollLeft = _b[0], changedScrollTop = _b[1];
                            setScrollPosition(viewport, changedScrollTop, changedScrollLeft);
                        }
                        exports.setScrollToFocus = setScrollToFocus;
                        function setScrollToSelection(store) {
                            var _a = store.columnCoords, widths = _a.widths, columnOffsets = _a.offsets, _b = store.rowCoords, heights = _b.heights, rowOffsets = _b.offsets, inputRange = store.selection.inputRange, viewport = store.viewport;
                            if (!inputRange) {
                                return;
                            }
                            var rowIndex = inputRange.row[1];
                            var columnIndex = inputRange.column[1];
                            var cellSide = columnIndex > widths.L.length - 1 ? 'R' : 'L';
                            var rightSideColumnIndex = columnIndex < widths.L.length ? widths.L.length : columnIndex - widths.L.length;
                            var left = columnOffsets[cellSide][rightSideColumnIndex];
                            var right = left + widths[cellSide][rightSideColumnIndex];
                            var top = rowOffsets[rowIndex];
                            var bottom = top + heights[rowIndex];
                            var cellPosRect = { left: left, right: right, top: top, bottom: bottom };
                            var _c = viewport_1.getChangedScrollPosition(store, cellSide, cellPosRect), changedScrollLeft = _c[0], changedScrollTop = _c[1];
                            setScrollPosition(viewport, changedScrollTop, changedScrollLeft);
                        }
                        exports.setScrollToSelection = setScrollToSelection;
                        function setScrollLeft(_a, scrollLeft) {
                            var viewport = _a.viewport;
                            viewport.scrollLeft = scrollLeft;
                        }
                        exports.setScrollLeft = setScrollLeft;
                        function setScrollTop(_a, scrollTop) {
                            var viewport = _a.viewport;
                            viewport.scrollTop = scrollTop;
                        }
                        exports.setScrollTop = setScrollTop;
                        function initScrollPosition(_a) {
                            var viewport = _a.viewport;
                            viewport.scrollLeft = 0;
                            viewport.scrollTop = 0;
                        }
                        exports.initScrollPosition = initScrollPosition;


                        /***/ }),
                    /* 23 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.updateAllSummaryValues = exports.updateSummaryValueByRow = exports.updateSummaryValueByColumn = exports.updateSummaryValueByCell = exports.setSummaryColumnContent = void 0;
                        var summary_1 = __webpack_require__(42);
                        var common_1 = __webpack_require__(0);
                        var summary_2 = __webpack_require__(43);
                        var observable_1 = __webpack_require__(5);
                        function setSummaryColumnContent(_a, columnName, columnContent) {
                            var summary = _a.summary, data = _a.data;
                            var castedColumnContent = summary_1.castToSummaryColumnContent(columnContent);
                            var content = summary_1.extractSummaryColumnContent(castedColumnContent, null);
                            summary.summaryColumnContents[columnName] = content;
                            summary.summaryValues[columnName] = summary_2.createSummaryValue(content, columnName, data);
                            observable_1.notify(summary, 'summaryValues');
                        }
                        exports.setSummaryColumnContent = setSummaryColumnContent;
                        function updateSummaryValue(_a, columnName, type, options) {
                            var summary = _a.summary, data = _a.data;
                            var content = summary.summaryColumnContents[columnName];
                            if (!content || !content.useAutoSummary) {
                                return;
                            }
                            var summaryValue = summary.summaryValues[columnName];
                            var orgValue = Number(options.orgValue) || 0;
                            var value = Number(options.value) || 0;
                            var cntVariation = options.type === 'APPEND' ? 1 : -1;
                            var columnFilter = common_1.findProp('columnName', columnName, data.filters || []);
                            var hasColumnFilter = !!(columnFilter && common_1.isFunction(columnFilter.conditionFn));
                            var included = hasColumnFilter && columnFilter.conditionFn(value);
                            var sum = summaryValue.sum, min = summaryValue.min, max = summaryValue.max, cnt = summaryValue.cnt;
                            var _b = summaryValue.filtered, filteredSum = _b.sum, filteredMin = _b.min, filteredMax = _b.max, filteredCnt = _b.cnt;
                            switch (type) {
                                case 'UPDATE_COLUMN':
                                    sum = value * cnt;
                                    min = value;
                                    max = value;
                                    if (hasColumnFilter) {
                                        filteredCnt = included ? filteredCnt : 0;
                                        filteredSum = included ? value * filteredCnt : 0;
                                        filteredMin = included ? value : 0;
                                        filteredMax = included ? value : 0;
                                    }
                                    break;
                                case 'UPDATE_CELL':
                                    sum = sum - orgValue + value;
                                    if (hasColumnFilter) {
                                        var orgIncluded = columnFilter.conditionFn(orgValue);
                                        if (!orgIncluded && included) {
                                            filteredSum = filteredSum + value;
                                            filteredCnt += 1;
                                        }
                                        else if (orgIncluded && !included) {
                                            filteredSum = filteredSum - orgValue;
                                            filteredCnt -= 1;
                                        }
                                        else if (orgIncluded && included) {
                                            filteredSum = filteredSum - orgValue + value;
                                        }
                                    }
                                    break;
                                case 'UPDATE_ROW':
                                    cnt += cntVariation;
                                    sum = sum + cntVariation * value;
                                    if (hasColumnFilter && included) {
                                        filteredSum = filteredSum + cntVariation * value;
                                        filteredCnt += cntVariation;
                                    }
                                    break;
                                // do nothing;
                            }
                            var avg = sum / cnt;
                            var filteredAvg = filteredSum / filteredCnt;
                            min = Math.min(value, min);
                            max = Math.max(value, max);
                            filteredMin = Math.min(value, filteredMin);
                            filteredMax = Math.max(value, filteredMax);
                            summary.summaryValues[columnName] = {
                                sum: sum,
                                min: min,
                                max: max,
                                avg: avg,
                                cnt: cnt,
                                filtered: {
                                    sum: filteredSum,
                                    min: filteredMin,
                                    max: filteredMax,
                                    avg: filteredAvg,
                                    cnt: filteredCnt,
                                },
                            };
                            observable_1.notify(summary, 'summaryValues');
                        }
                        function updateSummaryValueByCell(store, columnName, options) {
                            updateSummaryValue(store, columnName, 'UPDATE_CELL', options);
                        }
                        exports.updateSummaryValueByCell = updateSummaryValueByCell;
                        function updateSummaryValueByColumn(store, columnName, options) {
                            updateSummaryValue(store, columnName, 'UPDATE_COLUMN', options);
                        }
                        exports.updateSummaryValueByColumn = updateSummaryValueByColumn;
                        function updateSummaryValueByRow(store, row, options) {
                            var summary = store.summary, column = store.column;
                            var type = options.type, orgRow = options.orgRow;
                            var summaryColumns = column.allColumns.filter(function (_a) {
                                var name = _a.name;
                                return !!summary.summaryColumnContents[name];
                            });
                            summaryColumns.forEach(function (_a) {
                                var name = _a.name;
                                if (type === 'SET') {
                                    updateSummaryValue(store, name, 'UPDATE_CELL', { orgValue: orgRow[name], value: row[name] });
                                }
                                else {
                                    updateSummaryValue(store, name, 'UPDATE_ROW', { type: type, value: row[name] });
                                }
                            });
                        }
                        exports.updateSummaryValueByRow = updateSummaryValueByRow;
                        function updateAllSummaryValues(_a) {
                            var summary = _a.summary, data = _a.data, column = _a.column;
                            var summaryColumns = column.allColumns.filter(function (_a) {
                                var name = _a.name;
                                return !!summary.summaryColumnContents[name];
                            });
                            summaryColumns.forEach(function (_a) {
                                var name = _a.name;
                                var content = summary.summaryColumnContents[name];
                                summary.summaryValues[name] = summary_2.createSummaryValue(content, name, data);
                            });
                            observable_1.notify(summary, 'summaryValues');
                        }
                        exports.updateAllSummaryValues = updateAllSummaryValues;


                        /***/ }),
                    /* 24 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getValidationCode = exports.forceValidateUniquenessOfColumn = exports.forceValidateUniquenessOfColumns = exports.replaceColumnUniqueInfoMap = exports.removeUniqueInfoMap = exports.addUniqueInfoMap = exports.invokeWithUniqueValidationColumn = exports.createNewValidationMap = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var observable_1 = __webpack_require__(5);
                        var instance_1 = __webpack_require__(7);
                        var data_1 = __webpack_require__(6);
                        var instanceValidationMap = {};
                        var isValidatingUniquenessMap = {};
                        function createNewValidationMap(id) {
                            instanceValidationMap[id] = {};
                        }
                        exports.createNewValidationMap = createNewValidationMap;
                        function invokeWithUniqueValidationColumn(column, fn) {
                            column.validationColumns.forEach(function (_a) {
                                var name = _a.name, validation = _a.validation;
                                if (validation.unique) {
                                    fn(name);
                                }
                            });
                        }
                        exports.invokeWithUniqueValidationColumn = invokeWithUniqueValidationColumn;
                        function addUniqueInfoMap(id, row, column) {
                            invokeWithUniqueValidationColumn(column, function (name) {
                                return addColumnUniqueInfoMap(id, row.rowKey, name, row[name]);
                            });
                        }
                        exports.addUniqueInfoMap = addUniqueInfoMap;
                        function removeUniqueInfoMap(id, row, column) {
                            invokeWithUniqueValidationColumn(column, function (name) {
                                return removeColumnUniqueInfoMap(id, row.rowKey, name, row[name]);
                            });
                        }
                        exports.removeUniqueInfoMap = removeUniqueInfoMap;
                        function removeColumnUniqueInfoMap(id, rowKey, columnName, cellValue) {
                            var value = String(cellValue);
                            var uniqueInfoMap = instanceValidationMap[id];
                            if (uniqueInfoMap && uniqueInfoMap[value] && uniqueInfoMap[value][columnName]) {
                                uniqueInfoMap[value][columnName] = uniqueInfoMap[value][columnName].filter(function (targetRowKey) { return targetRowKey !== rowKey; });
                            }
                        }
                        function addColumnUniqueInfoMap(id, rowKey, columnName, cellValue) {
                            var value = String(cellValue);
                            var uniqueInfoMap = instanceValidationMap[id];
                            uniqueInfoMap[value] = uniqueInfoMap[value] || {};
                            uniqueInfoMap[value][columnName] = uniqueInfoMap[value][columnName] || [];
                            uniqueInfoMap[value][columnName].push(rowKey);
                        }
                        function replaceColumnUniqueInfoMap(id, column, _a) {
                            var rowKey = _a.rowKey, columnName = _a.columnName, prevValue = _a.prevValue, value = _a.value;
                            if (common_1.some(function (_a) {
                                var name = _a.name;
                                return name === columnName;
                            }, column.validationColumns)) {
                                removeColumnUniqueInfoMap(id, rowKey, columnName, prevValue);
                                addColumnUniqueInfoMap(id, rowKey, columnName, value);
                            }
                        }
                        exports.replaceColumnUniqueInfoMap = replaceColumnUniqueInfoMap;
                        function forceValidateUniquenessOfColumns(rawData, column) {
                            if (rawData.length) {
                                // trick for forcing to validate the uniqueness
                                invokeWithUniqueValidationColumn(column, function (name) { return observable_1.notify(rawData[0], name); });
                            }
                        }
                        exports.forceValidateUniquenessOfColumns = forceValidateUniquenessOfColumns;
                        function forceValidateUniquenessOfColumn(rawData, column, columnName) {
                            if (common_1.some(function (_a) {
                                var name = _a.name;
                                return name === columnName;
                            }, column.validationColumns) && rawData.length) {
                                // trick for forcing to validate the uniqueness
                                observable_1.notify(rawData[0], columnName);
                            }
                        }
                        exports.forceValidateUniquenessOfColumn = forceValidateUniquenessOfColumn;
                        function hasDuplicateValue(id, columnName, cellValue) {
                            var _a;
                            var value = String(cellValue);
                            var uniqueInfoMap = instanceValidationMap[id];
                            return !!(uniqueInfoMap && uniqueInfoMap[value] && ((_a = uniqueInfoMap[value][columnName]) === null || _a === void 0 ? void 0 : _a.length) > 1);
                        }
                        function validateDataUniqueness(id, value, columnName, invalidStates) {
                            if (hasDuplicateValue(id, columnName, value)) {
                                invalidStates.push({ code: 'UNIQUE' });
                            }
                            // prevent recursive call of 'validateDataUniqueness' when scrolling or manipulating the data
                            if (!isValidatingUniquenessMap[columnName] &&
                                !common_1.includes(observable_1.getRunningObservers(), 'lazyObservable')) {
                                var rawData_1 = [];
                                observable_1.unobservedInvoke(function () {
                                    // @TODO: should get the latest rawData through function(not private field of the grid instance)
                                    // @ts-ignore
                                    rawData_1 = instance_1.getInstance(id).store.data.rawData;
                                });
                                isValidatingUniquenessMap[columnName] = true;
                                rawData_1.forEach(function (row) {
                                    if (observable_1.isObservable(row)) {
                                        observable_1.notify(row, columnName);
                                    }
                                });
                                setTimeout(function () {
                                    isValidatingUniquenessMap[columnName] = false;
                                });
                            }
                        }
                        function validateCustomValidator(row, value, columnName, validatorFn, invalidStates) {
                            var originRow = data_1.getOmittedInternalProp(row);
                            observable_1.unobservedInvoke(function () {
                                var result = validatorFn(value, originRow, columnName);
                                var _a = (common_1.isBoolean(result)
                                    ? { valid: result }
                                    : result), valid = _a.valid, meta = _a.meta;
                                if (!valid) {
                                    invalidStates.push(tslib_1.__assign({ code: 'VALIDATOR_FN' }, meta));
                                }
                            });
                        }
                        function getValidationCode(_a) {
                            var id = _a.id, value = _a.value, row = _a.row, columnName = _a.columnName, validation = _a.validation;
                            var invalidStates = [];
                            if (!validation) {
                                return invalidStates;
                            }
                            var required = validation.required, dataType = validation.dataType, min = validation.min, max = validation.max, regExp = validation.regExp, unique = validation.unique, validatorFn = validation.validatorFn;
                            if (required && common_1.isBlank(value)) {
                                invalidStates.push({ code: 'REQUIRED' });
                            }
                            if (unique) {
                                validateDataUniqueness(id, value, columnName, invalidStates);
                            }
                            if (common_1.isFunction(validatorFn)) {
                                validateCustomValidator(row, value, columnName, validatorFn, invalidStates);
                            }
                            if (dataType === 'string' && !common_1.isString(value)) {
                                invalidStates.push({ code: 'TYPE_STRING' });
                            }
                            if (regExp && common_1.isString(value) && !regExp.test(value)) {
                                invalidStates.push({ code: 'REGEXP', regExp: regExp });
                            }
                            var numberValue = common_1.convertToNumber(value);
                            if (dataType === 'number' && !common_1.isNumber(numberValue)) {
                                invalidStates.push({ code: 'TYPE_NUMBER' });
                            }
                            if (common_1.isNumber(min) && common_1.isNumber(numberValue) && numberValue < min) {
                                invalidStates.push({ code: 'MIN', min: min });
                            }
                            if (common_1.isNumber(max) && common_1.isNumber(numberValue) && numberValue > max) {
                                invalidStates.push({ code: 'MAX', max: max });
                            }
                            return invalidStates;
                        }
                        exports.getValidationCode = getValidationCode;


                        /***/ }),
                    /* 25 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getFormattedValue = exports.createFormattedValue = exports.getMaxTextMap = exports.setMaxColumnTextMap = exports.setMaxTextMap = exports.initMaxTextMap = void 0;
                        var listItemText_1 = __webpack_require__(59);
                        var common_1 = __webpack_require__(0);
                        var maxTextMap = {};
                        function initMaxTextMap() {
                            maxTextMap = {};
                        }
                        exports.initMaxTextMap = initMaxTextMap;
                        function setMaxTextMap(column, row) {
                            column.autoResizingColumn.forEach(function (columnInfo) {
                                var name = columnInfo.name;
                                var formattedValue = createFormattedValue(row, columnInfo);
                                if (!maxTextMap[name] || maxTextMap[name].formattedValue.length < formattedValue.length) {
                                    setMaxColumnTextMap(name, formattedValue, row);
                                }
                            });
                        }
                        exports.setMaxTextMap = setMaxTextMap;
                        function setMaxColumnTextMap(columnName, formattedValue, row) {
                            maxTextMap[columnName] = { formattedValue: formattedValue, row: row };
                        }
                        exports.setMaxColumnTextMap = setMaxColumnTextMap;
                        function getMaxTextMap() {
                            return maxTextMap;
                        }
                        exports.getMaxTextMap = getMaxTextMap;
                        function createFormattedValue(row, columnInfo) {
                            var name = columnInfo.name, formatter = columnInfo.formatter, defaultValue = columnInfo.defaultValue;
                            var formatterProps = { row: row, column: columnInfo, value: row[name] };
                            return getFormattedValue(formatterProps, formatter, row[name] || defaultValue, row._relationListItemMap[name]);
                        }
                        exports.createFormattedValue = createFormattedValue;
                        function getFormattedValue(props, formatter, defaultValue, relationListItems) {
                            var value;
                            if (formatter === 'listItemText') {
                                value = listItemText_1.listItemText(props, relationListItems);
                            }
                            else if (common_1.isFunction(formatter)) {
                                value = formatter(props);
                            }
                            else if (common_1.isString(formatter)) {
                                value = formatter;
                            }
                            else {
                                value = defaultValue;
                            }
                            var strValue = getCellDisplayValue(value);
                            if (strValue && props.column.escapeHTML) {
                                return common_1.encodeHTMLEntity(strValue);
                            }
                            return strValue;
                        }
                        exports.getFormattedValue = getFormattedValue;
                        function getCellDisplayValue(value) {
                            if (common_1.isNil(value)) {
                                return '';
                            }
                            return String(value);
                        }


                        /***/ }),
                    /* 26 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.createObservableData = exports.fillMissingColumnData = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var observable_1 = __webpack_require__(5);
                        var data_1 = __webpack_require__(13);
                        var data_2 = __webpack_require__(6);
                        var tree_1 = __webpack_require__(20);
                        var common_1 = __webpack_require__(0);
                        function getDataToBeObservable(acc, row, viewRow, index, treeColumnName) {
                            if (treeColumnName && row._attributes.tree.hidden) {
                                return acc;
                            }
                            if (!observable_1.isObservable(row) ||
                                (viewRow && row.rowKey === viewRow.rowKey && !observable_1.isObservable(viewRow.valueMap))) {
                                acc.rows.push(row);
                                acc.targetIndexes.push(index);
                            }
                            return acc;
                        }
                        function createOriginData(data, rowRange, treeColumnName) {
                            var start = rowRange[0], end = rowRange[1];
                            var viewData = data.viewData.slice(start, end);
                            return data.rawData
                                .slice(start, end)
                                .reduce(function (acc, row, index) {
                                    return getDataToBeObservable(acc, row, viewData[index], index + start, treeColumnName);
                                }, {
                                    rows: [],
                                    targetIndexes: [],
                                });
                        }
                        function createFilteredOriginData(data, rowRange, treeColumnName) {
                            var start = rowRange[0], end = rowRange[1];
                            var rawData = data.rawData, viewData = data.viewData;
                            return data
                                .filteredIndex.slice(start, end)
                                .reduce(function (acc, rowIndex) {
                                    return getDataToBeObservable(acc, rawData[rowIndex], viewData[rowIndex], rowIndex, treeColumnName);
                                }, { rows: [], targetIndexes: [] });
                        }
                        function changeToObservableData(id, column, data, originData) {
                            var targetIndexes = originData.targetIndexes, rows = originData.rows;
                            var rawData = data.rawData;
                            fillMissingColumnData(column, rows);
                            // prevRows is needed to create rowSpan
                            var prevRows = targetIndexes.map(function (targetIndex) { return data.rawData[targetIndex - 1]; });
                            for (var index = 0, end = rows.length; index < end; index += 1) {
                                var targetIndex = targetIndexes[index];
                                var rawRow = data_1.createRawRow(id, rows[index], index, column, {
                                    lazyObservable: false,
                                    prevRow: prevRows[index],
                                    keyColumnName: column.keyColumnName,
                                });
                                var viewRow = data_1.createViewRow(id, rawRow, rawData, column);
                                common_1.silentSplice(data.rawData, targetIndex, 1, rawRow);
                                common_1.silentSplice(data.viewData, targetIndex, 1, viewRow);
                            }
                            observable_1.notify(data, 'rawData', 'filteredRawData', 'viewData', 'filteredViewData');
                        }
                        function changeToObservableTreeData(id, column, data, originData) {
                            var rows = originData.rows;
                            var rawData = data.rawData, viewData = data.viewData;
                            fillMissingColumnData(column, rows);
                            // create new creation key for updating the observe function of hoc component
                            data_1.generateDataCreationKey();
                            rows.forEach(function (row) {
                                var parentRow = data_2.findRowByRowKey(data, column, id, row._attributes.tree.parentRowKey);
                                var rawRow = tree_1.createTreeRawRow(id, row, parentRow || null, column);
                                var viewRow = data_1.createViewRow(id, rawRow, rawData, column);
                                var foundIndex = data_2.findIndexByRowKey(data, column, id, rawRow.rowKey);
                                common_1.silentSplice(rawData, foundIndex, 1, rawRow);
                                common_1.silentSplice(viewData, foundIndex, 1, viewRow);
                            });
                            observable_1.notify(data, 'rawData', 'filteredRawData', 'viewData', 'filteredViewData');
                        }
                        function fillMissingColumnData(column, rawData) {
                            for (var i = 0; i < rawData.length; i += 1) {
                                rawData[i] = tslib_1.__assign(tslib_1.__assign({}, column.emptyRow), rawData[i]);
                            }
                        }
                        exports.fillMissingColumnData = fillMissingColumnData;
                        function createObservableData(_a, allRowRange) {
                            var column = _a.column, data = _a.data, viewport = _a.viewport, id = _a.id;
                            if (allRowRange === void 0) { allRowRange = false; }
                            var rowRange = allRowRange ? [0, data.rawData.length] : viewport.rowRange;
                            var treeColumnName = column.treeColumnName;
                            var originData = data.filters && !allRowRange
                                ? createFilteredOriginData(data, rowRange, treeColumnName)
                                : createOriginData(data, rowRange, treeColumnName);
                            if (!originData.rows.length) {
                                return;
                            }
                            if (treeColumnName) {
                                changeToObservableTreeData(id, column, data, originData);
                            }
                            else {
                                changeToObservableData(id, column, data, originData);
                            }
                        }
                        exports.createObservableData = createObservableData;


                        /***/ }),
                    /* 27 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.resetSortState = exports.sortByCurrentState = exports.resetSortKey = exports.updateSortKey = exports.emitAfterSort = exports.emitBeforeSort = exports.initSortState = exports.unsort = exports.sort = exports.changeSortState = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var observable_1 = __webpack_require__(5);
                        var sort_1 = __webpack_require__(70);
                        var eventBus_1 = __webpack_require__(8);
                        var data_1 = __webpack_require__(14);
                        var data_2 = __webpack_require__(6);
                        var column_1 = __webpack_require__(12);
                        var sort_2 = __webpack_require__(41);
                        function createSoretedViewData(rawData) {
                            return rawData.map(function (_a) {
                                var rowKey = _a.rowKey, sortKey = _a.sortKey, uniqueKey = _a.uniqueKey;
                                return ({ rowKey: rowKey, sortKey: sortKey, uniqueKey: uniqueKey });
                            });
                        }
                        function sortData(store) {
                            var data = store.data, column = store.column;
                            var sortState = data.sortState, rawData = data.rawData, viewData = data.viewData, pageRowRange = data.pageRowRange;
                            var columns = sortState.columns;
                            var sortedColumns = columns.map(function (sortedColumn) {
                                var _a;
                                return (tslib_1.__assign(tslib_1.__assign({}, sortedColumn), { comparator: (_a = column.allColumnMap[sortedColumn.columnName]) === null || _a === void 0 ? void 0 : _a.comparator }));
                            });
                            if (data_2.isScrollPagination(data, true)) {
                                // should sort the sliced data which is displayed in viewport in case of client infinite scrolling
                                var targetRawData = rawData.slice.apply(rawData, pageRowRange);
                                targetRawData.sort(sort_1.sortRawData(sortedColumns));
                                var targetViewData = createSoretedViewData(targetRawData);
                                data.rawData = targetRawData.concat(rawData.slice(pageRowRange[1]));
                                data.viewData = targetViewData.concat(viewData.slice(pageRowRange[1]));
                            }
                            else {
                                rawData.sort(sort_1.sortRawData(sortedColumns));
                                data.viewData = createSoretedViewData(rawData);
                            }
                        }
                        function setInitialSortState(data) {
                            data.sortState.columns = [{ columnName: 'sortKey', ascending: true }];
                        }
                        function setSortStateForEmptyState(data) {
                            if (!data.sortState.columns.length) {
                                setInitialSortState(data);
                            }
                        }
                        function toggleSortAscending(data, index, ascending, sortingType, cancelable) {
                            var defaultAscending = sortingType === 'asc';
                            if (defaultAscending === ascending && cancelable) {
                                data.sortState.columns.splice(index, 1);
                            }
                            else {
                                data.sortState.columns[index].ascending = ascending;
                            }
                        }
                        function changeSingleSortState(data, columnName, ascending, sortingType, cancelable) {
                            var sortState = data.sortState;
                            var columns = sortState.columns;
                            var sortedColumn = { columnName: columnName, ascending: ascending };
                            if (columns.length === 1 && columns[0].columnName === columnName) {
                                var columnIndex = common_1.findPropIndex('columnName', columnName, sortState.columns);
                                toggleSortAscending(data, columnIndex, ascending, sortingType, cancelable);
                            }
                            else {
                                data.sortState.columns = [sortedColumn];
                            }
                        }
                        function changeMultiSortState(data, columnName, ascending, sortingType, cancelable) {
                            var sortedColumn = { columnName: columnName, ascending: ascending };
                            var sortState = data.sortState;
                            var columns = sortState.columns;
                            var columnIndex = common_1.findPropIndex('columnName', columnName, columns);
                            if (columnIndex === -1) {
                                data.sortState.columns = data_2.isInitialSortState(sortState)
                                    ? [sortedColumn]
                                    : tslib_1.__spreadArrays(columns, [sortedColumn]);
                            }
                            else {
                                toggleSortAscending(data, columnIndex, ascending, sortingType, cancelable);
                            }
                        }
                        function changeSortState(_a, columnName, ascending, multiple, cancelable) {
                            var data = _a.data, column = _a.column;
                            if (cancelable === void 0) { cancelable = true; }
                            if (columnName === 'sortKey') {
                                setInitialSortState(data);
                            }
                            else {
                                var sortingType = column.allColumnMap[columnName].sortingType;
                                if (multiple) {
                                    changeMultiSortState(data, columnName, ascending, sortingType, cancelable);
                                }
                                else {
                                    changeSingleSortState(data, columnName, ascending, sortingType, cancelable);
                                }
                                setSortStateForEmptyState(data);
                            }
                            if (!data.sortState.useClient) {
                                observable_1.notify(data, 'sortState');
                            }
                        }
                        exports.changeSortState = changeSortState;
                        function applySortedData(store) {
                            sortData(store);
                            observable_1.notify(store.data, 'sortState');
                            data_1.updateRowNumber(store, 0);
                            data_1.setCheckedAllRows(store);
                        }
                        function sort(store, columnName, ascending, multiple, cancelable) {
                            if (multiple === void 0) { multiple = false; }
                            if (cancelable === void 0) { cancelable = true; }
                            var data = store.data, column = store.column;
                            var sortState = data.sortState;
                            if (column_1.isComplexHeader(column, columnName) || !data_2.isSortable(sortState, column, columnName)) {
                                return;
                            }
                            var cancelSort = sort_2.isCancelSort(store, columnName, ascending, cancelable);
                            var gridEvent = emitBeforeSort(store, cancelSort, { columnName: columnName, ascending: ascending, multiple: multiple });
                            if (gridEvent.isStopped()) {
                                return;
                            }
                            changeSortState(store, columnName, ascending, multiple, cancelable);
                            applySortedData(store);
                            emitAfterSort(store, cancelSort, columnName);
                        }
                        exports.sort = sort;
                        function unsort(store, columnName) {
                            if (columnName === void 0) { columnName = 'sortKey'; }
                            var data = store.data, column = store.column;
                            var sortState = data.sortState;
                            if (column_1.isComplexHeader(column, columnName) || !data_2.isSortable(sortState, column, columnName)) {
                                return;
                            }
                            emitBeforeSort(store, true, { columnName: columnName, multiple: true });
                            if (columnName === 'sortKey') {
                                setInitialSortState(data);
                            }
                            else {
                                var index = common_1.findPropIndex('columnName', columnName, data.sortState.columns);
                                if (index !== -1) {
                                    data.sortState.columns.splice(index, 1);
                                    setSortStateForEmptyState(data);
                                }
                            }
                            applySortedData(store);
                            emitAfterSort(store, true, columnName);
                        }
                        exports.unsort = unsort;
                        function initSortState(data) {
                            setInitialSortState(data);
                            observable_1.notify(data, 'sortState');
                        }
                        exports.initSortState = initSortState;
                        function emitBeforeSort(store, cancelSort, eventParams) {
                            var id = store.id, data = store.data;
                            var eventBus = eventBus_1.getEventBus(id);
                            var eventType = cancelSort ? 'beforeUnsort' : 'beforeSort';
                            var gridEvent = sort_2.createSortEvent(eventType, tslib_1.__assign(tslib_1.__assign({}, eventParams), { sortState: data.sortState }));
                            eventBus.trigger(eventType, gridEvent);
                            return gridEvent;
                        }
                        exports.emitBeforeSort = emitBeforeSort;
                        function emitAfterSort(store, cancelSort, columnName) {
                            var id = store.id, data = store.data;
                            var eventBus = eventBus_1.getEventBus(id);
                            // @TODO: `sort` event will be deprecated. This event is replaced with `afterSort` event
                            var eventTypes = (cancelSort ? ['afterUnsort'] : ['afterSort', 'sort']);
                            eventTypes.forEach(function (eventType) {
                                var gridEvent = sort_2.createSortEvent(eventType, { columnName: columnName, sortState: data.sortState });
                                eventBus.trigger(eventType, gridEvent);
                            });
                        }
                        exports.emitAfterSort = emitAfterSort;
                        function updateSortKey(data, sortKey, appended) {
                            if (appended === void 0) { appended = true; }
                            var incremental = appended ? 1 : -1;
                            var rawData = data.rawData, viewData = data.viewData;
                            for (var idx = 0; idx < rawData.length; idx += 1) {
                                if (rawData[idx].sortKey >= sortKey) {
                                    rawData[idx].sortKey += incremental;
                                    viewData[idx].sortKey += incremental;
                                }
                            }
                            if (appended) {
                                rawData[sortKey].sortKey = sortKey;
                                viewData[sortKey].sortKey = sortKey;
                            }
                        }
                        exports.updateSortKey = updateSortKey;
                        function resetSortKey(data, start) {
                            var rawData = data.rawData, viewData = data.viewData;
                            for (var idx = start; idx < rawData.length; idx += 1) {
                                rawData[idx].sortKey = idx;
                                viewData[idx].sortKey = idx;
                            }
                        }
                        exports.resetSortKey = resetSortKey;
                        function sortByCurrentState(store) {
                            var data = store.data;
                            if (data_2.isSorted(data)) {
                                var _a = data.sortState.columns[0], columnName = _a.columnName, ascending = _a.ascending;
                                sort(store, columnName, ascending, true, false);
                            }
                        }
                        exports.sortByCurrentState = sortByCurrentState;
                        function resetSortState(store, sortState) {
                            var data = store.data, column = store.column;
                            if (sortState) {
                                var columnName = sortState.columnName, ascending = sortState.ascending, multiple = sortState.multiple;
                                var _a = column.allColumnMap[columnName], sortingType = _a.sortingType, sortable = _a.sortable;
                                if (sortable) {
                                    var cancelable = common_1.isUndefined(ascending);
                                    var nextAscending = cancelable ? sortingType === 'asc' : ascending;
                                    changeSortState(store, columnName, nextAscending, multiple, cancelable);
                                    observable_1.notify(data, 'sortState');
                                }
                            }
                            else {
                                initSortState(data);
                            }
                        }
                        exports.resetSortState = resetSortState;


                        /***/ }),
                    /* 28 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.composeConditionFn = exports.getFilterConditionFn = exports.getUnixTime = exports.filterSelectOption = void 0;
                        var common_1 = __webpack_require__(0);
                        exports.filterSelectOption = {
                            number: {
                                eq: '=',
                                lt: '<',
                                gt: '>',
                                lte: '<=',
                                gte: '>=',
                                ne: '!=',
                            },
                            text: {
                                contain: 'Contains',
                                eq: 'Equals',
                                ne: 'Not equals',
                                start: 'Starts with',
                                end: 'Ends with',
                            },
                            date: {
                                eq: 'Equals',
                                ne: 'Not equals',
                                after: 'After',
                                afterEq: 'After or Equal',
                                before: 'Before',
                                beforeEq: 'Before or Equal',
                            },
                        };
                        function getUnixTime(value) {
                            return parseInt((new Date(String(value)).getTime() / 1000).toFixed(0), 10);
                        }
                        exports.getUnixTime = getUnixTime;
                        function getPredicateWithType(code, type, inputValue) {
                            var convertFn = {
                                number: Number,
                                text: String,
                                select: String,
                                date: getUnixTime,
                            }[type];
                            return code === 'eq'
                                ? function (cellValue) { return convertFn(cellValue) === convertFn(inputValue); }
                                : function (cellValue) { return convertFn(cellValue) !== convertFn(inputValue); };
                        }
                        function getFilterConditionFn(code, inputValue, type) {
                            switch (code) {
                                case 'eq':
                                case 'ne':
                                    return getPredicateWithType(code, type, inputValue);
                                case 'lt':
                                    return function (cellValue) { return Number(cellValue) < Number(inputValue); };
                                case 'gt':
                                    return function (cellValue) { return Number(cellValue) > Number(inputValue); };
                                case 'lte':
                                    return function (cellValue) { return Number(cellValue) <= Number(inputValue); };
                                case 'gte':
                                    return function (cellValue) { return Number(cellValue) >= Number(inputValue); };
                                case 'contain':
                                    return function (cellValue) {
                                        return common_1.isString(cellValue) && common_1.isString(inputValue) && cellValue.indexOf(inputValue) !== -1;
                                    };
                                case 'start':
                                    return function (cellValue) {
                                        return common_1.isString(cellValue) && common_1.isString(inputValue) && common_1.startsWith(inputValue, cellValue);
                                    };
                                case 'end':
                                    return function (cellValue) {
                                        return common_1.isString(cellValue) && common_1.isString(inputValue) && common_1.endsWith(inputValue, cellValue);
                                    };
                                case 'after':
                                    return function (cellValue) { return getUnixTime(cellValue) > getUnixTime(inputValue); };
                                case 'afterEq':
                                    return function (cellValue) { return getUnixTime(cellValue) >= getUnixTime(inputValue); };
                                case 'before':
                                    return function (cellValue) { return getUnixTime(cellValue) < getUnixTime(inputValue); };
                                case 'beforeEq':
                                    return function (cellValue) { return getUnixTime(cellValue) <= getUnixTime(inputValue); };
                                default:
                                    throw new Error('code not available.');
                            }
                        }
                        exports.getFilterConditionFn = getFilterConditionFn;
                        function composeConditionFn(fns, operator) {
                            return function (value) {
                                return fns.reduce(function (acc, fn) {
                                    return operator === 'OR' ? acc || fn(value) : acc && fn(value);
                                }, operator !== 'OR');
                            };
                        }
                        exports.composeConditionFn = composeConditionFn;


                        /***/ }),
                    /* 29 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.removeTreeRow = exports.appendTreeRow = exports.changeTreeRowsCheckedState = exports.collapseAll = exports.collapseByRowKey = exports.expandAll = exports.expandByRowKey = exports.removeExpandedAttr = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var data_1 = __webpack_require__(13);
                        var data_2 = __webpack_require__(6);
                        var observable_1 = __webpack_require__(5);
                        var instance_1 = __webpack_require__(7);
                        var data_3 = __webpack_require__(14);
                        var tree_1 = __webpack_require__(21);
                        var eventBus_1 = __webpack_require__(8);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var tree_2 = __webpack_require__(20);
                        var common_1 = __webpack_require__(0);
                        var dom_1 = __webpack_require__(2);
                        var lazyObservable_1 = __webpack_require__(26);
                        var column_1 = __webpack_require__(12);
                        var data_4 = __webpack_require__(25);
                        var constant_1 = __webpack_require__(16);
                        var column_2 = __webpack_require__(30);
                        var computedFontStyle = '';
                        function changeExpandedAttr(row, expanded) {
                            var tree = row._attributes.tree;
                            if (tree) {
                                row._attributes.expanded = expanded;
                                tree.expanded = expanded;
                            }
                        }
                        function changeHiddenAttr(row, hidden) {
                            var tree = row._attributes.tree;
                            if (tree) {
                                tree.hidden = hidden;
                            }
                        }
                        function expand(store, row, recursive) {
                            var rowKey = row.rowKey;
                            var eventBus = eventBus_1.getEventBus(store.id);
                            var gridEvent = new gridEvent_1.default({ rowKey: rowKey });
                            /**
                             * Occurs when the row having child rows is expanded
                             * @event Grid#expand
                             * @type {module:event/gridEvent}
                             * @property {number|string} rowKey - rowKey of the expanded row
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('expand', gridEvent);
                            if (gridEvent.isStopped()) {
                                return;
                            }
                            var data = store.data, rowCoords = store.rowCoords, dimension = store.dimension, column = store.column, id = store.id, viewport = store.viewport, columnCoords = store.columnCoords;
                            var heights = rowCoords.heights;
                            changeExpandedAttr(row, true);
                            var childRowKeys = tree_1.getChildRowKeys(row);
                            updateTreeColumnWidth(childRowKeys, column, columnCoords, dimension, data.rawData);
                            childRowKeys.forEach(function (childRowKey) {
                                var childRow = data_2.findRowByRowKey(data, column, id, childRowKey);
                                if (!childRow) {
                                    return;
                                }
                                changeHiddenAttr(childRow, false);
                                if (!tree_1.isLeaf(childRow) && (tree_1.isExpanded(childRow) || recursive)) {
                                    expand(store, childRow, recursive);
                                }
                                var index = data_2.findIndexByRowKey(data, column, id, childRowKey);
                                heights[index] = data_2.getRowHeight(childRow, dimension.rowHeight);
                            });
                            if (childRowKeys.length) {
                                observable_1.notify(rowCoords, 'heights');
                                observable_1.notify(viewport, 'rowRange');
                            }
                        }
                        function updateTreeColumnWidth(childRowKeys, column, columnCoords, dimension, rawData) {
                            var visibleColumnsBySideWithRowHeader = column.visibleColumnsBySideWithRowHeader, treeIcon = column.treeIcon, allColumnMap = column.allColumnMap;
                            var treeColumnName = column.treeColumnName;
                            var treeColumnSide = column_1.getColumnSide(column, treeColumnName);
                            var treeColumnIndex = common_1.findPropIndex('name', treeColumnName, column.visibleColumnsBySide[treeColumnSide]);
                            var columnInfo = visibleColumnsBySideWithRowHeader[treeColumnSide][treeColumnIndex];
                            // @TODO: auto resizing is operated with 'autoResizing' option
                            // 'resizable' condition should be deprecated in next version
                            if (columnInfo.resizable || columnInfo.autoResizing) {
                                var maxWidth = getChildTreeNodeMaxWidth(childRowKeys, rawData, columnInfo, treeIcon);
                                var prevWidth = columnCoords.widths[treeColumnSide][treeColumnIndex] + dimension.cellBorderWidth;
                                allColumnMap[treeColumnName].baseWidth = Math.max(prevWidth, maxWidth);
                                allColumnMap[treeColumnName].fixedWidth = true;
                            }
                        }
                        function getChildTreeNodeMaxWidth(childRowKeys, rawData, column, useIcon) {
                            var maxLength = 0;
                            computedFontStyle = computedFontStyle || dom_1.getComputedFontStyle('tree-wrapper-relative');
                            var getMaxWidth = childRowKeys.reduce(function (acc, rowKey) {
                                var row = common_1.findProp('rowKey', rowKey, rawData);
                                var formattedValue = data_4.createFormattedValue(row, column);
                                if (formattedValue.length > maxLength) {
                                    maxLength = formattedValue.length;
                                    acc = function () {
                                        return dom_1.getTextWidth(formattedValue, computedFontStyle) +
                                            tree_2.getTreeIndentWidth(tree_1.getDepth(rawData, row), useIcon) +
                                            constant_1.TREE_CELL_HORIZONTAL_PADDING;
                                    };
                                }
                                return acc;
                            }, function () { return 0; });
                            return getMaxWidth();
                        }
                        function collapse(store, row, recursive) {
                            var rowKey = row.rowKey;
                            var eventBus = eventBus_1.getEventBus(store.id);
                            var gridEvent = new gridEvent_1.default({ rowKey: rowKey });
                            /**
                             * Occurs when the row having child rows is collapsed
                             * @event Grid#collapse
                             * @type {module:event/gridEvent}
                             * @property {number|string} rowKey - rowKey of the collapsed row
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('collapse', gridEvent);
                            if (gridEvent.isStopped()) {
                                return;
                            }
                            var data = store.data, rowCoords = store.rowCoords, column = store.column, id = store.id;
                            var heights = rowCoords.heights;
                            changeExpandedAttr(row, false);
                            var childRowKeys = tree_1.getChildRowKeys(row);
                            childRowKeys.forEach(function (childRowKey) {
                                var childRow = data_2.findRowByRowKey(data, column, id, childRowKey);
                                if (!childRow) {
                                    return;
                                }
                                changeHiddenAttr(childRow, true);
                                if (!tree_1.isLeaf(childRow)) {
                                    if (recursive) {
                                        collapse(store, childRow, recursive);
                                    }
                                    else {
                                        tree_1.getDescendantRows(store, childRowKey).forEach(function (_a) {
                                            var descendantRowKey = _a.rowKey;
                                            var index = data_2.findIndexByRowKey(data, column, id, descendantRowKey);
                                            heights[index] = 0;
                                        });
                                    }
                                }
                                var index = data_2.findIndexByRowKey(data, column, id, childRowKey);
                                heights[index] = 0;
                            });
                            observable_1.notify(rowCoords, 'heights');
                        }
                        function setCheckedState(row, state) {
                            if (row && data_3.isUpdatableRowAttr('checked', row._attributes.checkDisabled)) {
                                row._attributes.checked = state;
                            }
                        }
                        function changeAncestorRowsCheckedState(store, rowKey) {
                            var data = store.data, column = store.column, id = store.id;
                            var rawData = data.rawData;
                            var row = data_2.findRowByRowKey(data, column, id, rowKey);
                            if (row) {
                                tree_1.traverseAncestorRows(rawData, row, function (parentRow) {
                                    var childRowKeys = tree_1.getChildRowKeys(parentRow);
                                    var checkedChildRows = childRowKeys.filter(function (childRowKey) {
                                        var childRow = data_2.findRowByRowKey(data, column, id, childRowKey);
                                        return !!childRow && childRow._attributes.checked;
                                    });
                                    var checked = childRowKeys.length === checkedChildRows.length;
                                    setCheckedState(parentRow, checked);
                                });
                            }
                        }
                        function changeDescendantRowsCheckedState(store, rowKey, state) {
                            var data = store.data, column = store.column, id = store.id;
                            var rawData = data.rawData;
                            var row = data_2.findRowByRowKey(data, column, id, rowKey);
                            if (row) {
                                tree_1.traverseDescendantRows(rawData, row, function (childRow) {
                                    setCheckedState(childRow, state);
                                });
                            }
                        }
                        function removeChildRowKey(row, rowKey) {
                            var tree = row._attributes.tree;
                            if (tree) {
                                common_1.removeArrayItem(rowKey, tree.childRowKeys);
                                observable_1.notify(tree, 'childRowKeys');
                            }
                        }
                        function removeExpandedAttr(row) {
                            var tree = row._attributes.tree;
                            if (tree) {
                                delete tree.expanded;
                                observable_1.notify(tree, 'expanded');
                            }
                        }
                        exports.removeExpandedAttr = removeExpandedAttr;
                        function expandByRowKey(store, rowKey, recursive) {
                            var data = store.data, column = store.column, id = store.id;
                            var row = data_2.findRowByRowKey(data, column, id, rowKey);
                            if (row) {
                                expand(store, row, recursive);
                            }
                        }
                        exports.expandByRowKey = expandByRowKey;
                        function expandAll(store) {
                            store.data.rawData.forEach(function (row) {
                                if (tree_1.isRootChildRow(row) && !tree_1.isLeaf(row)) {
                                    expand(store, row, true);
                                }
                            });
                        }
                        exports.expandAll = expandAll;
                        function collapseByRowKey(store, rowKey, recursive) {
                            var data = store.data, column = store.column, id = store.id;
                            var row = data_2.findRowByRowKey(data, column, id, rowKey);
                            if (row) {
                                collapse(store, row, recursive);
                            }
                        }
                        exports.collapseByRowKey = collapseByRowKey;
                        function collapseAll(store) {
                            store.data.rawData.forEach(function (row) {
                                if (tree_1.isRootChildRow(row) && !tree_1.isLeaf(row)) {
                                    collapse(store, row, true);
                                }
                            });
                        }
                        exports.collapseAll = collapseAll;
                        function changeTreeRowsCheckedState(store, rowKey, state) {
                            var _a = store.column, treeColumnName = _a.treeColumnName, treeCascadingCheckbox = _a.treeCascadingCheckbox;
                            if (treeColumnName && treeCascadingCheckbox) {
                                changeDescendantRowsCheckedState(store, rowKey, state);
                                changeAncestorRowsCheckedState(store, rowKey);
                            }
                        }
                        exports.changeTreeRowsCheckedState = changeTreeRowsCheckedState;
                        // @TODO: consider tree disabled state with cascading
                        function appendTreeRow(store, row, options) {
                            var data = store.data, column = store.column, rowCoords = store.rowCoords, dimension = store.dimension, id = store.id;
                            var rawData = data.rawData, viewData = data.viewData;
                            var heights = rowCoords.heights;
                            var parentRowKey = options.parentRowKey, offset = options.offset;
                            var parentRow = data_2.findRowByRowKey(data, column, id, parentRowKey);
                            var startIdx = tree_1.getStartIndexToAppendRow(store, parentRow, offset);
                            var rawRows = tree_2.flattenTreeData(id, [row], parentRow, column, {
                                keyColumnName: column.keyColumnName,
                                offset: offset,
                            });
                            lazyObservable_1.fillMissingColumnData(column, rawRows);
                            observable_1.batchObserver(function () {
                                rawData.splice.apply(rawData, tslib_1.__spreadArrays([startIdx, 0], rawRows));
                            });
                            var viewRows = rawRows.map(function (rawRow) { return data_1.createViewRow(id, rawRow, rawData, column); });
                            viewData.splice.apply(viewData, tslib_1.__spreadArrays([startIdx, 0], viewRows));
                            var rowHeights = rawRows.map(function (rawRow) {
                                changeTreeRowsCheckedState(store, rawRow.rowKey, rawRow._attributes.checked);
                                instance_1.getDataManager(id).push('CREATE', rawRow, true);
                                return data_2.getRowHeight(rawRow, dimension.rowHeight);
                            });
                            heights.splice.apply(heights, tslib_1.__spreadArrays([startIdx, 0], rowHeights));
                            postUpdateAfterManipulation(store, startIdx, rawRows);
                        }
                        exports.appendTreeRow = appendTreeRow;
                        // @TODO: consider tree disabled state with cascading
                        function removeTreeRow(store, rowKey) {
                            var data = store.data, rowCoords = store.rowCoords, id = store.id, column = store.column;
                            var rawData = data.rawData, viewData = data.viewData;
                            var heights = rowCoords.heights;
                            var parentRow = tree_1.getParentRow(store, rowKey);
                            data_3.uncheck(store, rowKey);
                            if (parentRow) {
                                removeChildRowKey(parentRow, rowKey);
                                if (!tree_1.getChildRowKeys(parentRow).length) {
                                    removeExpandedAttr(parentRow);
                                }
                            }
                            var startIdx = data_2.findIndexByRowKey(data, column, id, rowKey);
                            var deleteCount = tree_1.getDescendantRows(store, rowKey).length + 1;
                            var removedRows = [];
                            observable_1.batchObserver(function () {
                                removedRows = rawData.splice(startIdx, deleteCount);
                            });
                            viewData.splice(startIdx, deleteCount);
                            heights.splice(startIdx, deleteCount);
                            for (var i = removedRows.length - 1; i >= 0; i -= 1) {
                                instance_1.getDataManager(id).push('DELETE', removedRows[i]);
                            }
                            postUpdateAfterManipulation(store, startIdx, rawData);
                        }
                        exports.removeTreeRow = removeTreeRow;
                        function postUpdateAfterManipulation(store, rowIndex, rows) {
                            data_3.setLoadingState(store, data_2.getLoadingState(store.data.rawData));
                            data_3.updateRowNumber(store, rowIndex);
                            data_3.setCheckedAllRows(store);
                            column_2.setAutoResizingColumnWidths(store, rows);
                        }


                        /***/ }),
                    /* 30 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.setColumnWidthsByText = exports.setAutoResizingColumnWidths = exports.changeColumnHeadersByName = exports.setComplexColumnHeaders = exports.showColumn = exports.hideColumn = exports.resetColumnWidths = exports.setColumns = exports.setColumnWidth = exports.setFrozenColumnCount = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var column_1 = __webpack_require__(31);
                        var data_1 = __webpack_require__(13);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var eventBus_1 = __webpack_require__(8);
                        var focus_1 = __webpack_require__(18);
                        var observable_1 = __webpack_require__(5);
                        var sort_1 = __webpack_require__(27);
                        var filter_1 = __webpack_require__(33);
                        var selection_1 = __webpack_require__(15);
                        var common_1 = __webpack_require__(0);
                        var viewport_1 = __webpack_require__(22);
                        var dom_1 = __webpack_require__(2);
                        var data_2 = __webpack_require__(25);
                        var tree_1 = __webpack_require__(20);
                        var tree_2 = __webpack_require__(21);
                        var constant_1 = __webpack_require__(16);
                        function setFrozenColumnCount(_a, count) {
                            var column = _a.column;
                            column.frozenCount = count;
                        }
                        exports.setFrozenColumnCount = setFrozenColumnCount;
                        function getCellWidthToBeResized(columns, range, resizeAmount, startWidths) {
                            var widths = [];
                            var startIdx = range[0], endIdx = range[1];
                            var rangeLength = endIdx - startIdx + 1;
                            var delta = resizeAmount / rangeLength;
                            for (var idx = 0; idx < rangeLength; idx += 1) {
                                var columnIdx = startIdx + idx;
                                var minWidth = columns[columnIdx].minWidth;
                                var width = Math.max(startWidths[idx] + delta, minWidth);
                                widths.push(width);
                            }
                            return widths;
                        }
                        function setColumnWidth(_a, side, range, resizeAmount, startWidths) {
                            var column = _a.column, id = _a.id;
                            var eventBus = eventBus_1.getEventBus(id);
                            var columns = column.visibleColumnsBySideWithRowHeader[side];
                            var startIdx = range[0], endIdx = range[1];
                            var resizedColumns = [];
                            var widths = getCellWidthToBeResized(columns, range, resizeAmount, startWidths);
                            for (var idx = startIdx; idx <= endIdx; idx += 1) {
                                resizedColumns.push({
                                    columnName: columns[idx].name,
                                    width: widths[idx - startIdx],
                                });
                            }
                            var gridEvent = new gridEvent_1.default({ resizedColumns: resizedColumns });
                            /**
                             * Occurs when column is resized
                             * @event Grid#columnResize
                             * @property {Array} resizedColumns - state about resized columns
                             * @property {number} resizedColumns.columnName - columnName of the target cell
                             * @property {number} resizedColumns.width - width of the resized column
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('columnResize', gridEvent);
                            if (!gridEvent.isStopped()) {
                                widths.forEach(function (width, idx) {
                                    var columnIdx = startIdx + idx;
                                    var item = columns[columnIdx];
                                    item.baseWidth = width;
                                    item.fixedWidth = true;
                                });
                            }
                        }
                        exports.setColumnWidth = setColumnWidth;
                        function setColumns(store, optColumns) {
                            var column = store.column, data = store.data, id = store.id;
                            var _a = column.dataForColumnCreation, columnOptions = _a.columnOptions, copyOptions = _a.copyOptions, treeColumnOptions = _a.treeColumnOptions, rowHeaders = _a.rowHeaders;
                            var relationColumns = optColumns.reduce(function (acc, _a) {
                                var _b = _a.relations, relations = _b === void 0 ? [] : _b;
                                return acc.concat(column_1.createRelationColumns(relations)).filter(function (columnName, index) {
                                    var foundIndex = acc.indexOf(columnName);
                                    return foundIndex === -1 || foundIndex === index;
                                });
                            }, []);
                            var columnInfos = optColumns.map(function (optColumn) {
                                return column_1.createColumn(optColumn, columnOptions, relationColumns, copyOptions, treeColumnOptions, column.columnHeaderInfo, !!optColumn.disabled);
                            });
                            var dataCreationKey = data_1.generateDataCreationKey();
                            viewport_1.initScrollPosition(store);
                            focus_1.initFocus(store);
                            selection_1.initSelection(store);
                            column.allColumns = tslib_1.__spreadArrays(rowHeaders, columnInfos);
                            data.viewData.forEach(function (viewRow) {
                                if (Array.isArray(viewRow.__unobserveFns__)) {
                                    viewRow.__unobserveFns__.forEach(function (fn) { return fn(); });
                                }
                            });
                            data.rawData = data.rawData.map(function (row) {
                                var newRow = tslib_1.__assign(tslib_1.__assign({}, column.emptyRow), row);
                                newRow.uniqueKey = dataCreationKey + "-" + row.rowKey;
                                return newRow;
                            });
                            data.viewData = data.rawData.map(function (row) {
                                return observable_1.isObservable(row)
                                    ? data_1.createViewRow(id, row, data.rawData, column)
                                    : { rowKey: row.rowKey, sortKey: row.sortKey, uniqueKey: row.uniqueKey };
                            });
                            filter_1.initFilter(store);
                            sort_1.unsort(store);
                            setColumnWidthsByText(store);
                        }
                        exports.setColumns = setColumns;
                        function resetColumnWidths(_a, widths) {
                            var column = _a.column;
                            column.visibleColumns.forEach(function (columnInfo, idx) {
                                columnInfo.baseWidth = widths[idx];
                                columnInfo.autoResizing = false;
                            });
                        }
                        exports.resetColumnWidths = resetColumnWidths;
                        function setColumnsHiddenValue(column, columnName, hidden) {
                            var allColumnMap = column.allColumnMap, complexColumnHeaders = column.complexColumnHeaders;
                            if (complexColumnHeaders.length) {
                                var complexColumn = common_1.findProp('name', columnName, complexColumnHeaders);
                                if (complexColumn) {
                                    complexColumn.childNames.forEach(function (childName) {
                                        allColumnMap[childName].hidden = hidden;
                                    });
                                    return;
                                }
                            }
                            allColumnMap[columnName].hidden = hidden;
                        }
                        function hideColumn(store, columnName) {
                            var column = store.column, focus = store.focus;
                            if (focus.columnName === columnName) {
                                focus_1.initFocus(store);
                            }
                            selection_1.initSelection(store);
                            filter_1.unfilter(store, columnName);
                            sort_1.unsort(store, columnName);
                            setColumnsHiddenValue(column, columnName, true);
                        }
                        exports.hideColumn = hideColumn;
                        function showColumn(_a, columnName) {
                            var column = _a.column;
                            setColumnsHiddenValue(column, columnName, false);
                        }
                        exports.showColumn = showColumn;
                        function setComplexColumnHeaders(store, complexColumnHeaders) {
                            store.column.complexColumnHeaders = complexColumnHeaders;
                        }
                        exports.setComplexColumnHeaders = setComplexColumnHeaders;
                        function changeColumnHeadersByName(_a, columnsMap) {
                            var column = _a.column;
                            var complexColumnHeaders = column.complexColumnHeaders, allColumnMap = column.allColumnMap;
                            Object.keys(columnsMap).forEach(function (columnName) {
                                var col = allColumnMap[columnName];
                                if (col) {
                                    col.header = columnsMap[columnName];
                                }
                                if (complexColumnHeaders.length) {
                                    var complexCol = common_1.findProp('name', columnName, complexColumnHeaders);
                                    if (complexCol) {
                                        complexCol.header = columnsMap[columnName];
                                    }
                                }
                            });
                            observable_1.notify(column, 'allColumns');
                        }
                        exports.changeColumnHeadersByName = changeColumnHeadersByName;
                        function setAutoResizingColumnWidths(store, targetData) {
                            var autoResizingColumn = store.column.autoResizingColumn;
                            var rawData = targetData || store.data.rawData;
                            if (!rawData.length || !autoResizingColumn.length) {
                                return;
                            }
                            data_2.initMaxTextMap();
                            var maxTextMap = data_2.getMaxTextMap();
                            rawData.forEach(function (row) {
                                autoResizingColumn.forEach(function (columnInfo) {
                                    var name = columnInfo.name;
                                    var formattedValue = data_2.createFormattedValue(row, columnInfo);
                                    if (!maxTextMap[name] || maxTextMap[name].formattedValue.length < formattedValue.length) {
                                        data_2.setMaxColumnTextMap(name, formattedValue, row);
                                    }
                                });
                            });
                            setColumnWidthsByText(store);
                        }
                        exports.setAutoResizingColumnWidths = setAutoResizingColumnWidths;
                        function setColumnWidthsByText(store) {
                            var autoResizingColumn = store.column.autoResizingColumn;
                            if (store.data.rawData.length && autoResizingColumn.length) {
                                autoResizingColumn.forEach(function (_a) {
                                    var name = _a.name;
                                    setColumnWidthByText(store, name);
                                });
                            }
                        }
                        exports.setColumnWidthsByText = setColumnWidthsByText;
                        function setColumnWidthByText(_a, columnName) {
                            var data = _a.data, column = _a.column;
                            var allColumnMap = column.allColumnMap, treeColumnName = column.treeColumnName, treeIcon = column.treeIcon;
                            var maxTextMap = data_2.getMaxTextMap();
                            var _b = maxTextMap[columnName], formattedValue = _b.formattedValue, row = _b.row;
                            var width = dom_1.getTextWidth(formattedValue, dom_1.getComputedFontStyle(treeColumnName ? 'tree-wrapper-relative' : 'cell'));
                            if (treeColumnName) {
                                width +=
                                    tree_1.getTreeIndentWidth(tree_2.getDepth(data.rawData, row), treeIcon) + constant_1.TREE_CELL_HORIZONTAL_PADDING;
                            }
                            allColumnMap[columnName].baseWidth = Math.max(allColumnMap[columnName].minWidth, width);
                            allColumnMap[columnName].fixedWidth = true;
                        }


                        /***/ }),
                    /* 31 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = exports.createColumn = exports.createRelationColumns = exports.createColumnFilterOption = exports.validateRelationColumn = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var observable_1 = __webpack_require__(5);
                        var column_1 = __webpack_require__(10);
                        var common_1 = __webpack_require__(0);
                        var default_1 = __webpack_require__(60);
                        var manager_1 = __webpack_require__(61);
                        var rowHeaderInput_1 = __webpack_require__(68);
                        var DEF_ROW_HEADER_INPUT = '<input type="checkbox" name="_checked" />';
                        var ROW_HEADER = 40;
                        var COLUMN = 50;
                        var rowHeadersMap = {
                            rowNum: '_number',
                            checkbox: '_checked',
                        };
                        function validateRelationColumn(columnInfos) {
                            var checked = {};
                            function checkCircularRelation(column, relations) {
                                var name = column.name, relationMap = column.relationMap;
                                relations.push(name);
                                checked[name] = true;
                                if (common_1.uniq(relations).length !== relations.length) {
                                    throw new Error('Cannot create circular reference between relation columns');
                                }
                                if (!common_1.isUndefined(relationMap)) {
                                    Object.keys(relationMap).forEach(function (targetName) {
                                        var targetColumn = common_1.findProp('name', targetName, columnInfos);
                                        // copy the 'relation' array to prevent to push all relation column into same array
                                        checkCircularRelation(targetColumn, tslib_1.__spreadArrays(relations));
                                    });
                                }
                            }
                            columnInfos.forEach(function (column) {
                                if (!checked[column.name]) {
                                    checkCircularRelation(column, []);
                                }
                            });
                        }
                        exports.validateRelationColumn = validateRelationColumn;
                        function createBuiltInEditorOptions(editorType, options) {
                            var editInfo = manager_1.editorMap[editorType];
                            return {
                                type: editInfo[0],
                                options: tslib_1.__assign(tslib_1.__assign({}, editInfo[1]), options),
                            };
                        }
                        function createEditorOptions(editor) {
                            if (common_1.isFunction(editor)) {
                                return { type: editor };
                            }
                            if (common_1.isString(editor)) {
                                return createBuiltInEditorOptions(editor);
                            }
                            if (common_1.isObject(editor)) {
                                return common_1.isString(editor.type)
                                    ? createBuiltInEditorOptions(editor.type, editor.options)
                                    : editor;
                            }
                            return null;
                        }
                        function createRendererOptions(renderer) {
                            if (common_1.isFunction(renderer)) {
                                return { type: renderer };
                            }
                            if (common_1.isObject(renderer) && !common_1.isFunction(renderer) && common_1.isFunction(renderer.type)) {
                                return renderer;
                            }
                            return { type: default_1.DefaultRenderer };
                        }
                        function createTreeInfo(treeColumnOptions, name) {
                            if (treeColumnOptions && treeColumnOptions.name === name) {
                                var _a = treeColumnOptions.useIcon, useIcon = _a === void 0 ? true : _a;
                                return { tree: { useIcon: useIcon } };
                            }
                            return null;
                        }
                        function createRelationMap(relations) {
                            var relationMap = {};
                            relations.forEach(function (relation) {
                                var editable = relation.editable, disabled = relation.disabled, listItems = relation.listItems, _a = relation.targetNames, targetNames = _a === void 0 ? [] : _a;
                                targetNames.forEach(function (targetName) {
                                    relationMap[targetName] = {
                                        editable: editable,
                                        disabled: disabled,
                                        listItems: listItems,
                                    };
                                });
                            });
                            return relationMap;
                        }
                        function createColumnHeaderInfo(name, columnHeaderInfo) {
                            var columnHeaders = columnHeaderInfo.columnHeaders, defaultAlign = columnHeaderInfo.align, defaultVAlign = columnHeaderInfo.valign;
                            var columnOption = common_1.findProp('name', name, columnHeaders);
                            var headerAlign = columnOption && columnOption.align ? columnOption.align : defaultAlign;
                            var headerVAlign = columnOption && columnOption.valign ? columnOption.valign : defaultVAlign;
                            var headerRenderer = columnOption && columnOption.renderer ? columnOption.renderer : null;
                            return {
                                headerAlign: headerAlign,
                                headerVAlign: headerVAlign,
                                headerRenderer: headerRenderer,
                            };
                        }
                        function createColumnFilterOption(filter) {
                            var defaultOption = {
                                type: common_1.isObject(filter) ? filter.type : filter,
                                showApplyBtn: false,
                                showClearBtn: false,
                            };
                            if (common_1.isString(filter)) {
                                if (filter === 'select') {
                                    return tslib_1.__assign(tslib_1.__assign({}, defaultOption), { operator: 'OR' });
                                }
                            }
                            if (common_1.isObject(filter)) {
                                return tslib_1.__assign(tslib_1.__assign({}, defaultOption), (filter.type === 'select'
                                    ? common_1.omit(filter, 'showApplyBtn', 'showClearBtn', 'operator', 'options')
                                    : filter));
                            }
                            return defaultOption;
                        }
                        exports.createColumnFilterOption = createColumnFilterOption;
                        function createRelationColumns(relations) {
                            var relationColumns = [];
                            relations.forEach(function (relation) {
                                var _a = relation.targetNames, targetNames = _a === void 0 ? [] : _a;
                                targetNames.forEach(function (targetName) {
                                    relationColumns.push(targetName);
                                });
                            });
                            return relationColumns;
                        }
                        exports.createRelationColumns = createRelationColumns;
                        // eslint-disable-next-line max-params
                        function createColumn(column, columnOptions, relationColumns, gridCopyOptions, treeColumnOptions, columnHeaderInfo, disabled) {
                            var name = column.name, header = column.header, width = column.width, minWidth = column.minWidth, align = column.align, hidden = column.hidden, resizable = column.resizable, editor = column.editor, renderer = column.renderer, relations = column.relations, sortable = column.sortable, sortingType = column.sortingType, copyOptions = column.copyOptions, validation = column.validation, formatter = column.formatter, onBeforeChange = column.onBeforeChange, onAfterChange = column.onAfterChange, whiteSpace = column.whiteSpace, ellipsis = column.ellipsis, valign = column.valign, defaultValue = column.defaultValue, escapeHTML = column.escapeHTML, ignored = column.ignored, filter = column.filter, className = column.className, comparator = column.comparator;
                            var editorOptions = createEditorOptions(editor);
                            var rendererOptions = createRendererOptions(renderer);
                            var filterOptions = filter ? createColumnFilterOption(filter) : null;
                            var _a = createColumnHeaderInfo(name, columnHeaderInfo), headerAlign = _a.headerAlign, headerVAlign = _a.headerVAlign, headerRenderer = _a.headerRenderer;
                            return observable_1.observable(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ name: name,
                                escapeHTML: escapeHTML, header: header || name, hidden: Boolean(hidden), resizable: common_1.isUndefined(resizable) ? Boolean(columnOptions.resizable) : Boolean(resizable), align: align || 'left', fixedWidth: typeof width === 'number', copyOptions: tslib_1.__assign(tslib_1.__assign({}, gridCopyOptions), copyOptions), baseWidth: (width === 'auto' ? 0 : width) || 0, minWidth: minWidth || columnOptions.minWidth || COLUMN, relationMap: createRelationMap(relations || []), related: common_1.includes(relationColumns, name), sortable: sortable, sortingType: sortingType || 'asc', validation: validation ? tslib_1.__assign({}, validation) : {}, renderer: rendererOptions, formatter: formatter,
                                onBeforeChange: onBeforeChange,
                                onAfterChange: onAfterChange,
                                whiteSpace: whiteSpace,
                                ellipsis: ellipsis, valign: valign || 'middle', defaultValue: defaultValue,
                                ignored: ignored }, (!!editorOptions && { editor: editorOptions })), createTreeInfo(treeColumnOptions, name)), { headerAlign: headerAlign,
                                headerVAlign: headerVAlign, filter: filterOptions, headerRenderer: headerRenderer,
                                className: className,
                                disabled: disabled,
                                comparator: comparator, autoResizing: width === 'auto' }));
                        }
                        exports.createColumn = createColumn;
                        function createRowHeader(data, columnHeaderInfo) {
                            var rowHeader = common_1.isString(data)
                                ? { name: rowHeadersMap[data] }
                                : tslib_1.__assign({ name: rowHeadersMap[data.type] }, common_1.omit(data, 'type'));
                            var name = rowHeader.name, header = rowHeader.header, align = rowHeader.align, valign = rowHeader.valign, renderer = rowHeader.renderer, width = rowHeader.width, minWidth = rowHeader.minWidth;
                            var baseMinWith = common_1.isNumber(minWidth) ? minWidth : ROW_HEADER;
                            var baseWidth = (width === 'auto' ? baseMinWith : width) || baseMinWith;
                            var rowNumColumn = column_1.isRowNumColumn(name);
                            var defaultHeader = rowNumColumn ? 'No. ' : DEF_ROW_HEADER_INPUT;
                            var rendererOptions = renderer || {
                                type: rowNumColumn ? default_1.DefaultRenderer : rowHeaderInput_1.RowHeaderInputRenderer,
                            };
                            var _a = createColumnHeaderInfo(name, columnHeaderInfo), headerAlign = _a.headerAlign, headerVAlign = _a.headerVAlign, headerRenderer = _a.headerRenderer;
                            return observable_1.observable({
                                name: name,
                                header: header || defaultHeader,
                                hidden: false,
                                resizable: false,
                                align: align || 'center',
                                valign: valign || 'middle',
                                renderer: createRendererOptions(rendererOptions),
                                fixedWidth: true,
                                baseWidth: baseWidth,
                                escapeHTML: false,
                                minWidth: baseMinWith,
                                headerAlign: headerAlign,
                                headerVAlign: headerVAlign,
                                headerRenderer: headerRenderer,
                                autoResizing: false,
                            });
                        }
                        function createComplexColumnHeaders(column, columnHeaderInfo) {
                            var header = column.header, name = column.name, childNames = column.childNames, renderer = column.renderer, hideChildHeaders = column.hideChildHeaders, _a = column.resizable, resizable = _a === void 0 ? false : _a;
                            var headerAlign = column.headerAlign || columnHeaderInfo.align;
                            var headerVAlign = column.headerVAlign || columnHeaderInfo.valign;
                            return observable_1.observable({
                                header: header,
                                name: name,
                                childNames: childNames,
                                headerAlign: headerAlign,
                                headerVAlign: headerVAlign,
                                headerRenderer: renderer || null,
                                hideChildHeaders: hideChildHeaders,
                                resizable: resizable,
                            });
                        }
                        function create(_a) {
                            var columns = _a.columns, columnOptions = _a.columnOptions, rowHeaders = _a.rowHeaders, copyOptions = _a.copyOptions, keyColumnName = _a.keyColumnName, treeColumnOptions = _a.treeColumnOptions, complexColumns = _a.complexColumns, align = _a.align, valign = _a.valign, columnHeaders = _a.columnHeaders, disabled = _a.disabled;
                            var relationColumns = columns.reduce(function (acc, _a) {
                                var relations = _a.relations;
                                acc = acc.concat(createRelationColumns(relations || []));
                                return acc.filter(function (columnName, idx) { return acc.indexOf(columnName) === idx; });
                            }, []);
                            var columnHeaderInfo = { columnHeaders: columnHeaders, align: align, valign: valign };
                            var rowHeaderInfos = rowHeaders.map(function (rowHeader) {
                                return createRowHeader(rowHeader, columnHeaderInfo);
                            });
                            var columnInfos = columns.map(function (column) {
                                return createColumn(column, columnOptions, relationColumns, copyOptions, treeColumnOptions, columnHeaderInfo, !!(disabled || column.disabled));
                            });
                            validateRelationColumn(columnInfos);
                            var allColumns = rowHeaderInfos.concat(columnInfos);
                            var treeColumnName = treeColumnOptions.name, _b = treeColumnOptions.useIcon, treeIcon = _b === void 0 ? true : _b, _c = treeColumnOptions.useCascadingCheckbox, treeCascadingCheckbox = _c === void 0 ? true : _c;
                            var complexColumnHeaders = complexColumns.map(function (column) {
                                return createComplexColumnHeaders(column, columnHeaderInfo);
                            });
                            return observable_1.observable(tslib_1.__assign({ keyColumnName: keyColumnName,
                                allColumns: allColumns,
                                complexColumnHeaders: complexColumnHeaders,
                                columnHeaderInfo: columnHeaderInfo, frozenCount: columnOptions.frozenCount || 0, dataForColumnCreation: {
                                    copyOptions: copyOptions,
                                    columnOptions: columnOptions,
                                    treeColumnOptions: treeColumnOptions,
                                    relationColumns: relationColumns,
                                    rowHeaders: rowHeaderInfos,
                                }, get allColumnMap() {
                                    return common_1.createMapFromArray(this.allColumns, 'name');
                                }, get rowHeaderCount() {
                                    return rowHeaderInfos.length;
                                }, get visibleColumns() {
                                    return this.allColumns.slice(this.rowHeaderCount).filter(function (_a) {
                                        var hidden = _a.hidden;
                                        return !hidden;
                                    });
                                },
                                get visibleColumnsWithRowHeader() {
                                    return this.allColumns.filter(function (_a) {
                                        var hidden = _a.hidden;
                                        return !hidden;
                                    });
                                }, get visibleColumnsBySide() {
                                    return {
                                        L: this.visibleColumns.slice(0, this.frozenCount),
                                        R: this.visibleColumns.slice(this.frozenCount),
                                    };
                                }, get visibleColumnsBySideWithRowHeader() {
                                    var frozenLastIndex = this.rowHeaderCount + this.frozenCount;
                                    return {
                                        L: this.visibleColumnsWithRowHeader.slice(0, frozenLastIndex),
                                        R: this.visibleColumnsWithRowHeader.slice(frozenLastIndex),
                                    };
                                },
                                get defaultValues() {
                                    return this.allColumns
                                        .filter(function (_a) {
                                            var defaultValue = _a.defaultValue;
                                            return Boolean(defaultValue);
                                        })
                                        .map(function (_a) {
                                            var name = _a.name, defaultValue = _a.defaultValue;
                                            return ({ name: name, value: defaultValue });
                                        });
                                }, get visibleFrozenCount() {
                                    return this.visibleColumnsBySideWithRowHeader.L.length;
                                }, get validationColumns() {
                                    return this.allColumns.filter(function (_a) {
                                        var validation = _a.validation;
                                        return !common_1.isEmpty(validation);
                                    });
                                },
                                get ignoredColumns() {
                                    return this.allColumns.filter(function (_a) {
                                        var ignored = _a.ignored;
                                        return ignored;
                                    }).map(function (_a) {
                                        var name = _a.name;
                                        return name;
                                    });
                                },
                                get columnMapWithRelation() {
                                    // copy the array to prevent to affect allColumns property
                                    var copiedColumns = tslib_1.__spreadArrays(this.allColumns);
                                    copiedColumns.sort(function (columnA, columnB) {
                                        var _a, _b;
                                        var hasRelationMapA = !common_1.isEmpty(columnA.relationMap);
                                        var hasRelationMapB = !common_1.isEmpty(columnB.relationMap);
                                        if (hasRelationMapA && hasRelationMapB) {
                                            if ((_a = columnA.relationMap) === null || _a === void 0 ? void 0 : _a[columnB.name]) {
                                                return -1;
                                            }
                                            return ((_b = columnB.relationMap) === null || _b === void 0 ? void 0 : _b[columnA.name]) ? 1 : 0;
                                        }
                                        if (hasRelationMapA) {
                                            return -1;
                                        }
                                        return hasRelationMapB ? 1 : 0;
                                    });
                                    return common_1.createMapFromArray(copiedColumns, 'name');
                                }, get columnsWithoutRowHeader() {
                                    return this.allColumns.slice(this.rowHeaderCount);
                                }, get emptyRow() {
                                    return this.columnsWithoutRowHeader.reduce(function (acc, _a) {
                                        var _b;
                                        var name = _a.name;
                                        return (tslib_1.__assign(tslib_1.__assign({}, acc), (_b = {}, _b[name] = null, _b)));
                                    }, {});
                                },
                                get autoResizingColumn() {
                                    return this.columnsWithoutRowHeader.filter(function (_a) {
                                        var autoResizing = _a.autoResizing;
                                        return autoResizing;
                                    });
                                } }, (treeColumnName && { treeColumnName: treeColumnName, treeIcon: treeIcon, treeCascadingCheckbox: treeCascadingCheckbox })));
                        }
                        exports.create = create;


                        /***/ }),
                    /* 32 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.setLayerPosition = exports.getContainerElement = exports.setOpacity = void 0;
                        var dom_1 = __webpack_require__(2);
                        var INDENT = 5;
                        var SCROLL_BAR_WIDTH = 17;
                        var SCROLL_BAR_HEIGHT = 17;
                        function setOpacity(el, opacity) {
                            el.style.opacity = String(opacity);
                        }
                        exports.setOpacity = setOpacity;
                        function getContainerElement(el) {
                            return dom_1.findParent(el, 'container');
                        }
                        exports.getContainerElement = getContainerElement;
                        function setLayerPosition(innerEl, layerEl, childEl, startBottom) {
                            if (startBottom === void 0) { startBottom = false; }
                            var containerRect = getContainerElement(innerEl).getBoundingClientRect();
                            var innerHeight = window.innerHeight, innerWidth = window.innerWidth;
                            var _a = innerEl.getBoundingClientRect(), left = _a.left, top = _a.top, bottom = _a.bottom;
                            var _b = layerEl.getBoundingClientRect(), layerHeight = _b.height, layerWidth = _b.width;
                            var layerTop = startBottom ? bottom : top + INDENT;
                            var childElHeight = 0;
                            var childElWidth = 0;
                            if (childEl) {
                                var _c = childEl.getBoundingClientRect(), height = _c.height, width = _c.width;
                                childElHeight = height;
                                childElWidth = width;
                            }
                            var totalHeight = layerHeight + childElHeight;
                            var totalWidth = layerWidth || childElWidth;
                            layerEl.style.top = (layerTop + totalHeight > innerHeight - SCROLL_BAR_WIDTH
                                ? innerHeight - totalHeight - INDENT - SCROLL_BAR_WIDTH
                                : layerTop) - containerRect.top + "px";
                            layerEl.style.left = (left + totalWidth > innerWidth - SCROLL_BAR_HEIGHT
                                ? innerWidth - totalWidth - INDENT - SCROLL_BAR_HEIGHT
                                : left) - containerRect.left + "px";
                        }
                        exports.setLayerPosition = setLayerPosition;


                        /***/ }),
                    /* 33 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.resetFilterState = exports.emitAfterFilter = exports.initFilter = exports.setFilter = exports.unfilter = exports.clearFilter = exports.updateFilters = exports.filter = exports.setActiveFilterState = exports.clearActiveFilterState = exports.applyActiveFilterState = exports.setActiveColumnAddress = exports.setActiveSelectFilterState = exports.toggleSelectAllCheckbox = exports.setActiveFilterOperator = void 0;
                        var observable_1 = __webpack_require__(5);
                        var common_1 = __webpack_require__(0);
                        var filter_1 = __webpack_require__(28);
                        var data_1 = __webpack_require__(6);
                        var column_1 = __webpack_require__(31);
                        var viewport_1 = __webpack_require__(22);
                        var selection_1 = __webpack_require__(15);
                        var focus_1 = __webpack_require__(18);
                        var eventBus_1 = __webpack_require__(8);
                        var column_2 = __webpack_require__(12);
                        var data_2 = __webpack_require__(14);
                        var summary_1 = __webpack_require__(23);
                        var filter_2 = __webpack_require__(44);
                        var pagination_1 = __webpack_require__(34);
                        function initLayerAndScrollAfterFiltering(store) {
                            var data = store.data;
                            viewport_1.initScrollPosition(store);
                            selection_1.initSelection(store);
                            focus_1.initFocus(store);
                            pagination_1.updatePageOptions(store, { totalCount: data.filteredRawData.length, page: 1 });
                            data_2.updateHeights(store);
                            data_2.setCheckedAllRows(store);
                        }
                        function setActiveFilterOperator(store, operator) {
                            var column = store.column, filterLayerState = store.filterLayerState;
                            var activeFilterState = filterLayerState.activeFilterState;
                            var columnInfo = column.allColumnMap[activeFilterState.columnName];
                            var columnFilterOption = columnInfo.filter;
                            activeFilterState.operator = operator;
                            if (!columnFilterOption.showApplyBtn) {
                                columnFilterOption.operator = operator;
                                applyActiveFilterState(store);
                            }
                        }
                        exports.setActiveFilterOperator = setActiveFilterOperator;
                        function toggleSelectAllCheckbox(store, checked) {
                            var column = store.column, filterLayerState = store.filterLayerState, data = store.data;
                            var activeFilterState = filterLayerState.activeFilterState;
                            var columnName = activeFilterState.columnName;
                            var columnInfo = column.allColumnMap[columnName];
                            if (checked) {
                                var columnData = data_1.getUniqColumnData(data.rawData, column, columnName);
                                activeFilterState.state = columnData.map(function (value) { return ({ code: 'eq', value: value }); });
                            }
                            else {
                                activeFilterState.state = [];
                            }
                            if (!columnInfo.filter.showApplyBtn) {
                                applyActiveFilterState(store);
                            }
                        }
                        exports.toggleSelectAllCheckbox = toggleSelectAllCheckbox;
                        function setActiveSelectFilterState(store, value, checked) {
                            var column = store.column, filterLayerState = store.filterLayerState;
                            var activeFilterState = filterLayerState.activeFilterState;
                            var columnName = filterLayerState.activeColumnAddress.name;
                            var columnInfo = column.allColumnMap[columnName];
                            if (checked) {
                                activeFilterState.state.push({ value: value, code: 'eq' });
                            }
                            else {
                                var index = common_1.findPropIndex('value', value, activeFilterState.state);
                                activeFilterState.state.splice(index, 1);
                            }
                            if (!columnInfo.filter.showApplyBtn) {
                                applyActiveFilterState(store);
                            }
                            else {
                                observable_1.notify(filterLayerState, 'activeFilterState');
                            }
                        }
                        exports.setActiveSelectFilterState = setActiveSelectFilterState;
                        function setActiveColumnAddress(store, address) {
                            var data = store.data, column = store.column, filterLayerState = store.filterLayerState;
                            var filters = data.filters, filteredRawData = data.filteredRawData;
                            filterLayerState.activeColumnAddress = address;
                            if (!address) {
                                filterLayerState.activeFilterState = null;
                                return;
                            }
                            var columnName = address.name;
                            var _a = column.allColumnMap[columnName].filter, type = _a.type, operator = _a.operator;
                            var initialState = [];
                            if (filters) {
                                var prevFilter = common_1.findProp('columnName', columnName, filters);
                                if (prevFilter) {
                                    initialState = prevFilter.state;
                                }
                            }
                            if (type === 'select' && !initialState.length) {
                                var columnData = data_1.getUniqColumnData(filteredRawData, column, columnName);
                                initialState = columnData.map(function (value) { return ({ code: 'eq', value: value }); });
                            }
                            filterLayerState.activeFilterState = {
                                columnName: columnName,
                                type: type,
                                operator: operator,
                                state: initialState,
                            };
                        }
                        exports.setActiveColumnAddress = setActiveColumnAddress;
                        function applyActiveFilterState(store) {
                            var filterLayerState = store.filterLayerState, data = store.data, column = store.column;
                            var columnName = filterLayerState.activeColumnAddress.name;
                            var _a = filterLayerState.activeFilterState, state = _a.state, type = _a.type, operator = _a.operator;
                            var validState = state.filter(function (item) { return String(item.value).length; });
                            if (type !== 'select' && !validState.length) {
                                unfilter(store, columnName);
                                return;
                            }
                            filterLayerState.activeFilterState.state = validState;
                            if (type === 'select') {
                                var columnData = data_1.getUniqColumnData(data.rawData, column, columnName);
                                if (columnData.length === state.length) {
                                    unfilter(store, columnName);
                                    return;
                                }
                            }
                            var fns = validState.map(function (_a) {
                                var code = _a.code, value = _a.value;
                                return filter_1.getFilterConditionFn(code, value, type);
                            });
                            filter(store, columnName, filter_1.composeConditionFn(fns, operator), state);
                        }
                        exports.applyActiveFilterState = applyActiveFilterState;
                        function clearActiveFilterState(store) {
                            var filterLayerState = store.filterLayerState;
                            var activeFilterState = filterLayerState.activeFilterState;
                            activeFilterState.state = [];
                            unfilter(store, activeFilterState.columnName);
                        }
                        exports.clearActiveFilterState = clearActiveFilterState;
                        function setActiveFilterState(store, state, filterIndex) {
                            var column = store.column, filterLayerState = store.filterLayerState;
                            var columnName = filterLayerState.activeColumnAddress.name;
                            var columnInfo = column.allColumnMap[columnName];
                            filterLayerState.activeFilterState.state[filterIndex] = state;
                            if (!columnInfo.filter.showApplyBtn) {
                                applyActiveFilterState(store);
                            }
                            else {
                                observable_1.notify(filterLayerState, 'activeFilterState');
                            }
                        }
                        exports.setActiveFilterState = setActiveFilterState;
                        function filter(store, columnName, conditionFn, state) {
                            var column = store.column;
                            var columnFilterInfo = column.allColumnMap[columnName].filter;
                            if (column_2.isComplexHeader(column, columnName) ||
                                !columnFilterInfo ||
                                column_2.isHiddenColumn(column, columnName)) {
                                return;
                            }
                            var type = columnFilterInfo.type, operator = columnFilterInfo.operator;
                            var nextColumnFilterState = { columnName: columnName, type: type, conditionFn: conditionFn, state: state, operator: operator };
                            var gridEvent = emitBeforeFilter(store, 'beforeFilter', nextColumnFilterState);
                            if (gridEvent.isStopped()) {
                                return;
                            }
                            pagination_1.updatePageOptions(store, { page: 1 });
                            updateFilters(store, columnName, nextColumnFilterState);
                            initLayerAndScrollAfterFiltering(store);
                            summary_1.updateAllSummaryValues(store);
                            emitAfterFilter(store, 'afterFilter', columnName);
                        }
                        exports.filter = filter;
                        function updateFilters(_a, columnName, nextColumnFilterState) {
                            var data = _a.data;
                            var filters = data.filters || [];
                            var filterIndex = common_1.findPropIndex('columnName', columnName, filters);
                            if (filterIndex >= 0) {
                                filters.splice(filterIndex, 1, nextColumnFilterState);
                            }
                            else {
                                data.filters = filters.concat(nextColumnFilterState);
                            }
                        }
                        exports.updateFilters = updateFilters;
                        function clearFilter(_a, columnName) {
                            var data = _a.data;
                            var filters = data.filters || [];
                            var filterIndex = common_1.findPropIndex('columnName', columnName, filters);
                            if (filterIndex >= 0) {
                                if (filters.length === 1) {
                                    data.filters = null;
                                }
                                else {
                                    filters.splice(filterIndex, 1);
                                }
                            }
                        }
                        exports.clearFilter = clearFilter;
                        function clearAll(store) {
                            var gridEvent = emitBeforeFilter(store, 'beforeUnfilter', { columnName: null });
                            if (gridEvent.isStopped()) {
                                return;
                            }
                            initFilter(store);
                            initLayerAndScrollAfterFiltering(store);
                            summary_1.updateAllSummaryValues(store);
                            emitAfterFilter(store, 'afterUnfilter', null);
                        }
                        function unfilter(store, columnName) {
                            var data = store.data, column = store.column;
                            var filters = data.filters;
                            if (!columnName) {
                                clearAll(store);
                                return;
                            }
                            if (column_2.isComplexHeader(column, columnName) || column_2.isHiddenColumn(column, columnName)) {
                                return;
                            }
                            if (filters) {
                                var gridEvent = emitBeforeFilter(store, 'beforeUnfilter', { columnName: columnName });
                                if (gridEvent.isStopped()) {
                                    return;
                                }
                                clearFilter(store, columnName);
                                initLayerAndScrollAfterFiltering(store);
                                summary_1.updateAllSummaryValues(store);
                                emitAfterFilter(store, 'afterUnfilter', columnName);
                            }
                        }
                        exports.unfilter = unfilter;
                        function setFilter(store, columnName, filterOpt) {
                            var column = store.column;
                            var filterOptions = column_1.createColumnFilterOption(filterOpt);
                            var index = common_1.findPropIndex('name', columnName, column.allColumns);
                            if (index !== -1) {
                                if (column.allColumns[index].filter) {
                                    unfilter(store, columnName);
                                }
                                column.allColumns[index].filter = filterOptions;
                                observable_1.notify(column, 'allColumns');
                            }
                        }
                        exports.setFilter = setFilter;
                        function initFilter(store) {
                            var filterLayerState = store.filterLayerState, data = store.data;
                            filterLayerState.activeFilterState = null;
                            filterLayerState.activeColumnAddress = null;
                            data.filters = null;
                        }
                        exports.initFilter = initFilter;
                        function emitBeforeFilter(store, eventType, eventParams) {
                            var eventBus = eventBus_1.getEventBus(store.id);
                            var gridEvent = filter_2.createFilterEvent(store, eventType, eventParams);
                            eventBus.trigger(eventType, gridEvent);
                            return gridEvent;
                        }
                        function emitAfterFilter(store, eventType, columnName) {
                            var id = store.id;
                            var eventBus = eventBus_1.getEventBus(id);
                            // @TODO: `filter` event will be deprecated. This event is replaced with `afterFilter` event
                            var eventTypes = (eventType === 'afterFilter'
                                ? ['afterFilter', 'filter']
                                : ['afterUnfilter']);
                            eventTypes.forEach(function (type) {
                                var gridEvent = filter_2.createFilterEvent(store, type, { columnName: columnName });
                                eventBus.trigger(type, gridEvent);
                            });
                        }
                        exports.emitAfterFilter = emitAfterFilter;
                        function resetFilterState(store, filterState) {
                            if (filterState) {
                                var columnFilterState = filterState.columnFilterState, columnName = filterState.columnName;
                                var columnFilterOption = store.column.allColumnMap[columnName].filter;
                                if (columnFilterOption) {
                                    if (columnFilterState) {
                                        var nextState = {
                                            conditionFn: function () { return true; },
                                            type: columnFilterOption.type,
                                            state: columnFilterState,
                                            columnName: columnName,
                                            operator: columnFilterOption.operator,
                                        };
                                        updateFilters(store, columnName, nextState);
                                    }
                                    else {
                                        clearFilter(store, columnName);
                                    }
                                }
                            }
                            else {
                                initFilter(store);
                            }
                        }
                        exports.resetFilterState = resetFilterState;


                        /***/ }),
                    /* 34 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.resetPageState = exports.updatePageWhenRemovingRow = exports.movePage = exports.updatePageOptions = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var data_1 = __webpack_require__(6);
                        var viewport_1 = __webpack_require__(22);
                        var selection_1 = __webpack_require__(15);
                        var focus_1 = __webpack_require__(18);
                        var data_2 = __webpack_require__(14);
                        var summary_1 = __webpack_require__(23);
                        var observable_1 = __webpack_require__(5);
                        function updatePageOptions(_a, pageOptions, forceUpdatePage) {
                            var data = _a.data;
                            if (forceUpdatePage === void 0) { forceUpdatePage = false; }
                            var orgPageOptions = data.pageOptions;
                            if (!common_1.isEmpty(orgPageOptions)) {
                                // if infinite scrolling is applied, page number should be not reset to know the last loaded page
                                if (!forceUpdatePage && data_1.isScrollPagination(data)) {
                                    delete pageOptions.page;
                                }
                                var newPageOptions = tslib_1.__assign(tslib_1.__assign({}, orgPageOptions), pageOptions);
                                if (!common_1.shallowEqual(newPageOptions, orgPageOptions)) {
                                    data.pageOptions = newPageOptions;
                                }
                            }
                        }
                        exports.updatePageOptions = updatePageOptions;
                        function movePage(store, page) {
                            var data = store.data;
                            viewport_1.initScrollPosition(store);
                            data.pageOptions.page = page;
                            observable_1.notify(data, 'pageOptions');
                            data_2.updateHeights(store);
                            selection_1.initSelection(store);
                            focus_1.initFocus(store);
                            data_2.setCheckedAllRows(store);
                            summary_1.updateAllSummaryValues(store);
                        }
                        exports.movePage = movePage;
                        function updatePageWhenRemovingRow(store, deletedCount) {
                            var pageOptions = store.data.pageOptions;
                            if (!common_1.isEmpty(pageOptions)) {
                                var perPage = pageOptions.perPage, totalCount = pageOptions.totalCount, page = pageOptions.page;
                                var modifiedLastPage = Math.floor((totalCount - deletedCount) / perPage);
                                if ((totalCount - deletedCount) % perPage) {
                                    modifiedLastPage += 1;
                                }
                                updatePageOptions(store, {
                                    totalCount: totalCount - deletedCount,
                                    page: (modifiedLastPage < page ? modifiedLastPage : page) || 1,
                                }, true);
                            }
                        }
                        exports.updatePageWhenRemovingRow = updatePageWhenRemovingRow;
                        function resetPageState(store, totalCount, pageState) {
                            var pageOptions = pageState ? common_1.pruneObject(pageState) : { page: 1, totalCount: totalCount };
                            updatePageOptions(store, pageOptions, true);
                        }
                        exports.resetPageState = resetPageState;


                        /***/ }),
                    /* 35 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.ColGroup = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var dom_1 = __webpack_require__(2);
                        var ColGroupComp = /** @class */ (function (_super) {
                            tslib_1.__extends(ColGroupComp, _super);
                            function ColGroupComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            ColGroupComp.prototype.render = function (_a) {
                                var _b;
                                var columns = _a.columns, widths = _a.widths, borderWidth = _a.borderWidth;
                                var attrs = (_b = {}, _b[dom_1.dataAttr.COLUMN_NAME] = name, _b);
                                return (preact_1.h("colgroup", null, columns.map(function (_a, idx) {
                                    var name = _a.name;
                                    return (preact_1.h("col", tslib_1.__assign({ key: name }, attrs, { style: { width: widths[idx] + borderWidth } })));
                                })));
                            };
                            return ColGroupComp;
                        }(preact_1.Component));
                        exports.ColGroup = hoc_1.connect(function (_a, _b) {
                            var _c;
                            var columnCoords = _a.columnCoords, viewport = _a.viewport, dimension = _a.dimension, column = _a.column;
                            var side = _b.side, useViewport = _b.useViewport;
                            return ({
                                widths: useViewport && side === 'R'
                                    ? (_c = columnCoords.widths[side]).slice.apply(_c, viewport.colRange) : columnCoords.widths[side],
                                columns: useViewport && side === 'R'
                                    ? viewport.columns
                                    : column.visibleColumnsBySideWithRowHeader[side],
                                borderWidth: dimension.cellBorderWidth,
                            });
                        })(ColGroupComp);


                        /***/ }),
                    /* 36 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        var tslib_1 = __webpack_require__(1);
                        var messages = {
                            en: {
                                display: {
                                    noData: '  .',
                                    loadingData: '  .',
                                    resizeHandleGuide: '      ,       .',
                                },
                                net: {
                                    confirmCreate: '{{count}}  ?',
                                    confirmUpdate: '{{count}}  ?',
                                    confirmDelete: '{{count}}  ?',
                                    confirmModify: '{{count}}  ?',
                                    noDataToCreate: '  .',
                                    noDataToUpdate: '  .',
                                    noDataToDelete: '  .',
                                    noDataToModify: '  .',
                                    failResponse: '    .\n   .',
                                },
                            },
                            ko: {
                                display: {
                                    noData: '  .',
                                    loadingData: '  .',
                                    resizeHandleGuide: '      ,       .',
                                },
                                net: {
                                    confirmCreate: '{{count}}  ?',
                                    confirmUpdate: '{{count}}  ?',
                                    confirmDelete: '{{count}}  ?',
                                    confirmModify: '{{count}}  ?',
                                    noDataToCreate: '  .',
                                    noDataToUpdate: '  .',
                                    noDataToDelete: '  .',
                                    noDataToModify: '  .',
                                    failResponse: '    .\n   .',
                                },
                            },
                        };
                        var messageMap = {};
                        /**
                         * Flatten message map
                         * @param {object} data - Messages
                         * @returns {object} Flatten message object (key format is 'key.subKey')
                         * @ignore
                         */
                        function flattenMessageMap(data) {
                            if (data === void 0) { data = {}; }
                            var obj = {};
                            var newKey;
                            Object.keys(data).forEach(function (key) {
                                var keyWithType = key;
                                var groupMessages = data[keyWithType];
                                Object.keys(groupMessages).forEach(function (subKey) {
                                    newKey = key + "." + subKey;
                                    obj[newKey] = groupMessages[subKey];
                                });
                            });
                            return obj;
                        }
                        /**
                         * Replace text
                         * @param {string} text - Text including handlebar expression
                         * @param {Object} values - Replaced values
                         * @returns {string} Replaced text
                         */
                        function replaceText(text, values) {
                            return text
                                ? text.replace(/\{\{(\w*)\}\}/g, function (_, prop) { return (values.hasOwnProperty(prop) ? values[prop] : ''); })
                                : '';
                        }
                        exports.default = {
                            /**
                             * Set messages
                             * @param {string} localeCode - Code to set locale messages and
                             *     this is the language or language-region combination. (ex: en-US)
                             * @param {object} [data] - Messages using in Grid
                             */
                            setLanguage: function (localeCode, data) {
                                var localeMessages = messages[localeCode];
                                if (!localeMessages && !data) {
                                    throw new Error('You should set messages to map the locale code.');
                                }
                                var newData = flattenMessageMap(data);
                                if (localeMessages) {
                                    var originData = flattenMessageMap(localeMessages);
                                    messageMap = tslib_1.__assign(tslib_1.__assign({}, originData), newData);
                                }
                                else {
                                    messageMap = newData;
                                }
                            },
                            /**
                             * Get message
                             * @param {string} key - Key to find message (ex: 'net.confirmCreate')
                             * @param {object} [replacements] - Values to replace string
                             * @returns {string} Message
                             */
                            get: function (key, replacements) {
                                if (replacements === void 0) { replacements = {}; }
                                var message = messageMap[key];
                                return replaceText(message, replacements);
                            },
                        };


                        /***/ }),
                    /* 37 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getText = exports.copyDataToRange = exports.getRangeToPaste = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        function getCustomValue(customValue, value, rowAttrs, column) {
                            return typeof customValue === 'function' ? customValue(value, rowAttrs, column) : customValue;
                        }
                        function getTextWithCopyOptionsApplied(valueMap, rawData, column) {
                            var text = valueMap.value;
                            var copyOptions = column.copyOptions, editor = column.editor;
                            var editorOptions = editor && editor.options;
                            // priority: customValue > useListItemText > useFormattedValue > original Data
                            if (copyOptions) {
                                if (copyOptions.customValue) {
                                    text = getCustomValue(copyOptions.customValue, valueMap.value, rawData, column);
                                }
                                else if (copyOptions.useListItemText && editorOptions) {
                                    var listItems_1 = editorOptions.listItems;
                                    var value = valueMap.value;
                                    var valueList = [value];
                                    var result_1 = [];
                                    if (typeof value === 'string') {
                                        valueList = value.split(',');
                                    }
                                    valueList.forEach(function (val) {
                                        var listItem = common_1.find(function (item) { return item.value === val; }, listItems_1);
                                        result_1.push(listItem ? listItem.text : val);
                                    });
                                    text = result_1.join(',');
                                }
                                else if (copyOptions.useFormattedValue) {
                                    text = "" + valueMap.formattedValue;
                                }
                            }
                            if (typeof text === 'undefined' || text === null) {
                                return '';
                            }
                            return String(text);
                        }
                        function getValueToString(store) {
                            var visibleColumnsWithRowHeader = store.column.visibleColumnsWithRowHeader, _a = store.focus, originalRowIndex = _a.originalRowIndex, columnName = _a.columnName, totalColumnIndex = _a.totalColumnIndex, _b = store.data, filteredViewData = _b.filteredViewData, filteredRawData = _b.filteredRawData;
                            if (common_1.isNull(originalRowIndex) || common_1.isNull(columnName) || common_1.isNull(totalColumnIndex)) {
                                return '';
                            }
                            var valueMap = filteredViewData[originalRowIndex].valueMap[columnName];
                            return getTextWithCopyOptionsApplied(valueMap, filteredRawData, visibleColumnsWithRowHeader[totalColumnIndex]);
                        }
                        function getValuesToString(store) {
                            var originalRange = store.selection.originalRange, visibleColumnsWithRowHeader = store.column.visibleColumnsWithRowHeader, _a = store.data, filteredViewData = _a.filteredViewData, filteredRawData = _a.filteredRawData;
                            if (!originalRange) {
                                return '';
                            }
                            var _b = originalRange, row = _b.row, column = _b.column;
                            var rowList = filteredViewData.slice(row[0], row[1] + 1);
                            var columnInRange = visibleColumnsWithRowHeader.slice(column[0], column[1] + 1);
                            return rowList
                                .map(function (_a) {
                                    var valueMap = _a.valueMap;
                                    return columnInRange
                                        .map(function (_a, index) {
                                            var name = _a.name;
                                            return getTextWithCopyOptionsApplied(valueMap[name], filteredRawData, visibleColumnsWithRowHeader[index]);
                                        })
                                        .join('\t');
                                })
                                .join('\n');
                        }
                        function getRangeToPaste(store, pasteData) {
                            var originalRange = store.selection.originalRange, _a = store.focus, totalColumnIndex = _a.totalColumnIndex, originalRowIndex = _a.originalRowIndex, visibleColumnsWithRowHeader = store.column.visibleColumnsWithRowHeader, viewData = store.data.viewData;
                            var startRowIndex, startColumnIndex;
                            if (originalRange) {
                                startRowIndex = originalRange.row[0];
                                startColumnIndex = originalRange.column[0];
                            }
                            else {
                                startRowIndex = originalRowIndex;
                                startColumnIndex = totalColumnIndex;
                            }
                            var endRowIndex = Math.min(pasteData.length + startRowIndex, viewData.length) - 1;
                            var endColumnIndex = Math.min(pasteData[0].length + startColumnIndex, visibleColumnsWithRowHeader.length) - 1;
                            return {
                                row: [startRowIndex, endRowIndex],
                                column: [startColumnIndex, endColumnIndex],
                            };
                        }
                        exports.getRangeToPaste = getRangeToPaste;
                        function copyDataToRange(range, pasteData) {
                            var rowLength = range.row[1] - range.row[0] + 1;
                            var colLength = range.column[1] - range.column[0] + 1;
                            var dataRowLength = pasteData.length;
                            var dataColLength = pasteData[0].length;
                            var rowDupCount = Math.floor(rowLength / dataRowLength) - 1;
                            var colDupCount = Math.floor(colLength / dataColLength) - 1;
                            var result = tslib_1.__spreadArrays(pasteData);
                            for (var i = 0; i < rowDupCount; i += 1) {
                                pasteData.forEach(function (row) {
                                    result.push(row.slice(0));
                                });
                            }
                            result.forEach(function (row) {
                                var rowData = row.slice(0);
                                for (var i = 0; i < colDupCount; i += 1) {
                                    row.push.apply(row, rowData);
                                }
                            });
                            return result;
                        }
                        exports.copyDataToRange = copyDataToRange;
                        function getText(store) {
                            var selection = store.selection, _a = store.focus, rowIndex = _a.rowIndex, columnName = _a.columnName;
                            if (selection.range) {
                                return getValuesToString(store);
                            }
                            if (rowIndex !== null && columnName !== null) {
                                return getValueToString(store);
                            }
                            return '';
                        }
                        exports.getText = getText;


                        /***/ }),
                    /* 38 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.createAjaxConfig = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        function createAjaxConfig(target) {
                            var configKeys = [
                                'contentType',
                                'withCredentials',
                                'mimeType',
                                'headers',
                                'serializer',
                            ];
                            return common_1.pick.apply(void 0, tslib_1.__spreadArrays([target], configKeys));
                        }
                        exports.createAjaxConfig = createAjaxConfig;


                        /***/ }),
                    /* 39 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getListItems = void 0;
                        var common_1 = __webpack_require__(0);
                        function getListItems(props) {
                            var _a = props.columnInfo.editor.options, listItems = _a.listItems, relationListItemMap = _a.relationListItemMap;
                            if (!common_1.isEmpty(relationListItemMap) && Array.isArray(relationListItemMap[props.rowKey])) {
                                return relationListItemMap[props.rowKey];
                            }
                            return listItems;
                        }
                        exports.getListItems = getListItems;


                        /***/ }),
                    /* 40 */
                    /***/ (function(module, exports) {

                        module.exports = __WEBPACK_EXTERNAL_MODULE__40__;

                        /***/ }),
                    /* 41 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.createSortEvent = exports.isCancelSort = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var common_1 = __webpack_require__(0);
                        function isCancelSort(_a, columnName, ascending, cancelable) {
                            var data = _a.data, column = _a.column;
                            var index = common_1.findPropIndex('columnName', columnName, data.sortState.columns);
                            var defaultAscending = column.allColumnMap[columnName].sortingType === 'asc';
                            return cancelable && ascending === defaultAscending && index !== -1;
                        }
                        exports.isCancelSort = isCancelSort;
                        function createSortEvent(eventType, eventParams) {
                            var columnName = eventParams.columnName, multiple = eventParams.multiple, ascending = eventParams.ascending;
                            var sortState = common_1.deepCopy(eventParams.sortState);
                            var props = {};
                            /* eslint-disable no-fallthrough */
                            switch (eventType) {
                                /**
                                 * Occurs before sorting.
                                 * @event Grid#beforeSort
                                 * @property {Object} sortState - Current sort state
                                 * @property {string} columnName - Target column name
                                 * @property {boolean} ascending - Next ascending state of a column.
                                 * If the event is not stopped this ascending state will be applied to grid.
                                 * @property {boolean} multiple - Whether to use multiple sort
                                 * @property {Grid} instance - Current grid instance
                                 */
                                case 'beforeSort':
                                    props = {
                                        sortState: sortState,
                                        columnName: columnName,
                                        ascending: ascending,
                                        multiple: multiple,
                                    };
                                    break;
                                /**
                                 * Occurs before unsorting.
                                 * @event Grid#beforeUnsort
                                 * @property {Object} sortState - Current sort state of the grid
                                 * @property {string} columnName - Target column name
                                 * @property {boolean} multiple - Whether to use multiple sort
                                 * @property {Grid} instance - Current grid instance
                                 */
                                case 'beforeUnsort':
                                    props = {
                                        sortState: sortState,
                                        columnName: columnName,
                                        multiple: multiple,
                                    };
                                    break;
                                /**
                                 * Occurs after sorting.
                                 * @deprecated
                                 * @event Grid#sort
                                 * @property {Object} sortState - sort state
                                 * @property {string} columnName - Target column name
                                 * @property {Grid} instance - Current grid instance
                                 */
                                case 'sort':
                                /**
                                 * Occurs after sorting.
                                 * @event Grid#afterSort
                                 * @property {Object} sortState - sort state
                                 * @property {string} columnName - Target column name
                                 * @property {Grid} instance - Current grid instance
                                 */
                                case 'afterSort':
                                /**
                                 * Occurs after unsorting.
                                 * @event Grid#afterUnsort
                                 * @property {Object} sortState - sort state
                                 * @property {string} columnName - Target column name
                                 * @property {Grid} instance - Current grid instance
                                 */
                                case 'afterUnsort':
                                    props = {
                                        sortState: sortState,
                                        columnName: columnName,
                                    };
                                    break;
                            }
                            /* eslint-disable no-fallthrough */
                            return new gridEvent_1.default(props);
                        }
                        exports.createSortEvent = createSortEvent;


                        /***/ }),
                    /* 42 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.extractSummaryColumnContent = exports.castToSummaryColumnContent = exports.calculate = exports.getSummaryValue = void 0;
                        var tslib_1 = __webpack_require__(1);
                        function assignFilteredSummaryValue(summaryValue) {
                            var sum = summaryValue.sum, min = summaryValue.min, max = summaryValue.max, avg = summaryValue.avg, cnt = summaryValue.cnt;
                            return {
                                filtered: {
                                    sum: sum,
                                    min: min,
                                    max: max,
                                    avg: avg,
                                    cnt: cnt,
                                },
                            };
                        }
                        function getSummaryValue(columnName, rawData, filteredRawData) {
                            var columnValues = rawData.map(function (row) { return row[columnName]; });
                            var summaryValue = calculate(columnValues);
                            if (rawData.length === filteredRawData.length) {
                                return tslib_1.__assign(tslib_1.__assign({}, summaryValue), assignFilteredSummaryValue(summaryValue));
                            }
                            var filteredColumnValues = filteredRawData.map(function (row) { return row[columnName]; });
                            return tslib_1.__assign(tslib_1.__assign({}, summaryValue), assignFilteredSummaryValue(calculate(filteredColumnValues)));
                        }
                        exports.getSummaryValue = getSummaryValue;
                        function calculate(values) {
                            var cnt = values.length;
                            var min = Number.MAX_VALUE;
                            var max = Number.MIN_VALUE;
                            var sum = 0;
                            var avg = 0;
                            for (var i = 0; i < cnt; i += 1) {
                                var value = Number(values[i]);
                                if (isNaN(value)) {
                                    value = 0;
                                }
                                sum += value;
                                if (min > value) {
                                    min = value;
                                }
                                if (max < value) {
                                    max = value;
                                }
                            }
                            if (!cnt) {
                                max = min = avg = 0;
                            }
                            else {
                                avg = sum / cnt;
                            }
                            return { sum: sum, min: min, max: max, avg: avg, cnt: cnt };
                        }
                        exports.calculate = calculate;
                        function castToSummaryColumnContent(content) {
                            if (!content) {
                                return null;
                            }
                            return typeof content === 'string'
                                ? { template: content, useAutoSummary: false }
                                : {
                                    template: content.template,
                                    useAutoSummary: typeof content.useAutoSummary === 'undefined' ? true : content.useAutoSummary,
                                };
                        }
                        exports.castToSummaryColumnContent = castToSummaryColumnContent;
                        function extractSummaryColumnContent(content, defaultContent) {
                            var summaryColumnContent = null;
                            if (content) {
                                summaryColumnContent = content;
                            }
                            else if (!content && defaultContent) {
                                summaryColumnContent = defaultContent;
                            }
                            return summaryColumnContent;
                        }
                        exports.extractSummaryColumnContent = extractSummaryColumnContent;


                        /***/ }),
                    /* 43 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = exports.createSummaryValue = void 0;
                        var observable_1 = __webpack_require__(5);
                        var summary_1 = __webpack_require__(42);
                        var common_1 = __webpack_require__(0);
                        function createSummaryValue(content, columnName, data) {
                            if (content && content.useAutoSummary) {
                                return summary_1.getSummaryValue(columnName, data.rawData, data.filteredRawData);
                            }
                            return {
                                sum: 0,
                                min: 0,
                                max: 0,
                                avg: 0,
                                cnt: 0,
                                filtered: {
                                    sum: 0,
                                    min: 0,
                                    max: 0,
                                    avg: 0,
                                    cnt: 0,
                                },
                            };
                        }
                        exports.createSummaryValue = createSummaryValue;
                        function create(_a) {
                            var column = _a.column, data = _a.data, summary = _a.summary;
                            var summaryColumnContents = {};
                            var summaryValues = {};
                            var orgColumnContent = summary.columnContent, defaultContent = summary.defaultContent;
                            if (Object.keys(summary).length) {
                                var castedDefaultContent_1 = summary_1.castToSummaryColumnContent(defaultContent || '');
                                var columnContent_1 = orgColumnContent || {};
                                var summaryColumns = Object.keys(columnContent_1);
                                var filteredSummaryColumns = summaryColumns.filter(function (columnName) { return !common_1.someProp('name', columnName, column.allColumns); });
                                var targetColumns = castedDefaultContent_1
                                    ? column.allColumns.map(function (_a) {
                                        var name = _a.name;
                                        return name;
                                    }).concat(filteredSummaryColumns)
                                    : summaryColumns;
                                targetColumns.forEach(function (columnName) {
                                    var castedColumnContent = summary_1.castToSummaryColumnContent(columnContent_1[columnName]);
                                    var content = summary_1.extractSummaryColumnContent(castedColumnContent, castedDefaultContent_1);
                                    summaryColumnContents[columnName] = content;
                                    summaryValues[columnName] = createSummaryValue(content, columnName, data);
                                });
                            }
                            return observable_1.observable({ summaryColumnContents: summaryColumnContents, summaryValues: summaryValues, defaultContent: defaultContent });
                        }
                        exports.create = create;


                        /***/ }),
                    /* 44 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.createFilterEvent = exports.getFilterState = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        function getFilterState(store) {
                            var filters = store.data.filters;
                            if (filters) {
                                common_1.deepCopyArray(filters);
                            }
                            return filters;
                        }
                        exports.getFilterState = getFilterState;
                        function createFilterEvent(_a, eventType, eventParams) {
                            var data = _a.data;
                            var columnName = eventParams.columnName, type = eventParams.type, conditionFn = eventParams.conditionFn, state = eventParams.state, operator = eventParams.operator;
                            var filterState = data.filters ? common_1.deepCopyArray(data.filters) : null;
                            var props = {};
                            /* eslint-disable no-fallthrough */
                            switch (eventType) {
                                /**
                                 * Occurs before filtering.
                                 * @event Grid#beforeFilter
                                 * @property {Grid} instance - Current grid instance
                                 * @property {Object} filterState - Current filter state
                                 * @property {string} columnName - Target column name
                                 * @property {string} type - Column Filter type
                                 * @property {string} operator - Column filter Operator('AND' | 'OR')
                                 * @property {function} conditionFn - Original function to filter the data in grid.
                                 * @property {Array} columnFilterState - Next filter state of column which triggers the event.
                                 * If the event is not stopped this state will be applied to grid.
                                 */
                                case 'beforeFilter':
                                    props = {
                                        filterState: filterState,
                                        columnFilterState: common_1.deepCopyArray(state),
                                        conditionFn: conditionFn,
                                        type: type,
                                        columnName: columnName,
                                        operator: operator,
                                    };
                                    break;
                                /**
                                 *Occursbeforeunfiltering
                                 *@eventGrid#beforeUnfilter
                                 *@property{Grid}instance-Currentgridinstance
                                 *@property{string} columnName - Target column name
                                 *@property{Object} filterState -Current filter state
                                 */
                                case 'beforeUnfilter':
                                /**
                                 *Occursafterfiltering
                                 * @deprecated
                                 *@eventGrid#filter
                                 *@property{Grid}instance-Currentgridinstance
                                 *@property{string} columnName - Target column name
                                 *@property{Object} filterState -Current filter state
                                 */
                                case 'filter':
                                /**
                                 *Occursafterfiltering
                                 *@eventGrid#afterFilter
                                 *@property{Grid}instance-Currentgridinstance
                                 *@property{string} columnName - Target column name
                                 *@property{Object} filterState -Current filter state
                                 */
                                case 'afterFilter':
                                /**
                                 *Occursafterunfiltering
                                 *@eventGrid#afterUnfilter
                                 *@property{Grid}instance-Currentgridinstance
                                 *@property{string} columnName - Target column name
                                 *@property{Object} filterState -Current filter state
                                 */
                                case 'afterUnfilter':
                                    props = {
                                        filterState: filterState,
                                        columnName: columnName,
                                    };
                                    break;
                            }
                            /* eslint-disable no-fallthrough */
                            return new gridEvent_1.default(props);
                        }
                        exports.createFilterEvent = createFilterEvent;


                        /***/ }),
                    /* 45 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.setAutoBodyHeight = exports.refreshLayout = exports.setHeaderHeight = exports.setOffsetLeft = exports.setOffsetTop = exports.setBodyHeight = exports.setHeight = exports.setWidth = void 0;
                        function setWidth(_a, width, autoWidth) {
                            var dimension = _a.dimension;
                            dimension.autoWidth = autoWidth;
                            dimension.width = width;
                        }
                        exports.setWidth = setWidth;
                        function setHeight(_a, height) {
                            var dimension = _a.dimension;
                            var headerHeight = dimension.headerHeight, summaryHeight = dimension.summaryHeight, tableBorderWidth = dimension.tableBorderWidth;
                            dimension.bodyHeight = height - headerHeight - summaryHeight - tableBorderWidth;
                        }
                        exports.setHeight = setHeight;
                        function setBodyHeight(_a, bodyHeight) {
                            var dimension = _a.dimension;
                            dimension.autoHeight = false;
                            dimension.bodyHeight = Math.max(bodyHeight, dimension.minBodyHeight);
                        }
                        exports.setBodyHeight = setBodyHeight;
                        function setOffsetTop(store, offsetTop) {
                            store.dimension.offsetTop = offsetTop;
                        }
                        exports.setOffsetTop = setOffsetTop;
                        function setOffsetLeft(store, offsetLeft) {
                            store.dimension.offsetLeft = offsetLeft;
                        }
                        exports.setOffsetLeft = setOffsetLeft;
                        function setHeaderHeight(store, height) {
                            store.dimension.headerHeight = height;
                        }
                        exports.setHeaderHeight = setHeaderHeight;
                        function refreshLayout(store, containerEl, parentEl) {
                            var dimension = store.dimension;
                            var autoWidth = dimension.autoWidth, fitToParentHeight = dimension.fitToParentHeight;
                            var clientHeight = containerEl.clientHeight, clientWidth = containerEl.clientWidth, scrollTop = containerEl.scrollTop, scrollLeft = containerEl.scrollLeft;
                            var _a = containerEl.getBoundingClientRect(), top = _a.top, left = _a.left;
                            setOffsetTop(store, top + scrollTop);
                            setOffsetLeft(store, left + scrollLeft);
                            setWidth(store, clientWidth, autoWidth);
                            if (fitToParentHeight && parentEl && parentEl.clientHeight !== clientHeight) {
                                setHeight(store, parentEl.clientHeight);
                            }
                        }
                        exports.refreshLayout = refreshLayout;
                        function setAutoBodyHeight(_a) {
                            var dimension = _a.dimension, rowCoords = _a.rowCoords;
                            var totalRowHeight = rowCoords.totalRowHeight;
                            var autoHeight = dimension.autoHeight, scrollXHeight = dimension.scrollXHeight, minBodyHeight = dimension.minBodyHeight;
                            if (autoHeight) {
                                dimension.bodyHeight = Math.max(totalRowHeight + scrollXHeight, minBodyHeight);
                            }
                        }
                        exports.setAutoBodyHeight = setAutoBodyHeight;


                        /***/ }),
                    /* 46 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.HeaderArea = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var colGroup_1 = __webpack_require__(35);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var columnResizer_1 = __webpack_require__(84);
                        var instance_1 = __webpack_require__(7);
                        var column_1 = __webpack_require__(12);
                        var complexHeader_1 = __webpack_require__(85);
                        var columnHeader_1 = __webpack_require__(47);
                        var HeaderAreaComp = /** @class */ (function (_super) {
                            tslib_1.__extends(HeaderAreaComp, _super);
                            function HeaderAreaComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.startSelectedName = null;
                                _this.handleDblClick = function (ev) {
                                    ev.stopPropagation();
                                };
                                _this.handleMouseMove = function (ev) {
                                    var _a = dom_1.getCoordinateWithOffset(ev.pageX, ev.pageY), pageX = _a[0], pageY = _a[1];
                                    _this.props.dispatch('dragMoveHeader', { pageX: pageX, pageY: pageY }, _this.startSelectedName);
                                };
                                _this.handleMouseDown = function (ev) {
                                    var _a = _this.props, dispatch = _a.dispatch, complexColumnHeaders = _a.complexColumnHeaders;
                                    var target = ev.target;
                                    if (dom_1.findParent(target, 'cell-row-header') ||
                                        dom_1.hasClass(target, 'btn-sorting') ||
                                        dom_1.hasClass(target, 'btn-filter')) {
                                        return;
                                    }
                                    var name = target.getAttribute('data-column-name');
                                    if (!name) {
                                        var parent = dom_1.findParent(target, 'cell-header');
                                        if (parent) {
                                            name = parent.getAttribute('data-column-name');
                                        }
                                    }
                                    var parentHeader = column_1.isParentColumnHeader(complexColumnHeaders, name);
                                    _this.startSelectedName = name;
                                    dispatch('mouseDownHeader', name, parentHeader);
                                    document.addEventListener('mousemove', _this.handleMouseMove);
                                    document.addEventListener('mouseup', _this.clearDocumentEvents);
                                    document.addEventListener('selectstart', _this.handleSelectStart);
                                };
                                _this.clearDocumentEvents = function () {
                                    _this.props.dispatch('dragEnd');
                                    dom_1.setCursorStyle('');
                                    document.removeEventListener('mousemove', _this.handleMouseMove);
                                    document.removeEventListener('mouseup', _this.clearDocumentEvents);
                                    document.removeEventListener('selectstart', _this.handleSelectStart);
                                };
                                _this.handleSelectStart = function (ev) {
                                    ev.preventDefault();
                                };
                                return _this;
                            }
                            HeaderAreaComp.prototype.isSelected = function (index) {
                                var columnSelectionRange = this.props.columnSelectionRange;
                                if (!columnSelectionRange) {
                                    return false;
                                }
                                var start = columnSelectionRange[0], end = columnSelectionRange[1];
                                return index >= start && index <= end;
                            };
                            HeaderAreaComp.prototype.componentDidUpdate = function () {
                                this.el.scrollLeft = this.props.scrollLeft;
                            };
                            HeaderAreaComp.prototype.render = function () {
                                var _this = this;
                                var _a = this.props, columns = _a.columns, headerHeight = _a.headerHeight, side = _a.side, complexColumnHeaders = _a.complexColumnHeaders, grid = _a.grid;
                                var headerHeightStyle = { height: headerHeight };
                                return (preact_1.h("div", { class: dom_1.cls('header-area'), style: headerHeightStyle, ref: function (el) {
                                            _this.el = el;
                                        } },
                                    preact_1.h("table", { class: dom_1.cls('table'), onMouseDown: this.handleMouseDown },
                                        preact_1.h(colGroup_1.ColGroup, { side: side, useViewport: false }),
                                        complexColumnHeaders.length ? (preact_1.h(complexHeader_1.ComplexHeader, { side: side, grid: grid })) : (preact_1.h("tbody", null,
                                            preact_1.h("tr", { style: headerHeightStyle, onDblClick: this.handleDblClick }, columns.map(function (columnInfo, index) { return (preact_1.h(columnHeader_1.ColumnHeader, { key: columnInfo.name, columnInfo: columnInfo, selected: _this.isSelected(index), grid: grid })); }))))),
                                    preact_1.h(columnResizer_1.ColumnResizer, { side: side })));
                            };
                            return HeaderAreaComp;
                        }(preact_1.Component));
                        exports.HeaderArea = hoc_1.connect(function (store, _a) {
                            var side = _a.side;
                            var _b = store.column, visibleColumnsBySideWithRowHeader = _b.visibleColumnsBySideWithRowHeader, complexColumnHeaders = _b.complexColumnHeaders, _c = store.dimension, headerHeight = _c.headerHeight, cellBorderWidth = _c.cellBorderWidth, rangeBySide = store.selection.rangeBySide, viewport = store.viewport, id = store.id;
                            return {
                                headerHeight: headerHeight,
                                cellBorderWidth: cellBorderWidth,
                                columns: visibleColumnsBySideWithRowHeader[side],
                                scrollLeft: side === 'L' ? 0 : viewport.scrollLeft,
                                grid: instance_1.getInstance(id),
                                columnSelectionRange: rangeBySide && rangeBySide[side].column ? rangeBySide[side].column : null,
                                complexColumnHeaders: complexColumnHeaders,
                            };
                        })(HeaderAreaComp);


                        /***/ }),
                    /* 47 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.ColumnHeader = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var dom_1 = __webpack_require__(2);
                        var headerCheckbox_1 = __webpack_require__(86);
                        var sortingButton_1 = __webpack_require__(87);
                        var sortingOrder_1 = __webpack_require__(88);
                        var filterButton_1 = __webpack_require__(89);
                        var column_1 = __webpack_require__(10);
                        var common_1 = __webpack_require__(0);
                        var ColumnHeader = /** @class */ (function (_super) {
                            tslib_1.__extends(ColumnHeader, _super);
                            function ColumnHeader() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            ColumnHeader.prototype.getElement = function (type) {
                                var columnInfo = this.props.columnInfo;
                                var name = columnInfo.name, sortable = columnInfo.sortable, sortingType = columnInfo.sortingType, filter = columnInfo.filter, headerRenderer = columnInfo.headerRenderer, header = columnInfo.header;
                                if (headerRenderer) {
                                    return null;
                                }
                                switch (type) {
                                    case 'checkbox':
                                        return column_1.isCheckboxColumn(name) ? preact_1.h(headerCheckbox_1.HeaderCheckbox, null) : header;
                                    case 'sortingBtn':
                                        return sortable && preact_1.h(sortingButton_1.SortingButton, { columnName: name, sortingType: sortingType });
                                    case 'sortingOrder':
                                        return sortable && preact_1.h(sortingOrder_1.SortingOrder, { columnName: name });
                                    case 'filter':
                                        return filter && preact_1.h(filterButton_1.FilterButton, { columnName: name });
                                    default:
                                        return null;
                                }
                            };
                            ColumnHeader.prototype.componentDidMount = function () {
                                var _a = this.props, columnInfo = _a.columnInfo, grid = _a.grid;
                                var headerRenderer = columnInfo.headerRenderer;
                                if (!headerRenderer || !this.el) {
                                    return;
                                }
                                var HeaderRendererClass = headerRenderer;
                                var renderer = new HeaderRendererClass({ grid: grid, columnInfo: columnInfo });
                                var rendererEl = renderer.getElement();
                                this.el.appendChild(rendererEl);
                                this.renderer = renderer;
                                if (common_1.isFunction(renderer.mounted)) {
                                    renderer.mounted(this.el);
                                }
                            };
                            ColumnHeader.prototype.componentWillReceiveProps = function (nextProps) {
                                if (this.renderer) {
                                    this.renderer.render({ columnInfo: nextProps.columnInfo, grid: nextProps.grid });
                                }
                            };
                            ColumnHeader.prototype.componentWillUnmount = function () {
                                if (this.renderer && common_1.isFunction(this.renderer.beforeDestroy)) {
                                    this.renderer.beforeDestroy();
                                }
                            };
                            ColumnHeader.prototype.render = function () {
                                var _this = this;
                                var _a = this.props, columnInfo = _a.columnInfo, colspan = _a.colspan, rowspan = _a.rowspan, selected = _a.selected, _b = _a.height, height = _b === void 0 ? null : _b;
                                var name = columnInfo.name, textAlign = columnInfo.headerAlign, verticalAlign = columnInfo.headerVAlign, headerRenderer = columnInfo.headerRenderer;
                                return (preact_1.h("th", tslib_1.__assign({ ref: function (el) {
                                        _this.el = el;
                                    }, "data-column-name": name, style: { textAlign: textAlign, verticalAlign: verticalAlign, padding: headerRenderer ? 0 : null, height: height }, class: dom_1.cls('cell', 'cell-header', [!column_1.isRowHeader(name) && selected, 'cell-selected'], [column_1.isRowHeader(name), 'cell-row-header']) }, (!!colspan && { colspan: colspan }), (!!rowspan && { rowspan: rowspan })), ['checkbox', 'sortingBtn', 'sortingOrder', 'filter'].map(function (type) { return _this.getElement(type); })));
                            };
                            return ColumnHeader;
                        }(preact_1.Component));
                        exports.ColumnHeader = ColumnHeader;


                        /***/ }),
                    /* 48 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.BodyArea = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var bodyRows_1 = __webpack_require__(90);
                        var colGroup_1 = __webpack_require__(35);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var focusLayer_1 = __webpack_require__(96);
                        var selectionLayer_1 = __webpack_require__(97);
                        var common_1 = __webpack_require__(0);
                        var editingLayer_1 = __webpack_require__(98);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var eventBus_1 = __webpack_require__(8);
                        // only updates when these props are changed
                        // for preventing unnecessary rendering when scroll changes
                        var PROPS_FOR_UPDATE = [
                            'bodyHeight',
                            'totalRowHeight',
                            'offsetLeft',
                            'offsetTop',
                            'totalColumnWidth',
                        ];
                        // Minimum distance (pixel) to detect if user wants to drag when moving mouse with button pressed.
                        var MIN_DISTANCE_FOR_DRAG = 10;
                        var BodyAreaComp = /** @class */ (function (_super) {
                            tslib_1.__extends(BodyAreaComp, _super);
                            function BodyAreaComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.dragStartData = {
                                    pageX: null,
                                    pageY: null,
                                };
                                _this.prevScrollLeft = 0;
                                _this.scrollToNextDebounced = common_1.debounce(function () {
                                    _this.props.dispatch('scrollToNext');
                                }, 200);
                                _this.handleScroll = function (ev) {
                                    var _a = ev.target, scrollLeft = _a.scrollLeft, scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
                                    var _b = _this.props, dispatch = _b.dispatch, eventBus = _b.eventBus, side = _b.side;
                                    dispatch('setScrollTop', scrollTop);
                                    if (side === 'R') {
                                        dispatch('setScrollLeft', scrollLeft);
                                        if (scrollTop > 0 &&
                                            scrollHeight - scrollTop === clientHeight &&
                                            _this.prevScrollLeft === scrollLeft) {
                                            var gridEvent = new gridEvent_1.default();
                                            /**
                                             * Occurs when scroll at the bottommost
                                             * @event Grid#scrollEnd
                                             * @property {Grid} instance - Current grid instance
                                             */
                                            eventBus.trigger('scrollEnd', gridEvent);
                                            _this.scrollToNextDebounced();
                                        }
                                        _this.prevScrollLeft = scrollLeft;
                                    }
                                };
                                _this.handleMouseDown = function (ev) {
                                    var targetElement = ev.target;
                                    if (!_this.el || targetElement === _this.el) {
                                        return;
                                    }
                                    var _a = _this.props, side = _a.side, dispatch = _a.dispatch;
                                    if (dom_1.hasClass(targetElement, 'cell-dummy')) {
                                        dispatch('saveAndFinishEditing');
                                        dispatch('initFocus');
                                        dispatch('initSelection');
                                        return;
                                    }
                                    var el = _this.el;
                                    var shiftKey = ev.shiftKey;
                                    var _b = dom_1.getCoordinateWithOffset(ev.pageX, ev.pageY), pageX = _b[0], pageY = _b[1];
                                    var scrollTop = el.scrollTop, scrollLeft = el.scrollLeft;
                                    var _c = el.getBoundingClientRect(), top = _c.top, left = _c.left;
                                    _this.boundingRect = { top: top, left: left };
                                    if (!dom_1.isDatePickerElement(targetElement) && !dom_1.findParent(targetElement, 'layer-editing')) {
                                        dispatch('mouseDownBody', tslib_1.__assign({ scrollTop: scrollTop, scrollLeft: scrollLeft, side: side }, _this.boundingRect), { pageX: pageX, pageY: pageY, shiftKey: shiftKey });
                                    }
                                    _this.dragStartData = { pageX: pageX, pageY: pageY };
                                    dom_1.setCursorStyle('default');
                                    document.addEventListener('mousemove', _this.handleMouseMove);
                                    document.addEventListener('mouseup', _this.clearDocumentEvents);
                                    document.addEventListener('selectstart', _this.handleSelectStart);
                                };
                                _this.moveEnoughToTriggerDragEvent = function (current) {
                                    var dx = Math.abs(_this.dragStartData.pageX - current.pageX);
                                    var dy = Math.abs(_this.dragStartData.pageY - current.pageY);
                                    var movedDistance = Math.round(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)));
                                    return movedDistance >= MIN_DISTANCE_FOR_DRAG;
                                };
                                _this.handleSelectStart = function (ev) {
                                    ev.preventDefault();
                                };
                                _this.handleMouseMove = function (ev) {
                                    var _a = dom_1.getCoordinateWithOffset(ev.pageX, ev.pageY), pageX = _a[0], pageY = _a[1];
                                    if (_this.moveEnoughToTriggerDragEvent({ pageX: pageX, pageY: pageY })) {
                                        var _b = _this, el = _b.el, boundingRect = _b.boundingRect, props = _b.props;
                                        var _c = el, scrollTop = _c.scrollTop, scrollLeft = _c.scrollLeft;
                                        var side = props.side, dispatch = props.dispatch;
                                        dispatch('dragMoveBody', _this.dragStartData, { pageX: pageX, pageY: pageY }, tslib_1.__assign({ scrollTop: scrollTop, scrollLeft: scrollLeft, side: side }, boundingRect));
                                    }
                                };
                                _this.clearDocumentEvents = function () {
                                    _this.dragStartData = { pageX: null, pageY: null };
                                    _this.props.dispatch('dragEnd');
                                    dom_1.setCursorStyle('');
                                    document.removeEventListener('mousemove', _this.handleMouseMove);
                                    document.removeEventListener('mouseup', _this.clearDocumentEvents);
                                    document.removeEventListener('selectstart', _this.handleSelectStart);
                                };
                                return _this;
                            }
                            BodyAreaComp.prototype.shouldComponentUpdate = function (nextProps) {
                                var currProps = this.props;
                                return common_1.some(function (propName) { return nextProps[propName] !== currProps[propName]; }, PROPS_FOR_UPDATE);
                            };
                            BodyAreaComp.prototype.componentWillReceiveProps = function (nextProps) {
                                var scrollTop = nextProps.scrollTop, scrollLeft = nextProps.scrollLeft;
                                this.el.scrollTop = scrollTop;
                                this.el.scrollLeft = scrollLeft;
                            };
                            BodyAreaComp.prototype.render = function (_a) {
                                var _this = this;
                                var side = _a.side, bodyHeight = _a.bodyHeight, totalRowHeight = _a.totalRowHeight, totalColumnWidth = _a.totalColumnWidth, scrollXHeight = _a.scrollXHeight, offsetTop = _a.offsetTop, offsetLeft = _a.offsetLeft, dummyRowCount = _a.dummyRowCount, scrollX = _a.scrollX, scrollY = _a.scrollY, cellBorderWidth = _a.cellBorderWidth;
                                var areaStyle = { height: bodyHeight };
                                if (!scrollX) {
                                    areaStyle.overflowX = 'hidden';
                                }
                                if (!scrollY && side === 'R') {
                                    areaStyle.overflowY = 'hidden';
                                }
                                var tableContainerStyle = {
                                    top: totalRowHeight ? offsetTop : 0,
                                    left: totalRowHeight ? offsetLeft : 0,
                                    height: dummyRowCount ? bodyHeight - scrollXHeight : '',
                                    overflow: dummyRowCount ? 'hidden' : 'visible',
                                };
                                var containerStyle = {
                                    width: totalColumnWidth + (side === 'R' ? 0 : cellBorderWidth),
                                    height: totalRowHeight ? totalRowHeight + cellBorderWidth : '100%',
                                };
                                return (preact_1.h("div", { class: dom_1.cls('body-area'), style: areaStyle, onScroll: this.handleScroll, onMouseDown: this.handleMouseDown, ref: function (el) {
                                            _this.el = el;
                                        } },
                                    preact_1.h("div", { class: dom_1.cls('body-container'), style: containerStyle },
                                        preact_1.h("div", { class: dom_1.cls('table-container'), style: tableContainerStyle },
                                            preact_1.h("table", { class: dom_1.cls('table') },
                                                preact_1.h(colGroup_1.ColGroup, { side: side, useViewport: true }),
                                                preact_1.h(bodyRows_1.BodyRows, { side: side }))),
                                        preact_1.h(focusLayer_1.FocusLayer, { side: side }),
                                        preact_1.h(selectionLayer_1.SelectionLayer, { side: side }),
                                        preact_1.h(editingLayer_1.EditingLayer, { side: side }))));
                            };
                            return BodyAreaComp;
                        }(preact_1.Component));
                        exports.BodyArea = hoc_1.connect(function (store, _a) {
                            var side = _a.side;
                            var columnCoords = store.columnCoords, rowCoords = store.rowCoords, dimension = store.dimension, viewport = store.viewport, id = store.id;
                            var totalRowHeight = rowCoords.totalRowHeight;
                            var totalColumnWidth = columnCoords.totalColumnWidth;
                            var bodyHeight = dimension.bodyHeight, scrollXHeight = dimension.scrollXHeight, scrollX = dimension.scrollX, scrollY = dimension.scrollY, cellBorderWidth = dimension.cellBorderWidth;
                            var offsetLeft = viewport.offsetLeft, offsetTop = viewport.offsetTop, scrollTop = viewport.scrollTop, scrollLeft = viewport.scrollLeft, dummyRowCount = viewport.dummyRowCount;
                            return {
                                bodyHeight: bodyHeight,
                                totalRowHeight: totalRowHeight,
                                offsetTop: offsetTop,
                                scrollTop: scrollTop,
                                totalColumnWidth: totalColumnWidth[side],
                                offsetLeft: side === 'L' ? 0 : offsetLeft,
                                scrollLeft: side === 'L' ? 0 : scrollLeft,
                                scrollXHeight: scrollXHeight,
                                dummyRowCount: dummyRowCount,
                                scrollX: scrollX,
                                scrollY: scrollY,
                                cellBorderWidth: cellBorderWidth,
                                eventBus: eventBus_1.getEventBus(id),
                            };
                        })(BodyAreaComp);


                        /***/ }),
                    /* 49 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.SummaryArea = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var colGroup_1 = __webpack_require__(35);
                        var summaryBodyRow_1 = __webpack_require__(99);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var SummaryAreaComp = /** @class */ (function (_super) {
                            tslib_1.__extends(SummaryAreaComp, _super);
                            function SummaryAreaComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.handleScroll = function (ev) {
                                    var scrollLeft = ev.target.scrollLeft;
                                    var _a = _this.props, dispatch = _a.dispatch, side = _a.side;
                                    if (side === 'R') {
                                        dispatch('setScrollLeft', scrollLeft);
                                    }
                                };
                                return _this;
                            }
                            SummaryAreaComp.prototype.componentWillReceiveProps = function (nextProps) {
                                if (this.el) {
                                    this.el.scrollLeft = nextProps.scrollLeft;
                                }
                            };
                            SummaryAreaComp.prototype.render = function (_a) {
                                var _this = this;
                                var height = _a.height, columns = _a.columns, side = _a.side;
                                var tableStyle = { height: height };
                                return (height > 0 && (preact_1.h("div", { class: dom_1.cls('summary-area'), onScroll: this.handleScroll, ref: function (el) {
                                            _this.el = el;
                                        } },
                                    preact_1.h("table", { class: dom_1.cls('table'), style: tableStyle },
                                        preact_1.h(colGroup_1.ColGroup, { side: side, useViewport: false }),
                                        preact_1.h(summaryBodyRow_1.SummaryBodyRow, { columns: columns })))));
                            };
                            return SummaryAreaComp;
                        }(preact_1.Component));
                        exports.SummaryArea = hoc_1.connect(function (store, _a) {
                            var side = _a.side;
                            var column = store.column, dimension = store.dimension, viewport = store.viewport;
                            var summaryHeight = dimension.summaryHeight;
                            var scrollLeft = viewport.scrollLeft;
                            return {
                                height: summaryHeight,
                                columns: column.visibleColumnsBySideWithRowHeader[side],
                                scrollLeft: scrollLeft,
                            };
                        })(SummaryAreaComp);


                        /***/ }),
                    /* 50 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.isMobile = exports.isEdge = void 0;
                        function isEdge() {
                            var rEdge = /Edge\/(\d+)\./;
                            return rEdge.exec(window.navigator.userAgent);
                        }
                        exports.isEdge = isEdge;
                        function isMobile() {
                            return /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);
                        }
                        exports.isMobile = isMobile;


                        /***/ }),
                    /* 51 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.findRowIndexByPosition = exports.findColumnIndexByPosition = exports.getColumnNameRange = exports.getOverflowFromMousePosition = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        function getTotalColumnOffsets(widths, cellBorderWidth) {
                            var totalWidths = tslib_1.__spreadArrays(widths.L, widths.R);
                            var offsets = [0];
                            for (var i = 1, len = totalWidths.length; i < len; i += 1) {
                                offsets.push(offsets[i - 1] + totalWidths[i - 1] + cellBorderWidth);
                            }
                            return offsets;
                        }
                        function getScrolledPosition(_a, dimension, leftSideWidth) {
                            var pageX = _a.pageX, pageY = _a.pageY, scrollLeft = _a.scrollLeft, scrollTop = _a.scrollTop;
                            var _b = getPositionFromBodyArea(pageX, pageY, dimension), bodyPositionX = _b.x, bodyPositionY = _b.y;
                            var scrollX = bodyPositionX > leftSideWidth ? scrollLeft : 0;
                            var scrolledPositionX = bodyPositionX + scrollX;
                            var scrolledPositionY = bodyPositionY + scrollTop;
                            return {
                                x: scrolledPositionX,
                                y: scrolledPositionY,
                            };
                        }
                        function judgeOverflow(_a, _b) {
                            var containerX = _a.x, containerY = _a.y;
                            var bodyHeight = _b.bodyHeight, bodyWidth = _b.bodyWidth;
                            var overflowY = 0;
                            var overflowX = 0;
                            if (containerY < 0) {
                                overflowY = -1;
                            }
                            else if (containerY > bodyHeight) {
                                overflowY = 1;
                            }
                            if (containerX < 0) {
                                overflowX = -1;
                            }
                            else if (containerX > bodyWidth) {
                                overflowX = 1;
                            }
                            return {
                                x: overflowX,
                                y: overflowY,
                            };
                        }
                        function getPositionFromBodyArea(pageX, pageY, dimension) {
                            var offsetLeft = dimension.offsetLeft, offsetTop = dimension.offsetTop, tableBorderWidth = dimension.tableBorderWidth, cellBorderWidth = dimension.cellBorderWidth, headerHeight = dimension.headerHeight, summaryHeight = dimension.summaryHeight, summaryPosition = dimension.summaryPosition;
                            var adjustedSummaryHeight = summaryPosition === 'top' ? summaryHeight : 0;
                            return {
                                x: pageX - offsetLeft,
                                y: pageY -
                                    (offsetTop + headerHeight + adjustedSummaryHeight + cellBorderWidth + tableBorderWidth),
                            };
                        }
                        function getOverflowFromMousePosition(pageX, pageY, bodyWidth, dimension) {
                            var bodyHeight = dimension.bodyHeight;
                            var _a = getPositionFromBodyArea(pageX, pageY, dimension), x = _a.x, y = _a.y;
                            return judgeOverflow({ x: x, y: y }, { bodyWidth: bodyWidth, bodyHeight: bodyHeight });
                        }
                        exports.getOverflowFromMousePosition = getOverflowFromMousePosition;
                        function getColumnNameRange(store, dragStartData, dragData, elementInfo) {
                            var allColumns = store.column.allColumns;
                            var scrollTop = elementInfo.scrollTop, scrollLeft = elementInfo.scrollLeft;
                            var startPageX = dragStartData.pageX, startPageY = dragStartData.pageY;
                            var endPageX = dragData.pageX, endPageY = dragData.pageY;
                            var startViewInfo = { pageX: startPageX, pageY: startPageY, scrollTop: scrollTop, scrollLeft: scrollLeft };
                            var endViewInfo = { pageX: endPageX, pageY: endPageY, scrollTop: scrollTop, scrollLeft: scrollLeft };
                            var startColumnIndex = findColumnIndexByPosition(store, startViewInfo);
                            var endColumnIndex = findColumnIndexByPosition(store, endViewInfo);
                            var startColumnName = allColumns[startColumnIndex].name;
                            var endColumnName = allColumns[endColumnIndex].name;
                            return [startColumnName, endColumnName];
                        }
                        exports.getColumnNameRange = getColumnNameRange;
                        function findColumnIndexByPosition(store, viewInfo) {
                            var dimension = store.dimension, columnCoords = store.columnCoords;
                            var widths = columnCoords.widths, areaWidth = columnCoords.areaWidth;
                            var totalColumnOffsets = getTotalColumnOffsets(widths, dimension.cellBorderWidth);
                            var scrolledPosition = getScrolledPosition(viewInfo, dimension, areaWidth.L);
                            return common_1.findOffsetIndex(totalColumnOffsets, scrolledPosition.x);
                        }
                        exports.findColumnIndexByPosition = findColumnIndexByPosition;
                        function findRowIndexByPosition(store, viewInfo) {
                            var dimension = store.dimension, columnCoords = store.columnCoords, rowCoords = store.rowCoords;
                            var areaWidth = columnCoords.areaWidth;
                            var scrolledPosition = getScrolledPosition(viewInfo, dimension, areaWidth.L);
                            return common_1.findOffsetIndex(rowCoords.offsets, scrolledPosition.y);
                        }
                        exports.findRowIndexByPosition = findRowIndexByPosition;


                        /***/ }),
                    /* 52 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.gridAjax = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var serializer_1 = __webpack_require__(125);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var common_1 = __webpack_require__(0);
                        var ENCODED_SPACE_REGEXP = /%20/g;
                        var QS_DELIM_REGEXP = /\?/;
                        function hasRequestBody(method) {
                            return /^(?:POST|PUT|PATCH)$/.test(method.toUpperCase());
                        }
                        function getSerialized(params, serializer) {
                            return common_1.isFunction(serializer) ? serializer(params) : serializer_1.serialize(params);
                        }
                        function handleReadyStateChange(xhr, options) {
                            var eventBus = options.eventBus, success = options.success, preCallback = options.preCallback, postCallback = options.postCallback;
                            // eslint-disable-next-line eqeqeq
                            if (xhr.readyState != XMLHttpRequest.DONE) {
                                return;
                            }
                            preCallback();
                            var gridEvent = new gridEvent_1.default({ xhr: xhr });
                            /**
                             * Occurs when the response is received from the server
                             * @event Grid#response
                             * @type {module:event/gridEvent}
                             * @property {XmlHttpRequest} xhr - XmlHttpRequest
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('response', gridEvent);
                            if (gridEvent.isStopped()) {
                                return;
                            }
                            if (xhr.status === 200) {
                                var response = JSON.parse(xhr.responseText);
                                if (response.result) {
                                    /**
                                     * Occurs after the response event, if the result is true
                                     * @event Grid#successResponse
                                     * @type {module:event/gridEvent}
                                     * @property {XmlHttpRequest} xhr - XmlHttpRequest
                                     * @property {Grid} instance - Current grid instance
                                     */
                                    eventBus.trigger('successResponse', gridEvent);
                                    if (gridEvent.isStopped()) {
                                        return;
                                    }
                                    success(response);
                                }
                                else if (!response.result) {
                                    /**
                                     * Occurs after the response event, if the result is false
                                     * @event Grid#failResponse
                                     * @type {module:event/gridEvent}
                                     * @property {XmlHttpRequest} xhr - XmlHttpRequest
                                     * @property {Grid} instance - Current grid instance
                                     */
                                    eventBus.trigger('failResponse', gridEvent);
                                    if (gridEvent.isStopped()) {
                                        return;
                                    }
                                }
                            }
                            else {
                                /**
                                 * Occurs after the response event, if the response is Error
                                 * @event Grid#errorResponse
                                 * @type {module:event/gridEvent}
                                 * @property {XmlHttpRequest} xhr - XmlHttpRequest
                                 * @property {Grid} instance - Current grid instance
                                 */
                                eventBus.trigger('errorResponse', gridEvent);
                                if (gridEvent.isStopped()) {
                                    return;
                                }
                            }
                            postCallback();
                        }
                        function open(xhr, options) {
                            var url = options.url, method = options.method, serializer = options.serializer, _a = options.params, params = _a === void 0 ? {} : _a;
                            var requestUrl = url;
                            if (!hasRequestBody(method)) {
                                // serialize query string
                                var qs = (QS_DELIM_REGEXP.test(url) ? '&' : '?') + getSerialized(params, serializer);
                                requestUrl = "" + url + qs;
                            }
                            xhr.open(method, requestUrl);
                        }
                        function applyConfig(xhr, options) {
                            var method = options.method, contentType = options.contentType, mimeType = options.mimeType, headers = options.headers, _a = options.withCredentials, withCredentials = _a === void 0 ? false : _a;
                            // set withCredentials
                            xhr.withCredentials = withCredentials;
                            // overide MIME type
                            if (mimeType) {
                                xhr.overrideMimeType(mimeType);
                            }
                            // set user defined request headers
                            if (common_1.isObject(headers)) {
                                Object.keys(headers).forEach(function (name) {
                                    if (headers[name]) {
                                        xhr.setRequestHeader(name, headers[name]);
                                    }
                                });
                            }
                            // set 'Content-Type' when request has body
                            if (hasRequestBody(method)) {
                                xhr.setRequestHeader('Content-Type', contentType + "; charset=UTF-8");
                            }
                            // set 'x-requested-with' header to prevent CSRF in old browser
                            xhr.setRequestHeader('x-requested-with', 'XMLHttpRequest');
                        }
                        function send(xhr, options) {
                            var method = options.method, eventBus = options.eventBus, serializer = options.serializer, preCallback = options.preCallback, _a = options.params, params = _a === void 0 ? {} : _a, _b = options.contentType, contentType = _b === void 0 ? 'application/x-www-form-urlencoded' : _b;
                            var body = null;
                            if (hasRequestBody(method)) {
                                // The space character '%20' is replaced to '+', because application/x-www-form-urlencoded follows rfc-1866
                                body =
                                    contentType.indexOf('application/x-www-form-urlencoded') !== -1
                                        ? getSerialized(params, serializer).replace(ENCODED_SPACE_REGEXP, '+')
                                        : JSON.stringify(params);
                            }
                            xhr.onreadystatechange = function () { return handleReadyStateChange(xhr, options); };
                            var gridEvent = new gridEvent_1.default({ xhr: xhr });
                            /**
                             * Occurs before the http request is sent
                             * @event Grid#beforeRequest
                             * @type {module:event/gridEvent}
                             * @property {XMLHttpRequest} xhr - Current XMLHttpRequest instance
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('beforeRequest', gridEvent);
                            if (gridEvent.isStopped()) {
                                preCallback();
                                return;
                            }
                            xhr.send(body);
                        }
                        function gridAjax(options) {
                            var xhr = new XMLHttpRequest();
                            [open, applyConfig, send].forEach(function (fn) { return fn(xhr, options); });
                        }
                        exports.gridAjax = gridAjax;


                        /***/ }),
                    /* 53 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.createManager = exports.getDataWithOptions = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var observable_1 = __webpack_require__(5);
                        var data_1 = __webpack_require__(6);
                        var paramNameMap = {
                            CREATE: 'createdRows',
                            UPDATE: 'updatedRows',
                            DELETE: 'deletedRows',
                        };
                        // @TODO: fix 'Row' type with record(Dictionary) type to use negate type or other type utility
                        function getDataWithOptions(targetRows, options) {
                            if (options === void 0) { options = {}; }
                            var _a = options.checkedOnly, checkedOnly = _a === void 0 ? false : _a, _b = options.withRawData, withRawData = _b === void 0 ? false : _b, _c = options.rowKeyOnly, rowKeyOnly = _c === void 0 ? false : _c, _d = options.ignoredColumns, ignoredColumns = _d === void 0 ? [] : _d;
                            var rows = targetRows.map(function (row) { return observable_1.getOriginObject(row); });
                            if (checkedOnly) {
                                rows = rows.filter(function (row) { return row._attributes.checked; });
                            }
                            if (ignoredColumns.length) {
                                // @ts-ignore
                                rows = rows.map(function (row) { return common_1.omit.apply(void 0, tslib_1.__spreadArrays([row], ignoredColumns)); });
                            }
                            if (!withRawData) {
                                rows = rows.map(function (row) { return data_1.getOmittedInternalProp(row); });
                            }
                            if (rowKeyOnly) {
                                return rows.map(function (row) { return row.rowKey; });
                            }
                            return rows;
                        }
                        exports.getDataWithOptions = getDataWithOptions;
                        function createManager() {
                            var originData = [];
                            var mixedOrder = false;
                            var dataMap = {
                                CREATE: [],
                                UPDATE: [],
                                DELETE: [],
                            };
                            var splice = function (type, rowKey, row) {
                                var index = common_1.findIndex(function (createdRow) { return createdRow.rowKey === rowKey; }, dataMap[type]);
                                if (index !== -1) {
                                    if (common_1.isUndefined(row)) {
                                        dataMap[type].splice(index, 1);
                                    }
                                    else {
                                        dataMap[type].splice(index, 1, row);
                                    }
                                }
                            };
                            var spliceAll = function (rowKey, row) {
                                splice('CREATE', rowKey, row);
                                splice('UPDATE', rowKey, row);
                                splice('DELETE', rowKey, row);
                            };
                            return {
                                // only for restore
                                setOriginData: function (data) {
                                    originData = data_1.changeRawDataToOriginDataForTree(data);
                                },
                                getOriginData: function () {
                                    return originData;
                                },
                                getModifiedData: function (type, options) {
                                    var _a;
                                    return _a = {}, _a[paramNameMap[type]] = getDataWithOptions(dataMap[type], options), _a;
                                },
                                getAllModifiedData: function (options) {
                                    var _this = this;
                                    return Object.keys(dataMap)
                                        .map(function (key) { return _this.getModifiedData(key, options); })
                                        .reduce(function (acc, data) { return (tslib_1.__assign(tslib_1.__assign({}, acc), data)); }, {});
                                },
                                isModified: function () {
                                    return !!(dataMap.CREATE.length || dataMap.UPDATE.length || dataMap.DELETE.length);
                                },
                                isModifiedByType: function (type) {
                                    return !!dataMap[type].length;
                                },
                                push: function (type, row, mixed) {
                                    if (mixed === void 0) { mixed = false; }
                                    var rowKey = row.rowKey;
                                    mixedOrder = mixedOrder || mixed;
                                    if (type === 'UPDATE' || type === 'DELETE') {
                                        splice('UPDATE', rowKey);
                                        // if the row was already registered in createdRows,
                                        // would update it in createdRows and not add it to updatedRows or deletedRows
                                        if (common_1.someProp('rowKey', rowKey, dataMap.CREATE)) {
                                            if (type === 'UPDATE') {
                                                splice('CREATE', rowKey, row);
                                            }
                                            else {
                                                splice('CREATE', rowKey);
                                            }
                                            return;
                                        }
                                    }
                                    if (!common_1.someProp('rowKey', rowKey, dataMap[type])) {
                                        dataMap[type].push(row);
                                    }
                                },
                                clearSpecificRows: function (rowsMap) {
                                    common_1.forEachObject(function (_, key) {
                                        rowsMap[key].forEach(function (row) {
                                            spliceAll(common_1.isObject(row) ? row.rowKey : row);
                                        });
                                    }, rowsMap);
                                },
                                clear: function (requestTypeCode) {
                                    if (requestTypeCode === 'MODIFY') {
                                        this.clearAll();
                                        return;
                                    }
                                    dataMap[requestTypeCode] = [];
                                },
                                clearAll: function () {
                                    dataMap.CREATE = [];
                                    dataMap.UPDATE = [];
                                    dataMap.DELETE = [];
                                },
                                isMixedOrder: function () {
                                    return mixedOrder;
                                },
                            };
                        }
                        exports.createManager = createManager;


                        /***/ }),
                    /* 54 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getAlertMessage = exports.getConfirmMessage = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var _1 = tslib_1.__importDefault(__webpack_require__(36));
                        var confirmMessageMap = {
                            CREATE: 'net.confirmCreate',
                            UPDATE: 'net.confirmUpdate',
                            DELETE: 'net.confirmDelete',
                            MODIFY: 'net.confirmModify',
                        };
                        var alertMessageMap = {
                            CREATE: 'net.noDataToCreate',
                            UPDATE: 'net.noDataToUpdate',
                            DELETE: 'net.noDataToDelete',
                            MODIFY: 'net.noDataToModify',
                        };
                        function getConfirmMessage(type, count) {
                            return _1.default.get(confirmMessageMap[type], { count: String(count) });
                        }
                        exports.getConfirmMessage = getConfirmMessage;
                        function getAlertMessage(type) {
                            return _1.default.get(alertMessageMap[type]);
                        }
                        exports.getAlertMessage = getAlertMessage;


                        /***/ }),
                    /* 55 */
                    /***/ (function(module, exports, __webpack_require__) {

                        var tslib_1 = __webpack_require__(1);
                        var grid_1 = tslib_1.__importDefault(__webpack_require__(56));
                        __webpack_require__(130);
                        grid_1.default.setLanguage('en');
                        module.exports = grid_1.default;


                        /***/ }),
                    /* 56 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var create_1 = __webpack_require__(57);
                        var root_1 = __webpack_require__(81);
                        var create_2 = __webpack_require__(113);
                        var manager_1 = tslib_1.__importDefault(__webpack_require__(118));
                        var instance_1 = __webpack_require__(7);
                        var i18n_1 = tslib_1.__importDefault(__webpack_require__(36));
                        var clipboard_1 = __webpack_require__(37);
                        var validation_1 = __webpack_require__(122);
                        var dom_1 = __webpack_require__(2);
                        var common_1 = __webpack_require__(0);
                        var observable_1 = __webpack_require__(5);
                        var eventBus_1 = __webpack_require__(8);
                        var data_1 = __webpack_require__(6);
                        var column_1 = __webpack_require__(10);
                        var serverSideDataProvider_1 = __webpack_require__(123);
                        var modifiedDataManager_1 = __webpack_require__(53);
                        var message_1 = __webpack_require__(54);
                        var paginationManager_1 = __webpack_require__(128);
                        var tree_1 = __webpack_require__(21);
                        var rowSpan_1 = __webpack_require__(11);
                        var googleAnalytics_1 = __webpack_require__(129);
                        var filter_1 = __webpack_require__(28);
                        var filter_2 = __webpack_require__(44);
                        /**
                         * Grid public API
                         * @param {Object} options
                         *      @param {HTMLElement} el - The target element to create grid.
                         *      @param {Array|Object} [options.data] - Grid data for making rows. When using the data source, sets to object.
                         *      @param {Object} [options.pageOptions={}] The object for the pagination options.
                         *      @param {Object} [options.header] - Options object for header.
                         *      @param {number} [options.header.height=40] - The height of the header area.
                         *      @param {number} [options.header.align=center] - Horizontal alignment of the header content.
                         *              Available values are 'left', 'center', 'right'.
                         *      @param {number} [options.header.valign=middle] - Vertical alignment of the row header content.
                         *              Available values are 'top', 'middle', 'bottom'.
                         *      @param {Array} [options.header.complexColumns] - This options creates new parent headers of the multiple columns
                         *          which includes the headers of specified columns, and sets up the hierarchy.
                         *          @param {string} [options.header.complexColumns.header] - The header of the complex column to be shown on the header.
                         *          @param {string} [options.header.complexColumns.name] - The name of column that makes tree column.
                         *          @param {Array} [options.header.complexColumns.childNames] - The name of the child header(subheader).
                         *          @param {function} [options.header.complexColumns.renderer] - Sets the custom renderer to customize the header content.
                         *          @param {string} [options.header.complexColumns.headerAlign=center] - Horizontal alignment of the header content.
                         *              Available values are 'left', 'center', 'right'.
                         *          @param {string} [options.header.complexColumns.headerVAlign=middle] - Vertical alignment of the row header content.
                         *              Available values are 'top', 'middle', 'bottom'.
                         *          @param {boolean} [options.header.complexColumns.hideChildHeaders=false] - If set to true, the child columns header are hidden.
                         *          @param {boolean} [options.header.complexColumns.resizable=false] - If set to true, resize-handles of each complex columns will be shown.
                         *      @param {string|number} [options.width='auto'] - Options for grid width.
                         *      @param {string|number} [options.rowHeight] - The height of each rows. The default value is 'auto',
                         *          the height of each rows expands to dom's height. If set to number, the height is fixed.
                         *      @param {number} [options.minRowHeight=40] - The minimum height of each rows. When this value is larger than
                         *          the row's height, it set to the row's height.
                         *      @param {string|number} [options.bodyHeight] - The height of body area. The default value is 'auto',
                         *          the height of body area expands to total height of rows. If set to 'fitToParent', the height of the grid
                         *          will expand to fit the height of parent element. If set to number, the height is fixed.
                         *      @param {number} [options.minBodyHeight=minRowHeight] - The minimum height of body area. When this value
                         *          is larger than the body's height, it set to the body's height.
                         *      @param {Object} [options.columnOptions] - Option object for all columns
                         *      @param {number} [options.columnOptions.minWidth=50] - Minimum width of each columns
                         *      @param {boolean} [options.columnOptions.resizable=false] - If set to true, resize-handles of each columns
                         *          will be shown.
                         *      @param {number} [options.columnOptions.frozenCount=0] - The number of frozen columns.
                         *          The columns indexed from 0 to this value will always be shown on the left side.
                         *          {@link Grid#setFrozenColumnCount} can be used for setting this value dynamically.
                         *      @param {number} [options.columnOptions.frozenBorderWidth=1] - The value of frozen border width.
                         *          When the frozen columns are created by "frozenCount" option, the frozen border width set.
                         *      @param {Object} [options.treeColumnOptions] - Option object for the tree column.
                         *      @param {string} [options.treeColumnOptions.name] - The name of column that makes tree column.
                         *      @param {boolean} [options.treeColumnOptions.useIcon=true] - If set to true, the folder or file icon is created on
                         *          the left side of the tree cell data.
                         *      @param {boolean} [options.treeColumnOptions.useCascadingCheckbox] - If set to true, a cascading relationship is
                         *          created in the checkbox between parent and child rows.
                         *      @param {Object} [options.copyOptions] - Option object for clipboard copying
                         *      @param {boolean} [options.copyOptions.useFormattedValue] - Whether to use formatted values or original values
                         *          as a string to be copied to the clipboard
                         *      @param {boolean} [options.copyOptions.useListItemText] - Copy select or checkbox cell values to 'text'
                         *          rather than 'value' of the listItem option.
                         *      @param {string|function} [options.copyOptions.customValue] - Copy text with 'formatter' in cell.
                         *      @param {boolean} [options.useClientSort=true] - If set to true, sorting will be executed by client itself
                         *          without server.
                         *      @param {string} [options.editingEvent='dblclick'] - If set to 'click', editable cell in the view-mode will be
                         *          changed to edit-mode by a single click.
                         *      @param {boolean} [options.scrollX=true] - Specifies whether to show horizontal scrollbar.
                         *      @param {boolean} [options.scrollY=true] - Specifies whether to show vertical scrollbar.
                         *      @param {boolean} [options.showDummyRows=false] - If set to true, empty area will be filled with dummy rows.
                         *      @param {string} [options.keyColumnName] - The name of the column to be used to identify each rows.
                         *          If not specified, unique value for each rows will be created internally.
                         *      @param {boolean} [options.heightResizable=false] - If set to true, a handle for resizing height will be shown.
                         *      @param {string} [options.selectionUnit='cell'] - The unit of selection on Grid. ('cell', 'row')
                         *      @param {Array} [options.rowHeaders] - Options for making the row header. The row header content is number of
                         *          each row or input element. The value of each item is enable to set string type. (ex: ['rowNum', 'checkbox'])
                         *          @param {string} [options.rowHeaders.type] - The type of the row header. ('rowNum', 'checkbox')
                         *          @param {string} [options.rowHeaders.header] - The header of the row header.
                         *          @param {number} [options.rowHeaders.width] - The width of the row header column. The unit is pixel.
                         *              If this value isn't set, the column's width sets to default value.
                         *          @param {string} [options.rowHeaders.align=left] - Horizontal alignment of the row header content.
                         *              Available values are 'left', 'center', 'right'.
                         *          @param {string} [options.rowHeaders.valign=middle] - Vertical alignment of the row header content.
                         *              Available values are 'top', 'middle', 'bottom'.
                         *          @param {function} [options.rowHeaders.renderer] - Sets the custom renderer to customize the header content.
                         *      @param {Array} options.columns - The configuration of the grid columns.
                         *          @param {string} options.columns.name - The name of the column.
                         *          @param {boolean} [options.columns.ellipsis=false] - If set to true, ellipsis will be used
                         *              for overflowing content.
                         *          @param {string} [options.columns.align=left] - Horizontal alignment of the column content.
                         *              Available values are 'left', 'center', 'right'.
                         *          @param {string} [options.columns.valign=middle] - Vertical alignment of the column content.
                         *              Available values are 'top', 'middle', 'bottom'.
                         *          @param {string} [options.columns.className] - The name of the class to be used for all cells of
                         *              the column.
                         *          @param {string} [options.columns.header] - The header of the column to be shown on the header.
                         *          @param {number} [options.columns.width] - The width of the column. The unit is pixel. If this value
                         *              isn't set, the column's width is automatically resized.
                         *          @param {number} [options.columns.minWidth=50] - The minimum width of the column. The unit is pixel.
                         *          @param {boolean} [options.columns.hidden] - If set to true, the column will not be shown.
                         *          @param {boolean} [options.columns.resizable] - If set to false, the width of the column
                         *              will not be changed.
                         *          @param {Object} [options.columns.validation] - The options to be used for validation.
                         *              Validation is executed whenever data is changed or the {@link Grid#validate} is called.
                         *          @param {boolean} [options.columns.validation.required=false] - If set to true, the data of the column
                         *              will be checked to be not empty.
                         *          @param {number|string} [options.columns.validation.dataType='string'] - Specifies the type of the cell value.
                         *              Available types are 'string' and 'number'.
                         *          @param {number} [options.columns.validation.min] - If set to numeric value, the data of the column
                         *              will be checked to be greater than 'min' value.
                         *              Available types are 'string' and 'number'.
                         *          @param {number} [options.columns.validation.max] - If set to numeric value, the data of the column
                         *              will be checked to be less than 'max' value.
                         *          @param {RegExp} [options.columns.validation.regExp] - If set to regular expression, the data of the column
                         *              will be checked using the regular expression.
                         *          @param {function} [options.columns.validation.validatorFn] - If set to function, the data of the column
                         *              will be checked using the result of the custom validator.
                         *          @param {boolean} [options.columns.validation.unique] - If set to true, check the uniqueness on the data of the column.
                         *          @param {string} [options.columns.defaultValue] - The default value to be shown when the column
                         *              doesn't have a value.
                         *          @param {function|string} [options.columns.formatter] - The function that formats the value of the cell.
                         *              The return value of the function will be shown as the value of the cell. If set to 'listItemText',
                         *              the value will be shown the text.
                         *          @param {boolean} [options.columns.escapeHTML=false] - If set to true, the value of the cell
                         *              will be encoded as HTML entities.
                         *          @param {boolean} [options.columns.ignored=false] - If set to true, the value of the column will be
                         *               ignored when setting up the list of modified rows.
                         *          @param {boolean} [options.columns.sortable=false] - If set to true, sort button will be shown on
                         *              the right side of the column header, which executes the sort action when clicked.
                         *          @param {string} [options.columns.sortingType='asc'] - If set to 'desc', will execute descending sort initially
                         *              when sort button is clicked.
                         *          @param {function} [options.columns.comparator] - The custom comparator that sorts the data of the column.
                         *              The return value should be same as the result of general 'compareFunction'.
                         *          @param {function} [options.columns.onBeforeChange] - The function that will be
                         *              called before changing the value of the cell. If stop() method in event object is called,
                         *              the changing will be canceled.
                         *          @param {function} [options.columns.onAfterChange] - The function that will be
                         *              called after changing the value of the cell.
                         *          @param {Object} [options.columns.editor] - The object for configuring editing UI.
                         *              @param {string|function} [options.columns.editor.type='text'] - The string value that specifies
                         *                  the type of the editing UI. Available values are 'text', 'password', 'select', 'radio', 'checkbox'.
                         *                  When using the custom editor, sets to the customized renderer constructor.
                         *              @param {Object} [options.columns.editor.options] - Option object using editor
                         *                  @param {Array} [options.columns.editor.options.listItems] - Specifies the option items for the
                         *                       'select', 'radio', 'checkbox' type. The item of the array must contain properties named
                         *                       'text' and 'value'. (e.g. [{text: 'option1', value: 1}, {...}])
                         *              @param {Object} [options.columns.copyOptions] - Option object for clipboard copying.
                         *                  This option is column specific, and overrides the global copyOptions.
                         *              @param {boolean} [options.columns.copyOptions.useFormattedValue] - Whether to use
                         *                  formatted values or original values as a string to be copied to the clipboard
                         *              @param {boolean} [options.columns.copyOptions.useListItemText] - Whether to use
                         *                  concatenated text or original values as a string to be copied to the clipboard
                         *              @param {function} [options.columns.copyOptions.customValue] - Whether to use
                         *                  customized value from "customValue" callback or original values as a string to be copied to the clipboard
                         *          @param {Array} [options.columns.relations] - Specifies relation between this and other column.
                         *              @param {Array} [options.columns.relations.targetNames] - Array of the names of target columns.
                         *              @param {function} [options.columns.relations.disabled] - If returns true, target columns
                         *                  will be disabled.
                         *              @param {function} [options.columns.relations.editable] - If returns true, target columns
                         *                  will be editable.
                         *              @param {function} [options.columns.relations.listItems] - The function whose return
                         *                  value specifies the option list for the 'select', 'radio', 'checkbox' type.
                         *                  The options list of target columns will be replaced with the return value of this function.
                         *          @param {string} [options.columns.whiteSpace='nowrap'] - If set to 'normal', the text line is broken
                         *              by fitting to the column's width. If set to 'pre', spaces are preserved and the text is braken by
                         *              new line characters. If set to 'pre-wrap', spaces are preserved, the text line is broken by
                         *              fitting to the column's width and new line characters. If set to 'pre-line', spaces are merged,
                         *              the text line is broken by fitting to the column's width and new line characters.
                         *      @param {Object} [options.summary] - The object for configuring summary area.
                         *          @param {number} [options.summary.height] - The height of the summary area.
                         *          @param {string} [options.summary.position='bottom'] - The position of the summary area. ('bottom', 'top')
                         *          @param {(string|Object)} [options.summary.defaultContent]
                         *              The configuring of summary cell for every column.
                         *              This options can be overriden for each column by columnContent options.
                         *              If type is string, the value is used as HTML of summary cell for every columns
                         *              without auto-calculation.
                         *              @param {boolean} [options.summary.defaultContent.useAutoSummary=true]
                         *                  If set to true, the summary value of every column is served as a parameter to the template
                         *                  function whenever data is changed.
                         *              @param {function} [options.summary.defaultContent.template] - Template function which returns the
                         *                  content(HTML) of the column of the summary. This function takes an K-V object as a parameter
                         *                  which contains a summary values keyed by 'sum', 'avg', 'min', 'max' and 'cnt'.
                         *          @param {Object} [options.summary.columnContent]
                         *              The configuring of summary cell for each column.
                         *              Sub options below are keyed by each column name.
                         *              If type of value of this object is string, the value is used as HTML of summary cell for
                         *              the column without auto-calculation.
                         *              @param {boolean} [options.summary.columnContent.useAutoSummary=true]
                         *                  If set to true, the summary value of each column is served as a parameter to the template
                         *                  function whenever data is changed.
                         *              @param {function} [options.summary.columnContent.template] - Template function which returns the
                         *                  content(HTML) of the column of the summary. This function takes an K-V object as a parameter
                         *                  which contains a summary values keyed by 'sum', 'avg', 'min', 'max' and 'cnt'.
                         *      @param {boolean} [options.usageStatistics=true] Send the hostname to google analytics.
                         *          If you do not want to send the hostname, this option set to false.
                         *      @param {function} [options.onGridMounted] - The function that will be called after rendering the grid.
                         *      @param {function} [options.onGridUpdated] - The function that will be called after updating the all data of the grid and rendering the grid.
                         *      @param {function} [options.onGridBeforeDestroy] - The function that will be called before destroying the grid.
                         */
                        var Grid = /** @class */ (function () {
                            function Grid(options) {
                                var _this = this;
                                var el = options.el, _a = options.usageStatistics, usageStatistics = _a === void 0 ? true : _a;
                                var id = instance_1.register(this);
                                var store = create_1.createStore(id, options);
                                var dispatch = create_2.createDispatcher(store);
                                var eventBus = eventBus_1.createEventBus(id);
                                var dataProvider = serverSideDataProvider_1.createProvider(store, dispatch, options.data);
                                var dataManager = modifiedDataManager_1.createManager();
                                var paginationManager = paginationManager_1.createPaginationManager();
                                this.el = el;
                                this.store = store;
                                this.dispatch = dispatch;
                                this.eventBus = eventBus;
                                this.dataProvider = dataProvider;
                                this.dataManager = dataManager;
                                this.paginationManager = paginationManager;
                                this.usageStatistics = usageStatistics;
                                if (this.usageStatistics) {
                                    googleAnalytics_1.sendHostname();
                                }
                                instance_1.registerDataSources(id, dataProvider, dataManager, paginationManager);
                                if (!manager_1.default.isApplied()) {
                                    manager_1.default.apply('default');
                                }
                                if (Array.isArray(options.data)) {
                                    this.dataManager.setOriginData(options.data);
                                }
                                var lifeCycleEvent = common_1.pick(options, 'onGridMounted', 'onGridBeforeDestroy', 'onGridUpdated');
                                Object.keys(lifeCycleEvent).forEach(function (eventName) {
                                    _this.eventBus.on(eventName, lifeCycleEvent[eventName]);
                                });
                                this.gridEl = preact_1.render(preact_1.h(root_1.Root, { store: store, dispatch: dispatch, rootElement: el }), el);
                                this.dispatch('setColumnWidthsByText');
                            }
                            /**
                             * Apply theme to all grid instances with the preset options of a given name.
                             * @static
                             * @param {string} presetName - preset theme name. Available values are 'default', 'striped' and 'clean'.
                             * @param {Object} [extOptions] - if exist, extend preset options with this object.
                             *     @param {Object} [extOptions.outline] - Styles for the table outline.
                             *         @param {string} [extOptions.outline.border] - Color of the table outline.
                             *         @param {boolean} [extOptions.outline.showVerticalBorder] - Whether vertical outlines of
                             *             the table are visible.
                             *     @param {Object} [extOptions.selection] - Styles for a selection layer.
                             *         @param {string} [extOptions.selection.background] - Background color of a selection layer.
                             *         @param {string} [extOptions.selection.border] - Border color of a selection layer.
                             *     @param {Object} [extOptions.scrollbar] - Styles for scrollbars.
                             *         @param {string} [extOptions.scrollbar.border] - Border color of scrollbars.
                             *         @param {string} [extOptions.scrollbar.background] - Background color of scrollbars.
                             *         @param {string} [extOptions.scrollbar.emptySpace] - Color of extra spaces except scrollbar.
                             *         @param {string} [extOptions.scrollbar.thumb] - Color of thumbs in scrollbars.
                             *         @param {string} [extOptions.scrollbar.active] - Color of arrows(for IE) or
                             *              thumb:hover(for other browsers) in scrollbars.
                             *     @param {Object} [extOptions.frozenBorder] - Styles for a frozen border.
                             *         @param {string} [extOptions.frozenBorder.border] - Border color of a frozen border.
                             *     @param {Object} [extOptions.area] - Styles for the table areas.
                             *         @param {Object} [extOptions.area.header] - Styles for the header area in the table.
                             *             @param {string} [extOptions.area.header.background] - Background color of the header area
                             *                 in the table.
                             *             @param {string} [extOptions.area.header.border] - Border color of the header area
                             *                 in the table.
                             *         @param {Object} [extOptions.area.body] - Styles for the body area in the table.
                             *             @param {string} [extOptions.area.body.background] - Background color of the body area
                             *                 in the table.
                             *         @param {Object} [extOptions.area.summary] - Styles for the summary area in the table.
                             *             @param {string} [extOptions.area.summary.background] - Background color of the summary area
                             *                 in the table.
                             *             @param {string} [extOptions.area.summary.border] - Border color of the summary area
                             *                 in the table.
                             *     @param {Object} [extOptions.row] - Styles for the table rows.
                             *         @param {Object} [extOptions.row.even] - Styles for even row.
                             *             @param {string} [extOptions.row.even.background] - background color of even row.
                             *             @param {string} [extOptions.row.even.text] - text color of even row.
                             *         @param {Object} [extOptions.row.odd] - Styles for odd row.
                             *             @param {string} [extOptions.row.odd.background] - background color of cells in odd row.
                             *             @param {string} [extOptions.row.odd.text] - text color of odd row.
                             *         @param {Object} [extOptions.row.dummy] - Styles of dummy row.
                             *             @param {string} [extOptions.row.dummy.background] - background color of dummy row.
                             *         @param {Object} [extOptions.row.hover] - Styles of hovered row.
                             *             @param {string} [extOptions.row.hover.background] - background color of hovered row.
                             *     @param {Object} [extOptions.cell] - Styles for the table cells.
                             *         @param {Object} [extOptions.cell.normal] - Styles for normal cells.
                             *             @param {string} [extOptions.cell.normal.background] - Background color of normal cells.
                             *             @param {string} [extOptions.cell.normal.border] - Border color of normal cells.
                             *             @param {string} [extOptions.cell.normal.text] - Text color of normal cells.
                             *             @param {boolean} [extOptions.cell.normal.showVerticalBorder] - Whether vertical borders of
                             *                 normal cells are visible.
                             *             @param {boolean} [extOptions.cell.normal.showHorizontalBorder] - Whether horizontal borders of
                             *                 normal cells are visible.
                             *         @param {Object} [extOptions.cell.header] - Styles for header cells.
                             *             @param {string} [extOptions.cell.header.background] - Background color of header cells.
                             *             @param {string} [extOptions.cell.header.border] - border color of header cells.
                             *             @param {string} [extOptions.cell.header.text] - text color of header cells.
                             *             @param {boolean} [extOptions.cell.header.showVerticalBorder] - Whether vertical borders of
                             *                 header cells are visible.
                             *             @param {boolean} [extOptions.cell.header.showHorizontalBorder] - Whether horizontal borders of
                             *                 header cells are visible.
                             *         @param {Object} [extOptions.cell.selectedHeader] - Styles for selected header cells.
                             *             @param {string} [extOptions.cell.selectedHeader.background] - background color of selected header cells.
                             *         @param {Object} [extOptions.cell.rowHeader] - Styles for row's header cells.
                             *             @param {string} [extOptions.cell.rowHeader.background] - Background color of row's header cells.
                             *             @param {string} [extOptions.cell.rowHeader.border] - border color of row's header cells.
                             *             @param {string} [extOptions.cell.rowHeader.text] - text color of row's header cells.
                             *             @param {boolean} [extOptions.cell.rowHeader.showVerticalBorder] - Whether vertical borders of
                             *                 row's header cells are visible.
                             *             @param {boolean} [extOptions.cell.rowHeader.showHorizontalBorder] - Whether horizontal borders of
                             *                 row's header cells are visible.
                             *         @param {Object} [extOptions.cell.selectedRowHeader] - Styles for selected row's header cells.
                             *             @param {string} [extOptions.cell.selectedRowHeader.background] - background color of selected row's haed cells.
                             *         @param {Object} [extOptions.cell.summary] - Styles for cells in the summary area.
                             *             @param {string} [extOptions.cell.summary.background] - Background color of cells in the summary area.
                             *             @param {string} [extOptions.cell.summary.border] - border color of cells in the summary area.
                             *             @param {string} [extOptions.cell.summary.text] - text color of cells in the summary area.
                             *             @param {boolean} [extOptions.cell.summary.showVerticalBorder] - Whether vertical borders of
                             *                 cells in the summary area are visible.
                             *             @param {boolean} [extOptions.cell.summary.showHorizontalBorder] - Whether horizontal borders of
                             *                 cells in the summary area are visible.
                             *         @param {Object} [extOptions.cell.focused] - Styles for a focused cell.
                             *             @param {string} [extOptions.cell.focused.background] - background color of a focused cell.
                             *             @param {string} [extOptions.cell.focused.border] - border color of a focused cell.
                             *         @param {Object} [extOptions.cell.focusedInactive] - Styles for a inactive focus cell.
                             *             @param {string} [extOptions.cell.focusedInactive.border] - border color of a inactive focus cell.
                             *         @param {Object} [extOptions.cell.required] - Styles for required cells.
                             *             @param {string} [extOptions.cell.required.background] - background color of required cells.
                             *             @param {string} [extOptions.cell.required.text] - text color of required cells.
                             *         @param {Object} [extOptions.cell.editable] - Styles for editable cells.
                             *             @param {string} [extOptions.cell.editable.background] - background color of the editable cells.
                             *             @param {string} [extOptions.cell.editable.text] - text color of the selected editable cells.
                             *         @param {Object} [extOptions.cell.disabled] - Styles for disabled cells.
                             *             @param {string} [extOptions.cell.disabled.background] - background color of disabled cells.
                             *             @param {string} [extOptions.cell.disabled.text] - text color of disabled cells.
                             *         @param {Object} [extOptions.cell.invalid] - Styles for invalid cells.
                             *             @param {string} [extOptions.cell.invalid.background] - background color of invalid cells.
                             *             @param {string} [extOptions.cell.invalid.text] - text color of invalid cells.
                             *         @param {Object} [extOptions.cell.currentRow] - Styles for cells in a current row.(deprecated since version 4.4.0)
                             *             @param {string} [extOptions.cell.currentRow.background] - background color of cells in a current row.
                             *             @param {string} [extOptions.cell.currentRow.text] - text color of cells in a current row.
                             *         @param {Object} [extOptions.cell.evenRow] - Styles for cells in even rows.(deprecated since version 4.4.0)
                             *             @param {string} [extOptions.cell.evenRow.background] - background color of cells in even rows.
                             *             @param {string} [extOptions.cell.evenRow.text] - text color of cells in even rows.
                             *         @param {Object} [extOptions.cell.oddRow] - Styles for cells in even rows.(deprecated since version 4.4.0)
                             *             @param {string} [extOptions.cell.oddRow.background] - background color of cells in odd rows.
                             *             @param {string} [extOptions.cell.oddRow.text] - text color of cells in odd rows.
                             *         @param {Object} [extOptions.cell.dummy] - Styles for dummy cells.(deprecated since version 4.4.0)
                             *             @param {string} [extOptions.cell.dummy.background] - background color of dummy cells.
                             * @example
                             * var Grid = tui.Grid; // or require('tui-grid')
                             *
                             * Grid.applyTheme('striped', {
                             *     grid: {
                             *         border: '#aaa',
                             *         text: '#333'
                             *     },
                             *     cell: {
                             *         disabled: {
                             *             text: '#999'
                             *         }
                             *     }
                             * });
                             */
                            Grid.applyTheme = function (presetName, extOptions) {
                                manager_1.default.apply(presetName, extOptions);
                            };
                            /**
                             * Set language
                             * @static
                             * @param {string} localeCode - Code to set locale messages and
                             *     this is the language or language-region combination (ex: en-US)
                             * @param {Object} [data] - Messages using in Grid
                             * @example
                             * var Grid = tui.Grid; // or require('tui-grid')
                             *
                             * Grid.setLanguage('en'); // default and set English
                             * Grid.setLanguage('ko'); // set Korean
                             * Grid.setLanguage('en-US', { // set new language
                             *      display: {
                             *          noData: 'No data.',
                             *          loadingData: 'Loading data.',
                             *          resizeHandleGuide: 'You can change the width of the column by mouse drag, ' +
                             *                              'and initialize the width by double-clicking.'
                             *      },
                             *      net: {
                             *          confirmCreate: 'Are you sure you want to create {{count}} data?',
                             *          confirmUpdate: 'Are you sure you want to update {{count}} data?',
                             *          confirmDelete: 'Are you sure you want to delete {{count}} data?',
                             *          confirmModify: 'Are you sure you want to modify {{count}} data?',
                             *          noDataToCreate: 'No data to create.',
                             *          noDataToUpdate: 'No data to update.',
                             *          noDataToDelete: 'No data to delete.',
                             *          noDataToModify: 'No data to modify.',
                             *          failResponse: 'An error occurred while requesting data.\nPlease try again.'
                             *      }
                             * });
                             */
                            Grid.setLanguage = function (localeCode, data) {
                                i18n_1.default.setLanguage(localeCode, data);
                            };
                            /**
                             * Set the width of the dimension.
                             * @param {number} width - The width of the dimension
                             */
                            Grid.prototype.setWidth = function (width) {
                                this.dispatch('setWidth', width, false);
                            };
                            /**
                             * Set the height of the dimension.
                             * @param {number} height - The height of the dimension
                             */
                            Grid.prototype.setHeight = function (height) {
                                this.dispatch('setHeight', height);
                            };
                            /**
                             * Set the height of body-area.
                             * @param {number} bodyHeight - The number of pixel
                             */
                            Grid.prototype.setBodyHeight = function (bodyHeight) {
                                this.dispatch('setBodyHeight', bodyHeight);
                            };
                            /**
                             * Set options for header.
                             * @param {Object} options - Options for header
                             * @param {number} [options.height] -  The height value
                             * @param {Array} [options.complexColumns] - The complex columns info
                             */
                            Grid.prototype.setHeader = function (_a) {
                                var height = _a.height, complexColumns = _a.complexColumns;
                                if (height) {
                                    this.dispatch('setHeaderHeight', height);
                                }
                                if (complexColumns) {
                                    this.dispatch('setComplexColumnHeaders', complexColumns);
                                }
                            };
                            /**
                             * Set the count of frozen columns.
                             * @param {number} count - The count of columns to be frozen
                             */
                            Grid.prototype.setFrozenColumnCount = function (count) {
                                this.dispatch('setFrozenColumnCount', count);
                            };
                            /**
                             * Hide columns
                             * @param {...string} arguments - Column names to hide
                             */
                            Grid.prototype.hideColumn = function (columnName) {
                                this.dispatch('hideColumn', columnName);
                            };
                            /**
                             * Show columns
                             * @param {...string} arguments - Column names to show
                             */
                            Grid.prototype.showColumn = function (columnName) {
                                this.dispatch('showColumn', columnName);
                            };
                            /**
                             * Select cells or rows by range
                             * @param {Object} range - Selection range
                             *     @param {Array} [range.start] - Index info of start selection (ex: [rowIndex, columnIndex])
                             *     @param {Array} [range.end] - Index info of end selection (ex: [rowIndex, columnIndex])
                             */
                            Grid.prototype.setSelectionRange = function (range) {
                                this.dispatch('setSelection', range);
                            };
                            /**
                             * get Selection range
                             * @returns {Object | null} range - Selection range
                             *     @returns {Array} [range.start] - Index info of start selection (ex: [rowIndex, columnIndex])
                             *     @returns {Array} [range.end] - Index info of end selection (ex: [rowIndex, columnIndex])
                             */
                            Grid.prototype.getSelectionRange = function () {
                                var rangeWithRowHeader = this.store.selection.rangeWithRowHeader;
                                if (rangeWithRowHeader) {
                                    var column = rangeWithRowHeader.column, row = rangeWithRowHeader.row;
                                    return {
                                        start: [row[0], column[0]],
                                        end: [row[1], column[1]],
                                    };
                                }
                                return null;
                            };
                            /**
                             * Return data of currently focused cell
                             * @returns {number|string} rowKey - The unique key of the row
                             * @returns {string} columnName - The name of the column
                             * @returns {string} value - The value of the cell
                             */
                            Grid.prototype.getFocusedCell = function () {
                                var _a = this.store.focus, columnName = _a.columnName, rowKey = _a.rowKey;
                                var value = null;
                                if (rowKey !== null && columnName !== null) {
                                    value = this.getValue(rowKey, columnName);
                                }
                                return { rowKey: rowKey, columnName: columnName, value: value };
                            };
                            /**
                             * Remove focus from the focused cell.
                             */
                            Grid.prototype.blur = function () {
                                this.dispatch('setFocusInfo', null, null, false);
                            };
                            /**
                             * Focus to the cell identified by given rowKey and columnName.
                             * @param {Number|String} rowKey - rowKey
                             * @param {String} columnName - columnName
                             * @param {Boolean} [setScroll=true] - if set to true, move scroll position to focused position
                             * @returns {Boolean} true if focused cell is changed
                             */
                            Grid.prototype.focus = function (rowKey, columnName, setScroll) {
                                var _this = this;
                                if (setScroll === void 0) { setScroll = true; }
                                var row = this.getRow(rowKey);
                                if (!row || !data_1.getRowHeight(row, this.store.dimension.rowHeight)) {
                                    return false;
                                }
                                this.dispatch('setFocusInfo', rowKey, columnName, true);
                                if (setScroll) {
                                    // Use setTimeout to wait until the DOM element is actually mounted or updated.
                                    // For example, when expands the tree row at bottom of the grid area with scroll,
                                    // grid needs to wait for mounting the expanded tree DOM element to detect the accurate scrolling position.
                                    setTimeout(function () {
                                        _this.dispatch('setScrollToFocus');
                                    });
                                }
                                return true;
                            };
                            /**
                             * Focus to the cell identified by given rowIndex and columnIndex.
                             * @param {Number} rowIndex - rowIndex
                             * @param {Number} columnIndex - columnIndex
                             * @param {boolean} [setScroll=true] - if set to true, scroll to focused cell
                             * @returns {Boolean} true if success
                             */
                            Grid.prototype.focusAt = function (rowIndex, columnIndex, setScroll) {
                                var _a = data_1.getCellAddressByIndex(this.store, rowIndex, columnIndex), rowKey = _a.rowKey, columnName = _a.columnName;
                                if (!common_1.isUndefined(rowKey) && columnName) {
                                    return this.focus(rowKey, columnName, setScroll);
                                }
                                return false;
                            };
                            /**
                             * Make view ready to get keyboard input.
                             */
                            Grid.prototype.activateFocus = function () {
                                this.dispatch('setNavigating', true);
                            };
                            /**
                             * Set focus on the cell at the specified index of row and column and starts to edit.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {string} columnName - The name of the column
                             * @param {boolean} [setScroll=true] - If set to true, the view will scroll to the cell element.
                             */
                            Grid.prototype.startEditing = function (rowKey, columnName, setScroll) {
                                if (this.focus(rowKey, columnName, setScroll)) {
                                    if (this.store.focus.rowKey === rowKey && this.store.focus.columnName === columnName) {
                                        this.dispatch('startEditing', rowKey, columnName);
                                    }
                                }
                            };
                            /**
                             * Set focus on the cell at the specified index of row and column and starts to edit.
                             * @param {number|string} rowIndex - The index of the row
                             * @param {string} columnIndex - The index of the column
                             * @param {boolean} [setScroll=true] - If set to true, the view will scroll to the cell element.
                             */
                            Grid.prototype.startEditingAt = function (rowIndex, columnIndex, setScroll) {
                                var _a = data_1.getCellAddressByIndex(this.store, rowIndex, columnIndex), rowKey = _a.rowKey, columnName = _a.columnName;
                                this.startEditing(rowKey, columnName, setScroll);
                            };
                            /**
                             * Save editing value and finishes to edit.
                             */
                            Grid.prototype.finishEditing = function (rowKey, columnName, value) {
                                // @TODO: should change the function signature as removing all current paramaters.
                                // The signature will be as below.
                                // ex) finishEditing()
                                this.dispatch('saveAndFinishEditing', value);
                            };
                            /**
                             * Cancel the editing.
                             */
                            Grid.prototype.cancelEditing = function () {
                                var editingAddress = this.store.focus.editingAddress;
                                if (editingAddress) {
                                    var rowKey = editingAddress.rowKey, columnName = editingAddress.columnName;
                                    var value = this.getValue(rowKey, columnName);
                                    this.dispatch('finishEditing', rowKey, columnName, value);
                                }
                            };
                            /**
                             * Set the value of the cell identified by the specified rowKey and columnName.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {string} columnName - The name of the column
                             * @param {number|string} value - The value to be set
                             * @param {boolean} [checkCellState=false] - If set to true, only editable and not disabled cells will be affected.
                             */
                            Grid.prototype.setValue = function (rowKey, columnName, value, checkCellState) {
                                this.dispatch('setValue', rowKey, columnName, value, checkCellState);
                            };
                            /**
                             * Return the value of the cell identified by the rowKey and columnName.
                             * @param {number|string} rowKey - The unique key of the target row.
                             * @param {string} columnName - The name of the column
                             * @returns {number|string|boolean|null} - The value of the cell
                             */
                            Grid.prototype.getValue = function (rowKey, columnName) {
                                var _a;
                                var _b = this.store, data = _b.data, column = _b.column, id = _b.id;
                                var targetRow = data_1.findRowByRowKey(data, column, id, rowKey, false);
                                if (targetRow) {
                                    return (_a = targetRow[columnName]) !== null && _a !== void 0 ? _a : null;
                                }
                                return null;
                            };
                            /**
                             * Set the all values in the specified column.
                             * @param {string} columnName - The name of the column
                             * @param {number|string} columnValue - The value to be set
                             * @param {boolean} [checkCellState=false] - If set to true, only editable and not disabled cells will be affected.
                             */
                            Grid.prototype.setColumnValues = function (columnName, columnValue, checkCellState) {
                                this.dispatch('setColumnValues', columnName, columnValue, checkCellState);
                            };
                            /**
                             * Return the HTMLElement of the cell identified by the rowKey and columnName.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {string} columnName - The name of the column
                             * @returns {HTMLElement} - The HTMLElement of the cell element
                             */
                            Grid.prototype.getElement = function (rowKey, columnName) {
                                return this.el.querySelector("." + dom_1.cls('cell') + "[" + dom_1.dataAttr.ROW_KEY + "=\"" + rowKey + "\"][" + dom_1.dataAttr.COLUMN_NAME + "=\"" + columnName + "\"]");
                            };
                            /**
                             * Set the HTML string of given column summary.
                             * The type of content is the same as the options.summary.columnContent of the constructor.
                             * @param {string} columnName - column name
                             * @param {string|object} columnContent - HTML string or options object.
                             */
                            Grid.prototype.setSummaryColumnContent = function (columnName, columnContent) {
                                this.dispatch('setSummaryColumnContent', columnName, columnContent);
                            };
                            /**
                             * Return the values of given column summary.
                             * If the column name is not specified, all values of available columns are returned.
                             * The shape of returning object looks like the example below.
                             * @param {string} [columnName] - column name
                             * @returns {Object}
                             * @example
                             * {
                             *     sum: 1000,
                             *     avg: 200,
                             *     max: 300,
                             *     min: 50,
                             *     cnt: 5,
                             *     filtered: {
                             *       sum: 1000,
                             *       avg: 200,
                             *       max: 300,
                             *       min: 50,
                             *       cnt: 5
                             *     }
                             * }
                             */
                            Grid.prototype.getSummaryValues = function (columnName) {
                                var summary = this.store.summary;
                                var content = summary.summaryColumnContents[columnName];
                                if (content && content.useAutoSummary) {
                                    return summary.summaryValues[columnName];
                                }
                                return null;
                            };
                            /**
                             * Return a list of the column model.
                             * @returns {Array} - A list of the column model.
                             */
                            Grid.prototype.getColumns = function () {
                                return this.store.column.allColumns
                                    .filter(function (_a) {
                                        var name = _a.name;
                                        return !column_1.isRowHeader(name);
                                    })
                                    .map(function (column) { return observable_1.getOriginObject(column); });
                            };
                            /**
                             * Set the list of column model.
                             * @param {Array} columns - A new list of column model
                             */
                            Grid.prototype.setColumns = function (columns) {
                                this.dispatch('setColumns', columns);
                            };
                            /**
                             * Set columns title
                             * @param {Object} columnsMap - columns map to be change
                             * @example
                             * {
                             *      columnName1: 'title1',
                             *      columnName2: 'title2',
                             *      columnName3: 'title3'
                             * }
                             */
                            Grid.prototype.setColumnHeaders = function (columnsMap) {
                                this.dispatch('changeColumnHeadersByName', columnsMap);
                            };
                            /**
                             * Reset the width of each column by using initial setting of column models.
                             */
                            Grid.prototype.resetColumnWidths = function (widths) {
                                this.dispatch('resetColumnWidths', widths);
                            };
                            /**
                             * Return a list of all values in the specified column.
                             * @param {string} columnName - The name of the column
                             * @returns {(Array|string)} - A List of all values in the specified column. (or JSON string of the list)
                             */
                            Grid.prototype.getColumnValues = function (columnName) {
                                return common_1.mapProp(columnName, this.store.data.rawData);
                            };
                            /**
                             * Return the index of the column indentified by the column name.
                             * @param {string} columnName - The unique key of the column
                             * @returns {number} - The index of the column
                             */
                            Grid.prototype.getIndexOfColumn = function (columnName) {
                                return common_1.findPropIndex('name', columnName, this.store.column.allColumns.filter(function (_a) {
                                    var name = _a.name;
                                    return !column_1.isRowHeader(name);
                                }));
                            };
                            /**
                             * Check the row identified by the specified rowKey.
                             * @param {number|string} rowKey - The unique key of the row
                             */
                            Grid.prototype.check = function (rowKey) {
                                this.dispatch('check', rowKey);
                            };
                            /**
                             * Uncheck the row identified by the specified rowKey.
                             * @param {number|string} rowKey - The unique key of the row
                             */
                            Grid.prototype.uncheck = function (rowKey) {
                                this.dispatch('uncheck', rowKey);
                            };
                            /**
                             * Check all rows.
                             * @param {boolean} [allPage] - check all rows when using pagination. The default value is 'true'.
                             */
                            Grid.prototype.checkAll = function (allPage) {
                                this.dispatch('checkAll', allPage);
                            };
                            /**
                             * Uncheck all rows.
                             * @param {boolean} [allPage] - Uncheck all rows when using pagination. The default value is 'true'.
                             */
                            Grid.prototype.uncheckAll = function (allPage) {
                                this.dispatch('uncheckAll', allPage);
                            };
                            /**
                             * Return a list of the rowKey of checked rows.
                             * @returns {Array.<string|number>} - A list of the rowKey.
                             */
                            Grid.prototype.getCheckedRowKeys = function () {
                                var rows = data_1.getCheckedRowInfoList(this.store).rows;
                                return rows.map(function (_a) {
                                    var rowKey = _a.rowKey;
                                    return rowKey;
                                });
                            };
                            /**
                             * Return a list of the checked rows.
                             * @returns {Array.<object>} - A list of the checked rows.
                             */
                            Grid.prototype.getCheckedRows = function () {
                                var rows = data_1.getCheckedRowInfoList(this.store).rows;
                                return rows.map(function (row) { return observable_1.getOriginObject(row); });
                            };
                            /**
                             * Find rows by conditions
                             * @param {Object|Function} conditions - object (key: column name, value: column value) or
                             *     function that check the value and returns true/false result to find rows
                             * @returns {Array} Row list
                             * @example <caption>Conditions type is object.</caption>
                             * grid.findRows({
                             *     artist: 'Birdy',
                             *     price: 10000
                             * });
                             * @example <caption>Conditions type is function.</caption>
                             * grid.findRows((row) => {
                             *     return (/b/ig.test(row.artist) && row.price > 10000);
                             * });
                             */
                            Grid.prototype.findRows = function (conditions) {
                                return data_1.getConditionalRows(this.store, conditions);
                            };
                            /**
                             * Sort all rows by the specified column.
                             * @param {string} columnName - The name of the column to be used to compare the rows
                             * @param {boolean} [ascending] - Whether the sort order is ascending.
                             *        If not specified, use the negative value of the current order.
                             * @param {boolean} [multiple] - Whether using multiple sort
                             */
                            Grid.prototype.sort = function (columnName, ascending, multiple) {
                                if (this.store.data.sortState.useClient) {
                                    this.dispatch('sort', columnName, ascending, multiple, false);
                                }
                                else {
                                    // @TODO: apply multi sort to dataSource
                                    this.dataProvider.sort(columnName, ascending, false);
                                }
                            };
                            /**
                             * If the parameter exists, unsort only column with columnName. If not exist, unsort all rows
                             * @param {string} [columnName] - The name of the column to be used to compare the rows
                             */
                            Grid.prototype.unsort = function (columnName) {
                                if (this.store.data.sortState.useClient) {
                                    this.dispatch('unsort', columnName);
                                }
                                else {
                                    this.dataProvider.unsort(columnName);
                                }
                            };
                            /**
                             * Get state of the sorted column in rows
                             * @returns {{columns: [{columnName: string, ascending: boolean}], useClient: boolean}} Sorted column's state
                             */
                            Grid.prototype.getSortState = function () {
                                return common_1.deepCopy(this.store.data.sortState);
                            };
                            /**
                             * Copy to clipboard
                             */
                            Grid.prototype.copyToClipboard = function () {
                                var clipboard = document.querySelector("." + dom_1.cls('clipboard'));
                                clipboard.innerHTML = clipboard_1.getText(this.store);
                                if (dom_1.isSupportWindowClipboardData()) {
                                    dom_1.setClipboardSelection(clipboard.childNodes[0]);
                                }
                                // Accessing the clipboard is a security concern on chrome
                                document.execCommand('copy');
                            };
                            /**
                             * Validate all data and returns the result.
                             * Return value is an array which contains only rows which have invalid cell data.
                             * @returns {Array.<Object>} An array of error object
                             * @example
                             * // return value example
                             * [
                             *     {
                             *         rowKey: 1,
                             *         errors: [
                             *             {
                             *                 columnName: 'c1',
                             *                 errorCode: ['REQUIRED'],
                             *                 errorInfo: [{ code: 'REQUIRED' }]
                             *             },
                             *             {
                             *                 columnName: 'c2',
                             *                 errorCode: ['VALIDATOR_FN'],
                             *                 errorInfo: [{ code: 'VALIDATOR_FN', customCode: 'CUSTOM_CODE' }]
                             *             }
                             *         ]
                             *     },
                             *     {
                             *         rowKey: 3,
                             *         errors: [
                             *             {
                             *                 columnName: 'c2',
                             *                 errorCode: ['MIN'],
                             *                 errorInfo: [{ code: 'MIN', min: 1000 }]
                             *             }
                             *         ]
                             *     }
                             * ]
                             */
                            Grid.prototype.validate = function () {
                                return validation_1.getInvalidRows(this.store);
                            };
                            /**
                             * Enable all rows.
                             */
                            Grid.prototype.enable = function () {
                                this.dispatch('setDisabled', false);
                            };
                            /**
                             * Disable all rows.
                             */
                            Grid.prototype.disable = function () {
                                this.dispatch('setDisabled', true);
                            };
                            /**
                             * Disable the row identified by the rowkey.
                             * @param {number|string} rowKey - The unique key of the target row
                             * @param {boolean} [withCheckbox] - change including checkbox. The default value is 'true'
                             */
                            Grid.prototype.disableRow = function (rowKey, withCheckbox) {
                                if (withCheckbox === void 0) { withCheckbox = true; }
                                this.dispatch('setRowDisabled', true, rowKey, withCheckbox);
                            };
                            /**
                             * Enable the row identified by the rowKey.
                             * @param {number|string} rowKey - The unique key of the target row
                             * @param {boolean} [withCheckbox] - change including checkbox. The default value is 'true'
                             */
                            Grid.prototype.enableRow = function (rowKey, withCheckbox) {
                                if (withCheckbox === void 0) { withCheckbox = true; }
                                this.dispatch('setRowDisabled', false, rowKey, withCheckbox);
                            };
                            /**
                             * Disable the row identified by the specified rowKey to not be able to check.
                             * @param {number|string} rowKey - The unique keyof the row.
                             */
                            Grid.prototype.disableRowCheck = function (rowKey) {
                                this.dispatch('setRowCheckDisabled', true, rowKey);
                            };
                            /**
                             * Enable the row identified by the rowKey to be able to check.
                             * @param {number|string} rowKey - The unique key of the row
                             */
                            Grid.prototype.enableRowCheck = function (rowKey) {
                                this.dispatch('setRowCheckDisabled', false, rowKey);
                            };
                            /**
                             * Disable the column identified by the column name.
                             * @param {string} columnName - column name
                             */
                            Grid.prototype.disableColumn = function (columnName) {
                                this.dispatch('setColumnDisabled', true, columnName);
                            };
                            /**
                             * Enable the column identified by the column name.
                             * @param {string} columnName - column name
                             */
                            Grid.prototype.enableColumn = function (columnName) {
                                this.dispatch('setColumnDisabled', false, columnName);
                            };
                            /**
                             * Insert the new row with specified data to the end of table.
                             * @param {Object} [row] - The data for the new row
                             * @param {Object} [options] - Options
                             * @param {number} [options.at] - The index at which new row will be inserted
                             * @param {boolean} [options.extendPrevRowSpan] - If set to true and the previous row at target index
                             *        has a rowspan data, the new row will extend the existing rowspan data.
                             * @param {boolean} [options.focus] - If set to true, move focus to the new row after appending
                             * @param {number|string} [options.parentRowKey] - Deprecated: Tree row key of the parent which appends given rows
                             */
                            Grid.prototype.appendRow = function (row, options) {
                                if (row === void 0) { row = {}; }
                                if (options === void 0) { options = {}; }
                                var treeColumnName = this.store.column.treeColumnName;
                                if (treeColumnName) {
                                    var offset = options.at, focus = options.focus, parentRowKey = options.parentRowKey;
                                    this.dispatch('appendTreeRow', row, { offset: offset, focus: focus, parentRowKey: parentRowKey });
                                }
                                else {
                                    this.dispatch('appendRow', row, options);
                                }
                                if (options.focus) {
                                    var rowIdx = common_1.isUndefined(options.at) ? this.getRowCount() - 1 : options.at;
                                    this.focusAt(rowIdx, 0);
                                }
                            };
                            /**
                             * Insert the new row with specified data to the beginning of table.
                             * @param {Object} [row] - The data for the new row
                             * @param {Object} [options] - Options
                             * @param {boolean} [options.focus] - If set to true, move focus to the new row after appending
                             */
                            Grid.prototype.prependRow = function (row, options) {
                                if (options === void 0) { options = {}; }
                                this.appendRow(row, tslib_1.__assign(tslib_1.__assign({}, options), { at: 0 }));
                            };
                            /**
                             * Remove the row identified by the specified rowKey.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {boolean} [options.removeOriginalData] - If set to true, the original data will be removed.
                             * @param {boolean} [options.keepRowSpanData] - If set to true, the value of the merged cells will not be
                             *     removed although the target is first cell of them.
                             */
                            Grid.prototype.removeRow = function (rowKey, options) {
                                if (options === void 0) { options = {}; }
                                var treeColumnName = this.store.column.treeColumnName;
                                if (treeColumnName) {
                                    this.removeTreeRow(rowKey);
                                }
                                else {
                                    this.dispatch('removeRow', rowKey, options);
                                }
                            };
                            /**
                             * Return the object that contains all values in the specified row.
                             * @param {number|string} rowKey - The unique key of the target row
                             * @returns {Object} - The object that contains all values in the row.
                             */
                            Grid.prototype.getRow = function (rowKey) {
                                return this.getRowAt(this.getIndexOfRow(rowKey));
                            };
                            /**
                             * Return the object that contains all values in the row at specified index.
                             * @param {number} rowIdx - The index of the row
                             * @returns {Object} - The object that contains all values in the row.
                             */
                            Grid.prototype.getRowAt = function (rowIdx) {
                                var row = this.store.data.rawData[rowIdx];
                                return row ? observable_1.getOriginObject(row) : null;
                            };
                            /**
                             * Return the index of the row indentified by the rowKey.
                             * @param {number|string} rowKey - The unique key of the row
                             * @returns {number} - The index of the row
                             */
                            Grid.prototype.getIndexOfRow = function (rowKey) {
                                var _a = this.store, data = _a.data, column = _a.column, id = _a.id;
                                return data_1.findIndexByRowKey(data, column, id, rowKey, false);
                            };
                            /**
                             * Return a list of all rows.
                             * @returns {Array} - A list of all rows
                             */
                            Grid.prototype.getData = function () {
                                return this.store.data.rawData.map(function (row) { return data_1.getOmittedInternalProp(row); });
                            };
                            /**
                             * Return the total number of the rows.
                             * @returns {number} - The total number of the rows
                             */
                            Grid.prototype.getRowCount = function () {
                                return this.store.data.rawData.length;
                            };
                            /**
                             * Remove all rows.
                             */
                            Grid.prototype.clear = function () {
                                this.dispatch('clearData');
                            };
                            /**
                             * Replace all rows with the specified list. This will not change the original data.
                             * @param {Array} data - A list of new rows
                             * @param {Object} [options] - Options
                             *     @param {Object} [options.sortState] - If set the sortState, the sort state will be applied when the new rows are set.
                             *       It is recommended that you do not use it unless you are getting the sorted data by communicating with the server without DataSource.
                             *         @param {string} [options.sortState.columnName] - Target column name.
                             *         @param {boolean} [options.sortState.ascending] - The ascending state of specific column which will apply to the grid.
                             *         @param {boolean} [options.sortState.multiple] - Whether to use multiple sorting.
                             *     @param {Object} [options.filterState] - If set the filterState, the filter state will be applied when the new rows are set.
                             *       It is recommended that you do not use it unless you are getting the filtered data by communicating with the server without DataSource.
                             *         @param {string} [options.filterState.columnName] - Target column name.
                             *         @param {Object} [options.filterState.columnFilterState] - The column filter state of column which will apply to the grid.
                             *             @param {string} [options.filterState.columnFilterState.code] - Code for column filter(ex. 'eq', 'gt').
                             *             @param {string} [options.filterState.columnFilterState.value] - Input value for column filter.
                             *     @param {Object} [options.pageState] - If set the pageState, the pagination state will be applied when the new rows are set.
                             *       It is recommended that you do not use it unless you are getting the paginated data by communicating with the server without DataSource.
                             *         @param {number} [options.pageState.page] - Target page number.
                             *         @param {number} [options.pageState.totalCount] - The total pagination count.
                             *         @param {number} [options.pageState.perPage] - Number of rows per page.
                             */
                            Grid.prototype.resetData = function (data, options) {
                                if (options === void 0) { options = {}; }
                                this.dispatch('resetData', data, options);
                            };
                            /**
                             * Add the specified css class to cell element identified by the rowKey and className
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {string} columnName - The name of the column
                             * @param {string} className - The css class name to add
                             */
                            Grid.prototype.addCellClassName = function (rowKey, columnName, className) {
                                this.dispatch('addCellClassName', rowKey, columnName, className);
                            };
                            /**
                             * Add the specified css class to all cell elements in the row identified by the rowKey
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {string} className - The css class name to add
                             */
                            Grid.prototype.addRowClassName = function (rowKey, className) {
                                this.dispatch('addRowClassName', rowKey, className);
                            };
                            /**
                             * Remove the specified css class from the cell element indentified by the rowKey and columnName.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {string} columnName - The name of the column
                             * @param {string} className - The css class name to be removed
                             */
                            Grid.prototype.removeCellClassName = function (rowKey, columnName, className) {
                                this.dispatch('removeCellClassName', rowKey, columnName, className);
                            };
                            /**
                             * Remove the specified css class from all cell elements in the row identified by the rowKey.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {string} className - The css class name to be removed
                             */
                            Grid.prototype.removeRowClassName = function (rowKey, className) {
                                this.dispatch('removeRowClassName', rowKey, className);
                            };
                            /**
                             * Add custom event to grid.
                             * @param {string} eventName - custom event name
                             * @param {function} fn - event handler
                             */
                            Grid.prototype.on = function (eventName, fn) {
                                this.eventBus.on(eventName, fn);
                            };
                            /**
                             * Remove custom event to grid.
                             * @param {string} eventName - custom event name
                             * @param {function} fn - event handler
                             */
                            Grid.prototype.off = function (eventName, fn) {
                                this.eventBus.off(eventName, fn);
                            };
                            /**
                             * Return an instance of tui.Pagination.
                             * @deprecated
                             * @returns {tui.Pagination}
                             */
                            Grid.prototype.getPagination = function () {
                                return this.paginationManager.getPagination();
                            };
                            /**
                             * Set number of rows per page and reload current page
                             * @param {number} perPage - Number of rows per page
                             */
                            Grid.prototype.setPerPage = function (perPage) {
                                var pagination = this.getPagination();
                                if (pagination) {
                                    var pageOptions = this.store.data.pageOptions;
                                    if (pageOptions.useClient) {
                                        this.dispatch('updatePageOptions', { perPage: perPage, page: 1 });
                                        this.dispatch('updateHeights');
                                    }
                                    else {
                                        this.readData(1, { perPage: perPage });
                                    }
                                }
                            };
                            /**
                             * Return true if there are at least one row modified.
                             * @returns {boolean} - True if there are at least one row modified.
                             */
                            Grid.prototype.isModified = function () {
                                return this.dataManager.isModified();
                            };
                            /**
                             * Return the object that contains the lists of changed data compared to the original data.
                             * The object has properties 'createdRows', 'updatedRows', 'deletedRows'.
                             * @param {Object} [options] Options
                             *     @param {boolean} [options.checkedOnly=false] - If set to true, only checked rows will be considered.
                             *     @param {boolean} [options.withRawData=false] - If set to true, the data will contains
                             *         the row data for internal use.
                             *     @param {boolean} [options.rowKeyOnly=false] - If set to true, only keys of the changed
                             *         rows will be returned.
                             *     @param {Array} [options.ignoredColumns] - A list of column name to be excluded.
                             * @returns {{createdRows: Array, updatedRows: Array, deletedRows: Array}} - Object that contains the result list.
                             */
                            Grid.prototype.getModifiedRows = function (options) {
                                if (options === void 0) { options = {}; }
                                var ignoredColumns = options.ignoredColumns;
                                var originIgnoredColumns = this.store.column.ignoredColumns;
                                options.ignoredColumns = Array.isArray(ignoredColumns)
                                    ? ignoredColumns.concat(originIgnoredColumns)
                                    : originIgnoredColumns;
                                return this.dataManager.getAllModifiedData(options);
                            };
                            /**
                             * Request 'readData' to the server. The last requested data will be extended with new data.
                             * @param {Number} page - Page number
                             * @param {Object} data - Data(parameters) to send to the server
                             * @param {Boolean} resetData - If set to true, last requested data will be ignored.
                             */
                            Grid.prototype.readData = function (page, data, resetData) {
                                if (data && data.sortColumn) {
                                    this.dataProvider.sort(data.sortColumn, data.sortAscending, false);
                                }
                                else {
                                    this.dataProvider.readData(page, data, resetData);
                                }
                            };
                            /**
                             * Send request to server to sync data
                             * @param {String} requestType - 'createData|updateData|deleteData|modifyData'
                             * @param {object} options - Options
                             *      @param {String} [options.url] - URL to send the request
                             *      @param {String} [options.method] - method to send the request
                             *      @param {boolean} [options.checkedOnly=false] - Whether the request param only contains checked rows
                             *      @param {boolean} [options.modifiedOnly=true] - Whether the request param only contains modified rows
                             *      @param {boolean} [options.showConfirm=true] - Whether to show confirm dialog before sending request
                             *      @param {boolean} [options.withCredentials=false] - Use withCredentials flag of XMLHttpRequest for ajax requests if true
                             */
                            Grid.prototype.request = function (requestType, options) {
                                if (options === void 0) { options = {}; }
                                this.dataProvider.request(requestType, options);
                            };
                            /**
                             * Request 'readData' with last requested data.
                             */
                            Grid.prototype.reloadData = function () {
                                this.dataProvider.reloadData();
                            };
                            /**
                             * Restore the data to the original data.
                             * (Original data is set by {@link Grid#resetData|resetData}
                             */
                            Grid.prototype.restore = function () {
                                this.resetData(this.dataManager.getOriginData());
                            };
                            /**
                             * Insert the new tree row with specified data.
                             * @param {Object} [row] - The tree data for the new row
                             * @param {Object} [options] - Options
                             * @param {number|string} [options.parentRowKey] - Tree row key of the parent which appends given rows
                             * @param {number} [options.offset] - The offset value to insert new tree row
                             * @param {boolean} [options.focus] - If set to true, move focus to the new tree row after appending
                             */
                            Grid.prototype.appendTreeRow = function (row, options) {
                                if (row === void 0) { row = {}; }
                                if (options === void 0) { options = {}; }
                                var treeColumnName = this.store.column.treeColumnName;
                                var parentRowKey = options.parentRowKey;
                                if (!treeColumnName || common_1.isUndefined(parentRowKey)) {
                                    return;
                                }
                                this.dispatch('appendTreeRow', row, options);
                                if (options.focus) {
                                    var offset = options.offset;
                                    var childRows = tree_1.getChildRows(this.store, parentRowKey);
                                    if (childRows.length) {
                                        var rowKey = (common_1.isUndefined(offset)
                                            ? childRows[childRows.length - 1]
                                            : childRows[offset]).rowKey;
                                        var rowIdx = this.getIndexOfRow(rowKey);
                                        this.focusAt(rowIdx, 0);
                                    }
                                }
                            };
                            /**
                             * Remove the tree row identified by the specified rowKey.
                             * @param {number|string} rowKey - The unique key of the row
                             */
                            Grid.prototype.removeTreeRow = function (rowKey) {
                                var treeColumnName = this.store.column.treeColumnName;
                                if (treeColumnName) {
                                    this.dispatch('removeTreeRow', rowKey);
                                }
                            };
                            /**
                             * Expand tree row.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {boolean} recursive - true for recursively expand all descendant
                             */
                            Grid.prototype.expand = function (rowKey, recursive) {
                                this.dispatch('expandByRowKey', rowKey, recursive);
                            };
                            /**
                             * Expand all tree row.
                             */
                            Grid.prototype.expandAll = function () {
                                this.dispatch('expandAll');
                            };
                            /**
                             * Expand tree row.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {boolean} recursive - true for recursively expand all descendant
                             */
                            Grid.prototype.collapse = function (rowKey, recursive) {
                                this.dispatch('collapseByRowKey', rowKey, recursive);
                            };
                            /**
                             * Collapse all tree row.
                             */
                            Grid.prototype.collapseAll = function () {
                                this.dispatch('collapseAll');
                            };
                            /**
                             * Get the parent of the row which has the given row key.
                             * @param {number|string} rowKey - The unique key of the row
                             * @returns {Object} - the parent row
                             */
                            Grid.prototype.getParentRow = function (rowKey) {
                                return tree_1.getParentRow(this.store, rowKey, true);
                            };
                            /**
                             * Get the children of the row which has the given row key.
                             * @param {number|string} rowKey - The unique key of the row
                             * @returns {Array.<Object>} - the children rows
                             */
                            Grid.prototype.getChildRows = function (rowKey) {
                                return tree_1.getChildRows(this.store, rowKey, true);
                            };
                            /**
                             * Get the ancestors of the row which has the given row key.
                             * @param {number|string} rowKey - The unique key of the row
                             * @returns {Array.<TreeRow>} - the ancestor rows
                             */
                            Grid.prototype.getAncestorRows = function (rowKey) {
                                return tree_1.getAncestorRows(this.store, rowKey);
                            };
                            /**
                             * Get the descendants of the row which has the given row key.
                             * @param {number|string} rowKey - The unique key of the row
                             * @returns {Array.<Object>} - the descendant rows
                             */
                            Grid.prototype.getDescendantRows = function (rowKey) {
                                return tree_1.getDescendantRows(this.store, rowKey);
                            };
                            /**
                             * Get the depth of the row which has the given row key.
                             * @param {number|string} rowKey - The unique key of the row
                             * @returns {number} - the depth
                             */
                            Grid.prototype.getDepth = function (rowKey) {
                                var _a = this.store, data = _a.data, column = _a.column, id = _a.id;
                                var rawData = data.rawData;
                                var row = data_1.findRowByRowKey(data, column, id, rowKey);
                                return row ? tree_1.getDepth(rawData, row) : 0;
                            };
                            /**
                             * Return the rowspan data of the cell identified by the rowKey and columnName.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {string} columnName - The name of the column
                             * @returns {Object} - Row span data
                             */
                            Grid.prototype.getRowSpanData = function (rowKey, columnName) {
                                return rowSpan_1.getRowSpanByRowKey(rowKey, columnName, this.store.data.rawData);
                            };
                            /**
                             * reset original data to current data.
                             * (Original data is set by {@link Grid#resetData|resetData}
                             */
                            Grid.prototype.resetOriginData = function () {
                                this.dataManager.setOriginData(this.store.data.rawData);
                            };
                            /** Remove all checked rows.
                             * @param {boolean} [showConfirm] - If set to true, confirm message will be shown before remove.
                             * @returns {boolean} - True if there's at least one row removed.
                             */
                            Grid.prototype.removeCheckedRows = function (showConfirm) {
                                var checkedRowInfoList = data_1.getCheckedRowInfoList(this.store);
                                var deletedCount = checkedRowInfoList.rows.length;
                                var confirmMessage = message_1.getConfirmMessage('DELETE', deletedCount);
                                if (deletedCount > 0 && (!showConfirm || confirm(confirmMessage))) {
                                    this.dispatch('removeRows', checkedRowInfoList);
                                    return true;
                                }
                                return false;
                            };
                            /**
                             * Refresh the layout view. Use this method when the view was rendered while hidden.
                             */
                            Grid.prototype.refreshLayout = function () {
                                var containerEl = this.el.querySelector("." + dom_1.cls('container'));
                                var parentElement = this.el.parentElement;
                                this.dispatch('refreshLayout', containerEl, parentElement);
                            };
                            /**
                             * Destroy the instance.
                             */
                            Grid.prototype.destroy = function () {
                                preact_1.render('', this.el, this.gridEl);
                                for (var key in this) {
                                    if (common_1.hasOwnProp(this, key)) {
                                        delete this[key];
                                    }
                                }
                            };
                            /**
                             * Set the option of column filter.
                             * @param {string} columnName - columnName
                             * @param {string | FilterOpt} filterOpt - filter type
                             */
                            Grid.prototype.setFilter = function (columnName, filterOpt) {
                                this.dispatch('setFilter', columnName, filterOpt);
                            };
                            /**
                             * Get filter state.
                             * @returns {Array.<FilterState>} - filter state
                             */
                            Grid.prototype.getFilterState = function () {
                                // @TODO: unify the structure to ResetOptions.filterState type definition
                                return filter_2.getFilterState(this.store);
                            };
                            /**
                             * Filter the data.
                             * @param {string} columnName - column name to filter
                             * @param {Array.<FilterState>} state - filter state
                             * @example
                             * grid.filter('name', [{code: 'eq', value: 3}, {code: 'eq', value: 4}]);
                             */
                            Grid.prototype.filter = function (columnName, state) {
                                var filter = this.store.column.allColumnMap[columnName].filter;
                                if (filter) {
                                    var type_1 = filter.type, operator = filter.operator;
                                    var conditionFn = state.map(function (_a) {
                                        var code = _a.code, value = _a.value;
                                        return filter_1.getFilterConditionFn(code, value, type_1);
                                    });
                                    this.dispatch('filter', columnName, filter_1.composeConditionFn(conditionFn, operator), state);
                                }
                            };
                            /**
                             * Remove filter state of specific column.
                             * @param {string} columnName - column name to unfilter
                             */
                            Grid.prototype.unfilter = function (columnName) {
                                this.dispatch('unfilter', columnName);
                            };
                            /**
                             * Add class name to all cell data of specific column.
                             * @param {string} columnName - column name to add className
                             * @param {string} className - class name
                             */
                            Grid.prototype.addColumnClassName = function (columnName, className) {
                                this.dispatch('addColumnClassName', columnName, className);
                            };
                            /**
                             * Remove class name to all cell data of specific column.
                             * @param {string} columnName - column name to add className
                             * @param {string} className - class name
                             */
                            Grid.prototype.removeColumnClassName = function (columnName, className) {
                                this.dispatch('removeColumnClassName', columnName, className);
                            };
                            /**
                             * Set new data to the row identified by the specified rowKey.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {object} row - The object that contains all values in the row.
                             */
                            Grid.prototype.setRow = function (rowKey, row) {
                                var _a = this.store, data = _a.data, column = _a.column, id = _a.id;
                                var rowIndex = data_1.findIndexByRowKey(data, column, id, rowKey, false);
                                this.dispatch('setRow', rowIndex, row);
                            };
                            /**
                             * Move the row identified by the specified rowKey to target index.
                             * If data is sorted or filtered, this couldn't be used.
                             * @param {number|string} rowKey - The unique key of the row
                             * @param {number} targetIndex - target index for moving
                             */
                            Grid.prototype.moveRow = function (rowKey, targetIndex) {
                                this.dispatch('moveRow', rowKey, targetIndex);
                            };
                            /**
                             * Set parameters to be sent with the request to communicate with the server.
                             * @param {Object} params - parameters to send to the server
                             */
                            Grid.prototype.setRequestParams = function (params) {
                                this.dataProvider.setRequestParams(params);
                            };
                            /**
                             * clear the modified data that is returned as the result of 'getModifiedRows' method.
                             * If the 'type' parameter is undefined, all modified data is cleared.
                             * @param {string} type - The modified type
                             */
                            Grid.prototype.clearModifiedData = function (type) {
                                if (type) {
                                    this.dataManager.clear(type);
                                }
                                else {
                                    this.dataManager.clearAll();
                                }
                            };
                            /**
                             * append rows.
                             * @param {Array} data - A list of new rows
                             */
                            Grid.prototype.appendRows = function (data) {
                                this.dispatch('appendRows', data);
                            };
                            /**
                             * Return the formatted value of the cell identified by the rowKey and columnName.
                             * @param {number|string} rowKey - The unique key of the target row.
                             * @param {string} columnName - The name of the column
                             * @returns {string|null} - The formatted value of the cell
                             */
                            Grid.prototype.getFormattedValue = function (rowKey, columnName) {
                                return data_1.getFormattedValue(this.store, rowKey, columnName);
                            };
                            /**
                             * Set total count of items for calculating the pagination.
                             * @param {number} totalCount - total count
                             */
                            Grid.prototype.setPaginationTotalCount = function (totalCount) {
                                this.dispatch('updatePageOptions', { totalCount: totalCount });
                            };
                            /**
                             * Get total count of items with the current pagination
                             * @returns {number} - total count
                             */
                            Grid.prototype.getPaginationTotalCount = function () {
                                return this.store.data.pageOptions.totalCount;
                            };
                            return Grid;
                        }());
                        exports.default = Grid;


                        /***/ }),
                    /* 57 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.createStore = void 0;
                        var observable_1 = __webpack_require__(5);
                        var data_1 = __webpack_require__(13);
                        var column_1 = __webpack_require__(31);
                        var dimension_1 = __webpack_require__(73);
                        var viewport_1 = __webpack_require__(74);
                        var columnCoords_1 = __webpack_require__(75);
                        var rowCoords_1 = __webpack_require__(76);
                        var focus_1 = __webpack_require__(77);
                        var summary_1 = __webpack_require__(43);
                        var selection_1 = __webpack_require__(78);
                        var renderState_1 = __webpack_require__(79);
                        var filterLayerState_1 = __webpack_require__(80);
                        var dimension_2 = __webpack_require__(45);
                        var lazyObservable_1 = __webpack_require__(26);
                        var validation_1 = __webpack_require__(24);
                        function createStore(id, options) {
                            validation_1.createNewValidationMap(id);
                            var el = options.el, width = options.width, rowHeight = options.rowHeight, bodyHeight = options.bodyHeight, heightResizable = options.heightResizable, minRowHeight = options.minRowHeight, minBodyHeight = options.minBodyHeight, _a = options.columnOptions, columnOptions = _a === void 0 ? {} : _a, keyColumnName = options.keyColumnName, _b = options.rowHeaders, rowHeaders = _b === void 0 ? [] : _b, _c = options.copyOptions, copyOptions = _c === void 0 ? {} : _c, _d = options.summary, summaryOptions = _d === void 0 ? {} : _d, _e = options.selectionUnit, selectionUnit = _e === void 0 ? 'cell' : _e, _f = options.showDummyRows, showDummyRows = _f === void 0 ? false : _f, _g = options.editingEvent, editingEvent = _g === void 0 ? 'dblclick' : _g, _h = options.tabMode, tabMode = _h === void 0 ? 'moveAndEdit' : _h, scrollX = options.scrollX, scrollY = options.scrollY, _j = options.useClientSort, useClientSort = _j === void 0 ? true : _j, _k = options.pageOptions, pageOptions = _k === void 0 ? {} : _k, _l = options.treeColumnOptions, treeColumnOptions = _l === void 0 ? { name: '' } : _l, _m = options.header, header = _m === void 0 ? {} : _m, _o = options.disabled, disabled = _o === void 0 ? false : _o;
                            var frozenBorderWidth = columnOptions.frozenBorderWidth;
                            var summaryHeight = summaryOptions.height, summaryPosition = summaryOptions.position;
                            var _p = header.height, headerHeight = _p === void 0 ? 40 : _p, _q = header.complexColumns, complexColumns = _q === void 0 ? [] : _q, _r = header.align, align = _r === void 0 ? 'center' : _r, _s = header.valign, valign = _s === void 0 ? 'middle' : _s, _t = header.columns, columnHeaders = _t === void 0 ? [] : _t;
                            var column = column_1.create({
                                columns: options.columns,
                                columnOptions: columnOptions,
                                rowHeaders: rowHeaders,
                                copyOptions: copyOptions,
                                keyColumnName: keyColumnName,
                                treeColumnOptions: treeColumnOptions,
                                complexColumns: complexColumns,
                                align: align,
                                valign: valign,
                                columnHeaders: columnHeaders,
                                disabled: disabled,
                            });
                            var data = data_1.create({
                                data: Array.isArray(options.data) ? options.data : [],
                                column: column,
                                pageOptions: pageOptions,
                                useClientSort: useClientSort,
                                id: id,
                                disabled: disabled,
                            });
                            var dimension = dimension_1.create({
                                column: column,
                                width: width,
                                domWidth: el.clientWidth,
                                rowHeight: rowHeight,
                                bodyHeight: bodyHeight,
                                minBodyHeight: minBodyHeight,
                                minRowHeight: minRowHeight,
                                heightResizable: heightResizable,
                                frozenBorderWidth: frozenBorderWidth,
                                summaryHeight: summaryHeight,
                                summaryPosition: summaryPosition,
                                scrollX: scrollX,
                                scrollY: scrollY,
                                headerHeight: headerHeight,
                            });
                            var columnCoords = columnCoords_1.create({ column: column, dimension: dimension });
                            var rowCoords = rowCoords_1.create({ data: data, dimension: dimension });
                            var viewport = viewport_1.create({
                                data: data,
                                column: column,
                                dimension: dimension,
                                rowCoords: rowCoords,
                                columnCoords: columnCoords,
                                showDummyRows: showDummyRows,
                            });
                            var focus = focus_1.create({
                                data: data,
                                column: column,
                                dimension: dimension,
                                columnCoords: columnCoords,
                                rowCoords: rowCoords,
                                editingEvent: editingEvent,
                                tabMode: tabMode,
                                id: id,
                            });
                            var summary = summary_1.create({ column: column, data: data, summary: summaryOptions });
                            var selection = selection_1.create({
                                selectionUnit: selectionUnit,
                                columnCoords: columnCoords,
                                column: column,
                                dimension: dimension,
                                rowCoords: rowCoords,
                                data: data,
                            });
                            var filterLayerState = filterLayerState_1.create();
                            var renderState = renderState_1.create();
                            var store = observable_1.observable({
                                id: id,
                                data: data,
                                column: column,
                                dimension: dimension,
                                columnCoords: columnCoords,
                                rowCoords: rowCoords,
                                viewport: viewport,
                                focus: focus,
                                summary: summary,
                                selection: selection,
                                renderState: renderState,
                                filterLayerState: filterLayerState,
                            });
                            // manual observe to resolve circular references
                            observable_1.observe(function () {
                                dimension_2.setAutoBodyHeight(store);
                            });
                            // makes the data observable as changes viewport
                            observable_1.observe(function () {
                                lazyObservable_1.createObservableData(store);
                            }, false, 'lazyObservable');
                            return store;
                        }
                        exports.createStore = createStore;


                        /***/ }),
                    /* 58 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.patchArrayMethods = void 0;
                        var observable_1 = __webpack_require__(5);
                        var common_1 = __webpack_require__(0);
                        var methods = ['splice', 'push', 'pop', 'shift', 'unshift'];
                        function patchArrayMethods(arr, obj, key) {
                            methods.forEach(function (method) {
                                var patchedMethod = common_1.hasOwnProp(arr, method) ? arr[method] : Array.prototype[method];
                                var derivedPatchedMethod = !patchedMethod.registered && common_1.hasOwnProp(arr, method);
                                // To prevent to stack the patched method recursively
                                if (derivedPatchedMethod || !common_1.hasOwnProp(arr, method)) {
                                    arr[method] = function patch() {
                                        var args = [];
                                        for (var _i = 0; _i < arguments.length; _i++) {
                                            args[_i] = arguments[_i];
                                        }
                                        var result = patchedMethod.apply(this, args);
                                        observable_1.notify(obj, key);
                                        return result;
                                    };
                                    if (derivedPatchedMethod) {
                                        arr[method].registered = true;
                                    }
                                }
                            });
                            return arr;
                        }
                        exports.patchArrayMethods = patchArrayMethods;


                        /***/ }),
                    /* 59 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.listItemText = void 0;
                        var common_1 = __webpack_require__(0);
                        function getListItemText(listItems, value) {
                            var item = common_1.findProp('value', value, listItems);
                            return item ? item.text : '';
                        }
                        function listItemText(_a, relationListItems) {
                            var column = _a.column, value = _a.value;
                            var type = column.editor.options.type;
                            var listItems = column.editor.options.listItems;
                            if (Array.isArray(relationListItems)) {
                                listItems = relationListItems;
                            }
                            if (type === 'checkbox') {
                                return String(value)
                                    .split(',')
                                    .map(getListItemText.bind(null, listItems))
                                    .filter(function (text) { return Boolean(text); })
                                    .join(',');
                            }
                            return getListItemText(listItems, value);
                        }
                        exports.listItemText = listItemText;


                        /***/ }),
                    /* 60 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.DefaultRenderer = void 0;
                        var dom_1 = __webpack_require__(2);
                        var DefaultRenderer = /** @class */ (function () {
                            function DefaultRenderer(props) {
                                var el = document.createElement('div');
                                var _a = props.columnInfo, ellipsis = _a.ellipsis, whiteSpace = _a.whiteSpace;
                                el.className = dom_1.cls('cell-content');
                                el.setAttribute('title', "" + props.formattedValue);
                                // @TODO: we should remove below options and consider common the renderer option for style, attribute and class names
                                if (ellipsis) {
                                    el.style.textOverflow = 'ellipsis';
                                }
                                if (whiteSpace) {
                                    el.style.whiteSpace = whiteSpace;
                                }
                                this.el = el;
                                this.render(props);
                            }
                            DefaultRenderer.prototype.getElement = function () {
                                return this.el;
                            };
                            DefaultRenderer.prototype.render = function (props) {
                                this.el.innerHTML = "" + props.formattedValue;
                            };
                            return DefaultRenderer;
                        }());
                        exports.DefaultRenderer = DefaultRenderer;


                        /***/ }),
                    /* 61 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.editorMap = void 0;
                        var text_1 = __webpack_require__(62);
                        var checkbox_1 = __webpack_require__(63);
                        var select_1 = __webpack_require__(64);
                        var datePicker_1 = __webpack_require__(67);
                        exports.editorMap = {
                            text: [text_1.TextEditor, { type: 'text' }],
                            password: [text_1.TextEditor, { type: 'password' }],
                            checkbox: [checkbox_1.CheckboxEditor, { type: 'checkbox' }],
                            radio: [checkbox_1.CheckboxEditor, { type: 'radio' }],
                            select: [select_1.SelectEditor],
                            datePicker: [datePicker_1.DatePickerEditor],
                        };


                        /***/ }),
                    /* 62 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.TextEditor = void 0;
                        var dom_1 = __webpack_require__(2);
                        var common_1 = __webpack_require__(0);
                        var TextEditor = /** @class */ (function () {
                            function TextEditor(props) {
                                var el = document.createElement('input');
                                var options = props.columnInfo.editor.options;
                                el.className = dom_1.cls('content-text');
                                el.type = options.type;
                                el.value = String(common_1.isNil(props.value) ? '' : props.value);
                                this.el = el;
                            }
                            TextEditor.prototype.getElement = function () {
                                return this.el;
                            };
                            TextEditor.prototype.getValue = function () {
                                return this.el.value;
                            };
                            TextEditor.prototype.mounted = function () {
                                this.el.select();
                            };
                            return TextEditor;
                        }());
                        exports.TextEditor = TextEditor;


                        /***/ }),
                    /* 63 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.CheckboxEditor = void 0;
                        var editor_1 = __webpack_require__(39);
                        var dom_1 = __webpack_require__(2);
                        var keyboard_1 = __webpack_require__(17);
                        var common_1 = __webpack_require__(0);
                        var dom_2 = __webpack_require__(32);
                        var LAYER_CLASSNAME = dom_1.cls('editor-checkbox-list-layer');
                        var LIST_ITEM_CLASSNAME = dom_1.cls('editor-checkbox');
                        var HOVERED_LIST_ITEM_CLASSNAME = dom_1.cls('editor-checkbox-hovered') + " " + LIST_ITEM_CLASSNAME;
                        var UNCHECKED_RADIO_LABEL_CLASSNAME = dom_1.cls('editor-label-icon-radio');
                        var CHECKED_RADIO_LABEL_CLASSNAME = dom_1.cls('editor-label-icon-radio-checked');
                        var UNCHECKED_CHECKBOX_LABEL_CLASSNAME = dom_1.cls('editor-label-icon-checkbox');
                        var CHECKED_CHECKBOX_LABEL_CLASSNAME = dom_1.cls('editor-label-icon-checkbox-checked');
                        var CheckboxEditor = /** @class */ (function () {
                            function CheckboxEditor(props) {
                                var _this = this;
                                this.hoveredItemId = '';
                                this.elementIds = [];
                                this.onMouseover = function (ev) {
                                    var targetId = _this.getItemId(ev.target);
                                    if (targetId && targetId !== _this.hoveredItemId) {
                                        _this.highlightItem(targetId);
                                    }
                                };
                                this.onChange = function (ev) {
                                    var value = ev.target.value;
                                    _this.setLabelClass(value);
                                };
                                this.onKeydown = function (ev) {
                                    var keyName = keyboard_1.getKeyStrokeString(ev);
                                    if (keyboard_1.isArrowKey(keyName)) {
                                        ev.preventDefault();
                                        var elementIdx = common_1.findIndex(function (id) { return id === _this.hoveredItemId; }, _this.elementIds);
                                        var totalCount = _this.elementIds.length;
                                        var offset = totalCount + (keyName === 'down' || keyName === 'right' ? 1 : -1);
                                        var id = _this.elementIds[(elementIdx + offset) % totalCount];
                                        _this.highlightItem(id);
                                    }
                                    else {
                                        // except arrow key, pass the event to editing layer for using existing editing keyMap
                                        _this.portalEditingKeydown(ev);
                                    }
                                };
                                var columnInfo = props.columnInfo, width = props.width, formattedValue = props.formattedValue, portalEditingKeydown = props.portalEditingKeydown;
                                var el = document.createElement('div');
                                var value = String(common_1.isNil(props.value) ? '' : props.value);
                                el.className = dom_1.cls('layer-editing-inner');
                                el.innerText = formattedValue;
                                this.inputType = columnInfo.editor.options.type;
                                var listItems = editor_1.getListItems(props);
                                var layer = this.createLayer(listItems, width);
                                this.portalEditingKeydown = portalEditingKeydown;
                                this.el = el;
                                this.layer = layer;
                                this.setValue(value);
                            }
                            CheckboxEditor.prototype.createLayer = function (listItems, width) {
                                var _this = this;
                                var layer = document.createElement('ul');
                                layer.className = LAYER_CLASSNAME;
                                layer.style.minWidth = width - 10 + "px";
                                // To hide the initial layer which is having the position which is not calculated properly
                                dom_2.setOpacity(layer, 0);
                                listItems.forEach(function (_a) {
                                    var text = _a.text, value = _a.value;
                                    var id = "checkbox-" + value;
                                    var listItemEl = document.createElement('li');
                                    listItemEl.id = id;
                                    listItemEl.className = LIST_ITEM_CLASSNAME;
                                    listItemEl.appendChild(_this.createCheckboxLabel(value, text));
                                    _this.elementIds.push(id);
                                    layer.appendChild(listItemEl);
                                });
                                layer.addEventListener('change', this.onChange);
                                layer.addEventListener('mouseover', this.onMouseover);
                                layer.addEventListener('keydown', this.onKeydown);
                                return layer;
                            };
                            CheckboxEditor.prototype.createCheckboxLabel = function (value, text) {
                                var input = document.createElement('input');
                                var label = document.createElement('label');
                                var span = document.createElement('span');
                                label.className =
                                    this.inputType === 'radio'
                                        ? UNCHECKED_RADIO_LABEL_CLASSNAME
                                        : UNCHECKED_CHECKBOX_LABEL_CLASSNAME;
                                input.type = this.inputType;
                                input.name = 'checkbox';
                                input.value = String(value);
                                span.innerText = text;
                                label.appendChild(input);
                                label.appendChild(span);
                                return label;
                            };
                            CheckboxEditor.prototype.getItemId = function (target) {
                                return target.id || target.parentElement.id;
                            };
                            CheckboxEditor.prototype.highlightItem = function (targetId) {
                                if (this.hoveredItemId) {
                                    this.layer.querySelector("#" + this.hoveredItemId).className = LIST_ITEM_CLASSNAME;
                                }
                                this.hoveredItemId = targetId;
                                var item = this.layer.querySelector("#" + targetId);
                                item.className = HOVERED_LIST_ITEM_CLASSNAME;
                                item.querySelector('input').focus();
                            };
                            CheckboxEditor.prototype.setLabelClass = function (inputValue) {
                                var label = this.layer.querySelector("#checkbox-" + inputValue + " label");
                                if (this.inputType === 'checkbox') {
                                    label.className = dom_1.hasClass(label, 'editor-label-icon-checkbox-checked')
                                        ? UNCHECKED_CHECKBOX_LABEL_CLASSNAME
                                        : CHECKED_CHECKBOX_LABEL_CLASSNAME;
                                }
                                else {
                                    var checkedLabel = this.layer.querySelector("." + CHECKED_RADIO_LABEL_CLASSNAME);
                                    if (checkedLabel) {
                                        checkedLabel.className = UNCHECKED_RADIO_LABEL_CLASSNAME;
                                    }
                                    label.className = CHECKED_RADIO_LABEL_CLASSNAME;
                                }
                            };
                            CheckboxEditor.prototype.getCheckedInput = function () {
                                return (this.layer.querySelector('input:checked') ||
                                    this.layer.querySelector('input'));
                            };
                            CheckboxEditor.prototype.getElement = function () {
                                return this.el;
                            };
                            CheckboxEditor.prototype.setValue = function (value) {
                                var _this = this;
                                String(value)
                                    .split(',')
                                    .forEach(function (inputValue) {
                                        var input = _this.layer.querySelector("input[value=\"" + inputValue + "\"]");
                                        if (input) {
                                            input.checked = true;
                                            _this.setLabelClass(inputValue);
                                        }
                                    });
                            };
                            CheckboxEditor.prototype.getValue = function () {
                                var checkedInputs = this.layer.querySelectorAll('input:checked');
                                var checkedValues = [];
                                for (var i = 0, len = checkedInputs.length; i < len; i += 1) {
                                    checkedValues.push(checkedInputs[i].value);
                                }
                                return checkedValues.join(',');
                            };
                            CheckboxEditor.prototype.mounted = function () {
                                // To prevent wrong stacked z-index context, layer append to grid container
                                dom_2.getContainerElement(this.el).appendChild(this.layer);
                                // @ts-ignore
                                dom_2.setLayerPosition(this.el, this.layer);
                                var checkedInput = this.getCheckedInput();
                                if (checkedInput) {
                                    this.highlightItem("checkbox-" + checkedInput.value);
                                }
                                // To show the layer which has appropriate position
                                dom_2.setOpacity(this.layer, 1);
                            };
                            CheckboxEditor.prototype.beforeDestroy = function () {
                                this.layer.removeEventListener('change', this.onChange);
                                this.layer.removeEventListener('mouseover', this.onMouseover);
                                this.layer.removeEventListener('keydown', this.onKeydown);
                                dom_2.getContainerElement(this.el).removeChild(this.layer);
                            };
                            return CheckboxEditor;
                        }());
                        exports.CheckboxEditor = CheckboxEditor;


                        /***/ }),
                    /* 64 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.SelectEditor = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var select_box_1 = tslib_1.__importDefault(__webpack_require__(65));
                        __webpack_require__(66);
                        var editor_1 = __webpack_require__(39);
                        var dom_1 = __webpack_require__(2);
                        var dom_2 = __webpack_require__(32);
                        var keyboard_1 = __webpack_require__(17);
                        var common_1 = __webpack_require__(0);
                        var SelectEditor = /** @class */ (function () {
                            function SelectEditor(props) {
                                var _this = this;
                                this.selectFinish = false;
                                this.isMounted = false;
                                this.onKeydown = function (ev) {
                                    var passingKeyNames = ['esc', 'shift-tab', 'tab'];
                                    var keyName = keyboard_1.getKeyStrokeString(ev);
                                    if (_this.selectFinish || common_1.includes(passingKeyNames, keyName)) {
                                        // with passingKeyNames, pass the event to editing layer for using existing editing keyMap
                                        _this.portalEditingKeydown(ev);
                                    }
                                    else {
                                        ev.preventDefault();
                                    }
                                };
                                var width = props.width, formattedValue = props.formattedValue, portalEditingKeydown = props.portalEditingKeydown;
                                var el = document.createElement('div');
                                var value = String(common_1.isNil(props.value) ? '' : props.value);
                                el.className = dom_1.cls('layer-editing-inner');
                                el.innerText = formattedValue;
                                var listItems = editor_1.getListItems(props);
                                var layer = this.createLayer(listItems, width, value);
                                this.portalEditingKeydown = portalEditingKeydown;
                                this.el = el;
                                this.layer = layer;
                                this.layer.addEventListener('keydown', this.onKeydown);
                            }
                            SelectEditor.prototype.setSelectFinish = function (selectFinish) {
                                var _this = this;
                                setTimeout(function () {
                                    _this.selectFinish = selectFinish;
                                });
                            };
                            SelectEditor.prototype.createLayer = function (listItems, width, value) {
                                var _this = this;
                                var layer = document.createElement('div');
                                layer.className = dom_1.cls('editor-select-box-layer');
                                layer.style.minWidth = width - 10 + "px";
                                // To hide the initial layer which is having the position which is not calculated properly
                                dom_2.setOpacity(layer, 0);
                                var data = listItems.map(function (item) { return ({ value: String(item.value), label: item.text }); });
                                this.selectBoxEl = new select_box_1.default(layer, { data: data });
                                this.selectBoxEl.on('close', function () {
                                    _this.focusSelectBox();
                                    _this.setSelectFinish(true);
                                    // @ts-ignore
                                    dom_2.setLayerPosition(_this.el, _this.layer, _this.selectBoxEl.dropdown.el);
                                });
                                this.selectBoxEl.on('open', function () {
                                    _this.setSelectFinish(false);
                                    if (_this.isMounted) {
                                        // @ts-ignore
                                        dom_2.setLayerPosition(_this.el, _this.layer, _this.selectBoxEl.dropdown.el);
                                    }
                                });
                                if (value) {
                                    this.selectBoxEl.select(value);
                                }
                                return layer;
                            };
                            SelectEditor.prototype.focusSelectBox = function () {
                                // https://github.com/nhn/toast-ui.select-box/issues/3
                                // @TODO: need to change after apply this issue
                                // @ts-ignore
                                this.selectBoxEl.input.focus();
                            };
                            SelectEditor.prototype.getElement = function () {
                                return this.el;
                            };
                            SelectEditor.prototype.getValue = function () {
                                return this.selectBoxEl.getSelectedItem().getValue();
                            };
                            SelectEditor.prototype.mounted = function () {
                                this.selectBoxEl.open();
                                // To prevent wrong stacked z-index context, layer append to grid container
                                dom_2.getContainerElement(this.el).appendChild(this.layer);
                                // @ts-ignore
                                dom_2.setLayerPosition(this.el, this.layer, this.selectBoxEl.dropdown.el);
                                this.focusSelectBox();
                                this.isMounted = true;
                                // To show the layer which has appropriate position
                                dom_2.setOpacity(this.layer, 1);
                            };
                            SelectEditor.prototype.beforeDestroy = function () {
                                this.selectBoxEl.destroy();
                                this.layer.removeEventListener('keydown', this.onKeydown);
                                dom_2.getContainerElement(this.el).removeChild(this.layer);
                            };
                            return SelectEditor;
                        }());
                        exports.SelectEditor = SelectEditor;


                        /***/ }),
                    /* 65 */
                    /***/ (function(module, exports, __webpack_require__) {

                        /*!
     * TOAST UI Select Box
     * @version 1.0.0 | Thu Oct 24 2019
     * @author NHN FE Development Lab <dl_javascript@nhn.com>
     * @license MIT
     */
                        (function webpackUniversalModuleDefinition(root, factory) {
                            module.exports = factory();
                        })(window, function() {
                            return /******/ (function(modules) { // webpackBootstrap
                                /******/ 	function hotDisposeChunk(chunkId) {
                                    /******/ 		delete installedChunks[chunkId];
                                    /******/ 	}
                                /******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
                                /******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
                                    /******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
                                    /******/ 		hotAddUpdateChunk(chunkId, moreModules);
                                    /******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
                                    /******/ 	} ;
                                /******/
                                /******/ 	// eslint-disable-next-line no-unused-vars
                                /******/ 	function hotDownloadUpdateChunk(chunkId) {
                                    /******/ 		var script = document.createElement("script");
                                    /******/ 		script.charset = "utf-8";
                                    /******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
                                    /******/ 		document.head.appendChild(script);
                                    /******/ 	}
                                /******/
                                /******/ 	// eslint-disable-next-line no-unused-vars
                                /******/ 	function hotDownloadManifest(requestTimeout) {
                                    /******/ 		requestTimeout = requestTimeout || 10000;
                                    /******/ 		return new Promise(function(resolve, reject) {
                                        /******/ 			if (typeof XMLHttpRequest === "undefined") {
                                            /******/ 				return reject(new Error("No browser support"));
                                            /******/ 			}
                                        /******/ 			try {
                                            /******/ 				var request = new XMLHttpRequest();
                                            /******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
                                            /******/ 				request.open("GET", requestPath, true);
                                            /******/ 				request.timeout = requestTimeout;
                                            /******/ 				request.send(null);
                                            /******/ 			} catch (err) {
                                            /******/ 				return reject(err);
                                            /******/ 			}
                                        /******/ 			request.onreadystatechange = function() {
                                            /******/ 				if (request.readyState !== 4) return;
                                            /******/ 				if (request.status === 0) {
                                                /******/ 					// timeout
                                                /******/ 					reject(
                                                    /******/ 						new Error("Manifest request to " + requestPath + " timed out.")
                                                    /******/ 					);
                                                /******/ 				} else if (request.status === 404) {
                                                /******/ 					// no update available
                                                /******/ 					resolve();
                                                /******/ 				} else if (request.status !== 200 && request.status !== 304) {
                                                /******/ 					// other failure
                                                /******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
                                                /******/ 				} else {
                                                /******/ 					// success
                                                /******/ 					try {
                                                    /******/ 						var update = JSON.parse(request.responseText);
                                                    /******/ 					} catch (e) {
                                                    /******/ 						reject(e);
                                                    /******/ 						return;
                                                    /******/ 					}
                                                /******/ 					resolve(update);
                                                /******/ 				}
                                            /******/ 			};
                                        /******/ 		});
                                    /******/ 	}
                                /******/
                                /******/ 	var hotApplyOnUpdate = true;
                                /******/ 	// eslint-disable-next-line no-unused-vars
                                /******/ 	var hotCurrentHash = "fbd02ae0ea88b9f7e886";
                                /******/ 	var hotRequestTimeout = 10000;
                                /******/ 	var hotCurrentModuleData = {};
                                /******/ 	var hotCurrentChildModule;
                                /******/ 	// eslint-disable-next-line no-unused-vars
                                /******/ 	var hotCurrentParents = [];
                                /******/ 	// eslint-disable-next-line no-unused-vars
                                /******/ 	var hotCurrentParentsTemp = [];
                                /******/
                                /******/ 	// eslint-disable-next-line no-unused-vars
                                /******/ 	function hotCreateRequire(moduleId) {
                                    /******/ 		var me = installedModules[moduleId];
                                    /******/ 		if (!me) return __webpack_require__;
                                    /******/ 		var fn = function(request) {
                                        /******/ 			if (me.hot.active) {
                                            /******/ 				if (installedModules[request]) {
                                                /******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
                                                    /******/ 						installedModules[request].parents.push(moduleId);
                                                    /******/ 					}
                                                /******/ 				} else {
                                                /******/ 					hotCurrentParents = [moduleId];
                                                /******/ 					hotCurrentChildModule = request;
                                                /******/ 				}
                                            /******/ 				if (me.children.indexOf(request) === -1) {
                                                /******/ 					me.children.push(request);
                                                /******/ 				}
                                            /******/ 			} else {
                                            /******/ 				console.warn(
                                                /******/ 					"[HMR] unexpected require(" +
                                                /******/ 						request +
                                                /******/ 						") from disposed module " +
                                                /******/ 						moduleId
                                                /******/ 				);
                                            /******/ 				hotCurrentParents = [];
                                            /******/ 			}
                                        /******/ 			return __webpack_require__(request);
                                        /******/ 		};
                                    /******/ 		var ObjectFactory = function ObjectFactory(name) {
                                        /******/ 			return {
                                            /******/ 				configurable: true,
                                            /******/ 				enumerable: true,
                                            /******/ 				get: function() {
                                                /******/ 					return __webpack_require__[name];
                                                /******/ 				},
                                            /******/ 				set: function(value) {
                                                /******/ 					__webpack_require__[name] = value;
                                                /******/ 				}
                                            /******/ 			};
                                        /******/ 		};
                                    /******/ 		for (var name in __webpack_require__) {
                                        /******/ 			if (
                                            /******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
                                            /******/ 				name !== "e" &&
                                            /******/ 				name !== "t"
                                            /******/ 			) {
                                            /******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
                                            /******/ 			}
                                        /******/ 		}
                                    /******/ 		fn.e = function(chunkId) {
                                        /******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
                                        /******/ 			hotChunksLoading++;
                                        /******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
                                            /******/ 				finishChunkLoading();
                                            /******/ 				throw err;
                                            /******/ 			});
                                        /******/
                                        /******/ 			function finishChunkLoading() {
                                            /******/ 				hotChunksLoading--;
                                            /******/ 				if (hotStatus === "prepare") {
                                                /******/ 					if (!hotWaitingFilesMap[chunkId]) {
                                                    /******/ 						hotEnsureUpdateChunk(chunkId);
                                                    /******/ 					}
                                                /******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
                                                    /******/ 						hotUpdateDownloaded();
                                                    /******/ 					}
                                                /******/ 				}
                                            /******/ 			}
                                        /******/ 		};
                                    /******/ 		fn.t = function(value, mode) {
                                        /******/ 			if (mode & 1) value = fn(value);
                                        /******/ 			return __webpack_require__.t(value, mode & ~1);
                                        /******/ 		};
                                    /******/ 		return fn;
                                    /******/ 	}
                                /******/
                                /******/ 	// eslint-disable-next-line no-unused-vars
                                /******/ 	function hotCreateModule(moduleId) {
                                    /******/ 		var hot = {
                                        /******/ 			// private stuff
                                        /******/ 			_acceptedDependencies: {},
                                        /******/ 			_declinedDependencies: {},
                                        /******/ 			_selfAccepted: false,
                                        /******/ 			_selfDeclined: false,
                                        /******/ 			_disposeHandlers: [],
                                        /******/ 			_main: hotCurrentChildModule !== moduleId,
                                        /******/
                                        /******/ 			// Module API
                                        /******/ 			active: true,
                                        /******/ 			accept: function(dep, callback) {
                                            /******/ 				if (dep === undefined) hot._selfAccepted = true;
                                            /******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
                                            /******/ 				else if (typeof dep === "object")
                                                /******/ 					for (var i = 0; i < dep.length; i++)
                                                    /******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
                                            /******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
                                            /******/ 			},
                                        /******/ 			decline: function(dep) {
                                            /******/ 				if (dep === undefined) hot._selfDeclined = true;
                                            /******/ 				else if (typeof dep === "object")
                                                /******/ 					for (var i = 0; i < dep.length; i++)
                                                    /******/ 						hot._declinedDependencies[dep[i]] = true;
                                            /******/ 				else hot._declinedDependencies[dep] = true;
                                            /******/ 			},
                                        /******/ 			dispose: function(callback) {
                                            /******/ 				hot._disposeHandlers.push(callback);
                                            /******/ 			},
                                        /******/ 			addDisposeHandler: function(callback) {
                                            /******/ 				hot._disposeHandlers.push(callback);
                                            /******/ 			},
                                        /******/ 			removeDisposeHandler: function(callback) {
                                            /******/ 				var idx = hot._disposeHandlers.indexOf(callback);
                                            /******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
                                            /******/ 			},
                                        /******/
                                        /******/ 			// Management API
                                        /******/ 			check: hotCheck,
                                        /******/ 			apply: hotApply,
                                        /******/ 			status: function(l) {
                                            /******/ 				if (!l) return hotStatus;
                                            /******/ 				hotStatusHandlers.push(l);
                                            /******/ 			},
                                        /******/ 			addStatusHandler: function(l) {
                                            /******/ 				hotStatusHandlers.push(l);
                                            /******/ 			},
                                        /******/ 			removeStatusHandler: function(l) {
                                            /******/ 				var idx = hotStatusHandlers.indexOf(l);
                                            /******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
                                            /******/ 			},
                                        /******/
                                        /******/ 			//inherit from previous dispose call
                                        /******/ 			data: hotCurrentModuleData[moduleId]
                                        /******/ 		};
                                    /******/ 		hotCurrentChildModule = undefined;
                                    /******/ 		return hot;
                                    /******/ 	}
                                /******/
                                /******/ 	var hotStatusHandlers = [];
                                /******/ 	var hotStatus = "idle";
                                /******/
                                /******/ 	function hotSetStatus(newStatus) {
                                    /******/ 		hotStatus = newStatus;
                                    /******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
                                        /******/ 			hotStatusHandlers[i].call(null, newStatus);
                                    /******/ 	}
                                /******/
                                /******/ 	// while downloading
                                /******/ 	var hotWaitingFiles = 0;
                                /******/ 	var hotChunksLoading = 0;
                                /******/ 	var hotWaitingFilesMap = {};
                                /******/ 	var hotRequestedFilesMap = {};
                                /******/ 	var hotAvailableFilesMap = {};
                                /******/ 	var hotDeferred;
                                /******/
                                /******/ 	// The update info
                                /******/ 	var hotUpdate, hotUpdateNewHash;
                                /******/
                                /******/ 	function toModuleId(id) {
                                    /******/ 		var isNumber = +id + "" === id;
                                    /******/ 		return isNumber ? +id : id;
                                    /******/ 	}
                                /******/
                                /******/ 	function hotCheck(apply) {
                                    /******/ 		if (hotStatus !== "idle") {
                                        /******/ 			throw new Error("check() is only allowed in idle status");
                                        /******/ 		}
                                    /******/ 		hotApplyOnUpdate = apply;
                                    /******/ 		hotSetStatus("check");
                                    /******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
                                        /******/ 			if (!update) {
                                            /******/ 				hotSetStatus("idle");
                                            /******/ 				return null;
                                            /******/ 			}
                                        /******/ 			hotRequestedFilesMap = {};
                                        /******/ 			hotWaitingFilesMap = {};
                                        /******/ 			hotAvailableFilesMap = update.c;
                                        /******/ 			hotUpdateNewHash = update.h;
                                        /******/
                                        /******/ 			hotSetStatus("prepare");
                                        /******/ 			var promise = new Promise(function(resolve, reject) {
                                            /******/ 				hotDeferred = {
                                                /******/ 					resolve: resolve,
                                                /******/ 					reject: reject
                                                /******/ 				};
                                            /******/ 			});
                                        /******/ 			hotUpdate = {};
                                        /******/ 			var chunkId = "main";
                                        /******/ 			// eslint-disable-next-line no-lone-blocks
                                        /******/ 			{
                                            /******/ 				/*globals chunkId */
                                            /******/ 				hotEnsureUpdateChunk(chunkId);
                                            /******/ 			}
                                        /******/ 			if (
                                            /******/ 				hotStatus === "prepare" &&
                                            /******/ 				hotChunksLoading === 0 &&
                                            /******/ 				hotWaitingFiles === 0
                                            /******/ 			) {
                                            /******/ 				hotUpdateDownloaded();
                                            /******/ 			}
                                        /******/ 			return promise;
                                        /******/ 		});
                                    /******/ 	}
                                /******/
                                /******/ 	// eslint-disable-next-line no-unused-vars
                                /******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
                                    /******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
                                        /******/ 			return;
                                    /******/ 		hotRequestedFilesMap[chunkId] = false;
                                    /******/ 		for (var moduleId in moreModules) {
                                        /******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
                                            /******/ 				hotUpdate[moduleId] = moreModules[moduleId];
                                            /******/ 			}
                                        /******/ 		}
                                    /******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
                                        /******/ 			hotUpdateDownloaded();
                                        /******/ 		}
                                    /******/ 	}
                                /******/
                                /******/ 	function hotEnsureUpdateChunk(chunkId) {
                                    /******/ 		if (!hotAvailableFilesMap[chunkId]) {
                                        /******/ 			hotWaitingFilesMap[chunkId] = true;
                                        /******/ 		} else {
                                        /******/ 			hotRequestedFilesMap[chunkId] = true;
                                        /******/ 			hotWaitingFiles++;
                                        /******/ 			hotDownloadUpdateChunk(chunkId);
                                        /******/ 		}
                                    /******/ 	}
                                /******/
                                /******/ 	function hotUpdateDownloaded() {
                                    /******/ 		hotSetStatus("ready");
                                    /******/ 		var deferred = hotDeferred;
                                    /******/ 		hotDeferred = null;
                                    /******/ 		if (!deferred) return;
                                    /******/ 		if (hotApplyOnUpdate) {
                                        /******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
                                        /******/ 			// avoid triggering uncaught exception warning in Chrome.
                                        /******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
                                        /******/ 			Promise.resolve()
                                            /******/ 				.then(function() {
                                                /******/ 					return hotApply(hotApplyOnUpdate);
                                                /******/ 				})
                                            /******/ 				.then(
                                                /******/ 					function(result) {
                                                    /******/ 						deferred.resolve(result);
                                                    /******/ 					},
                                                /******/ 					function(err) {
                                                    /******/ 						deferred.reject(err);
                                                    /******/ 					}
                                                /******/ 				);
                                        /******/ 		} else {
                                        /******/ 			var outdatedModules = [];
                                        /******/ 			for (var id in hotUpdate) {
                                            /******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
                                                /******/ 					outdatedModules.push(toModuleId(id));
                                                /******/ 				}
                                            /******/ 			}
                                        /******/ 			deferred.resolve(outdatedModules);
                                        /******/ 		}
                                    /******/ 	}
                                /******/
                                /******/ 	function hotApply(options) {
                                    /******/ 		if (hotStatus !== "ready")
                                        /******/ 			throw new Error("apply() is only allowed in ready status");
                                    /******/ 		options = options || {};
                                    /******/
                                    /******/ 		var cb;
                                    /******/ 		var i;
                                    /******/ 		var j;
                                    /******/ 		var module;
                                    /******/ 		var moduleId;
                                    /******/
                                    /******/ 		function getAffectedStuff(updateModuleId) {
                                        /******/ 			var outdatedModules = [updateModuleId];
                                        /******/ 			var outdatedDependencies = {};
                                        /******/
                                        /******/ 			var queue = outdatedModules.map(function(id) {
                                            /******/ 				return {
                                                /******/ 					chain: [id],
                                                /******/ 					id: id
                                                /******/ 				};
                                            /******/ 			});
                                        /******/ 			while (queue.length > 0) {
                                            /******/ 				var queueItem = queue.pop();
                                            /******/ 				var moduleId = queueItem.id;
                                            /******/ 				var chain = queueItem.chain;
                                            /******/ 				module = installedModules[moduleId];
                                            /******/ 				if (!module || module.hot._selfAccepted) continue;
                                            /******/ 				if (module.hot._selfDeclined) {
                                                /******/ 					return {
                                                    /******/ 						type: "self-declined",
                                                    /******/ 						chain: chain,
                                                    /******/ 						moduleId: moduleId
                                                    /******/ 					};
                                                /******/ 				}
                                            /******/ 				if (module.hot._main) {
                                                /******/ 					return {
                                                    /******/ 						type: "unaccepted",
                                                    /******/ 						chain: chain,
                                                    /******/ 						moduleId: moduleId
                                                    /******/ 					};
                                                /******/ 				}
                                            /******/ 				for (var i = 0; i < module.parents.length; i++) {
                                                /******/ 					var parentId = module.parents[i];
                                                /******/ 					var parent = installedModules[parentId];
                                                /******/ 					if (!parent) continue;
                                                /******/ 					if (parent.hot._declinedDependencies[moduleId]) {
                                                    /******/ 						return {
                                                        /******/ 							type: "declined",
                                                        /******/ 							chain: chain.concat([parentId]),
                                                        /******/ 							moduleId: moduleId,
                                                        /******/ 							parentId: parentId
                                                        /******/ 						};
                                                    /******/ 					}
                                                /******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
                                                /******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
                                                    /******/ 						if (!outdatedDependencies[parentId])
                                                        /******/ 							outdatedDependencies[parentId] = [];
                                                    /******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
                                                    /******/ 						continue;
                                                    /******/ 					}
                                                /******/ 					delete outdatedDependencies[parentId];
                                                /******/ 					outdatedModules.push(parentId);
                                                /******/ 					queue.push({
                                                    /******/ 						chain: chain.concat([parentId]),
                                                    /******/ 						id: parentId
                                                    /******/ 					});
                                                /******/ 				}
                                            /******/ 			}
                                        /******/
                                        /******/ 			return {
                                            /******/ 				type: "accepted",
                                            /******/ 				moduleId: updateModuleId,
                                            /******/ 				outdatedModules: outdatedModules,
                                            /******/ 				outdatedDependencies: outdatedDependencies
                                            /******/ 			};
                                        /******/ 		}
                                    /******/
                                    /******/ 		function addAllToSet(a, b) {
                                        /******/ 			for (var i = 0; i < b.length; i++) {
                                            /******/ 				var item = b[i];
                                            /******/ 				if (a.indexOf(item) === -1) a.push(item);
                                            /******/ 			}
                                        /******/ 		}
                                    /******/
                                    /******/ 		// at begin all updates modules are outdated
                                    /******/ 		// the "outdated" status can propagate to parents if they don't accept the children
                                    /******/ 		var outdatedDependencies = {};
                                    /******/ 		var outdatedModules = [];
                                    /******/ 		var appliedUpdate = {};
                                    /******/
                                    /******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
                                        /******/ 			console.warn(
                                            /******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
                                            /******/ 			);
                                        /******/ 		};
                                    /******/
                                    /******/ 		for (var id in hotUpdate) {
                                        /******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
                                            /******/ 				moduleId = toModuleId(id);
                                            /******/ 				/** @type {TODO} */
                                            /******/ 				var result;
                                            /******/ 				if (hotUpdate[id]) {
                                                /******/ 					result = getAffectedStuff(moduleId);
                                                /******/ 				} else {
                                                /******/ 					result = {
                                                    /******/ 						type: "disposed",
                                                    /******/ 						moduleId: id
                                                    /******/ 					};
                                                /******/ 				}
                                            /******/ 				/** @type {Error|false} */
                                            /******/ 				var abortError = false;
                                            /******/ 				var doApply = false;
                                            /******/ 				var doDispose = false;
                                            /******/ 				var chainInfo = "";
                                            /******/ 				if (result.chain) {
                                                /******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
                                                /******/ 				}
                                            /******/ 				switch (result.type) {
                                                /******/ 					case "self-declined":
                                                    /******/ 						if (options.onDeclined) options.onDeclined(result);
                                                    /******/ 						if (!options.ignoreDeclined)
                                                        /******/ 							abortError = new Error(
                                                            /******/ 								"Aborted because of self decline: " +
                                                            /******/ 									result.moduleId +
                                                            /******/ 									chainInfo
                                                            /******/ 							);
                                                    /******/ 						break;
                                                /******/ 					case "declined":
                                                    /******/ 						if (options.onDeclined) options.onDeclined(result);
                                                    /******/ 						if (!options.ignoreDeclined)
                                                        /******/ 							abortError = new Error(
                                                            /******/ 								"Aborted because of declined dependency: " +
                                                            /******/ 									result.moduleId +
                                                            /******/ 									" in " +
                                                            /******/ 									result.parentId +
                                                            /******/ 									chainInfo
                                                            /******/ 							);
                                                    /******/ 						break;
                                                /******/ 					case "unaccepted":
                                                    /******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
                                                    /******/ 						if (!options.ignoreUnaccepted)
                                                        /******/ 							abortError = new Error(
                                                            /******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
                                                            /******/ 							);
                                                    /******/ 						break;
                                                /******/ 					case "accepted":
                                                    /******/ 						if (options.onAccepted) options.onAccepted(result);
                                                    /******/ 						doApply = true;
                                                    /******/ 						break;
                                                /******/ 					case "disposed":
                                                    /******/ 						if (options.onDisposed) options.onDisposed(result);
                                                    /******/ 						doDispose = true;
                                                    /******/ 						break;
                                                /******/ 					default:
                                                    /******/ 						throw new Error("Unexception type " + result.type);
                                                /******/ 				}
                                            /******/ 				if (abortError) {
                                                /******/ 					hotSetStatus("abort");
                                                /******/ 					return Promise.reject(abortError);
                                                /******/ 				}
                                            /******/ 				if (doApply) {
                                                /******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
                                                /******/ 					addAllToSet(outdatedModules, result.outdatedModules);
                                                /******/ 					for (moduleId in result.outdatedDependencies) {
                                                    /******/ 						if (
                                                        /******/ 							Object.prototype.hasOwnProperty.call(
                                                        /******/ 								result.outdatedDependencies,
                                                        /******/ 								moduleId
                                                        /******/ 							)
                                                        /******/ 						) {
                                                        /******/ 							if (!outdatedDependencies[moduleId])
                                                            /******/ 								outdatedDependencies[moduleId] = [];
                                                        /******/ 							addAllToSet(
                                                            /******/ 								outdatedDependencies[moduleId],
                                                            /******/ 								result.outdatedDependencies[moduleId]
                                                            /******/ 							);
                                                        /******/ 						}
                                                    /******/ 					}
                                                /******/ 				}
                                            /******/ 				if (doDispose) {
                                                /******/ 					addAllToSet(outdatedModules, [result.moduleId]);
                                                /******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
                                                /******/ 				}
                                            /******/ 			}
                                        /******/ 		}
                                    /******/
                                    /******/ 		// Store self accepted outdated modules to require them later by the module system
                                    /******/ 		var outdatedSelfAcceptedModules = [];
                                    /******/ 		for (i = 0; i < outdatedModules.length; i++) {
                                        /******/ 			moduleId = outdatedModules[i];
                                        /******/ 			if (
                                            /******/ 				installedModules[moduleId] &&
                                            /******/ 				installedModules[moduleId].hot._selfAccepted &&
                                            /******/ 				// removed self-accepted modules should not be required
                                            /******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire
                                            /******/ 			) {
                                            /******/ 				outdatedSelfAcceptedModules.push({
                                                /******/ 					module: moduleId,
                                                /******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
                                                /******/ 				});
                                            /******/ 			}
                                        /******/ 		}
                                    /******/
                                    /******/ 		// Now in "dispose" phase
                                    /******/ 		hotSetStatus("dispose");
                                    /******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
                                        /******/ 			if (hotAvailableFilesMap[chunkId] === false) {
                                            /******/ 				hotDisposeChunk(chunkId);
                                            /******/ 			}
                                        /******/ 		});
                                    /******/
                                    /******/ 		var idx;
                                    /******/ 		var queue = outdatedModules.slice();
                                    /******/ 		while (queue.length > 0) {
                                        /******/ 			moduleId = queue.pop();
                                        /******/ 			module = installedModules[moduleId];
                                        /******/ 			if (!module) continue;
                                        /******/
                                        /******/ 			var data = {};
                                        /******/
                                        /******/ 			// Call dispose handlers
                                        /******/ 			var disposeHandlers = module.hot._disposeHandlers;
                                        /******/ 			for (j = 0; j < disposeHandlers.length; j++) {
                                            /******/ 				cb = disposeHandlers[j];
                                            /******/ 				cb(data);
                                            /******/ 			}
                                        /******/ 			hotCurrentModuleData[moduleId] = data;
                                        /******/
                                        /******/ 			// disable module (this disables requires from this module)
                                        /******/ 			module.hot.active = false;
                                        /******/
                                        /******/ 			// remove module from cache
                                        /******/ 			delete installedModules[moduleId];
                                        /******/
                                        /******/ 			// when disposing there is no need to call dispose handler
                                        /******/ 			delete outdatedDependencies[moduleId];
                                        /******/
                                        /******/ 			// remove "parents" references from all children
                                        /******/ 			for (j = 0; j < module.children.length; j++) {
                                            /******/ 				var child = installedModules[module.children[j]];
                                            /******/ 				if (!child) continue;
                                            /******/ 				idx = child.parents.indexOf(moduleId);
                                            /******/ 				if (idx >= 0) {
                                                /******/ 					child.parents.splice(idx, 1);
                                                /******/ 				}
                                            /******/ 			}
                                        /******/ 		}
                                    /******/
                                    /******/ 		// remove outdated dependency from module children
                                    /******/ 		var dependency;
                                    /******/ 		var moduleOutdatedDependencies;
                                    /******/ 		for (moduleId in outdatedDependencies) {
                                        /******/ 			if (
                                            /******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
                                            /******/ 			) {
                                            /******/ 				module = installedModules[moduleId];
                                            /******/ 				if (module) {
                                                /******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
                                                /******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
                                                    /******/ 						dependency = moduleOutdatedDependencies[j];
                                                    /******/ 						idx = module.children.indexOf(dependency);
                                                    /******/ 						if (idx >= 0) module.children.splice(idx, 1);
                                                    /******/ 					}
                                                /******/ 				}
                                            /******/ 			}
                                        /******/ 		}
                                    /******/
                                    /******/ 		// Now in "apply" phase
                                    /******/ 		hotSetStatus("apply");
                                    /******/
                                    /******/ 		hotCurrentHash = hotUpdateNewHash;
                                    /******/
                                    /******/ 		// insert new code
                                    /******/ 		for (moduleId in appliedUpdate) {
                                        /******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
                                            /******/ 				modules[moduleId] = appliedUpdate[moduleId];
                                            /******/ 			}
                                        /******/ 		}
                                    /******/
                                    /******/ 		// call accept handlers
                                    /******/ 		var error = null;
                                    /******/ 		for (moduleId in outdatedDependencies) {
                                        /******/ 			if (
                                            /******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
                                            /******/ 			) {
                                            /******/ 				module = installedModules[moduleId];
                                            /******/ 				if (module) {
                                                /******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
                                                /******/ 					var callbacks = [];
                                                /******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
                                                    /******/ 						dependency = moduleOutdatedDependencies[i];
                                                    /******/ 						cb = module.hot._acceptedDependencies[dependency];
                                                    /******/ 						if (cb) {
                                                        /******/ 							if (callbacks.indexOf(cb) !== -1) continue;
                                                        /******/ 							callbacks.push(cb);
                                                        /******/ 						}
                                                    /******/ 					}
                                                /******/ 					for (i = 0; i < callbacks.length; i++) {
                                                    /******/ 						cb = callbacks[i];
                                                    /******/ 						try {
                                                        /******/ 							cb(moduleOutdatedDependencies);
                                                        /******/ 						} catch (err) {
                                                        /******/ 							if (options.onErrored) {
                                                            /******/ 								options.onErrored({
                                                                /******/ 									type: "accept-errored",
                                                                /******/ 									moduleId: moduleId,
                                                                /******/ 									dependencyId: moduleOutdatedDependencies[i],
                                                                /******/ 									error: err
                                                                /******/ 								});
                                                            /******/ 							}
                                                        /******/ 							if (!options.ignoreErrored) {
                                                            /******/ 								if (!error) error = err;
                                                            /******/ 							}
                                                        /******/ 						}
                                                    /******/ 					}
                                                /******/ 				}
                                            /******/ 			}
                                        /******/ 		}
                                    /******/
                                    /******/ 		// Load self accepted modules
                                    /******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
                                        /******/ 			var item = outdatedSelfAcceptedModules[i];
                                        /******/ 			moduleId = item.module;
                                        /******/ 			hotCurrentParents = [moduleId];
                                        /******/ 			try {
                                            /******/ 				__webpack_require__(moduleId);
                                            /******/ 			} catch (err) {
                                            /******/ 				if (typeof item.errorHandler === "function") {
                                                /******/ 					try {
                                                    /******/ 						item.errorHandler(err);
                                                    /******/ 					} catch (err2) {
                                                    /******/ 						if (options.onErrored) {
                                                        /******/ 							options.onErrored({
                                                            /******/ 								type: "self-accept-error-handler-errored",
                                                            /******/ 								moduleId: moduleId,
                                                            /******/ 								error: err2,
                                                            /******/ 								originalError: err
                                                            /******/ 							});
                                                        /******/ 						}
                                                    /******/ 						if (!options.ignoreErrored) {
                                                        /******/ 							if (!error) error = err2;
                                                        /******/ 						}
                                                    /******/ 						if (!error) error = err;
                                                    /******/ 					}
                                                /******/ 				} else {
                                                /******/ 					if (options.onErrored) {
                                                    /******/ 						options.onErrored({
                                                        /******/ 							type: "self-accept-errored",
                                                        /******/ 							moduleId: moduleId,
                                                        /******/ 							error: err
                                                        /******/ 						});
                                                    /******/ 					}
                                                /******/ 					if (!options.ignoreErrored) {
                                                    /******/ 						if (!error) error = err;
                                                    /******/ 					}
                                                /******/ 				}
                                            /******/ 			}
                                        /******/ 		}
                                    /******/
                                    /******/ 		// handle errors in accept handlers and self accepted module load
                                    /******/ 		if (error) {
                                        /******/ 			hotSetStatus("fail");
                                        /******/ 			return Promise.reject(error);
                                        /******/ 		}
                                    /******/
                                    /******/ 		hotSetStatus("idle");
                                    /******/ 		return new Promise(function(resolve) {
                                        /******/ 			resolve(outdatedModules);
                                        /******/ 		});
                                    /******/ 	}
                                /******/
                                /******/ 	// The module cache
                                /******/ 	var installedModules = {};
                                /******/
                                /******/ 	// The require function
                                /******/ 	function __webpack_require__(moduleId) {
                                    /******/
                                    /******/ 		// Check if module is in cache
                                    /******/ 		if(installedModules[moduleId]) {
                                        /******/ 			return installedModules[moduleId].exports;
                                        /******/ 		}
                                    /******/ 		// Create a new module (and put it into the cache)
                                    /******/ 		var module = installedModules[moduleId] = {
                                        /******/ 			i: moduleId,
                                        /******/ 			l: false,
                                        /******/ 			exports: {},
                                        /******/ 			hot: hotCreateModule(moduleId),
                                        /******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
                                        /******/ 			children: []
                                        /******/ 		};
                                    /******/
                                    /******/ 		// Execute the module function
                                    /******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
                                    /******/
                                    /******/ 		// Flag the module as loaded
                                    /******/ 		module.l = true;
                                    /******/
                                    /******/ 		// Return the exports of the module
                                    /******/ 		return module.exports;
                                    /******/ 	}
                                /******/
                                /******/
                                /******/ 	// expose the modules object (__webpack_modules__)
                                /******/ 	__webpack_require__.m = modules;
                                /******/
                                /******/ 	// expose the module cache
                                /******/ 	__webpack_require__.c = installedModules;
                                /******/
                                /******/ 	// define getter function for harmony exports
                                /******/ 	__webpack_require__.d = function(exports, name, getter) {
                                    /******/ 		if(!__webpack_require__.o(exports, name)) {
                                        /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
                                        /******/ 		}
                                    /******/ 	};
                                /******/
                                /******/ 	// define __esModule on exports
                                /******/ 	__webpack_require__.r = function(exports) {
                                    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                                        /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
                                        /******/ 		}
                                    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
                                    /******/ 	};
                                /******/
                                /******/ 	// create a fake namespace object
                                /******/ 	// mode & 1: value is a module id, require it
                                /******/ 	// mode & 2: merge all properties of value into the ns
                                /******/ 	// mode & 4: return value when already ns object
                                /******/ 	// mode & 8|1: behave like require
                                /******/ 	__webpack_require__.t = function(value, mode) {
                                    /******/ 		if(mode & 1) value = __webpack_require__(value);
                                    /******/ 		if(mode & 8) return value;
                                    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
                                    /******/ 		var ns = Object.create(null);
                                    /******/ 		__webpack_require__.r(ns);
                                    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
                                    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
                                    /******/ 		return ns;
                                    /******/ 	};
                                /******/
                                /******/ 	// getDefaultExport function for compatibility with non-harmony modules
                                /******/ 	__webpack_require__.n = function(module) {
                                    /******/ 		var getter = module && module.__esModule ?
                                        /******/ 			function getDefault() { return module['default']; } :
                                        /******/ 			function getModuleExports() { return module; };
                                    /******/ 		__webpack_require__.d(getter, 'a', getter);
                                    /******/ 		return getter;
                                    /******/ 	};
                                /******/
                                /******/ 	// Object.prototype.hasOwnProperty.call
                                /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
                                /******/
                                /******/ 	// __webpack_public_path__
                                /******/ 	__webpack_require__.p = "dist";
                                /******/
                                /******/ 	// __webpack_hash__
                                /******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
                                /******/
                                /******/
                                /******/ 	// Load entry module and return exports
                                /******/ 	return hotCreateRequire("./src/js/index.js")(__webpack_require__.s = "./src/js/index.js");
                                /******/ })
                                /************************************************************************/
                                /******/ ({

                                    /***/ "./node_modules/tui-code-snippet/array/inArray.js":
                                    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/array/inArray.js ***!
      \********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /* eslint-disable complexity */
                                        /**
                                         * @fileoverview Returns the first index at which a given element can be found in the array.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var isArray = __webpack_require__(/*! ../type/isArray */ "./node_modules/tui-code-snippet/type/isArray.js");

                                        /**
                                         * @module array
                                         */

                                        /**
                                         * Returns the first index at which a given element can be found in the array
                                         * from start index(default 0), or -1 if it is not present.
                                         * It compares searchElement to elements of the Array using strict equality
                                         * (the same method used by the ===, or triple-equals, operator).
                                         * @param {*} searchElement Element to locate in the array
                                         * @param {Array} array Array that will be traversed.
                                         * @param {number} startIndex Start index in array for searching (default 0)
                                         * @returns {number} the First index at which a given element, or -1 if it is not present
                                         * @memberof module:array
                                         * @example
                                         * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
                                         *
                                         * var arr = ['one', 'two', 'three', 'four'];
                                         * var idx1 = inArray('one', arr, 3); // -1
                                         * var idx2 = inArray('one', arr); // 0
                                         */
                                        function inArray(searchElement, array, startIndex) {
                                            var i;
                                            var length;
                                            startIndex = startIndex || 0;

                                            if (!isArray(array)) {
                                                return -1;
                                            }

                                            if (Array.prototype.indexOf) {
                                                return Array.prototype.indexOf.call(array, searchElement, startIndex);
                                            }

                                            length = array.length;
                                            for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
                                                if (array[i] === searchElement) {
                                                    return i;
                                                }
                                            }

                                            return -1;
                                        }

                                        module.exports = inArray;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/collection/forEach.js":
                                    /*!*************************************************************!*\
      !*** ./node_modules/tui-code-snippet/collection/forEach.js ***!
      \*************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var isArray = __webpack_require__(/*! ../type/isArray */ "./node_modules/tui-code-snippet/type/isArray.js");
                                        var forEachArray = __webpack_require__(/*! ../collection/forEachArray */ "./node_modules/tui-code-snippet/collection/forEachArray.js");
                                        var forEachOwnProperties = __webpack_require__(/*! ../collection/forEachOwnProperties */ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js");

                                        /**
                                         * @module collection
                                         */

                                        /**
                                         * Execute the provided callback once for each property of object(or element of array) which actually exist.
                                         * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
                                         * If the callback function returns false, the loop will be stopped.
                                         * Callback function(iteratee) is invoked with three arguments:
                                         *  - The value of the property(or The value of the element)
                                         *  - The name of the property(or The index of the element)
                                         *  - The object being traversed
                                         * @param {Object} obj The object that will be traversed
                                         * @param {function} iteratee Callback function
                                         * @param {Object} [context] Context(this) of callback function
                                         * @memberof module:collection
                                         * @example
                                         * var forEach = require('tui-code-snippet/collection/forEach'); // node, commonjs
                                         *
                                         * var sum = 0;
                                         *
                                         * forEach([1,2,3], function(value){
                                         *     sum += value;
                                         * });
                                         * alert(sum); // 6
                                         *
                                         * // In case of Array-like object
                                         * var array = Array.prototype.slice.call(arrayLike); // change to array
                                         * forEach(array, function(value){
                                         *     sum += value;
                                         * });
                                         */
                                        function forEach(obj, iteratee, context) {
                                            if (isArray(obj)) {
                                                forEachArray(obj, iteratee, context);
                                            } else {
                                                forEachOwnProperties(obj, iteratee, context);
                                            }
                                        }

                                        module.exports = forEach;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/collection/forEachArray.js":
                                    /*!******************************************************************!*\
      !*** ./node_modules/tui-code-snippet/collection/forEachArray.js ***!
      \******************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Execute the provided callback once for each element present
                                         * in the array(or Array-like object) in ascending order.
                                         * If the callback function returns false, the loop will be stopped.
                                         * Callback function(iteratee) is invoked with three arguments:
                                         *  - The value of the element
                                         *  - The index of the element
                                         *  - The array(or Array-like object) being traversed
                                         * @param {Array} arr The array(or Array-like object) that will be traversed
                                         * @param {function} iteratee Callback function
                                         * @param {Object} [context] Context(this) of callback function
                                         * @memberof module:collection
                                         * @example
                                         * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
                                         *
                                         * var sum = 0;
                                         *
                                         * forEachArray([1,2,3], function(value){
                                         *     sum += value;
                                         * });
                                         * alert(sum); // 6
                                         */
                                        function forEachArray(arr, iteratee, context) {
                                            var index = 0;
                                            var len = arr.length;

                                            context = context || null;

                                            for (; index < len; index += 1) {
                                                if (iteratee.call(context, arr[index], index, arr) === false) {
                                                    break;
                                                }
                                            }
                                        }

                                        module.exports = forEachArray;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js":
                                    /*!**************************************************************************!*\
      !*** ./node_modules/tui-code-snippet/collection/forEachOwnProperties.js ***!
      \**************************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Execute the provided callback once for each property of object which actually exist.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Execute the provided callback once for each property of object which actually exist.
                                         * If the callback function returns false, the loop will be stopped.
                                         * Callback function(iteratee) is invoked with three arguments:
                                         *  - The value of the property
                                         *  - The name of the property
                                         *  - The object being traversed
                                         * @param {Object} obj The object that will be traversed
                                         * @param {function} iteratee  Callback function
                                         * @param {Object} [context] Context(this) of callback function
                                         * @memberof module:collection
                                         * @example
                                         * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
                                         *
                                         * var sum = 0;
                                         *
                                         * forEachOwnProperties({a:1,b:2,c:3}, function(value){
                                         *     sum += value;
                                         * });
                                         * alert(sum); // 6
                                         */
                                        function forEachOwnProperties(obj, iteratee, context) {
                                            var key;

                                            context = context || null;

                                            for (key in obj) {
                                                if (obj.hasOwnProperty(key)) {
                                                    if (iteratee.call(context, obj[key], key, obj) === false) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        module.exports = forEachOwnProperties;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/collection/toArray.js":
                                    /*!*************************************************************!*\
      !*** ./node_modules/tui-code-snippet/collection/toArray.js ***!
      \*************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Transform the Array-like object to Array.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var forEachArray = __webpack_require__(/*! ./forEachArray */ "./node_modules/tui-code-snippet/collection/forEachArray.js");

                                        /**
                                         * Transform the Array-like object to Array.
                                         * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
                                         * @param {*} arrayLike Array-like object
                                         * @returns {Array} Array
                                         * @memberof module:collection
                                         * @example
                                         * var toArray = require('tui-code-snippet/collection/toArray'); // node, commonjs
                                         *
                                         * var arrayLike = {
                                         *     0: 'one',
                                         *     1: 'two',
                                         *     2: 'three',
                                         *     3: 'four',
                                         *     length: 4
                                         * };
                                         * var result = toArray(arrayLike);
                                         *
                                         * alert(result instanceof Array); // true
                                         * alert(result); // one,two,three,four
                                         */
                                        function toArray(arrayLike) {
                                            var arr;
                                            try {
                                                arr = Array.prototype.slice.call(arrayLike);
                                            } catch (e) {
                                                arr = [];
                                                forEachArray(arrayLike, function(value) {
                                                    arr.push(value);
                                                });
                                            }

                                            return arr;
                                        }

                                        module.exports = toArray;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/customEvents/customEvents.js":
                                    /*!********************************************************************!*\
      !*** ./node_modules/tui-code-snippet/customEvents/customEvents.js ***!
      \********************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview This module provides some functions for custom events. And it is implemented in the observer design pattern.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var extend = __webpack_require__(/*! ../object/extend */ "./node_modules/tui-code-snippet/object/extend.js");
                                        var isExisty = __webpack_require__(/*! ../type/isExisty */ "./node_modules/tui-code-snippet/type/isExisty.js");
                                        var isString = __webpack_require__(/*! ../type/isString */ "./node_modules/tui-code-snippet/type/isString.js");
                                        var isObject = __webpack_require__(/*! ../type/isObject */ "./node_modules/tui-code-snippet/type/isObject.js");
                                        var isArray = __webpack_require__(/*! ../type/isArray */ "./node_modules/tui-code-snippet/type/isArray.js");
                                        var isFunction = __webpack_require__(/*! ../type/isFunction */ "./node_modules/tui-code-snippet/type/isFunction.js");
                                        var forEach = __webpack_require__(/*! ../collection/forEach */ "./node_modules/tui-code-snippet/collection/forEach.js");

                                        var R_EVENTNAME_SPLIT = /\s+/g;

                                        /**
                                         * @class
                                         * @example
                                         * // node, commonjs
                                         * var CustomEvents = require('tui-code-snippet/customEvents/customEvents');
                                         */
                                        function CustomEvents() {
                                            /**
                                             * @type {HandlerItem[]}
                                             */
                                            this.events = null;

                                            /**
                                             * only for checking specific context event was binded
                                             * @type {object[]}
                                             */
                                            this.contexts = null;
                                        }

                                        /**
                                         * Mixin custom events feature to specific constructor
                                         * @param {function} func - constructor
                                         * @example
                                         * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
                                         *
                                         * var model;
                                         * function Model() {
                                         *     this.name = '';
                                         * }
                                         * CustomEvents.mixin(Model);
                                         *
                                         * model = new Model();
                                         * model.on('change', function() { this.name = 'model'; }, this);
                                         * model.fire('change');
                                         * alert(model.name); // 'model';
                                         */
                                        CustomEvents.mixin = function(func) {
                                            extend(func.prototype, CustomEvents.prototype);
                                        };

                                        /**
                                         * Get HandlerItem object
                                         * @param {function} handler - handler function
                                         * @param {object} [context] - context for handler
                                         * @returns {HandlerItem} HandlerItem object
                                         * @private
                                         */
                                        CustomEvents.prototype._getHandlerItem = function(handler, context) {
                                            var item = {handler: handler};

                                            if (context) {
                                                item.context = context;
                                            }

                                            return item;
                                        };

                                        /**
                                         * Get event object safely
                                         * @param {string} [eventName] - create sub event map if not exist.
                                         * @returns {(object|array)} event object. if you supplied `eventName`
                                         *  parameter then make new array and return it
                                         * @private
                                         */
                                        CustomEvents.prototype._safeEvent = function(eventName) {
                                            var events = this.events;
                                            var byName;

                                            if (!events) {
                                                events = this.events = {};
                                            }

                                            if (eventName) {
                                                byName = events[eventName];

                                                if (!byName) {
                                                    byName = [];
                                                    events[eventName] = byName;
                                                }

                                                events = byName;
                                            }

                                            return events;
                                        };

                                        /**
                                         * Get context array safely
                                         * @returns {array} context array
                                         * @private
                                         */
                                        CustomEvents.prototype._safeContext = function() {
                                            var context = this.contexts;

                                            if (!context) {
                                                context = this.contexts = [];
                                            }

                                            return context;
                                        };

                                        /**
                                         * Get index of context
                                         * @param {object} ctx - context that used for bind custom event
                                         * @returns {number} index of context
                                         * @private
                                         */
                                        CustomEvents.prototype._indexOfContext = function(ctx) {
                                            var context = this._safeContext();
                                            var index = 0;

                                            while (context[index]) {
                                                if (ctx === context[index][0]) {
                                                    return index;
                                                }

                                                index += 1;
                                            }

                                            return -1;
                                        };

                                        /**
                                         * Memorize supplied context for recognize supplied object is context or
                                         *  name: handler pair object when off()
                                         * @param {object} ctx - context object to memorize
                                         * @private
                                         */
                                        CustomEvents.prototype._memorizeContext = function(ctx) {
                                            var context, index;

                                            if (!isExisty(ctx)) {
                                                return;
                                            }

                                            context = this._safeContext();
                                            index = this._indexOfContext(ctx);

                                            if (index > -1) {
                                                context[index][1] += 1;
                                            } else {
                                                context.push([ctx, 1]);
                                            }
                                        };

                                        /**
                                         * Forget supplied context object
                                         * @param {object} ctx - context object to forget
                                         * @private
                                         */
                                        CustomEvents.prototype._forgetContext = function(ctx) {
                                            var context, contextIndex;

                                            if (!isExisty(ctx)) {
                                                return;
                                            }

                                            context = this._safeContext();
                                            contextIndex = this._indexOfContext(ctx);

                                            if (contextIndex > -1) {
                                                context[contextIndex][1] -= 1;

                                                if (context[contextIndex][1] <= 0) {
                                                    context.splice(contextIndex, 1);
                                                }
                                            }
                                        };

                                        /**
                                         * Bind event handler
                                         * @param {(string|{name:string, handler:function})} eventName - custom
                                         *  event name or an object {eventName: handler}
                                         * @param {(function|object)} [handler] - handler function or context
                                         * @param {object} [context] - context for binding
                                         * @private
                                         */
                                        CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
                                            var events = this._safeEvent(eventName);
                                            this._memorizeContext(context);
                                            events.push(this._getHandlerItem(handler, context));
                                        };

                                        /**
                                         * Bind event handlers
                                         * @param {(string|{name:string, handler:function})} eventName - custom
                                         *  event name or an object {eventName: handler}
                                         * @param {(function|object)} [handler] - handler function or context
                                         * @param {object} [context] - context for binding
                                         * //-- #1. Get Module --//
                                         * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
                                         *
                                         * //-- #2. Use method --//
                                         * // # 2.1 Basic Usage
                                         * CustomEvents.on('onload', handler);
                                         *
                                         * // # 2.2 With context
                                         * CustomEvents.on('onload', handler, myObj);
                                         *
                                         * // # 2.3 Bind by object that name, handler pairs
                                         * CustomEvents.on({
                                         *     'play': handler,
                                         *     'pause': handler2
                                         * });
                                         *
                                         * // # 2.4 Bind by object that name, handler pairs with context object
                                         * CustomEvents.on({
                                         *     'play': handler
                                         * }, myObj);
                                         */
                                        CustomEvents.prototype.on = function(eventName, handler, context) {
                                            var self = this;

                                            if (isString(eventName)) {
                                                // [syntax 1, 2]
                                                eventName = eventName.split(R_EVENTNAME_SPLIT);
                                                forEach(eventName, function(name) {
                                                    self._bindEvent(name, handler, context);
                                                });
                                            } else if (isObject(eventName)) {
                                                // [syntax 3, 4]
                                                context = handler;
                                                forEach(eventName, function(func, name) {
                                                    self.on(name, func, context);
                                                });
                                            }
                                        };

                                        /**
                                         * Bind one-shot event handlers
                                         * @param {(string|{name:string,handler:function})} eventName - custom
                                         *  event name or an object {eventName: handler}
                                         * @param {function|object} [handler] - handler function or context
                                         * @param {object} [context] - context for binding
                                         */
                                        CustomEvents.prototype.once = function(eventName, handler, context) {
                                            var self = this;

                                            if (isObject(eventName)) {
                                                context = handler;
                                                forEach(eventName, function(func, name) {
                                                    self.once(name, func, context);
                                                });

                                                return;
                                            }

                                            function onceHandler() { // eslint-disable-line require-jsdoc
                                                handler.apply(context, arguments);
                                                self.off(eventName, onceHandler, context);
                                            }

                                            this.on(eventName, onceHandler, context);
                                        };

                                        /**
                                         * Splice supplied array by callback result
                                         * @param {array} arr - array to splice
                                         * @param {function} predicate - function return boolean
                                         * @private
                                         */
                                        CustomEvents.prototype._spliceMatches = function(arr, predicate) {
                                            var i = 0;
                                            var len;

                                            if (!isArray(arr)) {
                                                return;
                                            }

                                            for (len = arr.length; i < len; i += 1) {
                                                if (predicate(arr[i]) === true) {
                                                    arr.splice(i, 1);
                                                    len -= 1;
                                                    i -= 1;
                                                }
                                            }
                                        };

                                        /**
                                         * Get matcher for unbind specific handler events
                                         * @param {function} handler - handler function
                                         * @returns {function} handler matcher
                                         * @private
                                         */
                                        CustomEvents.prototype._matchHandler = function(handler) {
                                            var self = this;

                                            return function(item) {
                                                var needRemove = handler === item.handler;

                                                if (needRemove) {
                                                    self._forgetContext(item.context);
                                                }

                                                return needRemove;
                                            };
                                        };

                                        /**
                                         * Get matcher for unbind specific context events
                                         * @param {object} context - context
                                         * @returns {function} object matcher
                                         * @private
                                         */
                                        CustomEvents.prototype._matchContext = function(context) {
                                            var self = this;

                                            return function(item) {
                                                var needRemove = context === item.context;

                                                if (needRemove) {
                                                    self._forgetContext(item.context);
                                                }

                                                return needRemove;
                                            };
                                        };

                                        /**
                                         * Get matcher for unbind specific hander, context pair events
                                         * @param {function} handler - handler function
                                         * @param {object} context - context
                                         * @returns {function} handler, context matcher
                                         * @private
                                         */
                                        CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
                                            var self = this;

                                            return function(item) {
                                                var matchHandler = (handler === item.handler);
                                                var matchContext = (context === item.context);
                                                var needRemove = (matchHandler && matchContext);

                                                if (needRemove) {
                                                    self._forgetContext(item.context);
                                                }

                                                return needRemove;
                                            };
                                        };

                                        /**
                                         * Unbind event by event name
                                         * @param {string} eventName - custom event name to unbind
                                         * @param {function} [handler] - handler function
                                         * @private
                                         */
                                        CustomEvents.prototype._offByEventName = function(eventName, handler) {
                                            var self = this;
                                            var andByHandler = isFunction(handler);
                                            var matchHandler = self._matchHandler(handler);

                                            eventName = eventName.split(R_EVENTNAME_SPLIT);

                                            forEach(eventName, function(name) {
                                                var handlerItems = self._safeEvent(name);

                                                if (andByHandler) {
                                                    self._spliceMatches(handlerItems, matchHandler);
                                                } else {
                                                    forEach(handlerItems, function(item) {
                                                        self._forgetContext(item.context);
                                                    });

                                                    self.events[name] = [];
                                                }
                                            });
                                        };

                                        /**
                                         * Unbind event by handler function
                                         * @param {function} handler - handler function
                                         * @private
                                         */
                                        CustomEvents.prototype._offByHandler = function(handler) {
                                            var self = this;
                                            var matchHandler = this._matchHandler(handler);

                                            forEach(this._safeEvent(), function(handlerItems) {
                                                self._spliceMatches(handlerItems, matchHandler);
                                            });
                                        };

                                        /**
                                         * Unbind event by object(name: handler pair object or context object)
                                         * @param {object} obj - context or {name: handler} pair object
                                         * @param {function} handler - handler function
                                         * @private
                                         */
                                        CustomEvents.prototype._offByObject = function(obj, handler) {
                                            var self = this;
                                            var matchFunc;

                                            if (this._indexOfContext(obj) < 0) {
                                                forEach(obj, function(func, name) {
                                                    self.off(name, func);
                                                });
                                            } else if (isString(handler)) {
                                                matchFunc = this._matchContext(obj);

                                                self._spliceMatches(this._safeEvent(handler), matchFunc);
                                            } else if (isFunction(handler)) {
                                                matchFunc = this._matchHandlerAndContext(handler, obj);

                                                forEach(this._safeEvent(), function(handlerItems) {
                                                    self._spliceMatches(handlerItems, matchFunc);
                                                });
                                            } else {
                                                matchFunc = this._matchContext(obj);

                                                forEach(this._safeEvent(), function(handlerItems) {
                                                    self._spliceMatches(handlerItems, matchFunc);
                                                });
                                            }
                                        };

                                        /**
                                         * Unbind custom events
                                         * @param {(string|object|function)} eventName - event name or context or
                                         *  {name: handler} pair object or handler function
                                         * @param {(function)} handler - handler function
                                         * @example
                                         * //-- #1. Get Module --//
                                         * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
                                         *
                                         * //-- #2. Use method --//
                                         * // # 2.1 off by event name
                                         * CustomEvents.off('onload');
                                         *
                                         * // # 2.2 off by event name and handler
                                         * CustomEvents.off('play', handler);
                                         *
                                         * // # 2.3 off by handler
                                         * CustomEvents.off(handler);
                                         *
                                         * // # 2.4 off by context
                                         * CustomEvents.off(myObj);
                                         *
                                         * // # 2.5 off by context and handler
                                         * CustomEvents.off(myObj, handler);
                                         *
                                         * // # 2.6 off by context and event name
                                         * CustomEvents.off(myObj, 'onload');
                                         *
                                         * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
                                         * CustomEvents.off({
                                         *   'play': handler,
                                         *   'pause': handler2
                                         * });
                                         *
                                         * // # 2.8 off the all events
                                         * CustomEvents.off();
                                         */
                                        CustomEvents.prototype.off = function(eventName, handler) {
                                            if (isString(eventName)) {
                                                // [syntax 1, 2]
                                                this._offByEventName(eventName, handler);
                                            } else if (!arguments.length) {
                                                // [syntax 8]
                                                this.events = {};
                                                this.contexts = [];
                                            } else if (isFunction(eventName)) {
                                                // [syntax 3]
                                                this._offByHandler(eventName);
                                            } else if (isObject(eventName)) {
                                                // [syntax 4, 5, 6]
                                                this._offByObject(eventName, handler);
                                            }
                                        };

                                        /**
                                         * Fire custom event
                                         * @param {string} eventName - name of custom event
                                         */
                                        CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
                                            this.invoke.apply(this, arguments);
                                        };

                                        /**
                                         * Fire a event and returns the result of operation 'boolean AND' with all
                                         *  listener's results.
                                         *
                                         * So, It is different from {@link CustomEvents#fire}.
                                         *
                                         * In service code, use this as a before event in component level usually
                                         *  for notifying that the event is cancelable.
                                         * @param {string} eventName - Custom event name
                                         * @param {...*} data - Data for event
                                         * @returns {boolean} The result of operation 'boolean AND'
                                         * @example
                                         * var map = new Map();
                                         * map.on({
                                         *     'beforeZoom': function() {
                                         *         // It should cancel the 'zoom' event by some conditions.
                                         *         if (that.disabled && this.getState()) {
                                         *             return false;
                                         *         }
                                         *         return true;
                                         *     }
                                         * });
                                         *
                                         * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
                                         *     // if true,
                                         *     // doSomething
                                         * }
                                         */
                                        CustomEvents.prototype.invoke = function(eventName) {
                                            var events, args, index, item;

                                            if (!this.hasListener(eventName)) {
                                                return true;
                                            }

                                            events = this._safeEvent(eventName);
                                            args = Array.prototype.slice.call(arguments, 1);
                                            index = 0;

                                            while (events[index]) {
                                                item = events[index];

                                                if (item.handler.apply(item.context, args) === false) {
                                                    return false;
                                                }

                                                index += 1;
                                            }

                                            return true;
                                        };

                                        /**
                                         * Return whether at least one of the handlers is registered in the given
                                         *  event name.
                                         * @param {string} eventName - Custom event name
                                         * @returns {boolean} Is there at least one handler in event name?
                                         */
                                        CustomEvents.prototype.hasListener = function(eventName) {
                                            return this.getListenerLength(eventName) > 0;
                                        };

                                        /**
                                         * Return a count of events registered.
                                         * @param {string} eventName - Custom event name
                                         * @returns {number} number of event
                                         */
                                        CustomEvents.prototype.getListenerLength = function(eventName) {
                                            var events = this._safeEvent(eventName);

                                            return events.length;
                                        };

                                        module.exports = CustomEvents;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domEvent/_safeEvent.js":
                                    /*!**************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domEvent/_safeEvent.js ***!
      \**************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Get event collection for specific HTML element
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var EVENT_KEY = '_feEventKey';

                                        /**
                                         * Get event collection for specific HTML element
                                         * @param {HTMLElement} element - HTML element
                                         * @param {string} type - event type
                                         * @returns {array}
                                         * @private
                                         */
                                        function safeEvent(element, type) {
                                            var events = element[EVENT_KEY];
                                            var handlers;

                                            if (!events) {
                                                events = element[EVENT_KEY] = {};
                                            }

                                            handlers = events[type];
                                            if (!handlers) {
                                                handlers = events[type] = [];
                                            }

                                            return handlers;
                                        }

                                        module.exports = safeEvent;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domEvent/getTarget.js":
                                    /*!*************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domEvent/getTarget.js ***!
      \*************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Get a target element from an event object.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Get a target element from an event object.
                                         * @param {Event} e - event object
                                         * @returns {HTMLElement} - target element
                                         * @memberof module:domEvent
                                         */
                                        function getTarget(e) {
                                            return e.target || e.srcElement;
                                        }

                                        module.exports = getTarget;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domEvent/off.js":
                                    /*!*******************************************************!*\
      !*** ./node_modules/tui-code-snippet/domEvent/off.js ***!
      \*******************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Unbind DOM events
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var isString = __webpack_require__(/*! ../type/isString */ "./node_modules/tui-code-snippet/type/isString.js");
                                        var forEach = __webpack_require__(/*! ../collection/forEach */ "./node_modules/tui-code-snippet/collection/forEach.js");

                                        var safeEvent = __webpack_require__(/*! ./_safeEvent */ "./node_modules/tui-code-snippet/domEvent/_safeEvent.js");

                                        /**
                                         * Unbind DOM events
                                         * If a handler function is not passed, remove all events of that type.
                                         * @param {HTMLElement} element - element to unbindbind events
                                         * @param {(string|object)} types - Space splitted events names or
                                         *  eventName:handler object
                                         * @param {function} [handler] - handler function
                                         * @memberof module:domEvent
                                         */
                                        function off(element, types, handler) {
                                            if (isString(types)) {
                                                forEach(types.split(/\s+/g), function(type) {
                                                    unbindEvent(element, type, handler);
                                                });

                                                return;
                                            }

                                            forEach(types, function(func, type) {
                                                unbindEvent(element, type, func);
                                            });
                                        }

                                        /**
                                         * Unbind DOM events
                                         * If a handler function is not passed, remove all events of that type.
                                         * @param {HTMLElement} element - element to unbind events
                                         * @param {string} type - events name
                                         * @param {function} [handler] - handler function
                                         * @private
                                         */
                                        function unbindEvent(element, type, handler) {
                                            var events = safeEvent(element, type);
                                            var index;

                                            if (!handler) {
                                                forEach(events, function(item) {
                                                    removeHandler(element, type, item.wrappedHandler);
                                                });
                                                events.splice(0, events.length);
                                            } else {
                                                forEach(events, function(item, idx) {
                                                    if (handler === item.handler) {
                                                        removeHandler(element, type, item.wrappedHandler);
                                                        index = idx;

                                                        return false;
                                                    }

                                                    return true;
                                                });
                                                events.splice(index, 1);
                                            }
                                        }

                                        /**
                                         * Remove an event handler
                                         * @param {HTMLElement} element - An element to remove an event
                                         * @param {string} type - event type
                                         * @param {function} handler - event handler
                                         * @private
                                         */
                                        function removeHandler(element, type, handler) {
                                            if ('removeEventListener' in element) {
                                                element.removeEventListener(type, handler);
                                            } else if ('detachEvent' in element) {
                                                element.detachEvent('on' + type, handler);
                                            }
                                        }

                                        module.exports = off;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domEvent/on.js":
                                    /*!******************************************************!*\
      !*** ./node_modules/tui-code-snippet/domEvent/on.js ***!
      \******************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Bind DOM events
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var isString = __webpack_require__(/*! ../type/isString */ "./node_modules/tui-code-snippet/type/isString.js");
                                        var forEach = __webpack_require__(/*! ../collection/forEach */ "./node_modules/tui-code-snippet/collection/forEach.js");

                                        var safeEvent = __webpack_require__(/*! ./_safeEvent */ "./node_modules/tui-code-snippet/domEvent/_safeEvent.js");

                                        /**
                                         * Bind DOM events
                                         * @param {HTMLElement} element - element to bind events
                                         * @param {(string|object)} types - Space splitted events names or
                                         *  eventName:handler object
                                         * @param {(function|object)} handler - handler function or context for handler
                                         *  method
                                         * @param {object} [context] context - context for handler method.
                                         * @memberof module:domEvent
                                         */
                                        function on(element, types, handler, context) {
                                            if (isString(types)) {
                                                forEach(types.split(/\s+/g), function(type) {
                                                    bindEvent(element, type, handler, context);
                                                });

                                                return;
                                            }

                                            forEach(types, function(func, type) {
                                                bindEvent(element, type, func, handler);
                                            });
                                        }

                                        /**
                                         * Bind DOM events
                                         * @param {HTMLElement} element - element to bind events
                                         * @param {string} type - events name
                                         * @param {function} handler - handler function or context for handler
                                         *  method
                                         * @param {object} [context] context - context for handler method.
                                         * @private
                                         */
                                        function bindEvent(element, type, handler, context) {
                                            /**
                                             * Event handler
                                             * @param {Event} e - event object
                                             */
                                            function eventHandler(e) {
                                                handler.call(context || element, e || window.event);
                                            }

                                            if ('addEventListener' in element) {
                                                element.addEventListener(type, eventHandler);
                                            } else if ('attachEvent' in element) {
                                                element.attachEvent('on' + type, eventHandler);
                                            }
                                            memorizeHandler(element, type, handler, eventHandler);
                                        }

                                        /**
                                         * Memorize DOM event handler for unbinding.
                                         * @param {HTMLElement} element - element to bind events
                                         * @param {string} type - events name
                                         * @param {function} handler - handler function that user passed at on() use
                                         * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features
                                         * @private
                                         */
                                        function memorizeHandler(element, type, handler, wrappedHandler) {
                                            var events = safeEvent(element, type);
                                            var existInEvents = false;

                                            forEach(events, function(obj) {
                                                if (obj.handler === handler) {
                                                    existInEvents = true;

                                                    return false;
                                                }

                                                return true;
                                            });

                                            if (!existInEvents) {
                                                events.push({
                                                    handler: handler,
                                                    wrappedHandler: wrappedHandler
                                                });
                                            }
                                        }

                                        module.exports = on;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domEvent/preventDefault.js":
                                    /*!******************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domEvent/preventDefault.js ***!
      \******************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Prevent default action
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Prevent default action
                                         * @param {Event} e - event object
                                         * @memberof module:domEvent
                                         */
                                        function preventDefault(e) {
                                            if (e.preventDefault) {
                                                e.preventDefault();

                                                return;
                                            }

                                            e.returnValue = false;
                                        }

                                        module.exports = preventDefault;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domUtil/_setClassName.js":
                                    /*!****************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/_setClassName.js ***!
      \****************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Set className value
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var isArray = __webpack_require__(/*! ../type/isArray */ "./node_modules/tui-code-snippet/type/isArray.js");
                                        var isUndefined = __webpack_require__(/*! ../type/isUndefined */ "./node_modules/tui-code-snippet/type/isUndefined.js");

                                        /**
                                         * Set className value
                                         * @param {(HTMLElement|SVGElement)} element - target element
                                         * @param {(string|string[])} cssClass - class names
                                         * @private
                                         */
                                        function setClassName(element, cssClass) {
                                            cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

                                            cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

                                            if (isUndefined(element.className.baseVal)) {
                                                element.className = cssClass;

                                                return;
                                            }

                                            element.className.baseVal = cssClass;
                                        }

                                        module.exports = setClassName;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domUtil/addClass.js":
                                    /*!***********************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/addClass.js ***!
      \***********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Add css class to element
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var forEach = __webpack_require__(/*! ../collection/forEach */ "./node_modules/tui-code-snippet/collection/forEach.js");
                                        var inArray = __webpack_require__(/*! ../array/inArray */ "./node_modules/tui-code-snippet/array/inArray.js");
                                        var getClass = __webpack_require__(/*! ./getClass */ "./node_modules/tui-code-snippet/domUtil/getClass.js");
                                        var setClassName = __webpack_require__(/*! ./_setClassName */ "./node_modules/tui-code-snippet/domUtil/_setClassName.js");

                                        /**
                                         * domUtil module
                                         * @module domUtil
                                         */

                                        /**
                                         * Add css class to element
                                         * @param {(HTMLElement|SVGElement)} element - target element
                                         * @param {...string} cssClass - css classes to add
                                         * @memberof module:domUtil
                                         */
                                        function addClass(element) {
                                            var cssClass = Array.prototype.slice.call(arguments, 1);
                                            var classList = element.classList;
                                            var newClass = [];
                                            var origin;

                                            if (classList) {
                                                forEach(cssClass, function(name) {
                                                    element.classList.add(name);
                                                });

                                                return;
                                            }

                                            origin = getClass(element);

                                            if (origin) {
                                                cssClass = [].concat(origin.split(/\s+/), cssClass);
                                            }

                                            forEach(cssClass, function(cls) {
                                                if (inArray(cls, newClass) < 0) {
                                                    newClass.push(cls);
                                                }
                                            });

                                            setClassName(element, newClass);
                                        }

                                        module.exports = addClass;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domUtil/closest.js":
                                    /*!**********************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/closest.js ***!
      \**********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Find parent element recursively
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var matches = __webpack_require__(/*! ./matches */ "./node_modules/tui-code-snippet/domUtil/matches.js");

                                        /**
                                         * Find parent element recursively
                                         * @param {HTMLElement} element - base element to start find
                                         * @param {string} selector - selector string for find
                                         * @returns {HTMLElement} - element finded or null
                                         * @memberof module:domUtil
                                         */
                                        function closest(element, selector) {
                                            var parent = element.parentNode;

                                            if (matches(element, selector)) {
                                                return element;
                                            }

                                            while (parent && parent !== document) {
                                                if (matches(parent, selector)) {
                                                    return parent;
                                                }

                                                parent = parent.parentNode;
                                            }

                                            return null;
                                        }

                                        module.exports = closest;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domUtil/getClass.js":
                                    /*!***********************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/getClass.js ***!
      \***********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Get HTML element's design classes.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var isUndefined = __webpack_require__(/*! ../type/isUndefined */ "./node_modules/tui-code-snippet/type/isUndefined.js");

                                        /**
                                         * Get HTML element's design classes.
                                         * @param {(HTMLElement|SVGElement)} element target element
                                         * @returns {string} element css class name
                                         * @memberof module:domUtil
                                         */
                                        function getClass(element) {
                                            if (!element || !element.className) {
                                                return '';
                                            }

                                            if (isUndefined(element.className.baseVal)) {
                                                return element.className;
                                            }

                                            return element.className.baseVal;
                                        }

                                        module.exports = getClass;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domUtil/matches.js":
                                    /*!**********************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/matches.js ***!
      \**********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check element match selector
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var inArray = __webpack_require__(/*! ../array/inArray */ "./node_modules/tui-code-snippet/array/inArray.js");
                                        var toArray = __webpack_require__(/*! ../collection/toArray */ "./node_modules/tui-code-snippet/collection/toArray.js");

                                        var elProto = Element.prototype;
                                        var matchSelector = elProto.matches ||
                                            elProto.webkitMatchesSelector ||
                                            elProto.mozMatchesSelector ||
                                            elProto.msMatchesSelector ||
                                            function(selector) {
                                                var doc = this.document || this.ownerDocument;

                                                return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;
                                            };

                                        /**
                                         * Check element match selector
                                         * @param {HTMLElement} element - element to check
                                         * @param {string} selector - selector to check
                                         * @returns {boolean} is selector matched to element?
                                         * @memberof module:domUtil
                                         */
                                        function matches(element, selector) {
                                            return matchSelector.call(element, selector);
                                        }

                                        module.exports = matches;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domUtil/removeClass.js":
                                    /*!**************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/removeClass.js ***!
      \**************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Remove css class from element
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var forEachArray = __webpack_require__(/*! ../collection/forEachArray */ "./node_modules/tui-code-snippet/collection/forEachArray.js");
                                        var inArray = __webpack_require__(/*! ../array/inArray */ "./node_modules/tui-code-snippet/array/inArray.js");
                                        var getClass = __webpack_require__(/*! ./getClass */ "./node_modules/tui-code-snippet/domUtil/getClass.js");
                                        var setClassName = __webpack_require__(/*! ./_setClassName */ "./node_modules/tui-code-snippet/domUtil/_setClassName.js");

                                        /**
                                         * Remove css class from element
                                         * @param {(HTMLElement|SVGElement)} element - target element
                                         * @param {...string} cssClass - css classes to remove
                                         * @memberof module:domUtil
                                         */
                                        function removeClass(element) {
                                            var cssClass = Array.prototype.slice.call(arguments, 1);
                                            var classList = element.classList;
                                            var origin, newClass;

                                            if (classList) {
                                                forEachArray(cssClass, function(name) {
                                                    classList.remove(name);
                                                });

                                                return;
                                            }

                                            origin = getClass(element).split(/\s+/);
                                            newClass = [];
                                            forEachArray(origin, function(name) {
                                                if (inArray(name, cssClass) < 0) {
                                                    newClass.push(name);
                                                }
                                            });

                                            setClassName(element, newClass);
                                        }

                                        module.exports = removeClass;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/domUtil/removeElement.js":
                                    /*!****************************************************************!*\
      !*** ./node_modules/tui-code-snippet/domUtil/removeElement.js ***!
      \****************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Remove element from parent node.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Remove element from parent node.
                                         * @param {HTMLElement} element - element to remove.
                                         * @memberof module:domUtil
                                         */
                                        function removeElement(element) {
                                            if (element && element.parentNode) {
                                                element.parentNode.removeChild(element);
                                            }
                                        }

                                        module.exports = removeElement;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/object/extend.js":
                                    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/object/extend.js ***!
      \********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Extend the target object from other objects.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * @module object
                                         */

                                        /**
                                         * Extend the target object from other objects.
                                         * @param {object} target - Object that will be extended
                                         * @param {...object} objects - Objects as sources
                                         * @returns {object} Extended object
                                         * @memberof module:object
                                         */
                                        function extend(target, objects) { // eslint-disable-line no-unused-vars
                                            var hasOwnProp = Object.prototype.hasOwnProperty;
                                            var source, prop, i, len;

                                            for (i = 1, len = arguments.length; i < len; i += 1) {
                                                source = arguments[i];
                                                for (prop in source) {
                                                    if (hasOwnProp.call(source, prop)) {
                                                        target[prop] = source[prop];
                                                    }
                                                }
                                            }

                                            return target;
                                        }

                                        module.exports = extend;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/request/imagePing.js":
                                    /*!************************************************************!*\
      !*** ./node_modules/tui-code-snippet/request/imagePing.js ***!
      \************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Request image ping.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var forEachOwnProperties = __webpack_require__(/*! ../collection/forEachOwnProperties */ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js");

                                        /**
                                         * @module request
                                         */

                                        /**
                                         * Request image ping.
                                         * @param {String} url url for ping request
                                         * @param {Object} trackingInfo infos for make query string
                                         * @returns {HTMLElement}
                                         * @memberof module:request
                                         * @example
                                         * var imagePing = require('tui-code-snippet/request/imagePing'); // node, commonjs
                                         *
                                         * imagePing('https://www.google-analytics.com/collect', {
                                         *     v: 1,
                                         *     t: 'event',
                                         *     tid: 'trackingid',
                                         *     cid: 'cid',
                                         *     dp: 'dp',
                                         *     dh: 'dh'
                                         * });
                                         */
                                        function imagePing(url, trackingInfo) {
                                            var trackingElement = document.createElement('img');
                                            var queryString = '';
                                            forEachOwnProperties(trackingInfo, function(value, key) {
                                                queryString += '&' + key + '=' + value;
                                            });
                                            queryString = queryString.substring(1);

                                            trackingElement.src = url + '?' + queryString;

                                            trackingElement.style.display = 'none';
                                            document.body.appendChild(trackingElement);
                                            document.body.removeChild(trackingElement);

                                            return trackingElement;
                                        }

                                        module.exports = imagePing;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/request/sendHostname.js":
                                    /*!***************************************************************!*\
      !*** ./node_modules/tui-code-snippet/request/sendHostname.js ***!
      \***************************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Send hostname on DOMContentLoaded.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var isUndefined = __webpack_require__(/*! ../type/isUndefined */ "./node_modules/tui-code-snippet/type/isUndefined.js");
                                        var imagePing = __webpack_require__(/*! ./imagePing */ "./node_modules/tui-code-snippet/request/imagePing.js");

                                        var ms7days = 7 * 24 * 60 * 60 * 1000;

                                        /**
                                         * Check if the date has passed 7 days
                                         * @param {number} date - milliseconds
                                         * @returns {boolean}
                                         * @private
                                         */
                                        function isExpired(date) {
                                            var now = new Date().getTime();

                                            return now - date > ms7days;
                                        }

                                        /**
                                         * Send hostname on DOMContentLoaded.
                                         * To prevent hostname set tui.usageStatistics to false.
                                         * @param {string} appName - application name
                                         * @param {string} trackingId - GA tracking ID
                                         * @ignore
                                         */
                                        function sendHostname(appName, trackingId) {
                                            var url = 'https://www.google-analytics.com/collect';
                                            var hostname = location.hostname;
                                            var hitType = 'event';
                                            var eventCategory = 'use';
                                            var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
                                            var date = window.localStorage.getItem(applicationKeyForStorage);

                                            // skip if the flag is defined and is set to false explicitly
                                            if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
                                                return;
                                            }

                                            // skip if not pass seven days old
                                            if (date && !isExpired(date)) {
                                                return;
                                            }

                                            window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

                                            setTimeout(function() {
                                                if (document.readyState === 'interactive' || document.readyState === 'complete') {
                                                    imagePing(url, {
                                                        v: 1,
                                                        t: hitType,
                                                        tid: trackingId,
                                                        cid: hostname,
                                                        dp: hostname,
                                                        dh: appName,
                                                        el: appName,
                                                        ec: eventCategory
                                                    });
                                                }
                                            }, 1000);
                                        }

                                        module.exports = sendHostname;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/type/isArray.js":
                                    /*!*******************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isArray.js ***!
      \*******************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check whether the given variable is an instance of Array or not.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Check whether the given variable is an instance of Array or not.
                                         * If the given variable is an instance of Array, return true.
                                         * @param {*} obj - Target for checking
                                         * @returns {boolean} Is array instance?
                                         * @memberof module:type
                                         */
                                        function isArray(obj) {
                                            return obj instanceof Array;
                                        }

                                        module.exports = isArray;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/type/isBoolean.js":
                                    /*!*********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isBoolean.js ***!
      \*********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check whether the given variable is a string or not.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Check whether the given variable is a boolean or not.
                                         *  If the given variable is a boolean, return true.
                                         * @param {*} obj - Target for checking
                                         * @returns {boolean} Is boolean?
                                         * @memberof module:type
                                         */
                                        function isBoolean(obj) {
                                            return typeof obj === 'boolean' || obj instanceof Boolean;
                                        }

                                        module.exports = isBoolean;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/type/isExisty.js":
                                    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isExisty.js ***!
      \********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check whether the given variable is existing or not.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        var isUndefined = __webpack_require__(/*! ./isUndefined */ "./node_modules/tui-code-snippet/type/isUndefined.js");
                                        var isNull = __webpack_require__(/*! ./isNull */ "./node_modules/tui-code-snippet/type/isNull.js");

                                        /**
                                         * Check whether the given variable is existing or not.
                                         * If the given variable is not null and not undefined, returns true.
                                         * @param {*} param - Target for checking
                                         * @returns {boolean} Is existy?
                                         * @memberof module:type
                                         * @example
                                         * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
                                         *
                                         * isExisty(''); //true
                                         * isExisty(0); //true
                                         * isExisty([]); //true
                                         * isExisty({}); //true
                                         * isExisty(null); //false
                                         * isExisty(undefined); //false
                                         */
                                        function isExisty(param) {
                                            return !isUndefined(param) && !isNull(param);
                                        }

                                        module.exports = isExisty;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/type/isFunction.js":
                                    /*!**********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isFunction.js ***!
      \**********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check whether the given variable is a function or not.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Check whether the given variable is a function or not.
                                         * If the given variable is a function, return true.
                                         * @param {*} obj - Target for checking
                                         * @returns {boolean} Is function?
                                         * @memberof module:type
                                         */
                                        function isFunction(obj) {
                                            return obj instanceof Function;
                                        }

                                        module.exports = isFunction;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/type/isHTMLNode.js":
                                    /*!**********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isHTMLNode.js ***!
      \**********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check whether the given variable is a instance of HTMLNode or not.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Check whether the given variable is a instance of HTMLNode or not.
                                         * If the given variables is a instance of HTMLNode, return true.
                                         * @param {*} html - Target for checking
                                         * @returns {boolean} Is HTMLNode ?
                                         * @memberof module:type
                                         */
                                        function isHTMLNode(html) {
                                            if (typeof HTMLElement === 'object') {
                                                return (html && (html instanceof HTMLElement || !!html.nodeType));
                                            }

                                            return !!(html && html.nodeType);
                                        }

                                        module.exports = isHTMLNode;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/type/isNull.js":
                                    /*!******************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isNull.js ***!
      \******************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check whether the given variable is null or not.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Check whether the given variable is null or not.
                                         * If the given variable(arguments[0]) is null, returns true.
                                         * @param {*} obj - Target for checking
                                         * @returns {boolean} Is null?
                                         * @memberof module:type
                                         */
                                        function isNull(obj) {
                                            return obj === null;
                                        }

                                        module.exports = isNull;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/type/isNumber.js":
                                    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isNumber.js ***!
      \********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check whether the given variable is a number or not.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Check whether the given variable is a number or not.
                                         * If the given variable is a number, return true.
                                         * @param {*} obj - Target for checking
                                         * @returns {boolean} Is number?
                                         * @memberof module:type
                                         */
                                        function isNumber(obj) {
                                            return typeof obj === 'number' || obj instanceof Number;
                                        }

                                        module.exports = isNumber;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/type/isObject.js":
                                    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isObject.js ***!
      \********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check whether the given variable is an object or not.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Check whether the given variable is an object or not.
                                         * If the given variable is an object, return true.
                                         * @param {*} obj - Target for checking
                                         * @returns {boolean} Is object?
                                         * @memberof module:type
                                         */
                                        function isObject(obj) {
                                            return obj === Object(obj);
                                        }

                                        module.exports = isObject;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/type/isString.js":
                                    /*!********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isString.js ***!
      \********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check whether the given variable is a string or not.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Check whether the given variable is a string or not.
                                         * If the given variable is a string, return true.
                                         * @param {*} obj - Target for checking
                                         * @returns {boolean} Is string?
                                         * @memberof module:type
                                         */
                                        function isString(obj) {
                                            return typeof obj === 'string' || obj instanceof String;
                                        }

                                        module.exports = isString;


                                        /***/ }),

                                    /***/ "./node_modules/tui-code-snippet/type/isUndefined.js":
                                    /*!***********************************************************!*\
      !*** ./node_modules/tui-code-snippet/type/isUndefined.js ***!
      \***********************************************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {
                                        /**
                                         * @fileoverview Check whether the given variable is undefined or not.
                                         * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                         */



                                        /**
                                         * Check whether the given variable is undefined or not.
                                         * If the given variable is undefined, returns true.
                                         * @param {*} obj - Target for checking
                                         * @returns {boolean} Is undefined?
                                         * @memberof module:type
                                         */
                                        function isUndefined(obj) {
                                            return obj === undefined; // eslint-disable-line no-undefined
                                        }

                                        module.exports = isUndefined;


                                        /***/ }),

                                    /***/ "./src/css/selectBox.css":
                                    /*!*******************************!*\
      !*** ./src/css/selectBox.css ***!
      \*******************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        // extracted by mini-css-extract-plugin

                                        /***/ }),

                                    /***/ "./src/js/constants.js":
                                    /*!*****************************!*\
      !*** ./src/js/constants.js ***!
      \*****************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/collection/forEachOwnProperties */ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports, _forEachOwnProperties) {

                                            _exports.__esModule = true;
                                            _exports.cls = void 0;
                                            _forEachOwnProperties = _interopRequireDefault(_forEachOwnProperties);

                                            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

                                            /**
                                             * @fileoverview The static values
                                             * @author NHN. FE dev team.<dl_javascript@nhn.com>
                                             */
                                            var CSS_PREFIX = 'tui-select-box';
                                            var classNames = {
                                                SELECT_BOX: '',
                                                ITEM: 'item',
                                                ITEM_GROUP: 'item-group',
                                                ITEM_GROUP_LABEL: 'item-group-label',
                                                DROPDOWN: 'dropdown',
                                                INPUT: 'input',
                                                PLACEHOLDER: 'placeholder',
                                                ICON: 'icon',
                                                OPEN: 'open',
                                                HIDDEN: 'hidden',
                                                DISABLED: 'disabled',
                                                SELECTED: 'selected',
                                                HIGHLIGHT: 'highlight'
                                            };

                                            var cls = function () {
                                                (0, _forEachOwnProperties["default"])(classNames, function (value, key) {
                                                    if (value) {
                                                        classNames[key] = CSS_PREFIX + "-" + value;
                                                    } else {
                                                        classNames[key] = CSS_PREFIX;
                                                    }
                                                });
                                                return classNames;
                                            }();

                                            _exports.cls = cls;
                                        });

                                        /***/ }),

                                    /***/ "./src/js/dropdown.js":
                                    /*!****************************!*\
      !*** ./src/js/dropdown.js ***!
      \****************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/collection/forEachArray */ "./node_modules/tui-code-snippet/collection/forEachArray.js"), __webpack_require__(/*! tui-code-snippet/type/isExisty */ "./node_modules/tui-code-snippet/type/isExisty.js"), __webpack_require__(/*! tui-code-snippet/type/isNumber */ "./node_modules/tui-code-snippet/type/isNumber.js"), __webpack_require__(/*! tui-code-snippet/domUtil/addClass */ "./node_modules/tui-code-snippet/domUtil/addClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeClass */ "./node_modules/tui-code-snippet/domUtil/removeClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js"), __webpack_require__(/*! ./itemGroup */ "./src/js/itemGroup.js"), __webpack_require__(/*! ./item */ "./src/js/item.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports, _forEachArray, _isExisty, _isNumber, _addClass, _removeClass, _removeElement, _utils, _constants, _itemGroup, _item) {

                                            _exports.__esModule = true;
                                            _exports["default"] = void 0;
                                            _forEachArray = _interopRequireDefault(_forEachArray);
                                            _isExisty = _interopRequireDefault(_isExisty);
                                            _isNumber = _interopRequireDefault(_isNumber);
                                            _addClass = _interopRequireDefault(_addClass);
                                            _removeClass = _interopRequireDefault(_removeClass);
                                            _removeElement = _interopRequireDefault(_removeElement);
                                            _itemGroup = _interopRequireDefault(_itemGroup);
                                            _item = _interopRequireDefault(_item);

                                            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

                                            function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

                                            function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

                                            function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

                                            /**
                                             * @class
                                             * @ignore
                                             * @param {object} options - options
                                             *   @param {string} [options.placeholder] - placeholder for an input
                                             *   @param {array<itemData|itemGroupData>} options.data - data for ItemGroups and Items
                                             *   @param {boolean} [options.disabled=false] - whether a dropdown should be disabled or not
                                             */
                                            var Dropdown =
                                                /*#__PURE__*/
                                                function () {
                                                    function Dropdown(_ref) {
                                                        var placeholder = _ref.placeholder,
                                                            data = _ref.data,
                                                            _ref$disabled = _ref.disabled,
                                                            disabled = _ref$disabled === void 0 ? false : _ref$disabled;

                                                        /**
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */
                                                        this.el = (0, _utils.createElement)('ul', '', {
                                                            className: _constants.cls.DROPDOWN + " " + _constants.cls.HIDDEN
                                                        });
                                                        /**
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */

                                                        this.nativeEl = (0, _utils.createElement)('select', '', {
                                                            className: _constants.cls.HIDDEN,
                                                            tabIndex: -1
                                                        });
                                                        /**
                                                         * Items and ItemGroups
                                                         * @type {Array.<Item|ItemGroup>}
                                                         * @private
                                                         */

                                                        this.items = [];
                                                        /**
                                                         * the number of Item
                                                         * @type {number}
                                                         * @private
                                                         */

                                                        this.itemLength = 0;
                                                        /**
                                                         * @type {Item}
                                                         * @private
                                                         */

                                                        this.selectedItem = null;
                                                        /**
                                                         * @type {Item}
                                                         * @private
                                                         */

                                                        this.highlightedItem = null;
                                                        this.initialize(data, disabled, placeholder);
                                                    }
                                                    /**
                                                     * Create Items and ItemGroups and calculate the number of Items
                                                     * @return {array<Item|ItemGroup>}
                                                     * @private
                                                     */


                                                    var _proto = Dropdown.prototype;

                                                    _proto.initializeItems = function initializeItems(data) {
                                                        var _this = this;

                                                        var item;
                                                        var itemIndex = 0;
                                                        var itemGroupIndex = 0;
                                                        data.forEach(function (datum) {
                                                            if (datum.data) {
                                                                item = new _itemGroup["default"](_objectSpread({
                                                                    index: itemIndex,
                                                                    itemGroupIndex: itemGroupIndex
                                                                }, datum));
                                                                itemIndex += datum.data.length - 1;
                                                                itemGroupIndex += 1;
                                                            } else {
                                                                item = new _item["default"](_objectSpread({
                                                                    index: itemIndex
                                                                }, datum));
                                                            }

                                                            _this.items.push(item);

                                                            item.appendToContainer(_this.el, _this.nativeEl);
                                                            itemIndex += 1;
                                                        });
                                                        this.itemLength = itemIndex;
                                                    }
                                                    /**
                                                     * Initialize
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.initialize = function initialize(data, disabled, placeholder) {
                                                        var _this2 = this;

                                                        if (placeholder) {
                                                            (0, _utils.createElement)('option', '', {
                                                                label: placeholder,
                                                                value: ''
                                                            }, this.nativeEl);
                                                        }

                                                        this.initializeItems(data);
                                                        this.iterateItems(function (item) {
                                                            if (!_this2.selectedItem && item.isSelected()) {
                                                                _this2.selectedItem = item;
                                                            } else if (_this2.selectedItem && item.isSelected()) {
                                                                item.deselect();
                                                            }
                                                        });

                                                        if (disabled) {
                                                            this.disable();
                                                        }
                                                    }
                                                    /**
                                                     * Execute a function while iterating items
                                                     * @param {function} callback - function to execute
                                                     * @param  {...any} args - arguments
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.iterateItems = function iterateItems(callback) {
                                                        var _this3 = this;

                                                        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                                            args[_key - 1] = arguments[_key];
                                                        }

                                                        var index = 0;
                                                        (0, _forEachArray["default"])(this.items, function (item) {
                                                            var result = true;

                                                            if (item instanceof _itemGroup["default"]) {
                                                                (0, _forEachArray["default"])(item.getItems(), function (itemInGroup) {
                                                                    result = callback.apply(_this3, [itemInGroup, index].concat(args)) || false;
                                                                    index += 1;
                                                                    return result;
                                                                });
                                                                return result;
                                                            }

                                                            result = callback.apply(_this3, [item, index].concat(args));
                                                            index += 1;
                                                            return result;
                                                        });
                                                    }
                                                    /**
                                                     * Open a dropdown list
                                                     */
                                                    ;

                                                    _proto.open = function open() {
                                                        (0, _removeClass["default"])(this.el, _constants.cls.HIDDEN);
                                                        var highlightedItem = !this.selectedItem || this.selectedItem.isDisabled() ? this.getItems(function (item) {
                                                            return !item.isDisabled();
                                                        })[0] : this.selectedItem;
                                                        this.highlight(highlightedItem);
                                                    }
                                                    /**
                                                     * Close a dropdown list
                                                     */
                                                    ;

                                                    _proto.close = function close() {
                                                        (0, _addClass["default"])(this.el, _constants.cls.HIDDEN);
                                                        this.dehighlight();
                                                    }
                                                    /**
                                                     * Disable an dropdown
                                                     */
                                                    ;

                                                    _proto.disable = function disable() {
                                                        this.nativeEl.disabled = true;
                                                        (0, _addClass["default"])(this.el, _constants.cls.DISABLED);
                                                    }
                                                    /**
                                                     * Enable an dropdown
                                                     */
                                                    ;

                                                    _proto.enable = function enable() {
                                                        this.nativeEl.disabled = false;
                                                        (0, _removeClass["default"])(this.el, _constants.cls.DISABLED);
                                                    }
                                                    /**
                                                     * Select an Item
                                                     * @param {string|number|Item} value - if string, find an Item by its value. if number, find an Item by its index.
                                                     * @return {Item} result of selection
                                                     */
                                                    ;

                                                    _proto.select = function select(value) {
                                                        var selectedItem = value instanceof _item["default"] ? value : this.getItem(value);
                                                        this.deselect();

                                                        if (!selectedItem || selectedItem && selectedItem.isDisabled()) {
                                                            return null;
                                                        }

                                                        selectedItem.select();
                                                        this.selectedItem = selectedItem;
                                                        return selectedItem;
                                                    }
                                                    /**
                                                     * Deselect an Item
                                                     */
                                                    ;

                                                    _proto.deselect = function deselect() {
                                                        if (this.selectedItem) {
                                                            this.selectedItem.deselect();
                                                            this.selectedItem = null;
                                                        }
                                                    }
                                                    /**
                                                     * Highlight an Item
                                                     * @param {number|string|Item} value - if string, find an Item by its value. if number, find an Item by its index.
                                                     */
                                                    ;

                                                    _proto.highlight = function highlight(value) {
                                                        var highlightedItem;

                                                        if (value instanceof _item["default"]) {
                                                            highlightedItem = value;
                                                        } else if ((0, _isExisty["default"])(value)) {
                                                            highlightedItem = this.getItem(value);
                                                        }

                                                        if (highlightedItem && highlightedItem !== this.highlightedItem) {
                                                            this.dehighlight();
                                                            highlightedItem.highlight();
                                                            this.highlightedItem = highlightedItem;
                                                        }
                                                    }
                                                    /**
                                                     * Dehighlight an Item
                                                     */
                                                    ;

                                                    _proto.dehighlight = function dehighlight() {
                                                        if (this.highlightedItem) {
                                                            this.highlightedItem.dehighlight();
                                                            this.highlightedItem = null;
                                                        }
                                                    }
                                                    /**
                                                     * Move a highlighted Item
                                                     * @param {number} direction - direction to move
                                                     */
                                                    ;

                                                    _proto.moveHighlightedItem = function moveHighlightedItem(direction) {
                                                        var highlightedItem = this.getHighlightedItem();
                                                        var items = this.getItems();
                                                        var index = items.indexOf(highlightedItem);

                                                        if (index > -1) {
                                                            index += direction;

                                                            for (; index < items.length && index >= 0; index += direction) {
                                                                if (!items[index].isDisabled()) {
                                                                    this.highlight(items[index]);
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    /**
                                                     * Get all Items that pass the test implemented by the provided function
                                                     * If filter function is not passed, it returns all Items
                                                     * @param {function} callback - callback function to filter items
                                                     * @param {number} number - the number of items to find. -1 means all items.
                                                     * @return {array<Item>}
                                                     */
                                                    ;

                                                    _proto.getItems = function getItems(callback, number) {
                                                        if (callback === void 0) {
                                                            callback = function callback() {
                                                                return true;
                                                            };
                                                        }

                                                        if (number === void 0) {
                                                            number = -1;
                                                        }

                                                        var items = [];
                                                        this.iterateItems(function (item) {
                                                            if (callback(item)) {
                                                                items.push(item);
                                                                number -= 1;
                                                                return number !== 0;
                                                            }

                                                            return true;
                                                        });
                                                        return items;
                                                    }
                                                    /**
                                                     * Get an Item by its index or value
                                                     * @param {number|string} value - if string, the Item's value. if number, the Item's index.
                                                     * @return {Item}
                                                     */
                                                    ;

                                                    _proto.getItem = function getItem(value) {
                                                        var isValidItem = (0, _isNumber["default"])(value) ? function (comparedItem) {
                                                            return comparedItem.getIndex() === value;
                                                        } : function (comparedItem) {
                                                            return comparedItem.getValue() === value;
                                                        };
                                                        return this.getItems(isValidItem, 1)[0];
                                                    }
                                                    /**
                                                     * Get all ItemGroups that pass the test implemented by the provided function
                                                     * If filter function is not passed, it returns all ItemGroups
                                                     * @param {function} callback - callback function to filter item groups
                                                     * @param {number} number - the number of item groups to find. -1 means all item groups.
                                                     * @return {array<ItemGroup>}
                                                     */
                                                    ;

                                                    _proto.getItemGroups = function getItemGroups(callback, number) {
                                                        if (callback === void 0) {
                                                            callback = function callback() {
                                                                return true;
                                                            };
                                                        }

                                                        if (number === void 0) {
                                                            number = -1;
                                                        }

                                                        var itemGroups = [];
                                                        (0, _forEachArray["default"])(this.items, function (itemGroup) {
                                                            if (itemGroup instanceof _itemGroup["default"] && callback(itemGroup)) {
                                                                itemGroups.push(itemGroup);
                                                                number -= 1;
                                                                return number !== 0;
                                                            }

                                                            return true;
                                                        });
                                                        return itemGroups;
                                                    }
                                                    /**
                                                     * Get an ItemGroup by its index
                                                     * @param {number} index - groupIndex of the ItemGroup
                                                     * @return {ItemGroup}
                                                     */
                                                    ;

                                                    _proto.getItemGroup = function getItemGroup(index) {
                                                        return this.getItemGroups(function (itemGroup) {
                                                            return itemGroup.getIndex() === index;
                                                        }, 1)[0];
                                                    }
                                                    /**
                                                     * Return the number of Items
                                                     * @return {number}
                                                     */
                                                    ;

                                                    _proto.getItemLength = function getItemLength() {
                                                        return this.itemLength;
                                                    }
                                                    /**
                                                     * Return the selected Item
                                                     * @return {Item}
                                                     */
                                                    ;

                                                    _proto.getSelectedItem = function getSelectedItem() {
                                                        return this.selectedItem;
                                                    }
                                                    /**
                                                     * Return the highlighted Item
                                                     * @return {Item}
                                                     */
                                                    ;

                                                    _proto.getHighlightedItem = function getHighlightedItem() {
                                                        return this.highlightedItem;
                                                    }
                                                    /**
                                                     * Append the element and native element to the container
                                                     * @param {HTMLElement} container - container element
                                                     */
                                                    ;

                                                    _proto.appendToContainer = function appendToContainer(container) {
                                                        container.appendChild(this.el);
                                                        container.appendChild(this.nativeEl);
                                                    }
                                                    /**
                                                     * Destory a dropdown
                                                     */
                                                    ;

                                                    _proto.destroy = function destroy() {
                                                        this.items.forEach(function (item) {
                                                            return item.destroy();
                                                        });
                                                        (0, _removeElement["default"])(this.el);
                                                        (0, _removeElement["default"])(this.nativeEl);
                                                        this.el = this.nativeEl = this.items = this.selectedItem = this.highlightedItem = null;
                                                    };

                                                    return Dropdown;
                                                }();

                                            _exports["default"] = Dropdown;
                                        });

                                        /***/ }),

                                    /***/ "./src/js/index.js":
                                    /*!*************************!*\
      !*** ./src/js/index.js ***!
      \*************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./selectBox */ "./src/js/selectBox.js"), __webpack_require__(/*! ../css/selectBox.css */ "./src/css/selectBox.css")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports, _selectBox, _selectBox2) {

                                            _exports.__esModule = true;
                                            _exports["default"] = void 0;
                                            _selectBox = _interopRequireDefault(_selectBox);

                                            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

                                            /**
                                             * @fileoverview
                                             * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                             */
                                            var _default = _selectBox["default"];
                                            _exports["default"] = _default;
                                        });

                                        /***/ }),

                                    /***/ "./src/js/input.js":
                                    /*!*************************!*\
      !*** ./src/js/input.js ***!
      \*************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/domUtil/addClass */ "./node_modules/tui-code-snippet/domUtil/addClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeClass */ "./node_modules/tui-code-snippet/domUtil/removeClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports, _addClass, _removeClass, _removeElement, _utils, _constants) {

                                            _exports.__esModule = true;
                                            _exports["default"] = void 0;
                                            _addClass = _interopRequireDefault(_addClass);
                                            _removeClass = _interopRequireDefault(_removeClass);
                                            _removeElement = _interopRequireDefault(_removeElement);

                                            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

                                            /**
                                             * @fileoverview Input
                                             * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                             */

                                            /**
                                             * @class
                                             * @ignore
                                             * @param {object} options - options
                                             *   @param {string} [options.placeholder] - placeholder for a select box
                                             *   @param {string} [options.disabled] - whether an input should be disabled or not
                                             *   @param {boolean} [options.showIcon] - whether an arrow icon in the input should be shown
                                             */
                                            var Input =
                                                /*#__PURE__*/
                                                function () {
                                                    function Input(_ref) {
                                                        var placeholder = _ref.placeholder,
                                                            disabled = _ref.disabled,
                                                            showIcon = _ref.showIcon;

                                                        /**
                                                         * text for a placeholder
                                                         * @type {string}
                                                         * @private
                                                         */
                                                        this.placeholderText = placeholder;
                                                        /**
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */

                                                        this.el = (0, _utils.createElement)('div', '', {
                                                            className: _constants.cls.INPUT,
                                                            tabIndex: 0
                                                        });
                                                        /**
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */

                                                        this.placeholderEl = (0, _utils.createElement)('p', this.placeholderText, {
                                                            className: _constants.cls.PLACEHOLDER
                                                        }, this.el);
                                                        this.initialize(disabled, showIcon);
                                                    }
                                                    /**
                                                     * Initialize
                                                     * @private
                                                     */


                                                    var _proto = Input.prototype;

                                                    _proto.initialize = function initialize(disabled, showIcon) {
                                                        if (showIcon) {
                                                            (0, _utils.createElement)('span', 'select', {
                                                                className: _constants.cls.ICON
                                                            }, this.el);
                                                        } else {
                                                            this.placeholderEl.width = '100%';
                                                        }

                                                        if (disabled) {
                                                            this.disable();
                                                        }
                                                    }
                                                    /**
                                                     * Disable an input
                                                     */
                                                    ;

                                                    _proto.disable = function disable() {
                                                        (0, _addClass["default"])(this.el, _constants.cls.DISABLED);
                                                    }
                                                    /**
                                                     * Enable an input
                                                     */
                                                    ;

                                                    _proto.enable = function enable() {
                                                        (0, _removeClass["default"])(this.el, _constants.cls.DISABLED);
                                                    }
                                                    /**
                                                     * Open an input
                                                     */
                                                    ;

                                                    _proto.open = function open() {
                                                        (0, _addClass["default"])(this.el, _constants.cls.OPEN);
                                                    }
                                                    /**
                                                     * Close an input
                                                     */
                                                    ;

                                                    _proto.close = function close() {
                                                        (0, _removeClass["default"])(this.el, _constants.cls.OPEN);
                                                    }
                                                    /**
                                                     * Focus
                                                     */
                                                    ;

                                                    _proto.focus = function focus() {
                                                        this.el.focus();
                                                    }
                                                    /**
                                                     * Change the text in the placeholder
                                                     * @param {Item} item - selected Item
                                                     */
                                                    ;

                                                    _proto.changeText = function changeText(item) {
                                                        if (item) {
                                                            this.placeholderEl.innerText = item.getLabel();
                                                        } else {
                                                            this.placeholderEl.innerText = this.placeholderText;
                                                        }
                                                    }
                                                    /**
                                                     * Append the element to the container
                                                     * @param {HTMLElement} container - container element
                                                     */
                                                    ;

                                                    _proto.appendToContainer = function appendToContainer(container) {
                                                        container.appendChild(this.el);
                                                    }
                                                    /**
                                                     * Destroy an input
                                                     */
                                                    ;

                                                    _proto.destroy = function destroy() {
                                                        (0, _removeElement["default"])(this.el);
                                                        this.el = this.placeholderEl = null;
                                                    };

                                                    return Input;
                                                }();

                                            _exports["default"] = Input;
                                        });

                                        /***/ }),

                                    /***/ "./src/js/item.js":
                                    /*!************************!*\
      !*** ./src/js/item.js ***!
      \************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/domUtil/addClass */ "./node_modules/tui-code-snippet/domUtil/addClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeClass */ "./node_modules/tui-code-snippet/domUtil/removeClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports, _addClass, _removeClass, _removeElement, _utils, _constants) {

                                            _exports.__esModule = true;
                                            _exports["default"] = void 0;
                                            _addClass = _interopRequireDefault(_addClass);
                                            _removeClass = _interopRequireDefault(_removeClass);
                                            _removeElement = _interopRequireDefault(_removeElement);

                                            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

                                            /**
                                             * @fileoverview Item
                                             * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                             */

                                            /**
                                             * @class
                                             * @description
                                             * An item.
                                             * You can get Item by {@link SelectBox#getItem SelectBox.getItem()} and {@link SelectBox#getItems SelectBox.getItems()}.
                                             */
                                            var Item =
                                                /*#__PURE__*/
                                                function () {
                                                    /**
                                                     * @hideconstructor
                                                     * @param {object} options - options
                                                     *   @param {string} [options.label] - label to be displayed in the drop-down list
                                                     *   @param {string} options.value - value of an item
                                                     *   @param {boolean} [options.disabled=false] - whether an Item should be disabled or not
                                                     *   @param {boolean} [options.selected=false] - whether an Item should be pre-selected or not
                                                     *   @param {number} options.index - Item's index
                                                     */
                                                    function Item(_ref) {
                                                        var value = _ref.value,
                                                            label = _ref.label,
                                                            disabled = _ref.disabled,
                                                            selected = _ref.selected,
                                                            index = _ref.index;

                                                        /**
                                                         * value of an item
                                                         * @type {string}
                                                         * @private
                                                         */
                                                        this.value = "" + value;
                                                        /**
                                                         * label to be displayed in the drop-down list
                                                         * if label is an empty string, it should be same as its value
                                                         * @type {string}
                                                         * @private
                                                         */

                                                        this.label = label || this.value;
                                                        /**
                                                         * @type {number}
                                                         * @private
                                                         */

                                                        this.index = index;
                                                        /**
                                                         * whether an ItemGroup of the Item is disabled or not
                                                         * @type {boolean}
                                                         * @private
                                                         */

                                                        this.itemGroupDisabled = false;
                                                        /**
                                                         * whether an Item is disabled or not
                                                         * @type {boolean}
                                                         * @private
                                                         */

                                                        this.itemDisabled = false;
                                                        /**
                                                         * @type {boolean}
                                                         * @private
                                                         */

                                                        this.selected = false;
                                                        /**
                                                         * <li> element for a custom dropdown item
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */

                                                        this.el = (0, _utils.createElement)('li', this.label, {
                                                            className: _constants.cls.ITEM,
                                                            tabIndex: -1,
                                                            'data-value': this.value,
                                                            'data-index': this.index
                                                        });
                                                        /**
                                                         * <option> element for a select element
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */

                                                        this.nativeEl = (0, _utils.createElement)('option', '', {
                                                            value: this.value,
                                                            label: this.label
                                                        });
                                                        this.initialize(disabled, selected);
                                                    }
                                                    /**
                                                     * Initialize
                                                     * @private
                                                     */


                                                    var _proto = Item.prototype;

                                                    _proto.initialize = function initialize(disabled, selected) {
                                                        if (selected) {
                                                            this.select();
                                                        }

                                                        if (disabled) {
                                                            this.disable();
                                                        }
                                                    }
                                                    /**
                                                     * Make an Item disable
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.makeDisable = function makeDisable() {
                                                        this.nativeEl.disabled = true;
                                                        (0, _addClass["default"])(this.el, _constants.cls.DISABLED);
                                                    }
                                                    /**
                                                     * Make an Item enable
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.makeEnable = function makeEnable() {
                                                        this.nativeEl.disabled = false;
                                                        (0, _removeClass["default"])(this.el, _constants.cls.DISABLED);
                                                    }
                                                    /**
                                                     * Disable an Item due to an ItemGroup
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.disableItemGroup = function disableItemGroup() {
                                                        this.itemGroupDisabled = true;
                                                        this.makeDisable();
                                                    }
                                                    /**
                                                     * Enable an Item due to an ItemGroup
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.enableItemGroup = function enableItemGroup() {
                                                        this.itemGroupDisabled = false;

                                                        if (!this.isDisabled()) {
                                                            this.makeEnable();
                                                        }
                                                    }
                                                    /**
                                                     * Disable an Item
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.disable = function disable() {
                                                        this.itemDisabled = true;
                                                        this.makeDisable();
                                                    }
                                                    /**
                                                     * Enable an Item
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.enable = function enable() {
                                                        this.itemDisabled = false;

                                                        if (!this.isDisabled()) {
                                                            this.makeEnable();
                                                        }
                                                    }
                                                    /**
                                                     * Select an Item
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.select = function select() {
                                                        if (!this.isDisabled()) {
                                                            this.selected = this.nativeEl.selected = true;
                                                            (0, _addClass["default"])(this.el, _constants.cls.SELECTED);
                                                        }
                                                    }
                                                    /**
                                                     * Deselect an Item
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.deselect = function deselect() {
                                                        this.selected = this.nativeEl.selected = false;
                                                        (0, _removeClass["default"])(this.el, _constants.cls.SELECTED);
                                                    }
                                                    /**
                                                     * Highlight an Item
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.highlight = function highlight() {
                                                        if (!this.isDisabled()) {
                                                            (0, _addClass["default"])(this.el, _constants.cls.HIGHLIGHT);
                                                            this.el.focus();
                                                        }
                                                    }
                                                    /**
                                                     * Remove a highlight from an Item
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.dehighlight = function dehighlight() {
                                                        (0, _removeClass["default"])(this.el, _constants.cls.HIGHLIGHT);
                                                        this.el.blur();
                                                    }
                                                    /**
                                                     * Return an item's value.
                                                     * @return {string}
                                                     */
                                                    ;

                                                    _proto.getValue = function getValue() {
                                                        return this.value;
                                                    }
                                                    /**
                                                     * Return an item's label.
                                                     * @return {string}
                                                     */
                                                    ;

                                                    _proto.getLabel = function getLabel() {
                                                        return this.label;
                                                    }
                                                    /**
                                                     * Return an item's index.
                                                     * @return {number}
                                                     */
                                                    ;

                                                    _proto.getIndex = function getIndex() {
                                                        return this.index;
                                                    }
                                                    /**
                                                     * Return whether an item is selected or not.
                                                     * @return {boolean}
                                                     */
                                                    ;

                                                    _proto.isSelected = function isSelected() {
                                                        return this.selected;
                                                    }
                                                    /**
                                                     * Return whether an item is disabled or not.
                                                     * The result is true if any of the items and item groups are disabled.
                                                     * @return {boolean}
                                                     */
                                                    ;

                                                    _proto.isDisabled = function isDisabled() {
                                                        return this.itemDisabled || this.itemGroupDisabled;
                                                    }
                                                    /**
                                                     * Append the element and native element to the containers
                                                     * @param {HTMLElement} container - container element
                                                     * @param {HTMLElement} nativeContainer - native container element
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.appendToContainer = function appendToContainer(container, nativeContainer) {
                                                        container.appendChild(this.el);
                                                        nativeContainer.appendChild(this.nativeEl);
                                                    }
                                                    /**
                                                     * Destroy an Item
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.destroy = function destroy() {
                                                        (0, _removeElement["default"])(this.el);
                                                        (0, _removeElement["default"])(this.nativeEl);
                                                        this.el = this.nativeEl = null;
                                                    };

                                                    return Item;
                                                }();

                                            _exports["default"] = Item;
                                        });

                                        /***/ }),

                                    /***/ "./src/js/itemGroup.js":
                                    /*!*****************************!*\
      !*** ./src/js/itemGroup.js ***!
      \*****************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/domUtil/addClass */ "./node_modules/tui-code-snippet/domUtil/addClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeClass */ "./node_modules/tui-code-snippet/domUtil/removeClass.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js"), __webpack_require__(/*! ./item */ "./src/js/item.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports, _addClass, _removeClass, _removeElement, _utils, _constants, _item) {

                                            _exports.__esModule = true;
                                            _exports["default"] = void 0;
                                            _addClass = _interopRequireDefault(_addClass);
                                            _removeClass = _interopRequireDefault(_removeClass);
                                            _removeElement = _interopRequireDefault(_removeElement);
                                            _item = _interopRequireDefault(_item);

                                            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

                                            function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

                                            function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

                                            function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

                                            /**
                                             * @class
                                             * @description
                                             * A group of items.
                                             * You can get ItemGroup by {@link SelectBox#getItemGroup SelectBox.getItemGroup()} and {@link SelectBox#getItemGroups SelectBox.getItemGroups()}.
                                             */
                                            var ItemGroup =
                                                /*#__PURE__*/
                                                function () {
                                                    /**
                                                     * @hideconstructor
                                                     * @param {object} options - options
                                                     *   @param {string} [options.label] - label to be displayed in the dropdown list
                                                     *   @param {array<itemData>} options.data - data for Items to be included in the ItemGroup
                                                     *   @param {boolean} [options.disabled=false] - whether an ItemGroup should be disabled or not
                                                     *   @param {number} options.index - index of the first Item in the ItemGroup
                                                     *   @param {number} options.itemGroupIndex - index of the ItemGroup
                                                     */
                                                    function ItemGroup(_ref) {
                                                        var _ref$label = _ref.label,
                                                            label = _ref$label === void 0 ? '' : _ref$label,
                                                            data = _ref.data,
                                                            _ref$disabled = _ref.disabled,
                                                            disabled = _ref$disabled === void 0 ? false : _ref$disabled,
                                                            index = _ref.index,
                                                            itemGroupIndex = _ref.itemGroupIndex;

                                                        /**
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */
                                                        this.el = (0, _utils.createElement)('li', '', {
                                                            'data-group-index': itemGroupIndex
                                                        });
                                                        /**
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */

                                                        this.labelEl = (0, _utils.createElement)('span', label, {
                                                            className: _constants.cls.ITEM_GROUP_LABEL
                                                        }, this.el);
                                                        /**
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */

                                                        this.itemContainerEl = (0, _utils.createElement)('ul', '', {
                                                            className: _constants.cls.ITEM_GROUP
                                                        }, this.el);
                                                        /**
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */

                                                        this.nativeEl = (0, _utils.createElement)('optgroup', label);
                                                        /**
                                                         * @type {array<Item>}
                                                         * @private
                                                         */

                                                        this.items = this.createItems(data, index);
                                                        /**
                                                         * @type {number}
                                                         * @private
                                                         */

                                                        this.index = itemGroupIndex;
                                                        /**
                                                         * @type {string}
                                                         * @private
                                                         */

                                                        this.label = label;
                                                        /**
                                                         * whether an ItemGroup is disabled or not
                                                         * @type {boolean}
                                                         * @private
                                                         */

                                                        this.disabled = false;
                                                        this.initialize(disabled);
                                                    }
                                                    /**
                                                     * Create Items to be included in the ItemGroup
                                                     * @return {array<Item>}
                                                     * @private
                                                     */


                                                    var _proto = ItemGroup.prototype;

                                                    _proto.createItems = function createItems(data, index) {
                                                        var _this = this;

                                                        return data.map(function (datum, itemIndex) {
                                                            var item = new _item["default"](_objectSpread({
                                                                index: index + itemIndex
                                                            }, datum));
                                                            item.appendToContainer(_this.itemContainerEl, _this.nativeEl);
                                                            return item;
                                                        });
                                                    }
                                                    /**
                                                     * Initialize
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.initialize = function initialize(disabled) {
                                                        if (disabled) {
                                                            this.disable();
                                                        }
                                                    }
                                                    /**
                                                     * Disable an ItemGroup
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.disable = function disable() {
                                                        this.disabled = this.nativeEl.disabled = true;
                                                        (0, _addClass["default"])(this.labelEl, _constants.cls.DISABLED);
                                                        this.items.forEach(function (item) {
                                                            return item.disableItemGroup();
                                                        });
                                                    }
                                                    /**
                                                     * Enable an ItemGroup
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.enable = function enable() {
                                                        this.disabled = this.nativeEl.disabled = false;
                                                        (0, _removeClass["default"])(this.labelEl, _constants.cls.DISABLED);
                                                        this.items.forEach(function (item) {
                                                            return item.enableItemGroup();
                                                        });
                                                    }
                                                    /**
                                                     * Get {@link Item items} in the item group.
                                                     * @return {array<Item>}
                                                     * @example
                                                     * const items = itemGroup.getItems();
                                                     * console.log(items[0]); // first item in the item group
                                                     * console.log(items.length); // the number of items in the item group
                                                     */
                                                    ;

                                                    _proto.getItems = function getItems() {
                                                        return this.items;
                                                    }
                                                    /**
                                                     * Return an item group's index.
                                                     * @return {number}
                                                     */
                                                    ;

                                                    _proto.getIndex = function getIndex() {
                                                        return this.index;
                                                    }
                                                    /**
                                                     * Return an item group's label.
                                                     * @return {string}
                                                     */
                                                    ;

                                                    _proto.getLabel = function getLabel() {
                                                        return this.label;
                                                    }
                                                    /**
                                                     * Return whether an ItemGroup is disabled or not.
                                                     * @return {boolean}
                                                     */
                                                    ;

                                                    _proto.isDisabled = function isDisabled() {
                                                        return this.disabled;
                                                    }
                                                    /**
                                                     * Append the element and native element to the containers
                                                     * @param {HTMLElement} container - container element
                                                     * @param {HTMLElement} nativeContainer - native container element
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.appendToContainer = function appendToContainer(container, nativeContainer) {
                                                        container.appendChild(this.el);
                                                        nativeContainer.appendChild(this.nativeEl);
                                                    }
                                                    /**
                                                     * Destory an ItemGroup
                                                     * @ignore
                                                     */
                                                    ;

                                                    _proto.destroy = function destroy() {
                                                        this.items.forEach(function (item) {
                                                            return item.destroy();
                                                        });
                                                        (0, _removeElement["default"])(this.el);
                                                        (0, _removeElement["default"])(this.nativeEl);
                                                        this.el = this.labelEl = this.itemContainerEl = this.nativeEl = this.items = null;
                                                    };

                                                    return ItemGroup;
                                                }();

                                            _exports["default"] = ItemGroup;
                                        });

                                        /***/ }),

                                    /***/ "./src/js/keyEventUtils.js":
                                    /*!*********************************!*\
      !*** ./src/js/keyEventUtils.js ***!
      \*********************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports) {

                                            _exports.__esModule = true;
                                            _exports.identifyKey = void 0;

                                            /**
                                             * @fileoverview Utility functions related to key events
                                             * @author NHN. FE dev team.<dl_javascript@nhn.com>
                                             */
                                            var keyCodeMap = {
                                                38: 'arrowUp',
                                                40: 'arrowDown',
                                                32: 'space',
                                                13: 'enter',
                                                27: 'escape',
                                                61: 'tab'
                                            };
                                            var keyMap = {
                                                ArrowUp: 'arrowUp',
                                                Up: 'arrowUp',
                                                ArrowDown: 'arrowDown',
                                                Down: 'arrowDown',
                                                ' ': 'space',
                                                Spacebar: 'space',
                                                Enter: 'enter',
                                                Escape: 'escape',
                                                Esc: 'escape',
                                                Tab: 'tab'
                                            };
                                            /**
                                             * Identify the key (polyfill for IE)
                                             * @param {string} ev - keyboard event
                                             * @return {string} - key
                                             */

                                            var identifyKey = function identifyKey(ev) {
                                                var key = ev.key,
                                                    keyCode = ev.keyCode;

                                                if (key) {
                                                    return keyMap[key] || key;
                                                }

                                                return keyCodeMap[keyCode] || keyCode;
                                            };

                                            _exports.identifyKey = identifyKey;
                                        });

                                        /***/ }),

                                    /***/ "./src/js/selectBox.js":
                                    /*!*****************************!*\
      !*** ./src/js/selectBox.js ***!
      \*****************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/customEvents/customEvents */ "./node_modules/tui-code-snippet/customEvents/customEvents.js"), __webpack_require__(/*! tui-code-snippet/domEvent/on */ "./node_modules/tui-code-snippet/domEvent/on.js"), __webpack_require__(/*! tui-code-snippet/domEvent/off */ "./node_modules/tui-code-snippet/domEvent/off.js"), __webpack_require__(/*! tui-code-snippet/domEvent/preventDefault */ "./node_modules/tui-code-snippet/domEvent/preventDefault.js"), __webpack_require__(/*! tui-code-snippet/domEvent/getTarget */ "./node_modules/tui-code-snippet/domEvent/getTarget.js"), __webpack_require__(/*! tui-code-snippet/domUtil/closest */ "./node_modules/tui-code-snippet/domUtil/closest.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! tui-code-snippet/type/isObject */ "./node_modules/tui-code-snippet/type/isObject.js"), __webpack_require__(/*! tui-code-snippet/type/isExisty */ "./node_modules/tui-code-snippet/type/isExisty.js"), __webpack_require__(/*! tui-code-snippet/type/isHTMLNode */ "./node_modules/tui-code-snippet/type/isHTMLNode.js"), __webpack_require__(/*! tui-code-snippet/request/sendHostname */ "./node_modules/tui-code-snippet/request/sendHostname.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./keyEventUtils */ "./src/js/keyEventUtils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js"), __webpack_require__(/*! ./input */ "./src/js/input.js"), __webpack_require__(/*! ./dropdown */ "./src/js/dropdown.js"), __webpack_require__(/*! ./itemGroup */ "./src/js/itemGroup.js"), __webpack_require__(/*! ./item */ "./src/js/item.js"), __webpack_require__(/*! ./theme */ "./src/js/theme.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports, _customEvents, _on, _off, _preventDefault, _getTarget, _closest, _removeElement, _isObject, _isExisty, _isHTMLNode, _sendHostname, _utils, _keyEventUtils, _constants, _input, _dropdown, _itemGroup, _item, _theme) {

                                            _exports.__esModule = true;
                                            _exports["default"] = void 0;
                                            _customEvents = _interopRequireDefault(_customEvents);
                                            _on = _interopRequireDefault(_on);
                                            _off = _interopRequireDefault(_off);
                                            _preventDefault = _interopRequireDefault(_preventDefault);
                                            _getTarget = _interopRequireDefault(_getTarget);
                                            _closest = _interopRequireDefault(_closest);
                                            _removeElement = _interopRequireDefault(_removeElement);
                                            _isObject = _interopRequireDefault(_isObject);
                                            _isExisty = _interopRequireDefault(_isExisty);
                                            _isHTMLNode = _interopRequireDefault(_isHTMLNode);
                                            _sendHostname = _interopRequireDefault(_sendHostname);
                                            _input = _interopRequireDefault(_input);
                                            _dropdown = _interopRequireDefault(_dropdown);
                                            _itemGroup = _interopRequireDefault(_itemGroup);
                                            _item = _interopRequireDefault(_item);
                                            _theme = _interopRequireDefault(_theme);

                                            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

                                            /**
                                             * @fileoverview SelectBox
                                             * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                             */

                                            /**
                                             * @class
                                             * @param {HTMLElement|string} container - container element or selector
                                             * @mixes CustomEvents
                                             * @param {object} options
                                             *   @param {array<itemData|itemGroupData>} options.data - array of {@link itemData} and {@link itemGroupData}
                                             *   @param {string} [options.placeholder] - placeholder for an input
                                             *   @param {boolean} [options.disabled] - whether an Item should be disabled or not
                                             *   @param {boolean} [options.autofocus] - whether a selectbox should get focus when the select box appends to the container
                                             *   @param {boolean} [options.autoclose] - whether a selectbox should close after selection
                                             *   @param {boolean} [options.showIcon] - whether an arrow icon in the input should be shown
                                             *   @param {object} [options.theme] - {@link themeConfig} for custom style
                                             *   @param {boolean} [options.usageStatistics] - whether send hostname to google analytics. If you don't want to send the hostname, please set to false.
                                             * @example
                                             * import SelectBox from '@toast-ui/select-box';
                                             * // or const SelectBox = require('@toast-ui/select-box');
                                             * // or const SelectBox = tui.SelectBox;
                                             *
                                             * const selectBox = new SelectBox('#select-box', {
                                             *   placeholder: 'Please select an option.',
                                             *   data: [
                                             *     {
                                             *       label: 'Fruits',
                                             *       data: [ { label: 'Apple', value: 'apple' }, { label: 'Banana', value: 'banana' } ]
                                             *     },
                                             *     { label: 'The quick brown fox jumps over the lazy dog.', value: 'none' },
                                             *     {
                                             *       label: 'Colors',
                                             *       data: [
                                             *         { label: 'Red', value: 'red' },
                                             *         { label: 'Yellow', value: 'yellow' },
                                             *         { label: 'Green', value: 'green', disabled: true },
                                             *         { label: 'Blue', value: 'blue', disabled: true },
                                             *         { label: 'Purple', value: 'purple' }
                                             *       ]
                                             *     }
                                             *   ],
                                             *   autofocus: true,
                                             *   showIcon: false,
                                             *   theme: {
                                             *     'common.border': '1px solid black',
                                             *     'common.color': 'black',
                                             *     'item.highlighted.background': 'yellow'
                                             *   }
                                             * });
                                             */

                                            /**
                                             * SelectBox provides some custom events: ({@link SelectBox#event-open open}, {@link SelectBox#event-close close}, {@link SelectBox#event-disable disable}, {@link SelectBox#event-enable enable}, {@link SelectBox#event-change change}).
                                             * You can bind event handlers by {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#on selectBox.on(eventName, handler)} and unbind by {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents#off selectBox.off(eventName, handler)}.
                                             * Refer to the {@link https://nhn.github.io/tui.code-snippet/latest/CustomEvents CustomEvents} document at {@link https://github.com/nhn/tui.code-snippet tui-code-snippet} to know how to bind, and unbind custom events.
                                             * The example using custom events can be found {@link tutorial-example03-custom-events here}.
                                             * @typedef {class} CustomEvents
                                             * @example
                                             * // bind 'change' event
                                             * selectBox.on('change', ev => {
                                             *   console.log(`selected item is changed from ${ev.prev.getLabel()} to ${ev.curr.getLabel()}.`);
                                             * });
                                             *
                                             * // bind 'disable' and enable event
                                             * const print = ev => {
                                             *   let target = '';
                                             *   if (ev.target instanceof SelectBox) {
                                             *     target = 'Select box';
                                             *   } else {
                                             *     target = ev.target.getLabel();
                                             *   }
                                             *   console.log(`${target} is ${ev.type}.`);
                                             * }
                                             * selectBox.on({
                                             *   disable: print,
                                             *   enable: print
                                             * });
                                             *
                                             * // unbind change event
                                             * selectBox.off('change');
                                             *
                                             * // unbind disable event
                                             * selectBox.off(disable, print);
                                             *
                                             * // unbind all events
                                             * selectBox.off();
                                             */

                                            /**
                                             * Data of an {@link Item item}.
                                             * It is used for creating a {@link SelectBox}.
                                             * @typedef {object} itemData - data for {@link Item item}
                                             * @property {string} label - label to be displayed
                                             * @property {string} value - value of an item
                                             * @property {boolean} [disabled=false] - whether an item should be disabled or not
                                             * @property {boolean} [selected=false] - whether an item should be pre-selected or not
                                             * @example
                                             * const itemData = {
                                             *   label: 'disabled item',
                                             *   value: '0',
                                             *   disabled: true,
                                             *   selected: false
                                             * };
                                             */

                                            /**
                                             * Data of an {@link ItemGroup item group}.
                                             * It is used for creating a {@link SelectBox}.
                                             * ItemGroup supports only 1 level choices, so it does not work to add item groups in the item group.
                                             * The example using item groups can be found {@link tutorial-example01-basic here}.
                                             * @typedef {object} itemGroupData - data for {@link ItemGroup item group}
                                             * @property {string} label - label to be displayed
                                             * @property {array} data - {@link itemData data for item}
                                             * @property {boolean} [disabled=false] - whether an item group should be disabled or not
                                             * @example
                                             * const itemGroupData = {
                                             *   label: 'disabled items',
                                             *   data: [
                                             *     { label: 'disable', value: 'disable' },
                                             *     { label: 'none', value: '0' }
                                             *   ],
                                             *   disabled: true
                                             * };
                                             */
                                            var SelectBox =
                                                /*#__PURE__*/
                                                function () {
                                                    function SelectBox(container, _ref) {
                                                        var data = _ref.data,
                                                            _ref$placeholder = _ref.placeholder,
                                                            placeholder = _ref$placeholder === void 0 ? '' : _ref$placeholder,
                                                            _ref$disabled = _ref.disabled,
                                                            disabled = _ref$disabled === void 0 ? false : _ref$disabled,
                                                            _ref$autofocus = _ref.autofocus,
                                                            autofocus = _ref$autofocus === void 0 ? false : _ref$autofocus,
                                                            _ref$autoclose = _ref.autoclose,
                                                            autoclose = _ref$autoclose === void 0 ? true : _ref$autoclose,
                                                            _ref$showIcon = _ref.showIcon,
                                                            showIcon = _ref$showIcon === void 0 ? true : _ref$showIcon,
                                                            theme = _ref.theme,
                                                            _ref$usageStatistics = _ref.usageStatistics,
                                                            usageStatistics = _ref$usageStatistics === void 0 ? true : _ref$usageStatistics;

                                                        /**
                                                         * @type {HTMLElement}
                                                         * @private
                                                         */
                                                        this.el = (0, _utils.createElement)('div', '', {
                                                            className: _constants.cls.SELECT_BOX
                                                        });
                                                        /**
                                                         * @type {Input}
                                                         * @private
                                                         */

                                                        this.input = new _input["default"]({
                                                            placeholder: placeholder,
                                                            disabled: disabled,
                                                            showIcon: showIcon
                                                        });
                                                        /**
                                                         * @type {Dropdown}
                                                         * @private
                                                         */

                                                        this.dropdown = new _dropdown["default"]({
                                                            placeholder: placeholder,
                                                            disabled: disabled,
                                                            data: data
                                                        });
                                                        /**
                                                         * @type {boolean}
                                                         * @private
                                                         */

                                                        this.opened = false;
                                                        /**
                                                         * @type {boolean}
                                                         * @private
                                                         */

                                                        this.diabled = false;
                                                        /**
                                                         * @type {boolean}
                                                         */

                                                        this.autoclose = autoclose;
                                                        /**
                                                         * @type {Theme}
                                                         * @private
                                                         */

                                                        this.theme = (0, _isObject["default"])(theme) ? new _theme["default"](theme, container) : null;
                                                        this.initialize({
                                                            placeholder: placeholder,
                                                            disabled: disabled
                                                        });
                                                        this.appendToContainer(container);

                                                        if (autofocus) {
                                                            this.input.focus();
                                                        }

                                                        if (usageStatistics) {
                                                            (0, _sendHostname["default"])('select-box', 'UA-129987462-1');
                                                        }
                                                    }
                                                    /**
                                                     * Append the select box element to the container
                                                     * @param {HTMLElement|string} container - container element or selector
                                                     * @private
                                                     */


                                                    var _proto = SelectBox.prototype;

                                                    _proto.appendToContainer = function appendToContainer(container) {
                                                        var containerEl = (0, _isHTMLNode["default"])(container) ? container : document.querySelector(container);
                                                        containerEl.appendChild(this.el);
                                                    }
                                                    /**
                                                     * Initialize
                                                     * @param {object} options - options
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.initialize = function initialize(options) {
                                                        var selectedItem = this.getSelectedItem();

                                                        if (selectedItem) {
                                                            this.input.changeText(selectedItem);
                                                        } else if (!options.placeholder) {
                                                            this.select(0);
                                                        }

                                                        if (options.disabled) {
                                                            this.disable();
                                                        }

                                                        this.bindEvents();
                                                        this.input.appendToContainer(this.el);
                                                        this.dropdown.appendToContainer(this.el);
                                                    }
                                                    /**
                                                     * Bind events
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.bindEvents = function bindEvents() {
                                                        var _this = this;

                                                        (0, _on["default"])(document, 'click', function (ev) {
                                                            var target = (0, _getTarget["default"])(ev);

                                                            if (!(0, _closest["default"])(target, "." + _constants.cls.SELECT_BOX) && _this.opened) {
                                                                _this.close();
                                                            }
                                                        }, this);
                                                        (0, _on["default"])(this.el, 'click', function (ev) {
                                                            return _this.handleClick(ev, _constants.cls);
                                                        });
                                                        (0, _on["default"])(this.el, 'mouseover', function (ev) {
                                                            return _this.handleMouseover(ev, _constants.cls);
                                                        });
                                                        (0, _on["default"])(this.el, 'keydown', function (ev) {
                                                            return _this.handleKeydown(ev, _constants.cls);
                                                        });
                                                    }
                                                    /**
                                                     * Unbind events
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.unbindEvents = function unbindEvents() {
                                                        (0, _off["default"])(document, 'click');
                                                        (0, _off["default"])(this.el, 'click mouseover keydown');
                                                    }
                                                    /**
                                                     * Handle click events
                                                     * @param {Event} ev - an event
                                                     * @param {object} cls - cls
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.handleClick = function handleClick(ev, _ref2) {
                                                        var INPUT = _ref2.INPUT,
                                                            ITEM = _ref2.ITEM;
                                                        var target = (0, _getTarget["default"])(ev);
                                                        var itemEl = (0, _closest["default"])(target, "." + ITEM);

                                                        if (itemEl) {
                                                            this.select(itemEl.getAttribute('data-value'));
                                                        } else if ((0, _closest["default"])(target, "." + INPUT)) {
                                                            this.toggle();
                                                        }
                                                    }
                                                    /**
                                                     * Handle mouseover events
                                                     * @param {Event} ev - an event
                                                     * @param {object} cls - cls
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.handleMouseover = function handleMouseover(ev, _ref3) {
                                                        var ITEM = _ref3.ITEM;

                                                        if (this.checkMousemove(ev.clientX, ev.clientY)) {
                                                            var target = (0, _getTarget["default"])(ev);
                                                            var itemEl = (0, _closest["default"])(target, "." + ITEM);

                                                            if (itemEl) {
                                                                this.dropdown.highlight(itemEl.getAttribute('data-value'));
                                                            }
                                                        }
                                                    }
                                                    /**
                                                     * Check if a pointer is moved
                                                     * @param {number} x - mouseEvent.clientX
                                                     * @param {number} y - mouseEvent.clientY
                                                     * @return {boolean}
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.checkMousemove = function checkMousemove(x, y) {
                                                        if (this.prevX !== x || this.prevY !== y) {
                                                            this.prevX = x;
                                                            this.prevY = y;
                                                            return true;
                                                        }

                                                        return false;
                                                    }
                                                    /**
                                                     * Handle keydown events
                                                     * @param {Event} ev - an event
                                                     * @param {object} classNames - cls
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.handleKeydown = function handleKeydown(ev, classNames) {
                                                        var key = (0, _keyEventUtils.identifyKey)(ev);
                                                        var closeKeys = ['tab', 'escape'];
                                                        var activeKeys = ['arrowUp', 'arrowDown', 'space', 'enter'];

                                                        if (closeKeys.indexOf(key) > -1 && this.opened) {
                                                            this.close();

                                                            if (key === 'escape') {
                                                                this.input.focus();
                                                            }
                                                        } else if (activeKeys.indexOf(key) > -1) {
                                                            (0, _preventDefault["default"])(ev);
                                                            this.activateKeydown(ev, key, classNames);
                                                        }
                                                    }
                                                    /**
                                                     * Activate keydown events
                                                     * @param {Event} ev - an event
                                                     * @param {string} key - key pressed
                                                     * @param {object} classNames - cls
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.activateKeydown = function activateKeydown(ev, key, _ref4) {
                                                        var ITEM = _ref4.ITEM,
                                                            INPUT = _ref4.INPUT;
                                                        var target = (0, _getTarget["default"])(ev);
                                                        var itemEl = (0, _closest["default"])(target, "." + ITEM);

                                                        if (key === 'escape' && this.opened) {
                                                            this.close();
                                                            this.input.focus();
                                                        } else if (itemEl) {
                                                            this.pressKeyOnItem(key, itemEl);
                                                        } else if ((0, _closest["default"])(target, "." + INPUT)) {
                                                            this.pressKeyOnInput(key);
                                                        }
                                                    }
                                                    /**
                                                     * Handle keydown events when it occurs on the Input
                                                     * @param {string} key - key
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.pressKeyOnInput = function pressKeyOnInput(key) {
                                                        if (!this.opened) {
                                                            this.open();
                                                        } else if (key === 'arrowUp' || key === 'arrowDown') {
                                                            this.dropdown.moveHighlightedItem(key === 'arrowUp' ? -1 : 1);
                                                        }
                                                    }
                                                    /**
                                                     * Handle keydown events when it occurs on the Item
                                                     * @param {string} key - key
                                                     * @param {HTMLElement} itemEl - Item.el
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.pressKeyOnItem = function pressKeyOnItem(key, itemEl) {
                                                        if (key === 'enter' || key === 'space') {
                                                            this.selectByKeydown(itemEl);
                                                        } else if (key === 'arrowUp' || key === 'arrowDown') {
                                                            this.dropdown.moveHighlightedItem(key === 'arrowUp' ? -1 : 1);
                                                        }
                                                    }
                                                    /**
                                                     * Select an Item by space or enter
                                                     * @param {HTMLElement} itemEl - Item.el
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.selectByKeydown = function selectByKeydown(itemEl) {
                                                        this.select(itemEl.getAttribute('data-value'));
                                                        this.close();
                                                        this.input.focus();
                                                    }
                                                    /**
                                                     * Disable a select box, {@link ItemGroup item group} or {@link Item item}.
                                                     * If it takes no arguments, a select box is disabled.
                                                     * If it takes string, an item with the same value as the argument is disabled.
                                                     * If it takes number, an item with the same index as the argument is disabled.
                                                     * If it takes Item or ItemGroup, an argument itself is disabled.
                                                     * @param {string|number|Item|ItemGroup} value - if string, find an Item by its value. if number, find an Item by its index.
                                                     * @example
                                                     * selectBox.disable(); // select box is disabled.
                                                     * selectBox.disable(1); // second item is disabled.
                                                     * selectBox.disable('value') // item which of value is 'value' is disabled.
                                                     * selectBox.disable(selectBox.getSelectedItem()); // selected item is disabled.
                                                     */
                                                    ;

                                                    _proto.disable = function disable(value) {
                                                        if (!(0, _isExisty["default"])(value)) {
                                                            this.disabled = true;
                                                            this.input.disable();
                                                            this.dropdown.disable();
                                                            /**
                                                             * Occurs when a select box, {@link ItemGroup item group} or {@link Item item} is disabled.
                                                             * @event SelectBox#disable
                                                             * @type {object} ev
                                                             * @property {string} type - event name ('disable')
                                                             * @property {SelectBox|ItemGroup|Item} target - disabled target
                                                             * @example
                                                             * selectBox.on('disable', ev => {
                                                             *   console.log(ev.target);
                                                             * });
                                                             */

                                                            this.fire('disable', {
                                                                type: 'disable',
                                                                target: this
                                                            });
                                                        } else if (value instanceof _item["default"] || value instanceof _itemGroup["default"]) {
                                                            value.disable();
                                                            this.fire('disable', {
                                                                type: 'disable',
                                                                target: value
                                                            });
                                                        } else {
                                                            var disabledItem = this.dropdown.getItem(value);

                                                            if (disabledItem) {
                                                                disabledItem.disable();
                                                                this.fire('disable', {
                                                                    type: 'disable',
                                                                    target: disabledItem
                                                                });
                                                            }
                                                        }
                                                    }
                                                    /**
                                                     * Enable a select box, {@link ItemGroup item group} or {@link Item item}.
                                                     * If it takes no arguments, a select box is enabled.
                                                     * If it takes string, an item with the same value as the argument is enabled.
                                                     * If it takes number, an item with the same index as the argument is enabled.
                                                     * If it takes Item or ItemGroup, an argument itself is enabled.
                                                     * @param {string|number|Item|ItemGroup} value - if string, find an Item by its value. if number, find an Item by its index.
                                                     * @example
                                                     * selectBox.enable(); // select box is enabled.
                                                     * selectBox.enable(1); // second item is enabled.
                                                     * selectBox.enable('value') // item which of value is 'value' is enabled.
                                                     * selectBox.enable(selectBox.getSelectedItem()); // selected item is enabled.
                                                     */
                                                    ;

                                                    _proto.enable = function enable(value) {
                                                        if (!(0, _isExisty["default"])(value)) {
                                                            this.disabled = false;
                                                            this.input.enable();
                                                            this.dropdown.enable();
                                                            /**
                                                             * Occurs when a select box, {@link ItemGroup item group} or {@link Item item} is enabled.
                                                             * @event SelectBox#enable
                                                             * @type {object} ev
                                                             * @property {string} type - event name ('enable')
                                                             * @property {SelectBox|ItemGroup|Item} target - enable target
                                                             * @example
                                                             * selectBox.on('enable', ev => {
                                                             *   console.log(ev.target);
                                                             * });
                                                             */

                                                            this.fire('enable', {
                                                                type: 'enable',
                                                                target: this
                                                            });
                                                        } else if (value instanceof _item["default"] || value instanceof _itemGroup["default"]) {
                                                            value.enable();
                                                            this.fire('enable', {
                                                                type: 'enable',
                                                                target: value
                                                            });
                                                        } else {
                                                            var disabledItem = this.dropdown.getItem(value);

                                                            if (disabledItem) {
                                                                disabledItem.enable();
                                                                this.fire('enable', {
                                                                    type: 'enable',
                                                                    target: disabledItem
                                                                });
                                                            }
                                                        }
                                                    }
                                                    /**
                                                     * Open a dropdown list.
                                                     * @example
                                                     * selectBox.open();
                                                     */
                                                    ;

                                                    _proto.open = function open() {
                                                        if (!this.disabled) {
                                                            this.opened = true;
                                                            this.dropdown.open();
                                                            this.input.open();
                                                            /**
                                                             * Occurs when a select box opens.
                                                             * @event SelectBox#open
                                                             * @property {string} type - event name ('open')
                                                             * @example
                                                             * selectBox.on('open', ev => {
                                                             *   console.log('open');
                                                             * });
                                                             */

                                                            this.fire('open', {
                                                                type: 'open'
                                                            });
                                                        }
                                                    }
                                                    /**
                                                     * Close a dropdown list.
                                                     * @example
                                                     * selectBox.close();
                                                     */
                                                    ;

                                                    _proto.close = function close() {
                                                        this.opened = false;
                                                        this.dropdown.close();
                                                        this.input.close();
                                                        /**
                                                         * Occurs when a select box closes.
                                                         * @event SelectBox#close
                                                         * @property {string} type - event name ('close')
                                                         * @example
                                                         * selectBox.on('close', ev => {
                                                         *   console.log('close');
                                                         * });
                                                         */

                                                        this.fire('close', {
                                                            type: 'close'
                                                        });
                                                    }
                                                    /**
                                                     * Toggle a dropdown list.
                                                     * @example
                                                     * selectBox.toggle();
                                                     */
                                                    ;

                                                    _proto.toggle = function toggle() {
                                                        if (this.opened) {
                                                            this.close();
                                                        } else {
                                                            this.open();
                                                        }
                                                    }
                                                    /**
                                                     * Select an {@link Item item}.
                                                     * If it takes string, an item with the same value as the argument is selected.
                                                     * If it takes number, an item with the same index as the argument is selected.
                                                     * If it takes Item, an argument itself is selected.
                                                     * @param {string|number|Item} value - if string, find an Item by its value. if number, find an Item by its index.
                                                     * @return {Item} - selected Item.
                                                     * @example
                                                     * selectBox.select(1); // second item is selected.
                                                     * selectBox.select('value') // item which of value is 'value' is selected.
                                                     */
                                                    ;

                                                    _proto.select = function select(value) {
                                                        var selectedItem = null;
                                                        var prevSelectedItem = this.getSelectedItem();

                                                        if (!this.disabled) {
                                                            selectedItem = this.dropdown.select(value);

                                                            if (selectedItem) {
                                                                this.input.changeText(selectedItem);
                                                                /**
                                                                 * Occurs when an {@link Item item} is selected.
                                                                 * @event SelectBox#select
                                                                 * @type {object} ev
                                                                 * @property {string} type - event name ('select')
                                                                 * @property {Item} target - selected item
                                                                 * @ignore
                                                                 * @example
                                                                 * selectBox.on('select', ev => {
                                                                 *   console.log(`${ev.target.getLabel()} is selected.`);
                                                                 * });
                                                                 */

                                                                this.fire('select', {
                                                                    type: 'select',
                                                                    target: selectedItem
                                                                });

                                                                if (prevSelectedItem !== selectedItem) {
                                                                    /**
                                                                     * Occurs when a selected {@link Item item} is changed.
                                                                     * @event SelectBox#change
                                                                     * @type {object} ev
                                                                     * @property {string} type - event name ('change')
                                                                     * @property {Item} prev - previous selected item
                                                                     * @property {Item} curr - current selected item
                                                                     * @example
                                                                     * selectBox.on('change', ev => {
                                                                     *   console.log(`selected item is changed from ${ev.prev.getLabel()} to ${ev.curr.getLabel()}.`);
                                                                     * });
                                                                     */
                                                                    this.fire('change', {
                                                                        type: 'change',
                                                                        prev: prevSelectedItem,
                                                                        curr: selectedItem
                                                                    });
                                                                }

                                                                if (this.autoclose && this.opened) {
                                                                    this.close();
                                                                }
                                                            }
                                                        }

                                                        return selectedItem;
                                                    }
                                                    /**
                                                     * Deselect an item.
                                                     * If selectBox has a placeholder, the input's text is a placeholder.
                                                     * If no placeholder, ths input is empty.
                                                     * @example
                                                     * selectBox.deselect();
                                                     */
                                                    ;

                                                    _proto.deselect = function deselect() {
                                                        if (!this.disabled) {
                                                            this.dropdown.deselect();
                                                            this.input.changeText();
                                                        }
                                                    }
                                                    /**
                                                     * Return the selected {@link Item item}.
                                                     * @return {Item}
                                                     */
                                                    ;

                                                    _proto.getSelectedItem = function getSelectedItem() {
                                                        return this.dropdown.getSelectedItem();
                                                    }
                                                    /**
                                                     * Get all {@link Item items} that pass the test implemented by the provided function.
                                                     * If filter function is not passed, it returns all items.
                                                     * @param {function} callback - callback function to filter items
                                                     * @param {number} number - the number of items to find. If it is not passed, iterate all items.
                                                     * @return {array<Item>}
                                                     * @example
                                                     * selectBox.getItems(); // all items
                                                     * selectBox.getItems(item => {
                                                     *  return !item.isDisabled();
                                                     * }); // all enabled items
                                                     */
                                                    ;

                                                    _proto.getItems = function getItems(callback, number) {
                                                        return this.dropdown.getItems(callback, number);
                                                    }
                                                    /**
                                                     * Get an {@link Item item} by its index or value.
                                                     * @param {number|string} value - if string, the Item's value. if number, the Item's index.
                                                     * @return {Item}
                                                     * @example
                                                     * selectBox.getItem(0); // first item
                                                     * selectBox.getItem('value') // item which of value is 'value'
                                                     */
                                                    ;

                                                    _proto.getItem = function getItem(value) {
                                                        return this.dropdown.getItem(value);
                                                    }
                                                    /**
                                                     * Get all {@link ItemGroup item groups} that pass the test implemented by the provided function.
                                                     * If filter function is not passed, it returns all item groups.
                                                     * @param {function} callback - callback function to filter item groups
                                                     * @param {number} number - the number of items to find. If it is not passed, iterate all item groups.
                                                     * @return {array<ItemGroup>}
                                                     * @example
                                                     * selectBox.getItemGroups(); // all item groups
                                                     * selectBox.getItemGroups(itemGroup => {
                                                     *  return !itemGroup.isDisabled();
                                                     * }); // all enabled item groups
                                                     */
                                                    ;

                                                    _proto.getItemGroups = function getItemGroups(callback, number) {
                                                        return this.dropdown.getItemGroups(callback, number);
                                                    }
                                                    /**
                                                     * Get an {@link ItemGroup item group} by its index.
                                                     * @param {number} index - groupIndex of the ItemGroup
                                                     * @return {ItemGroup}
                                                     * @example
                                                     * selectBox.getItemGroup(0); // first item group
                                                     */
                                                    ;

                                                    _proto.getItemGroup = function getItemGroup(index) {
                                                        return this.dropdown.getItemGroup(index);
                                                    }
                                                    /**
                                                     * Destory a select box.
                                                     * @example
                                                     * selectBox.destroy();
                                                     */
                                                    ;

                                                    _proto.destroy = function destroy() {
                                                        this.unbindEvents();
                                                        this.input.destroy();
                                                        this.dropdown.destroy();

                                                        if (this.theme) {
                                                            this.theme.destroy();
                                                        }

                                                        (0, _removeElement["default"])(this.el);
                                                        this.container = this.el = this.input = this.dropdown = this.theme = null;
                                                    };

                                                    return SelectBox;
                                                }();

                                            _customEvents["default"].mixin(SelectBox);

                                            var _default = SelectBox;
                                            _exports["default"] = _default;
                                        });

                                        /***/ }),

                                    /***/ "./src/js/theme.js":
                                    /*!*************************!*\
      !*** ./src/js/theme.js ***!
      \*************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/collection/forEachOwnProperties */ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js"), __webpack_require__(/*! tui-code-snippet/domUtil/removeElement */ "./node_modules/tui-code-snippet/domUtil/removeElement.js"), __webpack_require__(/*! tui-code-snippet/type/isArray */ "./node_modules/tui-code-snippet/type/isArray.js"), __webpack_require__(/*! tui-code-snippet/type/isBoolean */ "./node_modules/tui-code-snippet/type/isBoolean.js"), __webpack_require__(/*! tui-code-snippet/type/isString */ "./node_modules/tui-code-snippet/type/isString.js"), __webpack_require__(/*! ./utils */ "./src/js/utils.js"), __webpack_require__(/*! ./constants */ "./src/js/constants.js"), __webpack_require__(/*! ./themeConfig */ "./src/js/themeConfig.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports, _forEachOwnProperties, _removeElement, _isArray, _isBoolean, _isString, _utils, _constants, _themeConfig) {

                                            _exports.__esModule = true;
                                            _exports["default"] = void 0;
                                            _forEachOwnProperties = _interopRequireDefault(_forEachOwnProperties);
                                            _removeElement = _interopRequireDefault(_removeElement);
                                            _isArray = _interopRequireDefault(_isArray);
                                            _isBoolean = _interopRequireDefault(_isBoolean);
                                            _isString = _interopRequireDefault(_isString);
                                            _themeConfig = _interopRequireDefault(_themeConfig);

                                            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

                                            function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

                                            function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

                                            function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

                                            /**
                                             * @class
                                             * @ignore
                                             * @param {object} customTheme - theme object for custom style
                                             * @param {HTMLElement|string} container - container element or selector
                                             */
                                            var Theme =
                                                /*#__PURE__*/
                                                function () {
                                                    function Theme(customTheme, container) {
                                                        this.containerSelector = (0, _utils.getSelector)(container);
                                                        this.cssString = this.buildAll((0, _utils.transform)(customTheme));
                                                        this.styleEl = this.createStyleElement();
                                                        document.getElementsByTagName('head')[0].appendChild(this.styleEl);
                                                    }
                                                    /**
                                                     * Create a style element
                                                     * @return {HTMLElement}
                                                     * @private
                                                     */


                                                    var _proto = Theme.prototype;

                                                    _proto.createStyleElement = function createStyleElement() {
                                                        var styleEl = document.createElement('style');
                                                        styleEl.type = 'text/css';

                                                        if (styleEl.styleSheet) {
                                                            styleEl.styleSheet.cssText = this.cssString;
                                                        } else {
                                                            styleEl.appendChild(document.createTextNode(this.cssString));
                                                        }

                                                        return styleEl;
                                                    }
                                                    /**
                                                     * Build css strings for Input, Dropdown, ItemGroup, and Item.
                                                     * @param {object} theme - theme object
                                                     * @return {string}
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.buildAll = function buildAll(theme) {
                                                        var exclude = {
                                                            border: '',
                                                            background: ''
                                                        };
                                                        return this.buildInput(_objectSpread({}, theme.common, {}, theme.input)) + this.buildDropdown(_objectSpread({}, theme.common, {
                                                            borderTop: '0'
                                                        }, theme.dropdown, {
                                                            height: ''
                                                        })) + this.buildItemGroup(theme.itemGroup ? _objectSpread({}, theme.common, {}, exclude, {}, theme.itemGroup.label) : _objectSpread({}, theme.common, {}, exclude)) + this.buildItem(theme.itemGroup ? _objectSpread({}, theme.common, {}, exclude, {}, theme.item, {
                                                            inItemGroup: theme.itemGroup.items
                                                        }) : _objectSpread({}, theme.common, {}, exclude, {}, theme.item));
                                                    }
                                                    /**
                                                     * Build css strings for Input
                                                     * @param {object} theme - theme object
                                                     * @return {string}
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.buildInput = function buildInput(theme) {
                                                        theme.placeholder = {};

                                                        if (theme.height) {
                                                            theme.placeholder.lineHeight = theme.height;
                                                        }

                                                        if ((0, _isBoolean["default"])(theme.showIcon) && !theme.showIcon) {
                                                            theme.icon = {
                                                                display: 'none'
                                                            };
                                                            theme.placeholder.width = '100%';
                                                        }

                                                        return this.buildCssString(_constants.cls.INPUT, theme) + this.buildCssString([_constants.cls.INPUT, _constants.cls.OPEN], theme.open) + this.buildCssString([_constants.cls.INPUT, _constants.cls.DISABLED], theme.disabled) + this.buildCssString(_constants.cls.PLACEHOLDER, theme.placeholder) + this.buildCssString(_constants.cls.ICON, theme.icon);
                                                    }
                                                    /**
                                                     * Build css strings for Dropdown
                                                     * @param {object} theme - theme object
                                                     * @return {string}
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.buildDropdown = function buildDropdown(theme) {
                                                        return this.buildCssString(_constants.cls.DROPDOWN, theme);
                                                    }
                                                    /**
                                                     * Build css strings for ItemGroup
                                                     * @param {object} theme - theme object
                                                     * @return {string}
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.buildItemGroup = function buildItemGroup(theme) {
                                                        if (theme.height) {
                                                            theme.lineHeight = theme.height;
                                                        }

                                                        return this.buildCssString(_constants.cls.ITEM_GROUP_LABEL, theme) + this.buildCssString([_constants.cls.ITEM_GROUP_LABEL, _constants.cls.DISABLED], theme.disabled);
                                                    }
                                                    /**
                                                     * Build css strings for Item
                                                     * @param {object} theme - theme object
                                                     * @return {string}
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.buildItem = function buildItem(theme) {
                                                        if (theme.height) {
                                                            theme.lineHeight = theme.height;
                                                        }

                                                        if (theme.selected) {
                                                            var base = (0, _utils.transform)(_themeConfig["default"]);
                                                            theme.selected = _objectSpread({}, base.item.selected, {}, theme.selected);
                                                            theme.disabled = _objectSpread({}, base.item.disabled, {}, theme.disabled);
                                                            theme.highlighted = _objectSpread({}, base.item.highlighted, {}, theme.highlighted);
                                                        }

                                                        return this.buildCssString(_constants.cls.ITEM, theme) + this.buildCssString([_constants.cls.ITEM, _constants.cls.SELECTED], theme.selected) + this.buildCssString([_constants.cls.ITEM, _constants.cls.DISABLED], theme.disabled) + this.buildCssString([_constants.cls.ITEM, _constants.cls.HIGHLIGHT], theme.highlighted) + this.buildCssString(_constants.cls.ITEM_GROUP + ">." + _constants.cls.ITEM, theme.inItemGroup);
                                                    }
                                                    /**
                                                     * Build css strings
                                                     * @param {string} className - className
                                                     * @param {object} theme - theme object
                                                     * @return {string}
                                                     * @private
                                                     */
                                                    ;

                                                    _proto.buildCssString = function buildCssString(className, theme) {
                                                        if ((0, _isArray["default"])(className)) {
                                                            className = className.join('.');
                                                        }

                                                        className = "." + className;
                                                        var cssString = '';
                                                        (0, _forEachOwnProperties["default"])(theme, function (value, key) {
                                                            if ((0, _isString["default"])(value) && value) {
                                                                key = key.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
                                                                cssString += key + ":" + value + ";";
                                                            }
                                                        });
                                                        return cssString ? this.containerSelector + " " + className + "{" + cssString + "}" : '';
                                                    }
                                                    /**
                                                     * Destory a theme
                                                     */
                                                    ;

                                                    _proto.destroy = function destroy() {
                                                        (0, _removeElement["default"])(this.styleEl);
                                                        this.styleEl = null;
                                                    };

                                                    return Theme;
                                                }();

                                            _exports["default"] = Theme;
                                        });

                                        /***/ }),

                                    /***/ "./src/js/themeConfig.js":
                                    /*!*******************************!*\
      !*** ./src/js/themeConfig.js ***!
      \*******************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports) {

                                            _exports.__esModule = true;
                                            _exports["default"] = void 0;

                                            /**
                                             * @fileoverview Theme configuration
                                             * @author NHN FE Development Lab <dl_javascript@nhn.com>
                                             */

                                            /**
                                             * Theme configuration.
                                             * "common" prefix is for the entire select box. Its properties are overriden by "input", "dropdown", "itemGroup", and "item".
                                             * The example using theme can be found {@link tutorial-example02-theme here}.
                                             * @typedef {object} themeConfig
                                             * @example
                                             * const themeConfig = {
                                             *   'common.border': '1px solid #ddd', // border for input and dropdown (not itemGroup and item)
                                             *   'common.background': '#fff',
                                             *   'common.color': '#333',
                                             *   'common.width': '100%',
                                             *   'common.height': '29px', // height for item and itemGroup label (not entire select box)
                                             *
                                             *   'common.disabled.background': '#f9f9f9',
                                             *   'common.disabled.color': 'c8c8c8',
                                             *
                                             *   // Input
                                             *   'input.border': '1px solid #ddd',
                                             *   'input.borderBottom': '',
                                             *   'input.background': 'inherit',
                                             *   'input.color': '#333',
                                             *   'input.width': '100%',
                                             *   'input.height': '29px',
                                             *
                                             *   // Input when dropdown is open
                                             *   'input.open.border': '1px solid #aaa',
                                             *   'input.open.background': 'inherit',
                                             *   'input.open.color': '#333',
                                             *
                                             *   // Input when selectbox is disabled
                                             *   'input.disabled.border': '1px solid #aaa',
                                             *   'input.disabled.background': '#f9f9f9',
                                             *   'input.disabled.color': '#c8c8c8',
                                             *
                                             *   // Dropdown
                                             *   'dropdown.border': '1px solid #aaa',
                                             *   'dropdown.borderTop': '0',
                                             *   'dropdown.background': 'inherit',
                                             *   'dropdown.width': '100%',
                                             *   'dropdown.maxHeight': '',
                                             *
                                             *   // ItemGroup's items
                                             *   // if you want to set the same padding value as the itemGroup.label, set to '8px'.
                                             *   'itemGroup.items.paddingLeft': '20px',
                                             *
                                             *   // ItemGroup's label
                                             *   'itemGroup.label.border': '0',
                                             *   'itemGroup.label.background': 'inherit',
                                             *   'itemGroup.label.color': '#333',
                                             *   'itemGroup.label.fontWeight': 'bold',
                                             *   'itemGroup.label.height': '29px',
                                             *
                                             *   // disabled ItemGroup's label
                                             *   'itemGroup.label.disabled.border': '0',
                                             *   'itemGroup.label.disabled.background': 'inherit',
                                             *   'itemGroup.label.disabled.color': '#333',
                                             *
                                             *   // Item
                                             *   'item.border': '0',
                                             *   'item.background': 'inherit',
                                             *   'item.color': '#333',
                                             *   'item.height': '29px',
                                             *
                                             *   // selected Item
                                             *   'item.selected.border': '0',
                                             *   'item.selected.background': '#f4f4f4',
                                             *   'item.selected.color': '#333',
                                             *
                                             *   // disabled Item
                                             *   'item.disabled.border': '0',
                                             *   'item.disabled.background': '#f9f9f9',
                                             *   'item.disabled.color': '#c8c8c8',
                                             *
                                             *   // highlighted Item
                                             *   'item.highlighted.border': '0',
                                             *   'item.highlighted.background': '#e5f6ff',
                                             *   'item.highlighted.color': '#333'
                                             * };
                                             */
                                            var _default = {
                                                'common.border': '1px solid #ddd',
                                                // border for input and dropdown (not itemGroup and item)
                                                'common.background': '#fff',
                                                'common.color': '#333',
                                                'common.width': '100%',
                                                'common.height': '29px',
                                                // height for item and itemGroup label (not entire select box)
                                                'common.disabled.background': '#f9f9f9',
                                                'common.disabled.color': 'c8c8c8',
                                                // Input
                                                'input.border': '1px solid #ddd',
                                                'input.borderBottom': '',
                                                'input.background': 'inherit',
                                                'input.color': '#333',
                                                'input.width': '100%',
                                                'input.height': '29px',
                                                // Input when dropdown is open
                                                'input.open.border': '1px solid #aaa',
                                                'input.open.background': 'inherit',
                                                'input.open.color': '#333',
                                                // Input when selectbox is disabled
                                                'input.disabled.border': '1px solid #aaa',
                                                'input.disabled.background': '#f9f9f9',
                                                'input.disabled.color': '#c8c8c8',
                                                // Dropdown
                                                'dropdown.border': '1px solid #aaa',
                                                'dropdown.borderTop': '0',
                                                'dropdown.background': 'inherit',
                                                'dropdown.width': '100%',
                                                'dropdown.maxHeight': '',
                                                // ItemGroup's items
                                                'itemGroup.items.paddingLeft': '20px',
                                                // ItemGroup's label
                                                'itemGroup.label.border': '0',
                                                'itemGroup.label.background': 'inherit',
                                                'itemGroup.label.color': '#333',
                                                'itemGroup.label.fontWeight': 'bold',
                                                'itemGroup.label.height': '29px',
                                                // disabled ItemGroup's label
                                                'itemGroup.label.disabled.border': '0',
                                                'itemGroup.label.disabled.background': 'inherit',
                                                'itemGroup.label.disabled.color': '#333',
                                                // Item
                                                'item.border': '0',
                                                'item.background': 'inherit',
                                                'item.color': '#333',
                                                'item.height': '29px',
                                                // selected Item
                                                'item.selected.border': '0',
                                                'item.selected.background': '#f4f4f4',
                                                'item.selected.color': '#333',
                                                // disabled Item
                                                'item.disabled.border': '0',
                                                'item.disabled.background': '#f9f9f9',
                                                'item.disabled.color': '#c8c8c8',
                                                // highlighted Item
                                                'item.highlighted.border': '0',
                                                'item.highlighted.background': '#e5f6ff',
                                                'item.highlighted.color': '#333'
                                            };
                                            _exports["default"] = _default;
                                        });

                                        /***/ }),

                                    /***/ "./src/js/utils.js":
                                    /*!*************************!*\
      !*** ./src/js/utils.js ***!
      \*************************/
                                    /*! no static exports found */
                                    /***/ (function(module, exports, __webpack_require__) {

                                        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
                                            {
                                                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! tui-code-snippet/collection/forEachOwnProperties */ "./node_modules/tui-code-snippet/collection/forEachOwnProperties.js"), __webpack_require__(/*! tui-code-snippet/type/isString */ "./node_modules/tui-code-snippet/type/isString.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                                                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                                            }
                                        })(this, function (_exports, _forEachOwnProperties, _isString) {

                                            _exports.__esModule = true;
                                            _exports.getSelector = _exports.createElement = _exports.transform = void 0;
                                            _forEachOwnProperties = _interopRequireDefault(_forEachOwnProperties);
                                            _isString = _interopRequireDefault(_isString);

                                            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

                                            /**
                                             * @fileoverview Utility functions
                                             * @author NHN. FE dev team.<dl_javascript@nhn.com>
                                             */

                                            /**
                                             * Transform an object using dot notation
                                             * @param {object} obj - object to transform
                                             * @return {object}
                                             */
                                            var transform = function transform(obj) {
                                                var result = {};
                                                (0, _forEachOwnProperties["default"])(obj, function (value, prop) {
                                                    var keys = prop.split('.');
                                                    var curr = result;
                                                    keys.forEach(function (key, index) {
                                                        if (index === keys.length - 1) {
                                                            curr[key] = value;
                                                        } else if (!curr[key]) {
                                                            curr[key] = {};
                                                        }

                                                        curr = curr[key];
                                                    });
                                                });
                                                return result;
                                            };
                                            /**
                                             * Create a HTML element
                                             * @param {string} tagName - tag name
                                             * @param {string} content - content in the element
                                             * @param {object} options - other properties for the element
                                             * @param {HTMLElement} container - parent element for the element
                                             * @return {HTMLElement}
                                             */


                                            _exports.transform = transform;

                                            var createElement = function createElement(tagName, content, options, container) {
                                                var el = document.createElement(tagName);

                                                if (content) {
                                                    el.innerText = content;
                                                }

                                                (0, _forEachOwnProperties["default"])(options, function (value, key) {
                                                    if (key.indexOf('data-') > -1) {
                                                        el.setAttribute(key, value);
                                                    } else {
                                                        el[key] = value;
                                                    }
                                                });

                                                if (container) {
                                                    container.appendChild(el);
                                                }

                                                return el;
                                            };
                                            /**
                                             * Get selectors for an element
                                             * @param {HTMLElement} el - element
                                             * @return {string}
                                             */


                                            _exports.createElement = createElement;

                                            var getSelector = function getSelector(el) {
                                                if ((0, _isString["default"])(el)) {
                                                    return el;
                                                }

                                                if (el.id) {
                                                    return "#" + el.id;
                                                }

                                                var className = "." + el.className.replace(/\s+/g, '.');

                                                if (className) {
                                                    var elems = document.querySelectorAll(className);

                                                    if (elems.length === 1) {
                                                        return className;
                                                    }
                                                }

                                                var tagName = el.tagName.toLowerCase();
                                                return "" + tagName + className;
                                            };

                                            _exports.getSelector = getSelector;
                                        });

                                        /***/ })

                                    /******/ })["default"];
                        });


                        /***/ }),
                    /* 66 */
                    /***/ (function(module, exports, __webpack_require__) {

                        // extracted by mini-css-extract-plugin

                        /***/ }),
                    /* 67 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.DatePickerEditor = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var tui_date_picker_1 = tslib_1.__importDefault(__webpack_require__(40));
                        var dom_1 = __webpack_require__(2);
                        var common_1 = __webpack_require__(0);
                        var dom_2 = __webpack_require__(32);
                        var DatePickerEditor = /** @class */ (function () {
                            function DatePickerEditor(props) {
                                var _this = this;
                                var usageStatistics = props.grid.usageStatistics, columnInfo = props.columnInfo;
                                var value = String(common_1.isNil(props.value) ? '' : props.value);
                                var el = document.createElement('div');
                                el.className = dom_1.cls('layer-editing-inner');
                                this.el = el;
                                this.inputEl = this.createInputElement();
                                var datepickerInputContainer = document.createElement('div');
                                datepickerInputContainer.className = dom_1.cls('datepicker-input-container');
                                datepickerInputContainer.appendChild(this.inputEl);
                                this.el.appendChild(datepickerInputContainer);
                                var layer = this.createLayer();
                                this.layer = layer;
                                var options = tslib_1.__assign({ showIcon: true }, columnInfo.editor.options);
                                if (options.showIcon) {
                                    var icon = this.createIcon();
                                    this.iconEl = icon;
                                    this.inputEl.className = dom_1.cls('datepicker-input');
                                    datepickerInputContainer.appendChild(icon);
                                }
                                var date;
                                if (!options.format) {
                                    options.format = 'yyyy-MM-dd';
                                }
                                if (common_1.isNumber(value) || common_1.isString(value)) {
                                    date = new Date(value);
                                }
                                var defaultOptions = {
                                    date: date,
                                    type: 'date',
                                    input: {
                                        element: this.inputEl,
                                        format: options.format,
                                    },
                                    usageStatistics: usageStatistics,
                                };
                                this.datePickerEl = new tui_date_picker_1.default(layer, common_1.deepMergedCopy(defaultOptions, options));
                                this.datePickerEl.on('close', function () { return _this.focus(); });
                            }
                            DatePickerEditor.prototype.createInputElement = function () {
                                var inputEl = document.createElement('input');
                                inputEl.className = dom_1.cls('content-text');
                                inputEl.type = 'text';
                                return inputEl;
                            };
                            DatePickerEditor.prototype.createLayer = function () {
                                var layer = document.createElement('div');
                                layer.className = dom_1.cls('editor-datepicker-layer');
                                // To hide the initial layer which is having the position which is not calculated properly
                                dom_2.setOpacity(layer, 0);
                                return layer;
                            };
                            DatePickerEditor.prototype.openDatePicker = function () {
                                this.datePickerEl.open();
                            };
                            DatePickerEditor.prototype.createIcon = function () {
                                var _this = this;
                                var icon = document.createElement('i');
                                icon.className = dom_1.cls('date-icon');
                                icon.addEventListener('click', function () { return _this.openDatePicker(); });
                                return icon;
                            };
                            DatePickerEditor.prototype.focus = function () {
                                this.inputEl.focus();
                            };
                            DatePickerEditor.prototype.getElement = function () {
                                return this.el;
                            };
                            DatePickerEditor.prototype.getValue = function () {
                                return this.inputEl.value;
                            };
                            DatePickerEditor.prototype.mounted = function () {
                                // To prevent wrong stacked z-index context, layer append to grid container
                                dom_2.getContainerElement(this.el).appendChild(this.layer);
                                this.inputEl.select();
                                this.datePickerEl.open();
                                // `this.layer.firstElementChild` is real datePicker layer(it is need to get total height)
                                dom_2.setLayerPosition(this.el, this.layer, this.layer.firstElementChild, true);
                                // To show the layer which has appropriate position
                                dom_2.setOpacity(this.layer, 1);
                            };
                            DatePickerEditor.prototype.beforeDestroy = function () {
                                if (this.iconEl) {
                                    this.iconEl.removeEventListener('click', this.openDatePicker);
                                }
                                this.datePickerEl.destroy();
                                dom_2.getContainerElement(this.el).removeChild(this.layer);
                            };
                            return DatePickerEditor;
                        }());
                        exports.DatePickerEditor = DatePickerEditor;


                        /***/ }),
                    /* 68 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.RowHeaderInputRenderer = void 0;
                        var dom_1 = __webpack_require__(2);
                        var RowHeaderInputRenderer = /** @class */ (function () {
                            function RowHeaderInputRenderer(props) {
                                var el = document.createElement('div');
                                var input = document.createElement('input');
                                var grid = props.grid, rowKey = props.rowKey, disabled = props.disabled;
                                el.className = dom_1.cls('row-header-checkbox');
                                input.type = 'checkbox';
                                input.name = '_checked';
                                input.disabled = disabled;
                                input.addEventListener('change', function () {
                                    if (input.checked) {
                                        grid.check(rowKey);
                                    }
                                    else {
                                        grid.uncheck(rowKey);
                                    }
                                });
                                el.appendChild(input);
                                this.el = el;
                                this.input = input;
                                this.render(props);
                            }
                            RowHeaderInputRenderer.prototype.getElement = function () {
                                return this.el;
                            };
                            RowHeaderInputRenderer.prototype.render = function (props) {
                                var value = props.value, disabled = props.disabled;
                                this.input.checked = Boolean(value);
                                this.input.disabled = disabled;
                            };
                            return RowHeaderInputRenderer;
                        }());
                        exports.RowHeaderInputRenderer = RowHeaderInputRenderer;


                        /***/ }),
                    /* 69 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.isEditingCell = exports.isFocusedCell = void 0;
                        function isFocusedCell(focus, rowKey, columnName) {
                            return rowKey === focus.rowKey && columnName === focus.columnName;
                        }
                        exports.isFocusedCell = isFocusedCell;
                        function isEditingCell(focus, rowKey, columnName) {
                            var editingAddress = focus.editingAddress;
                            return !!(editingAddress &&
                                editingAddress.rowKey === rowKey &&
                                editingAddress.columnName === columnName);
                        }
                        exports.isEditingCell = isEditingCell;


                        /***/ }),
                    /* 70 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.sortRawData = exports.compare = void 0;
                        var common_1 = __webpack_require__(0);
                        function compare(valueA, valueB) {
                            var isBlankA = common_1.isBlank(valueA);
                            var isBlankB = common_1.isBlank(valueB);
                            var convertedA = common_1.convertToNumber(valueA);
                            var convertedB = common_1.convertToNumber(valueB);
                            if (!common_1.isNumber(convertedA) || !common_1.isNumber(convertedB)) {
                                convertedA = String(valueA);
                                convertedB = String(valueB);
                            }
                            var result = 0;
                            if (isBlankA && !isBlankB) {
                                result = -1;
                            }
                            else if (!isBlankA && isBlankB) {
                                result = 1;
                            }
                            else if (convertedA < convertedB) {
                                result = -1;
                            }
                            else if (convertedA > convertedB) {
                                result = 1;
                            }
                            return result;
                        }
                        exports.compare = compare;
                        function getComparators(columns) {
                            var comparators = [];
                            columns.forEach(function (column) {
                                var columnName = column.columnName, ascending = column.ascending, customComparator = column.comparator;
                                var comparator = customComparator || compare;
                                comparators.push({
                                    name: columnName,
                                    comparator: ascending
                                        ? comparator
                                        : function (valueA, valueB, rowA, rowB) {
                                            return -comparator(valueA, valueB, rowA, rowB);
                                        },
                                });
                            });
                            return comparators;
                        }
                        function sortRawData(columns) {
                            var comparators = getComparators(columns);
                            return function (rowA, rowB) {
                                for (var _i = 0, comparators_1 = comparators; _i < comparators_1.length; _i++) {
                                    var _a = comparators_1[_i], columnName = _a.name, comparator = _a.comparator;
                                    var result = comparator(rowA[columnName], rowB[columnName], rowA, rowB);
                                    if (result) {
                                        return result;
                                    }
                                }
                                return 0;
                            };
                        }
                        exports.sortRawData = sortRawData;


                        /***/ }),
                    /* 71 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getChangedScrollPosition = void 0;
                        function getHorizontalScrollPosition(rightSideWidth, cellPosRect, scrollLeft, tableBorderWidth) {
                            var left = cellPosRect.left, right = cellPosRect.right;
                            if (left < scrollLeft) {
                                return left;
                            }
                            if (right > scrollLeft + rightSideWidth - tableBorderWidth) {
                                return right - rightSideWidth + tableBorderWidth;
                            }
                            return null;
                        }
                        function getVerticalScrollPosition(height, cellPosRect, scrollTop, tableBorderWidth) {
                            var top = cellPosRect.top, bottom = cellPosRect.bottom;
                            if (top < scrollTop) {
                                return top + tableBorderWidth;
                            }
                            if (bottom > scrollTop + height) {
                                return bottom - height + tableBorderWidth;
                            }
                            return null;
                        }
                        function getChangedScrollPosition(store, side, changedCellPosRect) {
                            var _a = store.dimension, bodyHeight = _a.bodyHeight, scrollXHeight = _a.scrollXHeight, scrollYWidth = _a.scrollYWidth, tableBorderWidth = _a.tableBorderWidth, areaWidth = store.columnCoords.areaWidth, focusedCellPostRect = store.focus.cellPosRect, viewport = store.viewport;
                            var scrollLeft = viewport.scrollLeft, scrollTop = viewport.scrollTop;
                            var cellPosRect = changedCellPosRect || focusedCellPostRect;
                            var changedScrollLeft = side === 'R'
                                ? getHorizontalScrollPosition(areaWidth.R - scrollYWidth, cellPosRect, scrollLeft, tableBorderWidth)
                                : null;
                            var changedScrollTop = getVerticalScrollPosition(bodyHeight - scrollXHeight, cellPosRect, scrollTop, tableBorderWidth);
                            return [changedScrollLeft, changedScrollTop];
                        }
                        exports.getChangedScrollPosition = getChangedScrollPosition;


                        /***/ }),
                    /* 72 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.updateRowSpanWhenRemoving = exports.updateRowSpanWhenAppending = void 0;
                        var data_1 = __webpack_require__(13);
                        var common_1 = __webpack_require__(0);
                        function updateRowSpanWhenAppending(data, prevRow, extendPrevRowSpan) {
                            var prevRowSpanMap = prevRow.rowSpanMap;
                            if (common_1.isEmpty(prevRowSpanMap)) {
                                return;
                            }
                            Object.keys(prevRowSpanMap).forEach(function (columnName) {
                                var prevRowSpan = prevRowSpanMap[columnName];
                                if (prevRowSpan) {
                                    var count = prevRowSpan.count, keyRow = prevRowSpan.mainRow, mainRowKey = prevRowSpan.mainRowKey;
                                    var mainRow = keyRow ? prevRow : common_1.findProp('rowKey', mainRowKey, data);
                                    var mainRowSpan = mainRow.rowSpanMap[columnName];
                                    var startOffset = keyRow || extendPrevRowSpan ? 1 : -count + 1;
                                    // keep rowSpan state when appends row in the middle of rowSpan
                                    if (mainRowSpan.spanCount > startOffset) {
                                        mainRowSpan.count += 1;
                                        mainRowSpan.spanCount += 1;
                                        updateSubRowSpan(data, mainRow, columnName, 1, mainRowSpan.spanCount);
                                    }
                                }
                            });
                        }
                        exports.updateRowSpanWhenAppending = updateRowSpanWhenAppending;
                        function updateRowSpanWhenRemoving(data, removedRow, nextRow, keepRowSpanData) {
                            var removedRowSpanMap = removedRow.rowSpanMap;
                            if (common_1.isEmpty(removedRowSpanMap)) {
                                return;
                            }
                            Object.keys(removedRowSpanMap).forEach(function (columnName) {
                                var removedRowSpan = removedRowSpanMap[columnName];
                                var count = removedRowSpan.count, keyRow = removedRowSpan.mainRow, mainRowKey = removedRowSpan.mainRowKey;
                                var mainRow, spanCount;
                                if (keyRow) {
                                    mainRow = nextRow;
                                    spanCount = count - 1;
                                    if (spanCount > 1) {
                                        var mainRowSpan = mainRow.rowSpanMap[columnName];
                                        mainRowSpan.mainRowKey = mainRow.rowKey;
                                        mainRowSpan.mainRow = true;
                                    }
                                    if (keepRowSpanData) {
                                        mainRow[columnName] = removedRow[columnName];
                                    }
                                }
                                else {
                                    mainRow = common_1.findProp('rowKey', mainRowKey, data);
                                    spanCount = mainRow.rowSpanMap[columnName].spanCount - 1;
                                }
                                if (spanCount > 1) {
                                    var mainRowSpan = mainRow.rowSpanMap[columnName];
                                    mainRowSpan.count = spanCount;
                                    mainRowSpan.spanCount = spanCount;
                                    updateSubRowSpan(data, mainRow, columnName, 1, spanCount);
                                }
                                else {
                                    delete mainRow.rowSpanMap[columnName];
                                }
                            });
                        }
                        exports.updateRowSpanWhenRemoving = updateRowSpanWhenRemoving;
                        function updateSubRowSpan(data, mainRow, columnName, startOffset, spanCount) {
                            var mainRowIndex = common_1.findPropIndex('rowKey', mainRow.rowKey, data);
                            for (var offset = startOffset; offset < spanCount; offset += 1) {
                                var row = data[mainRowIndex + offset];
                                row.rowSpanMap[columnName] = data_1.createRowSpan(false, mainRow.rowKey, -offset, spanCount);
                            }
                        }


                        /***/ }),
                    /* 73 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = void 0;
                        var observable_1 = __webpack_require__(5);
                        var common_1 = __webpack_require__(0);
                        function create(_a) {
                            var column = _a.column, _b = _a.width, width = _b === void 0 ? 'auto' : _b, domWidth = _a.domWidth, _c = _a.rowHeight, rowHeight = _c === void 0 ? 40 : _c, _d = _a.bodyHeight, bodyHeight = _d === void 0 ? 'auto' : _d, _e = _a.minRowHeight, minRowHeight = _e === void 0 ? 40 : _e, _f = _a.minBodyHeight, minBodyHeight = _f === void 0 ? 130 : _f, _g = _a.frozenBorderWidth, frozenBorderWidth = _g === void 0 ? 1 : _g, _h = _a.heightResizable, heightResizable = _h === void 0 ? false : _h, _j = _a.scrollX, scrollX = _j === void 0 ? true : _j, _k = _a.scrollY, scrollY = _k === void 0 ? true : _k, _l = _a.summaryHeight, summaryHeight = _l === void 0 ? 0 : _l, _m = _a.summaryPosition, summaryPosition = _m === void 0 ? 'bottom' : _m, _o = _a.headerHeight, headerHeight = _o === void 0 ? 40 : _o;
                            var bodyHeightVal = typeof bodyHeight === 'number' ? bodyHeight : 0;
                            return observable_1.observable({
                                offsetLeft: 0,
                                offsetTop: 0,
                                width: width === 'auto' ? domWidth : width,
                                autoWidth: width === 'auto',
                                minBodyHeight: minBodyHeight,
                                bodyHeight: Math.max(bodyHeightVal, minBodyHeight),
                                autoHeight: bodyHeight === 'auto',
                                heightResizable: heightResizable,
                                fitToParentHeight: bodyHeight === 'fitToParent',
                                minRowHeight: minRowHeight,
                                rowHeight: common_1.isNumber(rowHeight) ? Math.max(rowHeight, minRowHeight) : minRowHeight,
                                autoRowHeight: rowHeight === 'auto',
                                scrollX: scrollX,
                                scrollY: scrollY,
                                summaryHeight: summaryHeight,
                                summaryPosition: summaryPosition,
                                headerHeight: headerHeight,
                                scrollbarWidth: 17,
                                tableBorderWidth: 1,
                                cellBorderWidth: 1,
                                get scrollYWidth() {
                                    return this.scrollY ? this.scrollbarWidth : 0;
                                },
                                get scrollXHeight() {
                                    return this.scrollX ? this.scrollbarWidth : 0;
                                },
                                get frozenBorderWidth() {
                                    var visibleColumnsBySide = column.visibleColumnsBySide;
                                    var visibleLeftColumnCount = visibleColumnsBySide.L.length;
                                    return visibleLeftColumnCount > 0 ? frozenBorderWidth : 0;
                                },
                                get contentsWidth() {
                                    var columnLen = column.visibleColumnsWithRowHeader.length;
                                    var totalBorderWidth = columnLen * this.cellBorderWidth;
                                    return this.width - this.scrollYWidth - this.frozenBorderWidth - totalBorderWidth;
                                },
                            });
                        }
                        exports.create = create;


                        /***/ }),
                    /* 74 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = void 0;
                        var observable_1 = __webpack_require__(5);
                        var common_1 = __webpack_require__(0);
                        var rowSpan_1 = __webpack_require__(11);
                        var data_1 = __webpack_require__(6);
                        function findIndexByPosition(offsets, position) {
                            var rowOffset = common_1.findIndex(function (offset) { return offset > position; }, offsets);
                            return rowOffset === -1 ? offsets.length - 1 : rowOffset - 1;
                        }
                        function calculateRange(scrollPos, totalSize, offsets, data, rowCalculation) {
                            // safari uses negative scroll position for bouncing effect
                            scrollPos = Math.max(scrollPos, 0);
                            var start = findIndexByPosition(offsets, scrollPos);
                            var end = findIndexByPosition(offsets, scrollPos + totalSize) + 1;
                            var filteredRawData = data.filteredRawData, sortState = data.sortState, pageRowRange = data.pageRowRange;
                            var dataLength = filteredRawData.length;
                            if (rowCalculation && data_1.isClientPagination(data)) {
                                start = pageRowRange[0], end = pageRowRange[1];
                            }
                            if (dataLength && dataLength >= start && rowCalculation && rowSpan_1.isRowSpanEnabled(sortState)) {
                                var maxRowSpanCount = rowSpan_1.getMaxRowSpanCount(start, filteredRawData);
                                var topRowSpanIndex = start - maxRowSpanCount;
                                return [topRowSpanIndex >= 0 ? topRowSpanIndex : 0, end];
                            }
                            return [start, end];
                        }
                        function getCachedRange(cachedRange, newRange) {
                            if (cachedRange && common_1.arrayEqual(cachedRange, newRange)) {
                                return cachedRange;
                            }
                            return newRange;
                        }
                        function create(_a) {
                            var data = _a.data, column = _a.column, dimension = _a.dimension, rowCoords = _a.rowCoords, columnCoords = _a.columnCoords, showDummyRows = _a.showDummyRows;
                            return observable_1.observable({
                                scrollLeft: 0,
                                scrollTop: 0,
                                scrollPixelScale: 40,
                                get maxScrollLeft() {
                                    var scrollbarWidth = dimension.scrollbarWidth, cellBorderWidth = dimension.cellBorderWidth;
                                    var areaWidth = columnCoords.areaWidth, widths = columnCoords.widths;
                                    var totalRWidth = 0;
                                    widths.R.forEach(function (width) {
                                        totalRWidth += width + cellBorderWidth;
                                    });
                                    return totalRWidth - areaWidth.R + scrollbarWidth;
                                },
                                get maxScrollTop() {
                                    var bodyHeight = dimension.bodyHeight, scrollbarWidth = dimension.scrollbarWidth;
                                    var totalRowHeight = rowCoords.totalRowHeight;
                                    return totalRowHeight - bodyHeight + scrollbarWidth;
                                },
                                // only for right side columns
                                get colRange() {
                                    var range = calculateRange(this.scrollLeft, columnCoords.areaWidth.R, columnCoords.offsets.R, data);
                                    return getCachedRange(this.__storage__.colRange, range);
                                },
                                // only for right side columns
                                get columns() {
                                    var _a;
                                    return (_a = column.visibleColumnsBySideWithRowHeader.R).slice.apply(_a, this.colRange);
                                },
                                get offsetLeft() {
                                    return columnCoords.offsets.R[this.colRange[0]];
                                },
                                get rowRange() {
                                    var range = calculateRange(this.scrollTop, dimension.bodyHeight, rowCoords.offsets, data, true);
                                    return getCachedRange(this.__storage__.rowRange, range);
                                },
                                get rows() {
                                    var _a;
                                    return (_a = data.filteredViewData).slice.apply(_a, this.rowRange);
                                },
                                get offsetTop() {
                                    return rowCoords.offsets[this.rowRange[0] - data.pageRowRange[0]];
                                },
                                get dummyRowCount() {
                                    var rowHeight = dimension.rowHeight, bodyHeight = dimension.bodyHeight, scrollXHeight = dimension.scrollXHeight, cellBorderWidth = dimension.cellBorderWidth;
                                    var totalRowHeight = rowCoords.totalRowHeight;
                                    var adjustedRowHeight = rowHeight + cellBorderWidth;
                                    var adjustedBodyHeight = bodyHeight - scrollXHeight;
                                    if (showDummyRows && totalRowHeight < adjustedBodyHeight) {
                                        return Math.ceil((adjustedBodyHeight - totalRowHeight) / adjustedRowHeight) + 1;
                                    }
                                    return 0;
                                },
                            });
                        }
                        exports.create = create;


                        /***/ }),
                    /* 75 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var observable_1 = __webpack_require__(5);
                        var common_1 = __webpack_require__(0);
                        function distributeExtraWidthEqually(extraWidth, targetIdxes, widths) {
                            var targetLen = targetIdxes.length;
                            var avgValue = Math.round(extraWidth / targetLen);
                            var errorValue = avgValue * targetLen - extraWidth; // to correct total width
                            var result = tslib_1.__spreadArrays(widths);
                            targetIdxes.forEach(function (idx) {
                                result[idx] += avgValue;
                            });
                            if (targetLen) {
                                result[targetIdxes[targetLen - 1]] -= errorValue;
                            }
                            return result;
                        }
                        function fillEmptyWidth(contentWidth, widths) {
                            var remainTotalWidth = contentWidth - common_1.sum(widths);
                            var emptyIndexes = common_1.findIndexes(function (width) { return !width; }, widths);
                            return distributeExtraWidthEqually(remainTotalWidth, emptyIndexes, widths);
                        }
                        function applyMinimumWidth(minWidths, widths) {
                            return widths.map(function (width, index) { return Math.max(width, minWidths[index]); });
                        }
                        function reduceExcessColumnWidthSub(totalRemainWidth, availableList, widths) {
                            var avgValue = Math.round(totalRemainWidth / availableList.length);
                            var newAvailableList = [];
                            availableList.forEach(function (_a) {
                                var index = _a[0], width = _a[1];
                                // note that totalRemainWidth and avgValue are negative number.
                                if (width < Math.abs(avgValue)) {
                                    totalRemainWidth += width;
                                    widths[index] -= width;
                                }
                                else {
                                    newAvailableList.push([index, width]);
                                }
                            });
                            // call recursively until all available width are less than average
                            if (availableList.length > newAvailableList.length) {
                                return reduceExcessColumnWidthSub(totalRemainWidth, newAvailableList, widths);
                            }
                            var columnIndexes = availableList.map(function (_a) {
                                var index = _a[0];
                                return index;
                            });
                            return distributeExtraWidthEqually(totalRemainWidth, columnIndexes, widths);
                        }
                        function adjustWidths(minWidths, fixedFlags, availableWidth, fitToReducedTotal, widths) {
                            var columnLength = widths.length;
                            var totalExtraWidth = availableWidth - common_1.sum(widths);
                            var fixedCount = fixedFlags.filter(Boolean).length;
                            var fixedIndexes = common_1.findIndexes(function (v) { return !v; }, fixedFlags);
                            if (totalExtraWidth > 0 && columnLength > fixedCount) {
                                return distributeExtraWidthEqually(totalExtraWidth, fixedIndexes, widths);
                            }
                            if (fitToReducedTotal && totalExtraWidth < 0) {
                                var availableWidthInfos = fixedIndexes.map(function (index) { return [index, widths[index] - minWidths[index]]; });
                                return reduceExcessColumnWidthSub(totalExtraWidth, availableWidthInfos, widths);
                            }
                            return widths;
                        }
                        function calculateWidths(columns, cellBorderWidth, contentsWidth) {
                            var baseWidths = columns.map(function (_a) {
                                var baseWidth = _a.baseWidth;
                                return (baseWidth ? baseWidth - cellBorderWidth : 0);
                            });
                            var minWidths = columns.map(function (_a) {
                                var minWidth = _a.minWidth;
                                return minWidth - cellBorderWidth;
                            });
                            var fixedFlags = common_1.mapProp('fixedWidth', columns);
                            return common_1.pipe(baseWidths, fillEmptyWidth.bind(null, contentsWidth), applyMinimumWidth.bind(null, minWidths), adjustWidths.bind(null, minWidths, fixedFlags, contentsWidth, true));
                        }
                        function calculateOffsets(widths, borderWidth) {
                            var offsets = [0];
                            for (var i = 1, len = widths.length; i < len; i += 1) {
                                offsets[i] = offsets[i - 1] + widths[i - 1] + borderWidth;
                            }
                            return offsets;
                        }
                        function create(_a) {
                            var column = _a.column, dimension = _a.dimension;
                            return observable_1.observable({
                                get widths() {
                                    var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader, visibleFrozenCount = column.visibleFrozenCount;
                                    var widths = calculateWidths(visibleColumnsWithRowHeader, dimension.cellBorderWidth, dimension.contentsWidth);
                                    return {
                                        L: widths.slice(0, visibleFrozenCount),
                                        R: widths.slice(visibleFrozenCount),
                                    };
                                },
                                get offsets() {
                                    return {
                                        L: calculateOffsets(this.widths.L, dimension.cellBorderWidth),
                                        R: calculateOffsets(this.widths.R, dimension.cellBorderWidth),
                                    };
                                },
                                get areaWidth() {
                                    var visibleFrozenCount = column.visibleFrozenCount;
                                    var width = dimension.width, frozenBorderWidth = dimension.frozenBorderWidth, cellBorderWidth = dimension.cellBorderWidth;
                                    var leftAreaWidth = 0;
                                    if (visibleFrozenCount) {
                                        var leftBorderWidth = (visibleFrozenCount + 1) * cellBorderWidth;
                                        leftAreaWidth = common_1.sum(this.widths.L) + leftBorderWidth;
                                    }
                                    return {
                                        L: leftAreaWidth - frozenBorderWidth,
                                        R: width - leftAreaWidth,
                                    };
                                },
                                get totalColumnWidth() {
                                    return {
                                        L: common_1.last(this.offsets.L) + common_1.last(this.widths.L),
                                        R: common_1.last(this.offsets.R) + common_1.last(this.widths.R),
                                    };
                                },
                            });
                        }
                        exports.create = create;


                        /***/ }),
                    /* 76 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = void 0;
                        var observable_1 = __webpack_require__(5);
                        var common_1 = __webpack_require__(0);
                        var data_1 = __webpack_require__(6);
                        function create(_a) {
                            var _b;
                            var data = _a.data, dimension = _a.dimension;
                            var rowHeight = dimension.rowHeight;
                            var pageOptions = data.pageOptions, pageRowRange = data.pageRowRange;
                            return observable_1.observable({
                                heights: pageOptions.useClient
                                    ? (_b = data.filteredRawData).slice.apply(_b, pageRowRange).map(function (row) { return data_1.getRowHeight(row, rowHeight); })
                                    : data.filteredRawData.map(function (row) { return data_1.getRowHeight(row, rowHeight); }),
                                get offsets() {
                                    var offsets = [0];
                                    var heights = this.heights;
                                    for (var i = 1, len = heights.length; i < len; i += 1) {
                                        offsets[i] = offsets[i - 1] + heights[i - 1];
                                    }
                                    return offsets;
                                },
                                get totalRowHeight() {
                                    return this.heights.length ? common_1.last(this.offsets) + common_1.last(this.heights) : 0;
                                },
                            });
                        }
                        exports.create = create;


                        /***/ }),
                    /* 77 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = void 0;
                        var observable_1 = __webpack_require__(5);
                        var common_1 = __webpack_require__(0);
                        var rowSpan_1 = __webpack_require__(11);
                        var data_1 = __webpack_require__(6);
                        function create(_a) {
                            var column = _a.column, data = _a.data, dimension = _a.dimension, rowCoords = _a.rowCoords, columnCoords = _a.columnCoords, editingEvent = _a.editingEvent, tabMode = _a.tabMode, id = _a.id;
                            return observable_1.observable({
                                rowKey: null,
                                columnName: null,
                                prevRowKey: null,
                                prevColumnName: null,
                                editingAddress: null,
                                editingEvent: editingEvent,
                                navigating: false,
                                forcedDestroyEditing: false,
                                tabMode: tabMode,
                                get side() {
                                    if (this.columnName === null) {
                                        return null;
                                    }
                                    return common_1.someProp('name', this.columnName, column.visibleColumnsBySideWithRowHeader.R)
                                        ? 'R'
                                        : 'L';
                                },
                                get columnIndex() {
                                    var _a = this, columnName = _a.columnName, side = _a.side;
                                    return columnName === null || side === null
                                        ? null
                                        : common_1.findPropIndex('name', columnName, column.visibleColumnsBySideWithRowHeader[side]);
                                },
                                get totalColumnIndex() {
                                    var visibleColumnsBySideWithRowHeader = column.visibleColumnsBySideWithRowHeader;
                                    var _a = this, columnIndex = _a.columnIndex, side = _a.side;
                                    if (columnIndex === null) {
                                        return columnIndex;
                                    }
                                    return side === 'R' ? columnIndex + visibleColumnsBySideWithRowHeader.L.length : columnIndex;
                                },
                                get rowIndex() {
                                    var rowKey = this.rowKey;
                                    if (common_1.isNull(rowKey)) {
                                        return null;
                                    }
                                    var index = data_1.findIndexByRowKey(data, column, id, rowKey);
                                    return data_1.isClientPagination(data) ? index - data.pageRowRange[0] : index;
                                },
                                get originalRowIndex() {
                                    var rowIndex = this.rowIndex;
                                    if (common_1.isNull(rowIndex)) {
                                        return null;
                                    }
                                    if (data_1.isClientPagination(data)) {
                                        return rowIndex + data.pageRowRange[0];
                                    }
                                    return rowIndex;
                                },
                                get cellPosRect() {
                                    var _a = this, columnIndex = _a.columnIndex, rowIndex = _a.rowIndex, side = _a.side, columnName = _a.columnName, rowKey = _a.rowKey;
                                    var filteredRawData = data.filteredRawData, sortState = data.sortState;
                                    var cellBorderWidth = dimension.cellBorderWidth;
                                    if (columnIndex === null || rowIndex === null || side === null || columnName === null) {
                                        return null;
                                    }
                                    var widths = columnCoords.widths, offsets = columnCoords.offsets;
                                    var borderWidth = widths[side].length - 1 === columnIndex ? 0 : cellBorderWidth;
                                    var left = offsets[side][columnIndex];
                                    var right = left + widths[side][columnIndex] + borderWidth;
                                    var top = rowCoords.offsets[rowIndex];
                                    var bottom = top + rowCoords.heights[rowIndex];
                                    var rowSpan = rowSpan_1.getRowSpanByRowKey(rowKey, columnName, filteredRawData);
                                    if (rowSpan_1.isRowSpanEnabled(sortState) && rowSpan) {
                                        var verticalPos = rowSpan_1.getVerticalPosWithRowSpan(columnName, rowSpan, rowCoords, filteredRawData);
                                        return { left: left, right: right, top: verticalPos[0], bottom: verticalPos[1] };
                                    }
                                    return { left: left, right: right, top: top, bottom: bottom };
                                },
                            });
                        }
                        exports.create = create;


                        /***/ }),
                    /* 78 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var observable_1 = __webpack_require__(5);
                        var selection_1 = __webpack_require__(19);
                        var data_1 = __webpack_require__(6);
                        function getOwnSideColumnRange(columnRange, side, visibleFrozenCount) {
                            var _a = columnRange.map(function (columnIdx) { return columnIdx; }), start = _a[0], end = _a[1];
                            if (side === 'L' && start < visibleFrozenCount) {
                                return [start, Math.min(end, visibleFrozenCount - 1)];
                            }
                            if (side === 'R' && end >= visibleFrozenCount) {
                                return [Math.max(start, visibleFrozenCount) - visibleFrozenCount, end - visibleFrozenCount];
                            }
                            return null;
                        }
                        function getVerticalStyles(rowRange, rowOffsets, rowHeights, cellBorderWidth) {
                            var top = rowOffsets[rowRange[0]];
                            var bottom = rowOffsets[rowRange[1]] + rowHeights[rowRange[1]];
                            return { top: top, height: bottom - top - cellBorderWidth };
                        }
                        function getHorizontalStyles(columnRange, columnWidths, side, cellBorderWidth) {
                            var left = 0;
                            var width = 0;
                            if (!columnRange) {
                                return { left: left, width: width };
                            }
                            var widths = columnWidths[side];
                            var startIndex = columnRange[0];
                            var endIndex = Math.min(columnRange[1], widths.length - 1);
                            for (var i = 0; i <= endIndex; i += 1) {
                                if (i < startIndex) {
                                    left += widths[i] + cellBorderWidth;
                                }
                                else {
                                    width += widths[i] + cellBorderWidth;
                                }
                            }
                            width -= cellBorderWidth;
                            if (side === 'R' && endIndex === widths.length - 1) {
                                width -= cellBorderWidth;
                            }
                            return { left: left, width: width };
                        }
                        function create(_a) {
                            var selectionUnit = _a.selectionUnit, rowCoords = _a.rowCoords, columnCoords = _a.columnCoords, columnInfo = _a.column, dimension = _a.dimension, data = _a.data;
                            return observable_1.observable({
                                inputRange: null,
                                unit: selectionUnit,
                                type: 'cell',
                                intervalIdForAutoScroll: null,
                                get range() {
                                    if (!this.inputRange) {
                                        return null;
                                    }
                                    var columnWidths = columnCoords.widths;
                                    var row = selection_1.getSortedRange(this.inputRange.row);
                                    var column = selection_1.getSortedRange(this.inputRange.column);
                                    if (this.unit === 'row') {
                                        var endColumnIndex = columnWidths.L.length + columnWidths.R.length - 1;
                                        column = [0, endColumnIndex];
                                    }
                                    return { row: row, column: column };
                                },
                                get rangeBySide() {
                                    if (!this.range) {
                                        return null;
                                    }
                                    var visibleFrozenCount = columnInfo.visibleFrozenCount;
                                    var _a = this.range, column = _a.column, row = _a.row;
                                    return {
                                        L: { row: row, column: getOwnSideColumnRange(column, 'L', visibleFrozenCount) },
                                        R: { row: row, column: getOwnSideColumnRange(column, 'R', visibleFrozenCount) },
                                    };
                                },
                                get rangeAreaInfo() {
                                    if (!this.rangeBySide) {
                                        return null;
                                    }
                                    var cellBorderWidth = dimension.cellBorderWidth;
                                    var rowOffsets = rowCoords.offsets, rowHeights = rowCoords.heights;
                                    var columnWidths = columnCoords.widths;
                                    var _a = this.rangeBySide, leftRange = _a.L, rightRange = _a.R;
                                    var leftSideStyles = null;
                                    var rightSideStyles = null;
                                    if (leftRange.column) {
                                        leftSideStyles = tslib_1.__assign(tslib_1.__assign({}, getVerticalStyles(leftRange.row, rowOffsets, rowHeights, cellBorderWidth)), getHorizontalStyles(leftRange.column, columnWidths, 'L', cellBorderWidth));
                                    }
                                    if (rightRange.column) {
                                        rightSideStyles = tslib_1.__assign(tslib_1.__assign({}, getVerticalStyles(rightRange.row, rowOffsets, rowHeights, cellBorderWidth)), getHorizontalStyles(rightRange.column, columnWidths, 'R', cellBorderWidth));
                                    }
                                    return {
                                        L: leftSideStyles,
                                        R: rightSideStyles,
                                    };
                                },
                                get rangeWithRowHeader() {
                                    if (!this.range) {
                                        return null;
                                    }
                                    var rowHeaderCount = columnInfo.rowHeaderCount;
                                    var _a = this.range, row = _a.row, column = _a.column;
                                    var columnStartIndex = Math.max(column[0] - rowHeaderCount, 0);
                                    var columnEndIndex = Math.max(column[1] - rowHeaderCount, 0);
                                    return {
                                        row: row,
                                        column: [columnStartIndex, columnEndIndex],
                                    };
                                },
                                get originalRange() {
                                    if (!this.range) {
                                        return null;
                                    }
                                    var pageOptions = data.pageOptions;
                                    var _a = this.range, row = _a.row, column = _a.column;
                                    if (data_1.isClientPagination(data)) {
                                        var perPage = pageOptions.perPage, page = pageOptions.page;
                                        var prevPageRowCount = perPage * (page - 1);
                                        return {
                                            row: [row[0] + prevPageRowCount, row[1] + prevPageRowCount],
                                            column: column,
                                        };
                                    }
                                    return this.range;
                                },
                            });
                        }
                        exports.create = create;


                        /***/ }),
                    /* 79 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = void 0;
                        var observable_1 = __webpack_require__(5);
                        function create() {
                            return observable_1.observable({ hoveredRowKey: null, cellHeightMap: {} });
                        }
                        exports.create = create;


                        /***/ }),
                    /* 80 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.create = void 0;
                        var observable_1 = __webpack_require__(5);
                        function create() {
                            return observable_1.observable({ activeColumnAddress: null, activeFilterState: null });
                        }
                        exports.create = create;


                        /***/ }),
                    /* 81 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.Root = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var container_1 = __webpack_require__(82);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var eventBus_1 = __webpack_require__(8);
                        var Root = /** @class */ (function (_super) {
                            tslib_1.__extends(Root, _super);
                            function Root() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            Root.prototype.getChildContext = function () {
                                return {
                                    store: this.props.store,
                                    dispatch: this.props.dispatch,
                                };
                            };
                            Root.prototype.componentDidMount = function () {
                                var eventBus = eventBus_1.getEventBus(this.props.store.id);
                                var gridEvent = new gridEvent_1.default();
                                setTimeout(function () {
                                    /**
                                     * Occurs when the grid is mounted on DOM
                                     * @event Grid#onGridMounted
                                     * @property {Grid} instance - Current grid instance
                                     */
                                    eventBus.trigger('onGridMounted', gridEvent);
                                });
                            };
                            Root.prototype.componentWillUnmount = function () {
                                var eventBus = eventBus_1.getEventBus(this.props.store.id);
                                var gridEvent = new gridEvent_1.default();
                                /**
                                 * Occurs before the grid is detached from DOM
                                 * @event Grid#onGridBeforeDestroy
                                 * @property {Grid} instance - Current grid instance
                                 */
                                eventBus.trigger('onGridBeforeDestroy', gridEvent);
                            };
                            Root.prototype.render = function () {
                                return preact_1.h(container_1.Container, { rootElement: this.props.rootElement });
                            };
                            return Root;
                        }(preact_1.Component));
                        exports.Root = Root;


                        /***/ }),
                    /* 82 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.Container = exports.ContainerComp = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var leftSide_1 = __webpack_require__(83);
                        var rightSide_1 = __webpack_require__(101);
                        var stateLayer_1 = __webpack_require__(102);
                        var filterLayer_1 = __webpack_require__(103);
                        var heightResizeHandle_1 = __webpack_require__(109);
                        var clipboard_1 = __webpack_require__(110);
                        var pagination_1 = __webpack_require__(111);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var eventBus_1 = __webpack_require__(8);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var browser_1 = __webpack_require__(50);
                        var common_1 = __webpack_require__(0);
                        var keyboard_1 = __webpack_require__(17);
                        var DOUBLE_TAP_DURATION = 200;
                        var TAP_THRESHOLD = 10;
                        var ContainerComp = /** @class */ (function (_super) {
                            tslib_1.__extends(ContainerComp, _super);
                            function ContainerComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.touchEvent = {
                                    start: false,
                                    move: false,
                                    eventInfo: {
                                        pageX: -1,
                                        pageY: -1,
                                        timestamp: 0,
                                    },
                                };
                                _this.handleTouchStart = function () {
                                    if (!_this.el || !browser_1.isMobile()) {
                                        return;
                                    }
                                    _this.touchEvent.start = true;
                                };
                                _this.handleTouchMove = function () {
                                    if (!_this.el || !browser_1.isMobile() || !_this.touchEvent.start) {
                                        return;
                                    }
                                    _this.touchEvent.move = true;
                                };
                                _this.getCellRowKey = function (elem) {
                                    var address = dom_1.getCellAddress(elem);
                                    if (address) {
                                        return address.rowKey;
                                    }
                                    return null;
                                };
                                _this.handleTouchEnd = function (event) {
                                    if (!_this.el || !browser_1.isMobile()) {
                                        return;
                                    }
                                    var timeStamp = event.timeStamp;
                                    var _a = event.changedTouches[0], pageX = _a.pageX, pageY = _a.pageY;
                                    var _b = _this.touchEvent, eventInfo = _b.eventInfo, start = _b.start, move = _b.move;
                                    if (start && !move) {
                                        var prevPageX = eventInfo.pageX, prevPageY = eventInfo.pageY, prevTimestamp = eventInfo.timestamp;
                                        if (timeStamp - prevTimestamp <= DOUBLE_TAP_DURATION) {
                                            if (Math.abs(prevPageX - pageX) <= TAP_THRESHOLD &&
                                                Math.abs(prevPageY - pageY) <= TAP_THRESHOLD) {
                                                _this.startEditing(event.target);
                                            }
                                        }
                                        else {
                                            eventInfo.pageX = pageX;
                                            eventInfo.pageY = pageY;
                                            eventInfo.timestamp = timeStamp;
                                        }
                                    }
                                    _this.touchEvent.start = false;
                                    _this.touchEvent.move = false;
                                };
                                _this.handleMouseover = function (event) {
                                    var _a = _this.props, eventBus = _a.eventBus, dispatch = _a.dispatch, renderState = _a.renderState;
                                    var hoveredRowKey = renderState.hoveredRowKey;
                                    var gridEvent = new gridEvent_1.default({ event: event });
                                    var rowKey = _this.getCellRowKey(event.target);
                                    if (!common_1.isNull(rowKey)) {
                                        if (hoveredRowKey !== rowKey) {
                                            dispatch('setHoveredRowKey', rowKey);
                                        }
                                    }
                                    /**
                                     * Occurs when a mouse pointer is moved onto the Grid.
                                     * The properties of the event object include the native MouseEvent object.
                                     * @event Grid#mouseover
                                     * @property {Event} nativeEvent - Event object
                                     * @property {string} targetType - Type of event target
                                     * @property {number} rowKey - rowKey of the target cell
                                     * @property {string} columnName - columnName of the target cell
                                     * @property {Grid} instance - Current grid instance
                                     */
                                    eventBus.trigger('mouseover', gridEvent);
                                };
                                _this.handleClick = function (event) {
                                    var _a = _this.props, eventBus = _a.eventBus, editingEvent = _a.editingEvent;
                                    var gridEvent = new gridEvent_1.default({ event: event });
                                    /**
                                     * Occurs when a mouse button is clicked on the Grid.
                                     * The properties of the event object include the native event object.
                                     * @event Grid#click
                                     * @property {Event} nativeEvent - Event object
                                     * @property {string} targetType - Type of event target
                                     * @property {number} rowKey - rowKey of the target cell
                                     * @property {string} columnName - columnName of the target cell
                                     * @property {Grid} instance - Current grid instance
                                     */
                                    eventBus.trigger('click', gridEvent);
                                    if (!gridEvent.isStopped() && editingEvent === 'click') {
                                        _this.startEditing(event.target);
                                    }
                                };
                                _this.handleMouseout = function (event) {
                                    var _a = _this.props, eventBus = _a.eventBus, dispatch = _a.dispatch, renderState = _a.renderState;
                                    var hoveredRowKey = renderState.hoveredRowKey;
                                    var gridEvent = new gridEvent_1.default({ event: event });
                                    if (!common_1.isNull(hoveredRowKey)) {
                                        dispatch('setHoveredRowKey', null);
                                    }
                                    /**
                                     * Occurs when a mouse pointer is moved off from the Grid.
                                     * The event object has all properties copied from the native MouseEvent.
                                     * @event Grid#mouseout
                                     * @property {Event} nativeEvent - Event object
                                     * @property {string} targetType - Type of event target
                                     * @property {number | string} rowKey - rowKey of the target cell
                                     * @property {string} columnName - columnName of the target cell
                                     * @property {Grid} instance - Current grid instance
                                     */
                                    eventBus.trigger('mouseout', gridEvent);
                                };
                                _this.handleMouseDown = function (event) {
                                    if (!_this.el) {
                                        return;
                                    }
                                    var _a = _this.props, dispatch = _a.dispatch, editing = _a.editing, eventBus = _a.eventBus, filtering = _a.filtering;
                                    var el = _this.el;
                                    var gridEvent = new gridEvent_1.default({ event: event });
                                    /**
                                     * Occurs when a mouse button is downed on the Grid.
                                     * The event object has all properties copied from the native MouseEvent.
                                     * @event Grid#mousedown
                                     * @property {Event} nativeEvent - Event object
                                     * @property {string} targetType - Type of event target
                                     * @property {number | string} rowKey - rowKey of the target cell
                                     * @property {string} columnName - columnName of the target cell
                                     * @property {Grid} instance - Current grid instance
                                     */
                                    eventBus.trigger('mousedown', gridEvent);
                                    if (!gridEvent.isStopped()) {
                                        dispatch('setNavigating', true);
                                        if (!editing && !filtering) {
                                            event.preventDefault();
                                        }
                                        var _b = el.getBoundingClientRect(), top = _b.top, left = _b.left;
                                        dispatch('setOffsetTop', top + el.scrollTop);
                                        dispatch('setOffsetLeft', left + el.scrollLeft);
                                    }
                                };
                                _this.handleDblClick = function (event) {
                                    if (!_this.el || browser_1.isMobile()) {
                                        return;
                                    }
                                    var _a = _this.props, eventBus = _a.eventBus, editingEvent = _a.editingEvent;
                                    var gridEvent = new gridEvent_1.default({ event: event });
                                    /**
                                     * Occurs when a mouse button is double clicked on the Grid.
                                     * The properties of the event object include the native event object.
                                     * @event Grid#dblclick
                                     * @property {Event} nativeEvent - Event object
                                     * @property {string} targetType - Type of event target
                                     * @property {number} rowKey - rowKey of the target cell
                                     * @property {string} columnName - columnName of the target cell
                                     * @property {Grid} instance - Current grid instance
                                     */
                                    eventBus.trigger('dblclick', gridEvent);
                                    if (!gridEvent.isStopped() && editingEvent === 'dblclick') {
                                        _this.startEditing(event.target);
                                    }
                                };
                                _this.handleDocumentKeyDown = function (ev) {
                                    var keyName = keyboard_1.keyNameMap[ev.keyCode];
                                    if (keyName === 'esc') {
                                        _this.props.dispatch('setActiveColumnAddress', null);
                                    }
                                };
                                _this.handleDocumentMouseDown = function (ev) {
                                    var _a = _this.props, dispatch = _a.dispatch, filtering = _a.filtering;
                                    if (filtering) {
                                        var target = ev.target;
                                        if (!dom_1.findParent(target, 'btn-filter') && !dom_1.findParent(target, 'filter-container')) {
                                            dispatch('setActiveColumnAddress', null);
                                        }
                                    }
                                };
                                _this.syncWithDOMWidth = function () {
                                    _this.props.dispatch('refreshLayout', _this.el, _this.props.rootElement.parentElement);
                                };
                                return _this;
                            }
                            ContainerComp.prototype.startEditing = function (eventTarget) {
                                var _a = this.props, dispatch = _a.dispatch, focusedRowKey = _a.focusedRowKey, focusedColumnName = _a.focusedColumnName;
                                var address = dom_1.getCellAddress(eventTarget);
                                if (address) {
                                    var rowKey = address.rowKey, columnName = address.columnName;
                                    if (focusedRowKey === rowKey && focusedColumnName === columnName) {
                                        dispatch('startEditing', rowKey, columnName);
                                    }
                                }
                            };
                            ContainerComp.prototype.componentDidMount = function () {
                                if (this.props.autoWidth) {
                                    window.addEventListener('resize', this.syncWithDOMWidth);
                                    // In Preact, the componentDidMount is called before the DOM elements are actually mounted.
                                    // https://github.com/preactjs/preact/issues/648
                                    // Use setTimeout to wait until the DOM element is actually mounted
                                    window.setTimeout(this.syncWithDOMWidth, 0);
                                }
                                document.addEventListener('mousedown', this.handleDocumentMouseDown);
                                document.addEventListener('keydown', this.handleDocumentKeyDown);
                            };
                            ContainerComp.prototype.componentWillUnmount = function () {
                                if (this.props.autoWidth) {
                                    window.removeEventListener('resize', this.syncWithDOMWidth);
                                }
                            };
                            ContainerComp.prototype.shouldComponentUpdate = function (nextProps) {
                                if (this.props.autoWidth && nextProps.autoWidth) {
                                    return false;
                                }
                                return true;
                            };
                            ContainerComp.prototype.render = function () {
                                var _a;
                                var _this = this;
                                var _b = this.props, summaryHeight = _b.summaryHeight, summaryPosition = _b.summaryPosition, heightResizable = _b.heightResizable, gridId = _b.gridId, width = _b.width, autoWidth = _b.autoWidth, scrollXHeight = _b.scrollXHeight, showLeftSide = _b.showLeftSide, scrollX = _b.scrollX, scrollY = _b.scrollY, pageOptions = _b.pageOptions;
                                var style = { width: autoWidth ? '100%' : width };
                                var attrs = (_a = {}, _a[dom_1.dataAttr.GRID_ID] = gridId, _a);
                                return (preact_1.h("div", tslib_1.__assign({}, attrs, { style: style, class: dom_1.cls('container', [showLeftSide, 'show-lside-area']), onMouseDown: this.handleMouseDown, onDblClick: this.handleDblClick, onClick: this.handleClick, onMouseOut: this.handleMouseout, onMouseOver: this.handleMouseover, onTouchStart: this.handleTouchStart, onTouchMove: this.handleTouchMove, onTouchEnd: this.handleTouchEnd, ref: function (el) {
                                            _this.el = el;
                                        } }),
                                    pageOptions.position === 'top' && preact_1.h(pagination_1.Pagination, null),
                                    preact_1.h("div", { class: dom_1.cls('content-area', [!!summaryHeight, summaryPosition === 'top' ? 'has-summary-top' : 'has-summary-bottom'], [!scrollX, 'no-scroll-x'], [!scrollY, 'no-scroll-y']) },
                                        preact_1.h(leftSide_1.LeftSide, null),
                                        preact_1.h(rightSide_1.RightSide, null),
                                        preact_1.h("div", { class: dom_1.cls('border-line', 'border-line-top') }),
                                        preact_1.h("div", { class: dom_1.cls('border-line', 'border-line-left') }),
                                        preact_1.h("div", { class: dom_1.cls('border-line', 'border-line-right') }),
                                        preact_1.h("div", { class: dom_1.cls('border-line', 'border-line-bottom'), style: { bottom: scrollXHeight } })),
                                    heightResizable && preact_1.h(heightResizeHandle_1.HeightResizeHandle, null),
                                    preact_1.h(stateLayer_1.StateLayer, null),
                                    preact_1.h(clipboard_1.Clipboard, null),
                                    pageOptions.position === 'bottom' && preact_1.h(pagination_1.Pagination, null),
                                    preact_1.h(filterLayer_1.FilterLayer, null)));
                            };
                            return ContainerComp;
                        }(preact_1.Component));
                        exports.ContainerComp = ContainerComp;
                        exports.Container = hoc_1.connect(function (_a) {
                            var id = _a.id, dimension = _a.dimension, focus = _a.focus, columnCoords = _a.columnCoords, data = _a.data, filterLayerState = _a.filterLayerState, renderState = _a.renderState;
                            return ({
                                gridId: id,
                                width: dimension.width,
                                autoWidth: dimension.autoWidth,
                                editing: !!focus.editingAddress,
                                filtering: !!filterLayerState.activeColumnAddress,
                                scrollXHeight: dimension.scrollX ? dimension.scrollbarWidth : 0,
                                fitToParentHeight: dimension.fitToParentHeight,
                                summaryHeight: dimension.summaryHeight,
                                summaryPosition: dimension.summaryPosition,
                                heightResizable: dimension.heightResizable,
                                showLeftSide: !!columnCoords.areaWidth.L,
                                editingEvent: focus.editingEvent,
                                viewData: data.viewData,
                                pageOptions: data.pageOptions,
                                eventBus: eventBus_1.getEventBus(id),
                                scrollX: dimension.scrollX,
                                scrollY: dimension.scrollY,
                                renderState: renderState,
                                focusedRowKey: focus.rowKey,
                                focusedColumnName: focus.columnName,
                            });
                        })(ContainerComp);


                        /***/ }),
                    /* 83 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.LeftSide = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var headerArea_1 = __webpack_require__(46);
                        var bodyArea_1 = __webpack_require__(48);
                        var summaryArea_1 = __webpack_require__(49);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var LeftSideComp = /** @class */ (function (_super) {
                            tslib_1.__extends(LeftSideComp, _super);
                            function LeftSideComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            LeftSideComp.prototype.render = function (_a) {
                                var width = _a.width, scrollX = _a.scrollX;
                                var style = { width: width, display: 'block' };
                                var summaryPosition = this.props.summaryPosition;
                                return (preact_1.h("div", { class: dom_1.cls('lside-area'), style: style },
                                    preact_1.h(headerArea_1.HeaderArea, { side: "L" }),
                                    summaryPosition === 'top' && preact_1.h(summaryArea_1.SummaryArea, { side: "L" }),
                                    preact_1.h(bodyArea_1.BodyArea, { side: "L" }),
                                    summaryPosition === 'bottom' && preact_1.h(summaryArea_1.SummaryArea, { side: "L" }),
                                    scrollX && preact_1.h("div", { class: dom_1.cls('scrollbar-left-bottom') })));
                            };
                            return LeftSideComp;
                        }(preact_1.Component));
                        exports.LeftSide = hoc_1.connect(function (_a) {
                            var columnCoords = _a.columnCoords, dimension = _a.dimension;
                            return ({
                                width: columnCoords.areaWidth.L,
                                scrollX: dimension.scrollX,
                                summaryPosition: dimension.summaryPosition,
                            });
                        })(LeftSideComp);


                        /***/ }),
                    /* 84 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.ColumnResizer = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var common_1 = __webpack_require__(0);
                        var column_1 = __webpack_require__(12);
                        var WIDTH = 7;
                        var HALF_WIDTH = 3;
                        var ColumnResizerComp = /** @class */ (function (_super) {
                            tslib_1.__extends(ColumnResizerComp, _super);
                            function ColumnResizerComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.dragStartX = -1;
                                _this.draggingRange = [-1, -1];
                                _this.draggingWidths = [];
                                _this.handleMouseDown = function (ev, name) {
                                    var range = _this.getComplexHeaderRange(name);
                                    _this.draggingRange = range;
                                    _this.dragStartX = ev.pageX;
                                    _this.draggingWidths = _this.props.widths.slice(range[0], range[1] + 1);
                                    dom_1.setCursorStyle('col-resize');
                                    document.addEventListener('mousemove', _this.handleMouseMove);
                                    document.addEventListener('mouseup', _this.clearDocumentEvents);
                                    document.addEventListener('selectstart', _this.handleSelectStart);
                                };
                                _this.handleSelectStart = function (ev) {
                                    ev.preventDefault();
                                };
                                _this.handleMouseMove = function (ev) {
                                    var _a = _this.props, side = _a.side, dispatch = _a.dispatch;
                                    var resizeAmount = ev.pageX - _this.dragStartX;
                                    dispatch('setColumnWidth', side, _this.draggingRange, resizeAmount, _this.draggingWidths);
                                };
                                _this.clearDocumentEvents = function () {
                                    dom_1.setCursorStyle('');
                                    document.removeEventListener('mousemove', _this.handleMouseMove);
                                    document.removeEventListener('mouseup', _this.clearDocumentEvents);
                                    document.removeEventListener('selectstart', _this.handleSelectStart);
                                };
                                return _this;
                            }
                            ColumnResizerComp.prototype.componentWillUnmount = function () {
                                this.clearDocumentEvents();
                            };
                            ColumnResizerComp.prototype.renderHandle = function (info, index) {
                                var _a;
                                var _this = this;
                                var name = info.name, height = info.height, offsetX = info.offsetX, offsetY = info.offsetY, width = info.width, header = info.header;
                                var attrs = (_a = {},
                                    _a[dom_1.dataAttr.COLUMN_INDEX] = index,
                                    _a[dom_1.dataAttr.COLUMN_NAME] = name,
                                    _a);
                                return (preact_1.h("div", tslib_1.__assign({ class: dom_1.cls('column-resize-handle'), title: header }, attrs, { style: {
                                        height: height,
                                        width: WIDTH,
                                        left: offsetX + width - HALF_WIDTH,
                                        bottom: offsetY,
                                    }, onMouseDown: function (ev) { return _this.handleMouseDown(ev, name); } })));
                            };
                            ColumnResizerComp.prototype.isHideChildColumns = function (name) {
                                return common_1.some(function (item) { return common_1.includes(item.childNames, name) && !!item.hideChildHeaders; }, this.props.complexColumns);
                            };
                            ColumnResizerComp.prototype.findComplexColumnStartIndex = function (name) {
                                var _a = this.props, columns = _a.columns, complexColumns = _a.complexColumns, allColumnMap = _a.allColumnMap;
                                var idx = common_1.findPropIndex('name', name, columns);
                                if (idx === -1 && !allColumnMap[name].hidden) {
                                    var complexColumn = common_1.findProp('name', name, complexColumns);
                                    return this.findComplexColumnStartIndex(complexColumn.childNames[0]);
                                }
                                return idx;
                            };
                            ColumnResizerComp.prototype.findComplexColumnEndIndex = function (name) {
                                var _a = this.props, columns = _a.columns, complexColumns = _a.complexColumns, allColumnMap = _a.allColumnMap;
                                var idx = common_1.findPropIndex('name', name, columns);
                                if (idx === -1 && !allColumnMap[name].hidden) {
                                    var childNames = common_1.findProp('name', name, complexColumns).childNames;
                                    return this.findComplexColumnEndIndex(childNames[childNames.length - 1]);
                                }
                                return idx;
                            };
                            ColumnResizerComp.prototype.getComplexHeaderRange = function (name) {
                                var _this = this;
                                var _a = this.props, columns = _a.columns, complexColumns = _a.complexColumns;
                                var index = common_1.findPropIndex('name', name, columns);
                                if (index === -1) {
                                    var startIndex_1 = Number.MAX_VALUE;
                                    var endIndex_1 = Number.MIN_VALUE;
                                    var childNames = common_1.findProp('name', name, complexColumns).childNames;
                                    childNames.forEach(function (childName) {
                                        startIndex_1 = Math.min(startIndex_1, _this.findComplexColumnStartIndex(childName));
                                        endIndex_1 = Math.max(startIndex_1, _this.findComplexColumnEndIndex(childName));
                                    });
                                    return [startIndex_1, endIndex_1];
                                }
                                return [index, index];
                            };
                            ColumnResizerComp.prototype.getResizerCoords = function (name) {
                                var _a = this.props, offsets = _a.offsets, widths = _a.widths, columns = _a.columns, cellBorderWidth = _a.cellBorderWidth, complexColumns = _a.complexColumns;
                                var _b = this.getComplexHeaderRange(name), startIndex = _b[0], endIndex = _b[1];
                                var count = column_1.getChildHeaderCount(columns, complexColumns, name);
                                var cellBorder = count ? count * cellBorderWidth : cellBorderWidth;
                                return {
                                    width: common_1.sum(widths.slice(startIndex, endIndex + 1)),
                                    offsetX: offsets[startIndex] + cellBorder,
                                };
                            };
                            ColumnResizerComp.prototype.getResizableColumnsInfo = function () {
                                var _this = this;
                                var _a = this.props, columns = _a.columns, complexColumns = _a.complexColumns, headerHeight = _a.headerHeight;
                                var hierarchies = column_1.getComplexColumnsHierarchy(columns, complexColumns);
                                var maxLen = column_1.getHierarchyMaxRowCount(hierarchies);
                                var defaultHeight = headerHeight / maxLen;
                                var nameMap = {};
                                var resizerInfo = [];
                                hierarchies.forEach(function (cols) {
                                    var len = cols.length;
                                    var offsetY = headerHeight;
                                    cols.forEach(function (col, idx) {
                                        var resizable = col.resizable, name = col.name, header = col.header;
                                        var height = idx === len - 1 ? defaultHeight * (maxLen - len + 1) : defaultHeight;
                                        offsetY -= height;
                                        if (resizable && !_this.isHideChildColumns(name) && !nameMap[name]) {
                                            resizerInfo.push(tslib_1.__assign({ name: name,
                                                header: header,
                                                height: height,
                                                offsetY: offsetY }, _this.getResizerCoords(name)));
                                            nameMap[name] = true;
                                        }
                                    });
                                });
                                return resizerInfo;
                            };
                            ColumnResizerComp.prototype.render = function () {
                                var _this = this;
                                return (preact_1.h("div", { class: dom_1.cls('column-resize-container'), style: "display: block; margin-top: -35px; height: 35px;" }, this.getResizableColumnsInfo().map(function (info, index) { return _this.renderHandle(info, index); })));
                            };
                            return ColumnResizerComp;
                        }(preact_1.Component));
                        exports.ColumnResizer = hoc_1.connect(function (_a, _b) {
                            var column = _a.column, columnCoords = _a.columnCoords, dimension = _a.dimension;
                            var side = _b.side;
                            return ({
                                widths: columnCoords.widths[side],
                                offsets: columnCoords.offsets[side],
                                headerHeight: dimension.headerHeight,
                                cellBorderWidth: dimension.cellBorderWidth,
                                columns: column.visibleColumnsBySideWithRowHeader[side],
                                complexColumns: column.complexColumnHeaders,
                                allColumnMap: column.allColumnMap,
                            });
                        })(ColumnResizerComp);


                        /***/ }),
                    /* 85 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.ComplexHeader = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var selection_1 = __webpack_require__(19);
                        var columnHeader_1 = __webpack_require__(47);
                        var column_1 = __webpack_require__(12);
                        var ComplexHeaderComp = /** @class */ (function (_super) {
                            tslib_1.__extends(ComplexHeaderComp, _super);
                            function ComplexHeaderComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            ComplexHeaderComp.prototype.isSelected = function (name) {
                                var _a = this.props, columnSelectionRange = _a.columnSelectionRange, columns = _a.columns, complexColumnHeaders = _a.complexColumnHeaders;
                                if (!columnSelectionRange) {
                                    return false;
                                }
                                var selectionStart = columnSelectionRange[0], selectionEnd = columnSelectionRange[1];
                                var _b = selection_1.getChildColumnRange(columns, complexColumnHeaders, name), columnStart = _b[0], columnEnd = _b[1];
                                return (columnStart >= selectionStart &&
                                    columnStart <= selectionEnd &&
                                    columnEnd >= selectionStart &&
                                    columnEnd <= selectionEnd);
                            };
                            ComplexHeaderComp.prototype.createTableHeaderComponent = function (column, height, colspan, rowspan) {
                                var name = column.name;
                                return (preact_1.h(columnHeader_1.ColumnHeader, { key: name, height: height, colspan: colspan, rowspan: rowspan, columnInfo: column, selected: this.isSelected(name), grid: this.props.grid }));
                            };
                            ComplexHeaderComp.prototype.render = function () {
                                var _this = this;
                                var _a = this.props, columns = _a.columns, headerHeight = _a.headerHeight, cellBorderWidth = _a.cellBorderWidth, complexColumnHeaders = _a.complexColumnHeaders;
                                var hierarchies = column_1.getComplexColumnsHierarchy(columns, complexColumnHeaders);
                                var maxRowCount = column_1.getHierarchyMaxRowCount(hierarchies);
                                var rows = new Array(maxRowCount);
                                var columnNames = new Array(maxRowCount);
                                var colspans = [];
                                var rowHeight = (maxRowCount ? Math.floor((headerHeight - 1) / maxRowCount) : 0) - 1;
                                var rowspan = 1;
                                var height;
                                hierarchies.forEach(function (hierarchy, i) {
                                    var length = hierarchies[i].length;
                                    var curHeight = 0;
                                    hierarchy.forEach(function (column, j) {
                                        var columnName = column.name;
                                        rowspan = length - 1 === j && maxRowCount - length + 1 > 1 ? maxRowCount - length + 1 : 1;
                                        height = rowHeight * rowspan;
                                        if (j === length - 1) {
                                            height = headerHeight - curHeight - cellBorderWidth;
                                        }
                                        else {
                                            curHeight += height + cellBorderWidth;
                                        }
                                        if (columnNames[j] === columnName) {
                                            rows[j].pop();
                                            colspans[j] += 1;
                                        }
                                        else {
                                            colspans[j] = 1;
                                        }
                                        columnNames[j] = columnName;
                                        rows[j] = rows[j] || [];
                                        rows[j].push(_this.createTableHeaderComponent(column, height + cellBorderWidth, colspans[j], rowspan));
                                    });
                                });
                                return (preact_1.h("tbody", null, rows.map(function (row, index) { return (preact_1.h("tr", { key: "complex-header-" + index }, row)); })));
                            };
                            return ComplexHeaderComp;
                        }(preact_1.Component));
                        exports.ComplexHeader = hoc_1.connect(function (store, _a) {
                            var side = _a.side;
                            var _b = store.column, rowHeaderCount = _b.rowHeaderCount, visibleColumnsBySideWithRowHeader = _b.visibleColumnsBySideWithRowHeader, complexColumnHeaders = _b.complexColumnHeaders, _c = store.dimension, headerHeight = _c.headerHeight, cellBorderWidth = _c.cellBorderWidth, rangeBySide = store.selection.rangeBySide;
                            return {
                                headerHeight: headerHeight,
                                cellBorderWidth: cellBorderWidth,
                                columns: visibleColumnsBySideWithRowHeader[side],
                                complexColumnHeaders: complexColumnHeaders,
                                columnSelectionRange: rangeBySide && rangeBySide[side].column ? rangeBySide[side].column : null,
                                rowHeaderCount: rowHeaderCount,
                            };
                        })(ComplexHeaderComp);


                        /***/ }),
                    /* 86 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.HeaderCheckbox = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var HeaderCheckboxComp = /** @class */ (function (_super) {
                            tslib_1.__extends(HeaderCheckboxComp, _super);
                            function HeaderCheckboxComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.handleChange = function (ev) {
                                    var target = ev.target;
                                    var dispatch = _this.props.dispatch;
                                    if (target.checked) {
                                        dispatch('checkAll', false);
                                    }
                                    else {
                                        dispatch('uncheckAll', false);
                                    }
                                };
                                return _this;
                            }
                            HeaderCheckboxComp.prototype.componentDidMount = function () {
                                this.setCheckboxState();
                            };
                            HeaderCheckboxComp.prototype.componentDidUpdate = function () {
                                this.setCheckboxState();
                            };
                            HeaderCheckboxComp.prototype.setCheckboxState = function () {
                                var _a = this.props, checkedAllRows = _a.checkedAllRows, disabled = _a.disabled;
                                var input = this.el.querySelector('input[name=_checked]');
                                if (input) {
                                    input.checked = checkedAllRows;
                                    input.disabled = disabled;
                                }
                            };
                            HeaderCheckboxComp.prototype.render = function () {
                                var _this = this;
                                return (preact_1.h("span", { ref: function (el) {
                                        _this.el = el;
                                    }, dangerouslySetInnerHTML: { __html: this.props.header }, onChange: this.handleChange }));
                            };
                            return HeaderCheckboxComp;
                        }(preact_1.Component));
                        exports.HeaderCheckbox = hoc_1.connect(function (store) {
                            var _a = store.data, checkedAllRows = _a.checkedAllRows, disabledAllCheckbox = _a.disabledAllCheckbox, allColumnMap = store.column.allColumnMap;
                            return {
                                header: allColumnMap._checked.header,
                                checkedAllRows: checkedAllRows,
                                disabled: disabledAllCheckbox,
                            };
                        })(HeaderCheckboxComp);


                        /***/ }),
                    /* 87 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.SortingButton = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var instance_1 = __webpack_require__(7);
                        var common_1 = __webpack_require__(0);
                        var SortingButtonComp = /** @class */ (function (_super) {
                            tslib_1.__extends(SortingButtonComp, _super);
                            function SortingButtonComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.handleClick = function (ev) {
                                    var target = ev.target;
                                    var multiple = ev.ctrlKey || ev.metaKey;
                                    if (!dom_1.hasClass(target, 'btn-sorting')) {
                                        return;
                                    }
                                    var _a = _this.props, dispatch = _a.dispatch, sortState = _a.sortState, dataProvider = _a.dataProvider, defaultAscending = _a.defaultAscending;
                                    var columns = sortState.columns;
                                    var th = dom_1.findParent(target, 'cell');
                                    var columnName = th.getAttribute('data-column-name');
                                    var index = common_1.findPropIndex('columnName', columnName, columns);
                                    var ascending = index !== -1 ? !columns[index].ascending : defaultAscending;
                                    if (sortState.useClient) {
                                        dispatch('sort', columnName, ascending, multiple);
                                    }
                                    else {
                                        // @TODO: apply multi sort to dataSource
                                        dataProvider.sort(columnName, ascending, true);
                                    }
                                };
                                return _this;
                            }
                            SortingButtonComp.prototype.render = function () {
                                var _a = this.props, active = _a.active, ascending = _a.ascending;
                                return (preact_1.h("a", { class: dom_1.cls('btn-sorting', [active, ascending ? 'btn-sorting-up' : 'btn-sorting-down']), onClick: this.handleClick }));
                            };
                            return SortingButtonComp;
                        }(preact_1.Component));
                        exports.SortingButton = hoc_1.connect(function (store, props) {
                            var sortState = store.data.sortState, id = store.id;
                            var columnName = props.columnName, _a = props.sortingType, sortingType = _a === void 0 ? 'asc' : _a;
                            var columns = sortState.columns;
                            var index = common_1.findPropIndex('columnName', columnName, columns);
                            var ascending = index !== -1 ? columns[index].ascending : true;
                            return {
                                sortState: sortState,
                                ascending: ascending,
                                dataProvider: instance_1.getDataProvider(id),
                                defaultAscending: sortingType === 'asc',
                                active: index !== -1,
                            };
                        })(SortingButtonComp);


                        /***/ }),
                    /* 88 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.SortingOrder = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var common_1 = __webpack_require__(0);
                        var SortingOrderComp = /** @class */ (function (_super) {
                            tslib_1.__extends(SortingOrderComp, _super);
                            function SortingOrderComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            SortingOrderComp.prototype.render = function () {
                                var _a = this.props, order = _a.order, showOrder = _a.showOrder;
                                return showOrder && preact_1.h("span", { style: { color: '#bbb', fontWeight: 100 } }, order);
                            };
                            return SortingOrderComp;
                        }(preact_1.Component));
                        exports.SortingOrder = hoc_1.connect(function (store, props) {
                            var columns = store.data.sortState.columns;
                            var columnName = props.columnName;
                            var order = common_1.findPropIndex('columnName', columnName, columns) + 1;
                            var showOrder = !!order && columns.length > 1;
                            return {
                                order: order,
                                showOrder: showOrder,
                            };
                        })(SortingOrderComp);


                        /***/ }),
                    /* 89 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.FilterButton = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var common_1 = __webpack_require__(0);
                        var DISTANCE_FROM_ICON_TO_LAYER = 9;
                        var FilterButtonComp = /** @class */ (function (_super) {
                            tslib_1.__extends(FilterButtonComp, _super);
                            function FilterButtonComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.isActiveFilter = function () {
                                    var _a = _this.props, filters = _a.filters, columnName = _a.columnName;
                                    return filters ? common_1.someProp('columnName', columnName, filters) : false;
                                };
                                _this.handleClick = function (ev) {
                                    var target = ev.target;
                                    if (!dom_1.hasClass(target, 'btn-filter')) {
                                        return;
                                    }
                                    var _a = _this.props, activeColumnAddress = _a.activeColumnAddress, columnName = _a.columnName, dispatch = _a.dispatch, offsetLeft = _a.offsetLeft;
                                    if (!activeColumnAddress || activeColumnAddress.name !== columnName) {
                                        var left = target.getBoundingClientRect().left - offsetLeft - DISTANCE_FROM_ICON_TO_LAYER;
                                        dispatch('setActiveColumnAddress', { name: columnName, left: left });
                                    }
                                };
                                return _this;
                            }
                            FilterButtonComp.prototype.render = function () {
                                return (preact_1.h("a", { class: dom_1.cls('btn-filter', [this.isActiveFilter(), 'btn-filter-active']), onClick: this.handleClick }));
                            };
                            return FilterButtonComp;
                        }(preact_1.Component));
                        exports.FilterButton = hoc_1.connect(function (store, _a) {
                            var columnName = _a.columnName;
                            return ({
                                activeColumnAddress: store.filterLayerState.activeColumnAddress,
                                filters: store.data.filters,
                                columnName: columnName,
                                offsetLeft: store.dimension.offsetLeft,
                            });
                        })(FilterButtonComp);


                        /***/ }),
                    /* 90 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.BodyRows = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var bodyRow_1 = __webpack_require__(91);
                        var bodyDummyRow_1 = __webpack_require__(95);
                        var common_1 = __webpack_require__(0);
                        var hoc_1 = __webpack_require__(4);
                        var BodyRowsComp = /** @class */ (function (_super) {
                            tslib_1.__extends(BodyRowsComp, _super);
                            function BodyRowsComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            BodyRowsComp.prototype.shouldComponentUpdate = function (nextProps) {
                                return !common_1.shallowEqual(nextProps, this.props);
                            };
                            BodyRowsComp.prototype.render = function (_a) {
                                var rows = _a.rows, rowIndexOffset = _a.rowIndexOffset, columns = _a.columns, dummyRowCount = _a.dummyRowCount;
                                var columnNames = columns.map(function (_a) {
                                    var name = _a.name;
                                    return name;
                                });
                                return (preact_1.h("tbody", null,
                                    rows.map(function (row, index) { return (preact_1.h(bodyRow_1.BodyRow, { key: row.uniqueKey, rowIndex: index + rowIndexOffset, viewRow: row, columns: columns })); }),
                                    common_1.range(dummyRowCount).map(function (index) { return (preact_1.h(bodyDummyRow_1.BodyDummyRow, { key: "dummy-" + index, index: rows.length + index, columnNames: columnNames })); })));
                            };
                            return BodyRowsComp;
                        }(preact_1.Component));
                        exports.BodyRows = hoc_1.connect(function (_a, _b) {
                            var viewport = _a.viewport, column = _a.column, data = _a.data;
                            var side = _b.side;
                            return ({
                                rowIndexOffset: viewport.rowRange[0] - data.pageRowRange[0],
                                rows: viewport.rows,
                                columns: side === 'L' ? column.visibleColumnsBySideWithRowHeader.L : viewport.columns,
                                dummyRowCount: viewport.dummyRowCount,
                            });
                        })(BodyRowsComp);


                        /***/ }),
                    /* 91 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.BodyRow = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var dom_1 = __webpack_require__(2);
                        var common_1 = __webpack_require__(0);
                        var rowSpanCell_1 = __webpack_require__(92);
                        var ROW_HEIGHT_DEBOUNCE_TIME = 10;
                        var BodyRowComp = /** @class */ (function (_super) {
                            tslib_1.__extends(BodyRowComp, _super);
                            function BodyRowComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                // This debounced function is aimed to wait until setTimeout(.., 0) calls
                                // from the all child BodyCell components is made.
                                // 10ms is just an approximate number. (smaller than 10ms might be safe enough)
                                _this.updateRowHeightDebounced = common_1.debounce(function () {
                                    var _a = _this.props, dispatch = _a.dispatch, rowIndex = _a.rowIndex, rowHeight = _a.rowHeight;
                                    dispatch('refreshRowHeight', rowIndex, rowHeight);
                                }, ROW_HEIGHT_DEBOUNCE_TIME);
                                return _this;
                            }
                            BodyRowComp.prototype.componentWillUnmount = function () {
                                var _a = this.props, rowIndex = _a.rowIndex, autoRowHeight = _a.autoRowHeight, dispatch = _a.dispatch;
                                if (autoRowHeight) {
                                    dispatch('removeCellHeight', rowIndex);
                                }
                            };
                            BodyRowComp.prototype.render = function (_a) {
                                var _this = this;
                                var rowIndex = _a.rowIndex, viewRow = _a.viewRow, columns = _a.columns, rowHeight = _a.rowHeight, autoRowHeight = _a.autoRowHeight, hoveredRowKey = _a.hoveredRowKey, focusedRowKey = _a.focusedRowKey;
                                var isOddRow = rowIndex % 2 === 0;
                                return (rowHeight > 0 && (preact_1.h("tr", { style: { height: rowHeight }, class: dom_1.cls([isOddRow, 'row-odd'], [!isOddRow, 'row-even'], [!common_1.isNull(hoveredRowKey) && hoveredRowKey === viewRow.rowKey, 'row-hover'], [!common_1.isNull(focusedRowKey) && focusedRowKey === viewRow.rowKey, 'cell-current-row']) }, columns.map(function (columnInfo) {
                                    // Pass row object directly instead of passing value of it only,
                                    // so that BodyCell component can watch the change of value using selector function.
                                    return (preact_1.h(rowSpanCell_1.RowSpanCell, { key: columnInfo.name, viewRow: viewRow, columnInfo: columnInfo, refreshRowHeight: autoRowHeight ? _this.updateRowHeightDebounced : null, rowIndex: rowIndex }));
                                }))));
                            };
                            return BodyRowComp;
                        }(preact_1.Component));
                        exports.BodyRow = hoc_1.connect(function (_a, _b) {
                            var rowCoords = _a.rowCoords, dimension = _a.dimension, renderState = _a.renderState, focus = _a.focus;
                            var rowIndex = _b.rowIndex;
                            return ({
                                rowHeight: rowCoords.heights[rowIndex],
                                autoRowHeight: dimension.autoRowHeight,
                                cellBorderWidth: dimension.cellBorderWidth,
                                hoveredRowKey: renderState.hoveredRowKey,
                                focusedRowKey: focus.rowKey,
                            });
                        })(BodyRowComp);


                        /***/ }),
                    /* 92 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.RowSpanCell = exports.RowSpanCellComp = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var bodyCell_1 = __webpack_require__(93);
                        var RowSpanCellComp = /** @class */ (function (_super) {
                            tslib_1.__extends(RowSpanCellComp, _super);
                            function RowSpanCellComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            RowSpanCellComp.prototype.render = function () {
                                var _a = this.props, columnInfo = _a.columnInfo, refreshRowHeight = _a.refreshRowHeight, rowSpan = _a.rowSpan, enableRowSpan = _a.enableRowSpan, viewRow = _a.viewRow, rowIndex = _a.rowIndex;
                                var rowSpanAttr = null;
                                if (enableRowSpan && rowSpan) {
                                    if (!rowSpan.mainRow) {
                                        return null;
                                    }
                                    rowSpanAttr = { rowSpan: rowSpan.spanCount };
                                }
                                return (preact_1.h(bodyCell_1.BodyCell, { viewRow: viewRow, columnInfo: columnInfo, refreshRowHeight: refreshRowHeight, rowSpanAttr: rowSpanAttr, rowIndex: rowIndex }));
                            };
                            return RowSpanCellComp;
                        }(preact_1.Component));
                        exports.RowSpanCellComp = RowSpanCellComp;
                        exports.RowSpanCell = hoc_1.connect(function (_a, _b) {
                            var data = _a.data;
                            var viewRow = _b.viewRow, columnInfo = _b.columnInfo;
                            var sortState = data.sortState;
                            var rowSpan = (viewRow.rowSpanMap && viewRow.rowSpanMap[columnInfo.name]) || null;
                            var enableRowSpan = sortState.columns[0].columnName === 'sortKey';
                            return { rowSpan: rowSpan, enableRowSpan: enableRowSpan };
                        })(RowSpanCellComp);


                        /***/ }),
                    /* 93 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.BodyCell = exports.BodyCellComp = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var treeCellContents_1 = __webpack_require__(94);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var instance_1 = __webpack_require__(7);
                        var column_1 = __webpack_require__(10);
                        var common_1 = __webpack_require__(0);
                        var BodyCellComp = /** @class */ (function (_super) {
                            tslib_1.__extends(BodyCellComp, _super);
                            function BodyCellComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.handleMouseMove = function (ev) {
                                    var _a = dom_1.getCoordinateWithOffset(ev.pageX, ev.pageY), pageX = _a[0], pageY = _a[1];
                                    _this.props.dispatch('dragMoveRowHeader', { pageX: pageX, pageY: pageY });
                                };
                                _this.handleMouseDown = function (name, rowKey) {
                                    if (!column_1.isRowNumColumn(name)) {
                                        return;
                                    }
                                    _this.props.dispatch('mouseDownRowHeader', rowKey);
                                    document.addEventListener('mousemove', _this.handleMouseMove);
                                    document.addEventListener('mouseup', _this.clearDocumentEvents);
                                    document.addEventListener('selectstart', _this.handleSelectStart);
                                };
                                _this.clearDocumentEvents = function () {
                                    _this.props.dispatch('dragEnd');
                                    dom_1.setCursorStyle('');
                                    document.removeEventListener('mousemove', _this.handleMouseMove);
                                    document.removeEventListener('mouseup', _this.clearDocumentEvents);
                                    document.removeEventListener('selectstart', _this.handleSelectStart);
                                };
                                _this.handleSelectStart = function (ev) {
                                    ev.preventDefault();
                                };
                                return _this;
                            }
                            BodyCellComp.prototype.componentDidMount = function () {
                                var _a = this.props, grid = _a.grid, rowKey = _a.rowKey, renderData = _a.renderData, columnInfo = _a.columnInfo;
                                // eslint-disable-next-line new-cap
                                this.renderer = new columnInfo.renderer.type(tslib_1.__assign({ grid: grid,
                                    rowKey: rowKey,
                                    columnInfo: columnInfo }, renderData));
                                var rendererEl = this.renderer.getElement();
                                this.el.appendChild(rendererEl);
                                if (this.renderer.mounted) {
                                    this.renderer.mounted(this.el);
                                }
                                this.calculateRowHeight(this.props);
                            };
                            BodyCellComp.prototype.shouldComponentUpdate = function (nextProps) {
                                return !common_1.shallowEqual(this.props, nextProps);
                            };
                            BodyCellComp.prototype.componentWillReceiveProps = function (nextProps) {
                                var viewRow = nextProps.viewRow, renderData = nextProps.renderData, columnInfo = nextProps.columnInfo, rowKey = nextProps.rowKey, grid = nextProps.grid;
                                var _a = this.props, prevViewRow = _a.viewRow, prevRenderData = _a.renderData;
                                if ((prevRenderData !== renderData || viewRow.uniqueKey !== prevViewRow.uniqueKey) &&
                                    this.renderer &&
                                    common_1.isFunction(this.renderer.render)) {
                                    this.renderer.render(tslib_1.__assign({ grid: grid,
                                        rowKey: rowKey,
                                        columnInfo: columnInfo }, renderData));
                                    this.calculateRowHeight(nextProps);
                                }
                            };
                            BodyCellComp.prototype.componentWillUnmount = function () {
                                if (this.renderer && common_1.isFunction(this.renderer.beforeDestroy)) {
                                    this.renderer.beforeDestroy();
                                }
                            };
                            BodyCellComp.prototype.calculateRowHeight = function (props) {
                                var _this = this;
                                var rowIndex = props.rowIndex, columnInfo = props.columnInfo, refreshRowHeight = props.refreshRowHeight, defaultRowHeight = props.defaultRowHeight, dispatch = props.dispatch, cellBorderWidth = props.cellBorderWidth;
                                if (refreshRowHeight) {
                                    // In Preact, the componentDidMount is called before the DOM elements are actually mounted.
                                    // https://github.com/preactjs/preact/issues/648
                                    // Use setTimeout to wait until the DOM element is actually mounted
                                    //  - If the width of grid is 'auto' actual width of grid is calculated from the
                                    //    Container component using setTimeout(fn, 0)
                                    //  - Delay 16ms for defer the function call later than the Container component.
                                    window.setTimeout(function () {
                                        var height = _this.renderer.getElement().clientHeight + cellBorderWidth;
                                        dispatch('setCellHeight', columnInfo.name, rowIndex, height, defaultRowHeight);
                                        refreshRowHeight(height);
                                    }, 16);
                                }
                            };
                            BodyCellComp.prototype.render = function () {
                                var _a;
                                var _this = this;
                                var _b = this.props, rowKey = _b.rowKey, _c = _b.renderData, disabled = _c.disabled, editable = _c.editable, invalidStates = _c.invalidStates, className = _c.className, _d = _b.columnInfo, align = _d.align, valign = _d.valign, name = _d.name, _e = _d.validation, validation = _e === void 0 ? {} : _e, treeInfo = _b.treeInfo, selectedRow = _b.selectedRow, rowSpanAttr = _b.rowSpanAttr;
                                var style = {
                                    textAlign: align,
                                    verticalAlign: valign,
                                };
                                var attrs = (_a = {},
                                    _a[dom_1.dataAttr.ROW_KEY] = String(rowKey),
                                    _a[dom_1.dataAttr.COLUMN_NAME] = name,
                                    _a);
                                var classNames = dom_1.cls('cell', 'cell-has-input', [editable, 'cell-editable'], [column_1.isRowHeader(name), 'cell-row-header'], [validation.required || false, 'cell-required'], [!!invalidStates.length, 'cell-invalid'], [disabled, 'cell-disabled'], [!!treeInfo, 'cell-has-tree'], [column_1.isRowHeader(name) && selectedRow, 'cell-selected']) + " " + className;
                                return treeInfo ? (preact_1.h("td", tslib_1.__assign({}, attrs, { style: style, class: classNames }),
                                    preact_1.h("div", { class: dom_1.cls('tree-wrapper-relative') },
                                        preact_1.h("div", { class: dom_1.cls('tree-wrapper-valign-center'), style: { paddingLeft: treeInfo.indentWidth }, ref: function (el) {
                                                    _this.el = el;
                                                } },
                                            preact_1.h(treeCellContents_1.TreeCellContents, { treeInfo: treeInfo, rowKey: rowKey }))))) : (preact_1.h("td", tslib_1.__assign({}, attrs, rowSpanAttr, { style: style, class: classNames, ref: function (el) {
                                        _this.el = el;
                                    }, onMouseDown: function () { return _this.handleMouseDown(name, rowKey); } })));
                            };
                            return BodyCellComp;
                        }(preact_1.Component));
                        exports.BodyCellComp = BodyCellComp;
                        exports.BodyCell = hoc_1.connect(function (_a, _b) {
                            var id = _a.id, column = _a.column, selection = _a.selection, dimension = _a.dimension;
                            var viewRow = _b.viewRow, columnInfo = _b.columnInfo, rowIndex = _b.rowIndex;
                            var rowKey = viewRow.rowKey, valueMap = viewRow.valueMap, treeInfo = viewRow.treeInfo;
                            var treeColumnName = column.treeColumnName;
                            var grid = instance_1.getInstance(id);
                            var range = selection.range;
                            var columnName = columnInfo.name;
                            var defaultRowHeight = dimension.rowHeight, cellBorderWidth = dimension.cellBorderWidth;
                            return tslib_1.__assign(tslib_1.__assign({ grid: grid,
                                rowKey: rowKey,
                                columnInfo: columnInfo,
                                defaultRowHeight: defaultRowHeight, renderData: (valueMap && valueMap[columnName]) || { invalidStates: [] } }, (columnName === treeColumnName ? { treeInfo: treeInfo } : null)), { selectedRow: range ? rowIndex >= range.row[0] && rowIndex <= range.row[1] : false, cellBorderWidth: cellBorderWidth });
                        })(BodyCellComp);


                        /***/ }),
                    /* 94 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.TreeCellContents = exports.TreeCellContentsComp = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var constant_1 = __webpack_require__(16);
                        var TreeCellContentsComp = /** @class */ (function (_super) {
                            tslib_1.__extends(TreeCellContentsComp, _super);
                            function TreeCellContentsComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.handleClick = function (ev) {
                                    ev.stopPropagation();
                                    var _a = _this.props, dispatch = _a.dispatch, rowKey = _a.rowKey;
                                    var target = ev.target;
                                    if (dom_1.findParent(target, 'tree-button-collapse')) {
                                        dispatch('expandByRowKey', rowKey, false);
                                    }
                                    else if (dom_1.findParent(target, 'tree-button-expand')) {
                                        dispatch('collapseByRowKey', rowKey, false);
                                    }
                                };
                                return _this;
                            }
                            TreeCellContentsComp.prototype.getIndentComponent = function (depth, leaf) {
                                var indentItem = [];
                                for (var i = 0, len = depth; i < len; i += 1) {
                                    indentItem.push(preact_1.h("span", { class: dom_1.cls('tree-depth') }, i === len - 1 && !leaf && (preact_1.h("button", { class: dom_1.cls('btn-tree'), style: { left: i * constant_1.TREE_INDENT_WIDTH }, onClick: this.handleClick },
                                        preact_1.h("i", null)))));
                                }
                                return indentItem;
                            };
                            TreeCellContentsComp.prototype.render = function () {
                                var _a = this.props, depth = _a.depth, indentWidth = _a.indentWidth, leaf = _a.leaf, expanded = _a.expanded, useIcon = _a.useIcon;
                                return (preact_1.h("div", { class: dom_1.cls('tree-extra-content', [!leaf && expanded, 'tree-button-expand'], [!leaf && !expanded, 'tree-button-collapse']) },
                                    this.getIndentComponent(depth, leaf),
                                    useIcon && (preact_1.h("span", { class: dom_1.cls('tree-icon'), style: { left: indentWidth - constant_1.TREE_INDENT_WIDTH } },
                                    preact_1.h("i", null)))));
                            };
                            return TreeCellContentsComp;
                        }(preact_1.Component));
                        exports.TreeCellContentsComp = TreeCellContentsComp;
                        exports.TreeCellContents = hoc_1.connect(function (_a, _b) {
                            var column = _a.column;
                            var treeInfo = _b.treeInfo, rowKey = _b.rowKey;
                            var _c = column.treeIcon, useIcon = _c === void 0 ? true : _c;
                            var depth = treeInfo.depth, indentWidth = treeInfo.indentWidth, leaf = treeInfo.leaf, _d = treeInfo.expanded, expanded = _d === void 0 ? false : _d;
                            return {
                                rowKey: rowKey,
                                depth: depth,
                                indentWidth: indentWidth,
                                leaf: leaf,
                                expanded: expanded,
                                useIcon: useIcon,
                            };
                        })(TreeCellContentsComp);


                        /***/ }),
                    /* 95 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.BodyDummyRow = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var dom_1 = __webpack_require__(2);
                        var column_1 = __webpack_require__(10);
                        var BodyDummyRowComp = function (_a) {
                            var columnNames = _a.columnNames, rowHeight = _a.rowHeight, index = _a.index;
                            var isOddRow = index % 2 === 0;
                            return (preact_1.h("tr", { style: { height: rowHeight }, class: dom_1.cls([isOddRow, 'row-odd'], [!isOddRow, 'row-even']) }, columnNames.map(function (name) {
                                var _a;
                                var attrs = (_a = {}, _a[dom_1.dataAttr.COLUMN_NAME] = name, _a);
                                return (preact_1.h("td", tslib_1.__assign({}, attrs, { key: index, class: dom_1.cls('cell', 'cell-dummy', [column_1.isRowHeader(name), 'cell-row-header']) })));
                            })));
                        };
                        exports.BodyDummyRow = hoc_1.connect(function (_a) {
                            var rowHeight = _a.dimension.rowHeight;
                            return ({
                                rowHeight: rowHeight,
                            });
                        })(BodyDummyRowComp);


                        /***/ }),
                    /* 96 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.FocusLayer = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var FocusLayerComp = /** @class */ (function (_super) {
                            tslib_1.__extends(FocusLayerComp, _super);
                            function FocusLayerComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            FocusLayerComp.prototype.render = function () {
                                var _a = this.props, active = _a.active, cellPosRect = _a.cellPosRect, cellBorderWidth = _a.cellBorderWidth;
                                if (cellPosRect === null) {
                                    return null;
                                }
                                var top = cellPosRect.top, left = cellPosRect.left, right = cellPosRect.right, bottom = cellPosRect.bottom;
                                var height = bottom - top;
                                var width = right - left;
                                var leftStyle = {
                                    top: top,
                                    left: left,
                                    width: cellBorderWidth,
                                    height: height + cellBorderWidth,
                                };
                                var topStyle = {
                                    top: top === 0 ? cellBorderWidth : top,
                                    left: left,
                                    width: width + cellBorderWidth,
                                    height: cellBorderWidth,
                                };
                                var rightStyle = {
                                    top: top,
                                    left: left + width,
                                    width: cellBorderWidth,
                                    height: height + cellBorderWidth,
                                };
                                var bottomStyle = {
                                    top: top + height,
                                    left: left,
                                    width: width + cellBorderWidth,
                                    height: cellBorderWidth,
                                };
                                return (preact_1.h("div", { class: dom_1.cls('layer-focus', [!active, 'layer-focus-deactive']) },
                                    preact_1.h("div", { class: dom_1.cls('layer-focus-border'), style: leftStyle }),
                                    preact_1.h("div", { class: dom_1.cls('layer-focus-border'), style: topStyle }),
                                    preact_1.h("div", { class: dom_1.cls('layer-focus-border'), style: rightStyle }),
                                    preact_1.h("div", { class: dom_1.cls('layer-focus-border'), style: bottomStyle })));
                            };
                            return FocusLayerComp;
                        }(preact_1.Component));
                        exports.FocusLayer = hoc_1.connect(function (_a, _b) {
                            var focus = _a.focus, dimension = _a.dimension;
                            var side = _b.side;
                            var cellPosRect = focus.cellPosRect, editingAddress = focus.editingAddress, navigating = focus.navigating;
                            return {
                                active: !!editingAddress || navigating,
                                cellPosRect: side === focus.side ? cellPosRect : null,
                                cellBorderWidth: dimension.cellBorderWidth,
                            };
                        })(FocusLayerComp);


                        /***/ }),
                    /* 97 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.SelectionLayer = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var SelectionLayerComp = /** @class */ (function (_super) {
                            tslib_1.__extends(SelectionLayerComp, _super);
                            function SelectionLayerComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.handleMouseMove = function (ev) {
                                    var dispatch = _this.props.dispatch;
                                    var pageX = ev.pageX, pageY = ev.pageY;
                                    dispatch('setHoveredRowKeyByPosition', { pageX: pageX, pageY: pageY });
                                };
                                return _this;
                            }
                            SelectionLayerComp.prototype.render = function () {
                                var styles = this.props.styles;
                                return (preact_1.h("div", { onMouseMove: this.handleMouseMove }, !!styles && preact_1.h("div", { class: dom_1.cls('layer-selection'), style: styles })));
                            };
                            return SelectionLayerComp;
                        }(preact_1.Component));
                        exports.SelectionLayer = hoc_1.connect(function (_a, _b) {
                            var rangeAreaInfo = _a.selection.rangeAreaInfo;
                            var side = _b.side;
                            var styles = rangeAreaInfo && rangeAreaInfo[side];
                            return { styles: styles };
                        })(SelectionLayerComp);


                        /***/ }),
                    /* 98 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.EditingLayer = exports.EditingLayerComp = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var dom_1 = __webpack_require__(2);
                        var keyboard_1 = __webpack_require__(17);
                        var common_1 = __webpack_require__(0);
                        var instance_1 = __webpack_require__(7);
                        var EditingLayerComp = /** @class */ (function (_super) {
                            tslib_1.__extends(EditingLayerComp, _super);
                            function EditingLayerComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.handleKeyDown = function (ev) {
                                    var keyName = keyboard_1.getKeyStrokeString(ev);
                                    switch (keyName) {
                                        case 'enter':
                                            _this.finishEditing(true);
                                            break;
                                        case 'esc':
                                            _this.finishEditing(false);
                                            break;
                                        case 'tab':
                                            _this.moveTabFocus(ev, 'nextCell');
                                            break;
                                        case 'shift-tab':
                                            _this.moveTabFocus(ev, 'prevCell');
                                            break;
                                        // do nothing;
                                    }
                                };
                                return _this;
                            }
                            EditingLayerComp.prototype.moveTabFocus = function (ev, command) {
                                var dispatch = this.props.dispatch;
                                ev.preventDefault();
                                dispatch('moveTabFocus', command);
                                dispatch('setScrollToFocus');
                            };
                            EditingLayerComp.prototype.finishEditing = function (save) {
                                var _a = this.props, dispatch = _a.dispatch, editingAddress = _a.editingAddress, active = _a.active;
                                if (this.editor && active) {
                                    var _b = editingAddress, rowKey = _b.rowKey, columnName = _b.columnName;
                                    var value = this.editor.getValue();
                                    if (save) {
                                        dispatch('setValue', rowKey, columnName, value);
                                    }
                                    if (common_1.isFunction(this.editor.beforeDestroy)) {
                                        this.editor.beforeDestroy();
                                    }
                                    dispatch('finishEditing', rowKey, columnName, value);
                                }
                            };
                            EditingLayerComp.prototype.createEditor = function () {
                                var _a = this.props, allColumnMap = _a.allColumnMap, filteredViewData = _a.filteredViewData, editingAddress = _a.editingAddress, grid = _a.grid, cellPosRect = _a.cellPosRect;
                                var _b = editingAddress, rowKey = _b.rowKey, columnName = _b.columnName;
                                var _c = cellPosRect, right = _c.right, left = _c.left;
                                var columnInfo = allColumnMap[columnName];
                                var _d = common_1.findProp('rowKey', rowKey, filteredViewData).valueMap[columnName], value = _d.value, formattedValue = _d.formattedValue;
                                var EditorClass = columnInfo.editor.type;
                                var editorProps = {
                                    grid: grid,
                                    rowKey: rowKey,
                                    columnInfo: columnInfo,
                                    value: value,
                                    formattedValue: formattedValue,
                                    width: right - left,
                                    portalEditingKeydown: this.handleKeyDown,
                                };
                                var cellEditor = new EditorClass(editorProps);
                                var editorEl = cellEditor.getElement();
                                if (editorEl && this.contentEl) {
                                    this.contentEl.appendChild(editorEl);
                                    this.editor = cellEditor;
                                    if (common_1.isFunction(cellEditor.mounted)) {
                                        // To access the actual mounted DOM elements
                                        setTimeout(function () {
                                            cellEditor.mounted();
                                        });
                                    }
                                }
                            };
                            EditingLayerComp.prototype.componentDidUpdate = function (prevProps) {
                                var _a;
                                if (!prevProps.active &&
                                    this.props.active &&
                                    ((_a = this.props.editingAddress) === null || _a === void 0 ? void 0 : _a.columnName) === this.props.focusedColumnName) {
                                    this.createEditor();
                                }
                            };
                            EditingLayerComp.prototype.componentWillReceiveProps = function (nextProps) {
                                var _a = this.props, prevFocusedColumnName = _a.focusedColumnName, prevFocusedRowKey = _a.focusedRowKey, prevActive = _a.active;
                                var focusedColumnName = nextProps.focusedColumnName, focusedRowKey = nextProps.focusedRowKey, active = nextProps.active, forcedDestroyEditing = nextProps.forcedDestroyEditing;
                                if ((prevActive && !active && forcedDestroyEditing) ||
                                    (prevActive &&
                                        (focusedColumnName !== prevFocusedColumnName || focusedRowKey !== prevFocusedRowKey))) {
                                    this.finishEditing(true);
                                }
                            };
                            EditingLayerComp.prototype.render = function (_a) {
                                var _this = this;
                                var active = _a.active, cellPosRect = _a.cellPosRect, cellBorderWidth = _a.cellBorderWidth;
                                if (!active) {
                                    return null;
                                }
                                var _b = cellPosRect, top = _b.top, left = _b.left, right = _b.right, bottom = _b.bottom;
                                var height = bottom - top;
                                var width = right - left;
                                var editorStyles = {
                                    top: top ? top : cellBorderWidth,
                                    left: left,
                                    width: width + cellBorderWidth,
                                    height: top ? height + cellBorderWidth : height,
                                    lineHeight: top ? height - cellBorderWidth + "px" : height - cellBorderWidth * 2 + "px",
                                };
                                return (preact_1.h("div", { style: editorStyles, className: dom_1.cls('layer-editing', 'cell-content', 'cell-content-editor'), onKeyDown: this.handleKeyDown, ref: function (el) {
                                        _this.contentEl = el;
                                    } }));
                            };
                            return EditingLayerComp;
                        }(preact_1.Component));
                        exports.EditingLayerComp = EditingLayerComp;
                        exports.EditingLayer = hoc_1.connect(function (store, _a) {
                            var side = _a.side;
                            var data = store.data, column = store.column, id = store.id, focus = store.focus, dimension = store.dimension;
                            var editingAddress = focus.editingAddress, focusSide = focus.side, focusedRowKey = focus.rowKey, focusedColumnName = focus.columnName, forcedDestroyEditing = focus.forcedDestroyEditing, cellPosRect = focus.cellPosRect;
                            return {
                                grid: instance_1.getInstance(id),
                                active: side === focusSide && !common_1.isNull(editingAddress),
                                focusedRowKey: focusedRowKey,
                                focusedColumnName: focusedColumnName,
                                forcedDestroyEditing: forcedDestroyEditing,
                                cellPosRect: cellPosRect,
                                cellBorderWidth: dimension.cellBorderWidth,
                                editingAddress: editingAddress,
                                filteredViewData: data.filteredViewData,
                                allColumnMap: column.allColumnMap,
                            };
                        }, true)(EditingLayerComp);


                        /***/ }),
                    /* 99 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.SummaryBodyRow = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var summaryBodyCell_1 = __webpack_require__(100);
                        var common_1 = __webpack_require__(0);
                        var SummaryBodyRow = /** @class */ (function (_super) {
                            tslib_1.__extends(SummaryBodyRow, _super);
                            function SummaryBodyRow() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            SummaryBodyRow.prototype.shouldComponentUpdate = function (nextProps) {
                                return !common_1.shallowEqual(nextProps, this.props);
                            };
                            SummaryBodyRow.prototype.render = function (_a) {
                                var columns = _a.columns;
                                var columnNames = columns.map(function (_a) {
                                    var name = _a.name;
                                    return name;
                                });
                                return (preact_1.h("tbody", null,
                                    preact_1.h("tr", null, columnNames.map(function (name) { return (preact_1.h(summaryBodyCell_1.SummaryBodyCell, { key: name, columnName: name })); }))));
                            };
                            return SummaryBodyRow;
                        }(preact_1.Component));
                        exports.SummaryBodyRow = SummaryBodyRow;


                        /***/ }),
                    /* 100 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.SummaryBodyCell = exports.SummaryBodyCellComp = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var dom_1 = __webpack_require__(2);
                        var common_1 = __webpack_require__(0);
                        var hoc_1 = __webpack_require__(4);
                        var column_1 = __webpack_require__(10);
                        var SummaryBodyCellComp = /** @class */ (function (_super) {
                            tslib_1.__extends(SummaryBodyCellComp, _super);
                            function SummaryBodyCellComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.getTemplate = function () {
                                    var _a = _this.props, content = _a.content, summaryValue = _a.summaryValue, columnName = _a.columnName;
                                    if (!content || column_1.isRowHeader(columnName)) {
                                        return '';
                                    }
                                    var template = content.template;
                                    return typeof template === 'string' ? template : template(summaryValue);
                                };
                                return _this;
                            }
                            SummaryBodyCellComp.prototype.shouldComponentUpdate = function (nextProps) {
                                return !common_1.shallowEqual(nextProps, this.props);
                            };
                            SummaryBodyCellComp.prototype.render = function () {
                                var _a;
                                var columnName = this.props.columnName;
                                var attrs = (_a = {}, _a[dom_1.dataAttr.COLUMN_NAME] = columnName, _a);
                                var template = this.getTemplate();
                                return (preact_1.h("td", tslib_1.__assign({ class: dom_1.cls('cell', 'cell-summary'), dangerouslySetInnerHTML: { __html: template } }, attrs)));
                            };
                            return SummaryBodyCellComp;
                        }(preact_1.Component));
                        exports.SummaryBodyCellComp = SummaryBodyCellComp;
                        exports.SummaryBodyCell = hoc_1.connect(function (_a, _b) {
                            var summary = _a.summary;
                            var columnName = _b.columnName;
                            var summaryColumnContents = summary.summaryColumnContents, summaryValues = summary.summaryValues;
                            var content = summaryColumnContents[columnName];
                            var summaryValue = summaryValues[columnName];
                            return { content: content, summaryValue: summaryValue };
                        })(SummaryBodyCellComp);


                        /***/ }),
                    /* 101 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.RightSide = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var dom_1 = __webpack_require__(2);
                        var bodyArea_1 = __webpack_require__(48);
                        var headerArea_1 = __webpack_require__(46);
                        var summaryArea_1 = __webpack_require__(49);
                        var hoc_1 = __webpack_require__(4);
                        var RightSideComp = /** @class */ (function (_super) {
                            tslib_1.__extends(RightSideComp, _super);
                            function RightSideComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            RightSideComp.prototype.renderScrollbarYInnerBorder = function () {
                                var _a = this.props, cornerTopHeight = _a.cornerTopHeight, bodyHeight = _a.bodyHeight, scrollXHeight = _a.scrollXHeight;
                                var style = {
                                    top: cornerTopHeight,
                                    height: bodyHeight - scrollXHeight,
                                };
                                return preact_1.h("div", { class: dom_1.cls('scrollbar-y-inner-border'), style: style });
                            };
                            RightSideComp.prototype.renderScrollbarRightTop = function () {
                                var style = { height: this.props.cornerTopHeight };
                                return preact_1.h("div", { class: dom_1.cls('scrollbar-right-top'), style: style });
                            };
                            RightSideComp.prototype.renderScrollbarYOuterBorder = function () {
                                return preact_1.h("div", { class: dom_1.cls('scrollbar-y-outer-border') });
                            };
                            RightSideComp.prototype.renderScrollbarRightBottom = function () {
                                var style = { height: this.props.cornerBottomHeight };
                                return preact_1.h("div", { class: dom_1.cls('scrollbar-right-bottom'), style: style });
                            };
                            RightSideComp.prototype.renderScrollbarFrozenBorder = function () {
                                var _a = this.props, scrollXHeight = _a.scrollXHeight, frozenBorderWidth = _a.frozenBorderWidth, cellBorderWidth = _a.cellBorderWidth;
                                var style = {
                                    height: scrollXHeight,
                                    width: frozenBorderWidth,
                                    marginLeft: frozenBorderWidth ? -(frozenBorderWidth + cellBorderWidth) : 0,
                                };
                                return preact_1.h("div", { class: dom_1.cls('scrollbar-frozen-border'), style: style });
                            };
                            RightSideComp.prototype.renderFrozenBorder = function () {
                                var frozenBorderWidth = this.props.frozenBorderWidth;
                                var style = {
                                    marginLeft: -frozenBorderWidth,
                                    width: frozenBorderWidth,
                                };
                                return preact_1.h("div", { class: dom_1.cls('frozen-border'), style: style });
                            };
                            RightSideComp.prototype.render = function () {
                                var _a = this.props, marginLeft = _a.marginLeft, width = _a.width, summaryPosition = _a.summaryPosition, scrollY = _a.scrollY, scrollX = _a.scrollX, frozenBorderWidth = _a.frozenBorderWidth;
                                var style = {
                                    display: 'block',
                                    marginLeft: marginLeft,
                                    width: width,
                                };
                                return (preact_1.h("div", { class: dom_1.cls('rside-area'), style: style },
                                    preact_1.h(headerArea_1.HeaderArea, { side: "R" }),
                                    summaryPosition === 'top' && preact_1.h(summaryArea_1.SummaryArea, { side: "R" }),
                                    preact_1.h(bodyArea_1.BodyArea, { side: "R" }),
                                    summaryPosition === 'bottom' && preact_1.h(summaryArea_1.SummaryArea, { side: "R" }),
                                    scrollY && this.renderScrollbarYInnerBorder(),
                                    scrollY && this.renderScrollbarYOuterBorder(),
                                    scrollY && this.renderScrollbarRightTop(),
                                    scrollX && this.renderScrollbarFrozenBorder(),
                                    (scrollX || scrollY) && this.renderScrollbarRightBottom(),
                                    !!frozenBorderWidth && this.renderFrozenBorder()));
                            };
                            return RightSideComp;
                        }(preact_1.Component));
                        exports.RightSide = hoc_1.connect(function (_a) {
                            var dimension = _a.dimension, columnCoords = _a.columnCoords;
                            var scrollbarWidth = dimension.scrollbarWidth, scrollX = dimension.scrollX, scrollY = dimension.scrollY, summaryHeight = dimension.summaryHeight, headerHeight = dimension.headerHeight, cellBorderWidth = dimension.cellBorderWidth, tableBorderWidth = dimension.tableBorderWidth, bodyHeight = dimension.bodyHeight, summaryPosition = dimension.summaryPosition, frozenBorderWidth = dimension.frozenBorderWidth;
                            var cornerTopHeight = headerHeight;
                            var cornerBottomHeight = scrollX ? scrollbarWidth : 0;
                            if (scrollY && summaryHeight) {
                                if (summaryPosition === 'top') {
                                    cornerTopHeight += summaryHeight + tableBorderWidth;
                                }
                                else {
                                    cornerBottomHeight += summaryHeight;
                                }
                            }
                            var scrollXHeight = scrollX ? scrollbarWidth : 0;
                            var width = columnCoords.areaWidth.R;
                            var marginLeft = columnCoords.areaWidth.L + frozenBorderWidth;
                            if (marginLeft && !frozenBorderWidth) {
                                marginLeft -= cellBorderWidth;
                                width += cellBorderWidth;
                            }
                            return {
                                width: width,
                                marginLeft: marginLeft,
                                cornerTopHeight: cornerTopHeight,
                                cornerBottomHeight: cornerBottomHeight,
                                scrollXHeight: scrollXHeight,
                                bodyHeight: bodyHeight,
                                cellBorderWidth: cellBorderWidth,
                                frozenBorderWidth: frozenBorderWidth,
                                summaryPosition: summaryPosition,
                                scrollX: scrollX,
                                scrollY: scrollY,
                            };
                        })(RightSideComp);


                        /***/ }),
                    /* 102 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.StateLayer = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var dom_1 = __webpack_require__(2);
                        var hoc_1 = __webpack_require__(4);
                        var i18n_1 = tslib_1.__importDefault(__webpack_require__(36));
                        var StateLayerComp = /** @class */ (function (_super) {
                            tslib_1.__extends(StateLayerComp, _super);
                            function StateLayerComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            StateLayerComp.prototype.render = function (_a) {
                                var loadingState = _a.loadingState, top = _a.top, height = _a.height, left = _a.left, right = _a.right;
                                var display = loadingState === 'DONE' ? 'none' : 'block';
                                var layerStyle = { display: display, top: top, height: height, left: left, right: right };
                                var message = null;
                                if (loadingState === 'EMPTY') {
                                    message = i18n_1.default.get('display.noData');
                                }
                                else if (loadingState === 'LOADING') {
                                    message = i18n_1.default.get('display.loadingData');
                                }
                                return (preact_1.h("div", { class: dom_1.cls('layer-state'), style: layerStyle },
                                    preact_1.h("div", { class: dom_1.cls('layer-state-content') },
                                        preact_1.h("p", null, message),
                                        loadingState === 'LOADING' && preact_1.h("div", { class: dom_1.cls('layer-state-loading') }))));
                            };
                            return StateLayerComp;
                        }(preact_1.Component));
                        exports.StateLayer = hoc_1.connect(function (_a) {
                            var data = _a.data, dimension = _a.dimension;
                            var headerHeight = dimension.headerHeight, bodyHeight = dimension.bodyHeight, cellBorderWidth = dimension.cellBorderWidth, tableBorderWidth = dimension.tableBorderWidth, scrollXHeight = dimension.scrollXHeight, scrollYWidth = dimension.scrollYWidth;
                            return {
                                loadingState: data.loadingState,
                                top: headerHeight + cellBorderWidth,
                                height: bodyHeight - scrollXHeight - tableBorderWidth,
                                left: 0,
                                right: scrollYWidth + tableBorderWidth,
                            };
                        })(StateLayerComp);


                        /***/ }),
                    /* 103 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.FilterLayer = exports.FilterLayerComp = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var filterLayerInner_1 = __webpack_require__(104);
                        var FilterLayerComp = /** @class */ (function (_super) {
                            tslib_1.__extends(FilterLayerComp, _super);
                            function FilterLayerComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            FilterLayerComp.prototype.render = function (_a) {
                                var activeColumnAddress = _a.activeColumnAddress, activeFilterState = _a.activeFilterState;
                                return (activeColumnAddress &&
                                    activeFilterState && (preact_1.h(filterLayerInner_1.FilterLayerInner, { columnAddress: activeColumnAddress, filterState: activeFilterState })));
                            };
                            return FilterLayerComp;
                        }(preact_1.Component));
                        exports.FilterLayerComp = FilterLayerComp;
                        exports.FilterLayer = hoc_1.connect(function (_a) {
                            var filterLayerState = _a.filterLayerState;
                            var activeColumnAddress = filterLayerState.activeColumnAddress, activeFilterState = filterLayerState.activeFilterState;
                            return { activeColumnAddress: activeColumnAddress, activeFilterState: activeFilterState };
                        })(FilterLayerComp);


                        /***/ }),
                    /* 104 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.FilterLayerInner = exports.FilterLayerInnerComp = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var dom_1 = __webpack_require__(2);
                        var textFilter_1 = __webpack_require__(105);
                        var datePickerFilter_1 = __webpack_require__(106);
                        var filterOperator_1 = __webpack_require__(107);
                        var selectFilter_1 = __webpack_require__(108);
                        var common_1 = __webpack_require__(0);
                        var FilterLayerInnerComp = /** @class */ (function (_super) {
                            tslib_1.__extends(FilterLayerInnerComp, _super);
                            function FilterLayerInnerComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.renderFilter = function (index) {
                                    var _a = _this.props, columnAddress = _a.columnAddress, filterState = _a.filterState, columnInfo = _a.columnInfo;
                                    var type = columnInfo.filter.type;
                                    switch (type) {
                                        case 'text':
                                        case 'number':
                                            return (preact_1.h(textFilter_1.TextFilter, { columnAddress: columnAddress, filterState: filterState, filterIndex: index }));
                                        case 'date':
                                            return (preact_1.h(datePickerFilter_1.DatePickerFilter, { columnAddress: columnAddress, filterState: filterState, filterIndex: index }));
                                        case 'select':
                                            return preact_1.h(selectFilter_1.SelectFilter, { columnAddress: columnAddress, filterState: filterState });
                                        default:
                                            return null;
                                    }
                                };
                                return _this;
                            }
                            FilterLayerInnerComp.prototype.render = function () {
                                var _a = this.props, columnAddress = _a.columnAddress, columnInfo = _a.columnInfo, renderSecondFilter = _a.renderSecondFilter, dispatch = _a.dispatch, currentColumnActive = _a.currentColumnActive, filterState = _a.filterState;
                                var _b = columnInfo.filter, showApplyBtn = _b.showApplyBtn, showClearBtn = _b.showClearBtn;
                                var left = columnAddress.left;
                                return (preact_1.h("div", { className: dom_1.cls('filter-container'), style: { left: left } },
                                    preact_1.h("div", null,
                                        preact_1.h("span", { className: dom_1.cls('btn-filter', [currentColumnActive, 'btn-filter-active'], 'filter-icon') }),
                                        preact_1.h("a", { className: dom_1.cls('btn-close'), onClick: function () {
                                                dispatch('setActiveColumnAddress', null);
                                            } })),
                                    this.renderFilter(0),
                                    renderSecondFilter && preact_1.h(filterOperator_1.FilterOperator, { filterState: filterState }),
                                    renderSecondFilter && this.renderFilter(1),
                                    preact_1.h("div", { className: dom_1.cls('filter-btn-container') },
                                        showClearBtn && (preact_1.h("button", { className: dom_1.cls('filter-btn', 'filter-btn-clear'), onClick: function () {
                                                dispatch('clearActiveFilterState');
                                            } }, "Clear")),
                                        showApplyBtn && (preact_1.h("button", { className: dom_1.cls('filter-btn', 'filter-btn-apply'), onClick: function () {
                                                dispatch('applyActiveFilterState');
                                            } }, "Apply")))));
                            };
                            return FilterLayerInnerComp;
                        }(preact_1.Component));
                        exports.FilterLayerInnerComp = FilterLayerInnerComp;
                        exports.FilterLayerInner = hoc_1.connect(function (store, _a) {
                            var columnAddress = _a.columnAddress, filterState = _a.filterState;
                            var data = store.data, column = store.column;
                            var filters = data.filters;
                            var allColumnMap = column.allColumnMap;
                            var currentColumnActive = !!filters && common_1.some(function (item) { return item.columnName === columnAddress.name; }, filters);
                            var renderSecondFilter = !!(filterState.type !== 'select' &&
                                filterState.operator &&
                                filterState.state[0] &&
                                filterState.state[0].value.length);
                            return {
                                columnInfo: allColumnMap[columnAddress.name],
                                columnAddress: columnAddress,
                                filters: filters,
                                renderSecondFilter: renderSecondFilter,
                                currentColumnActive: currentColumnActive,
                            };
                        })(FilterLayerInnerComp);


                        /***/ }),
                    /* 105 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.TextFilter = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var dom_1 = __webpack_require__(2);
                        var filter_1 = __webpack_require__(28);
                        var common_1 = __webpack_require__(0);
                        var keyboard_1 = __webpack_require__(17);
                        var constant_1 = __webpack_require__(16);
                        var TextFilterComp = /** @class */ (function (_super) {
                            tslib_1.__extends(TextFilterComp, _super);
                            function TextFilterComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.getPreviousValue = function () {
                                    var _a = _this.props, filterIndex = _a.filterIndex, filterState = _a.filterState;
                                    var state = filterState.state;
                                    var code = 'eq';
                                    var value = '';
                                    if (state.length && state[filterIndex]) {
                                        var _b = state[filterIndex], prevCode = _b.code, prevValue = _b.value;
                                        code = prevCode;
                                        value = String(prevValue);
                                    }
                                    return { value: value, code: code };
                                };
                                _this.handleChange = common_1.debounce(function (ev) {
                                    var dispatch = _this.props.dispatch;
                                    var keyCode = ev.keyCode;
                                    if (keyboard_1.isNonPrintableKey(keyCode)) {
                                        return;
                                    }
                                    var keyName = keyboard_1.keyNameMap[keyCode];
                                    if (keyName === 'enter') {
                                        dispatch('applyActiveFilterState');
                                    }
                                    else {
                                        var filterIndex = _this.props.filterIndex;
                                        var value = _this.inputEl.value;
                                        var code = _this.selectEl.value;
                                        dispatch('setActiveFilterState', { value: value, code: code }, filterIndex);
                                    }
                                }, constant_1.FILTER_DEBOUNCE_TIME);
                                return _this;
                            }
                            TextFilterComp.prototype.render = function () {
                                var _this = this;
                                var columnInfo = this.props.columnInfo;
                                var _a = this.getPreviousValue(), code = _a.code, value = _a.value;
                                var selectOption = filter_1.filterSelectOption[columnInfo.filter.type];
                                return (preact_1.h("div", null,
                                    preact_1.h("div", { className: dom_1.cls('filter-dropdown') },
                                        preact_1.h("select", { ref: function (ref) {
                                                _this.selectEl = ref;
                                            }, onChange: this.handleChange }, Object.keys(selectOption).map(function (key) {
                                            return (preact_1.h("option", { value: key, key: key, selected: code === key }, selectOption[key]));
                                        }))),
                                    preact_1.h("input", { ref: function (ref) {
                                            _this.inputEl = ref;
                                        }, type: "text", className: dom_1.cls('filter-input'), onInput: this.handleChange, value: value })));
                            };
                            return TextFilterComp;
                        }(preact_1.Component));
                        exports.TextFilter = hoc_1.connect(function (store, _a) {
                            var filterIndex = _a.filterIndex, columnAddress = _a.columnAddress, filterState = _a.filterState;
                            var column = store.column, data = store.data;
                            var allColumnMap = column.allColumnMap;
                            var filters = data.filters;
                            return {
                                columnInfo: allColumnMap[columnAddress.name],
                                columnAddress: columnAddress,
                                filterIndex: filterIndex,
                                filters: filters,
                                filterState: filterState,
                            };
                        })(TextFilterComp);


                        /***/ }),
                    /* 106 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.DatePickerFilter = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var tui_date_picker_1 = tslib_1.__importDefault(__webpack_require__(40));
                        var hoc_1 = __webpack_require__(4);
                        var instance_1 = __webpack_require__(7);
                        var dom_1 = __webpack_require__(2);
                        var filter_1 = __webpack_require__(28);
                        var common_1 = __webpack_require__(0);
                        var keyboard_1 = __webpack_require__(17);
                        var constant_1 = __webpack_require__(16);
                        var DatePickerFilterComp = /** @class */ (function (_super) {
                            tslib_1.__extends(DatePickerFilterComp, _super);
                            function DatePickerFilterComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.createDatePicker = function () {
                                    var _a = _this.props, columnInfo = _a.columnInfo, grid = _a.grid;
                                    var _b = columnInfo.filter.options, options = _b === void 0 ? {} : _b;
                                    var usageStatistics = grid.usageStatistics;
                                    var value = _this.getPreviousValue().value;
                                    var date;
                                    if (!options.format) {
                                        options.format = 'yyyy/MM/dd';
                                    }
                                    if (common_1.isString(value) && value.length) {
                                        date = new Date(value);
                                    }
                                    var defaultOptions = {
                                        date: date,
                                        type: 'date',
                                        input: {
                                            element: _this.inputEl,
                                            format: options.format,
                                        },
                                        usageStatistics: usageStatistics,
                                    };
                                    _this.datePickerEl = new tui_date_picker_1.default(_this.calendarWrapper, common_1.deepMergedCopy(defaultOptions, options || {}));
                                    _this.datePickerEl.on('change', _this.handleChange);
                                };
                                _this.handleKeyUp = common_1.debounce(function (ev) {
                                    var keyCode = ev.keyCode;
                                    var keyName = keyboard_1.keyNameMap[keyCode];
                                    var dispatch = _this.props.dispatch;
                                    if (keyboard_1.isNonPrintableKey(keyCode)) {
                                        return;
                                    }
                                    if (keyName === 'enter') {
                                        dispatch('applyActiveFilterState');
                                    }
                                    else {
                                        _this.handleChange();
                                    }
                                }, constant_1.FILTER_DEBOUNCE_TIME);
                                _this.handleChange = function () {
                                    var dispatch = _this.props.dispatch;
                                    var filterIndex = _this.props.filterIndex;
                                    var value = _this.inputEl.value;
                                    var code = _this.selectEl.value;
                                    dispatch('setActiveFilterState', { value: value, code: code }, filterIndex);
                                };
                                _this.getPreviousValue = function () {
                                    var _a = _this.props, filterIndex = _a.filterIndex, filterState = _a.filterState;
                                    var state = filterState.state;
                                    var code = 'eq';
                                    var value = '';
                                    if (state.length && state[filterIndex]) {
                                        var _b = state[filterIndex], prevCode = _b.code, prevValue = _b.value;
                                        code = prevCode;
                                        value = String(prevValue);
                                    }
                                    return { value: value, code: code };
                                };
                                _this.openDatePicker = function () {
                                    _this.datePickerEl.open();
                                };
                                return _this;
                            }
                            DatePickerFilterComp.prototype.componentDidMount = function () {
                                this.createDatePicker();
                            };
                            DatePickerFilterComp.prototype.componentWillUnmount = function () {
                                this.datePickerEl.destroy();
                            };
                            DatePickerFilterComp.prototype.render = function () {
                                var _this = this;
                                var columnInfo = this.props.columnInfo;
                                var options = columnInfo.filter.options;
                                var showIcon = !(options && options.showIcon === false);
                                var selectOption = filter_1.filterSelectOption.date;
                                var _a = this.getPreviousValue(), value = _a.value, code = _a.code;
                                return (preact_1.h("div", null,
                                    preact_1.h("div", { className: dom_1.cls('filter-dropdown') },
                                        preact_1.h("select", { ref: function (ref) {
                                                _this.selectEl = ref;
                                            }, onChange: this.handleChange }, Object.keys(selectOption).map(function (key) {
                                            return (preact_1.h("option", { value: key, key: key, selected: code === key }, selectOption[key]));
                                        }))),
                                    preact_1.h("div", { className: dom_1.cls('datepicker-input-container') },
                                        preact_1.h("input", { ref: function (ref) {
                                                _this.inputEl = ref;
                                            }, type: "text", className: dom_1.cls('filter-input', [showIcon, 'datepicker-input']), onKeyUp: this.handleKeyUp, value: value }),
                                        showIcon && preact_1.h("i", { className: dom_1.cls('date-icon'), onClick: this.openDatePicker })),
                                    preact_1.h("div", { ref: function (ref) {
                                            _this.calendarWrapper = ref;
                                        }, style: { marginTop: '-4px' } })));
                            };
                            return DatePickerFilterComp;
                        }(preact_1.Component));
                        exports.DatePickerFilter = hoc_1.connect(function (store, _a) {
                            var filterIndex = _a.filterIndex, columnAddress = _a.columnAddress, filterState = _a.filterState;
                            var column = store.column, id = store.id, data = store.data;
                            var allColumnMap = column.allColumnMap;
                            var filters = data.filters;
                            return {
                                grid: instance_1.getInstance(id),
                                columnInfo: allColumnMap[columnAddress.name],
                                columnAddress: columnAddress,
                                filterIndex: filterIndex,
                                filters: filters,
                                filterState: filterState,
                            };
                        })(DatePickerFilterComp);


                        /***/ }),
                    /* 107 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.FilterOperator = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var dom_1 = __webpack_require__(2);
                        var FilterOperatorComp = /** @class */ (function (_super) {
                            tslib_1.__extends(FilterOperatorComp, _super);
                            function FilterOperatorComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.handleChangeOperator = function (ev) {
                                    var value = ev.target.value;
                                    _this.props.dispatch('setActiveFilterOperator', value);
                                };
                                return _this;
                            }
                            FilterOperatorComp.prototype.render = function () {
                                var _this = this;
                                var operator = this.props.operator;
                                return (preact_1.h("div", { className: dom_1.cls('filter-comparator-container') }, ['AND', 'OR'].map(function (operatorType) {
                                    var checked = operator === operatorType;
                                    return (preact_1.h("div", { key: operatorType, className: dom_1.cls('filter-comparator', [checked, 'filter-comparator-checked']) },
                                        preact_1.h("label", null,
                                            preact_1.h("input", { type: "radio", name: "filterOperator", value: operatorType, checked: checked, onChange: _this.handleChangeOperator }),
                                            preact_1.h("span", null, operatorType))));
                                })));
                            };
                            return FilterOperatorComp;
                        }(preact_1.Component));
                        exports.FilterOperator = hoc_1.connect(function (_, _a) {
                            var filterState = _a.filterState;
                            return ({
                                operator: filterState.operator || 'AND',
                            });
                        })(FilterOperatorComp);


                        /***/ }),
                    /* 108 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.SelectFilter = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var instance_1 = __webpack_require__(7);
                        var dom_1 = __webpack_require__(2);
                        var common_1 = __webpack_require__(0);
                        var data_1 = __webpack_require__(6);
                        var constant_1 = __webpack_require__(16);
                        var SelectFilterComp = /** @class */ (function (_super) {
                            tslib_1.__extends(SelectFilterComp, _super);
                            function SelectFilterComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.state = {
                                    searchInput: '',
                                };
                                _this.handleChange = common_1.debounce(function (ev, id) {
                                    var dispatch = _this.props.dispatch;
                                    var checked = ev.target.checked;
                                    dispatch('setActiveSelectFilterState', id, checked);
                                }, constant_1.FILTER_DEBOUNCE_TIME);
                                _this.toggleAllColumnCheckbox = common_1.debounce(function (ev) {
                                    var checked = ev.target.checked;
                                    _this.props.dispatch('toggleSelectAllCheckbox', checked);
                                }, constant_1.FILTER_DEBOUNCE_TIME);
                                _this.searchColumnData = common_1.debounce(function (ev) {
                                    var value = ev.target.value;
                                    _this.setState({ searchInput: value });
                                }, constant_1.FILTER_DEBOUNCE_TIME);
                                return _this;
                            }
                            SelectFilterComp.prototype.render = function () {
                                var _this = this;
                                var _a = this.props, columnData = _a.columnData, isAllSelected = _a.isAllSelected;
                                var searchInput = this.state.searchInput;
                                var data = searchInput.length
                                    ? columnData.filter(function (item) { return String(item.value).indexOf(searchInput) !== -1; })
                                    : columnData;
                                return (preact_1.h("div", { className: dom_1.cls('filter-list-container') },
                                    preact_1.h("input", { type: "text", className: dom_1.cls('filter-input'), placeholder: "Search...", onKeyUp: this.searchColumnData, value: searchInput ? String(searchInput) : '' }),
                                    preact_1.h("li", { className: dom_1.cls('filter-list-item', [isAllSelected, 'filter-list-item-checked']) },
                                        preact_1.h("label", null,
                                            preact_1.h("input", { type: "checkbox", onChange: this.toggleAllColumnCheckbox, checked: isAllSelected }),
                                            preact_1.h("span", null, "Select All"))),
                                    preact_1.h("ul", { className: dom_1.cls('filter-list') }, data.map(function (item) {
                                        var value = item.value, checked = item.checked;
                                        var text = String(value);
                                        return (preact_1.h("li", { className: dom_1.cls('filter-list-item', [checked, 'filter-list-item-checked']), key: text },
                                            preact_1.h("label", null,
                                                preact_1.h("input", { type: "checkbox", checked: checked, onChange: function (ev) { return _this.handleChange(ev, text); } }),
                                                preact_1.h("span", null, value))));
                                    }))));
                            };
                            return SelectFilterComp;
                        }(preact_1.Component));
                        exports.SelectFilter = hoc_1.connect(function (store, _a) {
                            var columnAddress = _a.columnAddress, filterState = _a.filterState;
                            var column = store.column, id = store.id, data = store.data;
                            var filters = data.filters, rawData = data.rawData;
                            var allColumnMap = column.allColumnMap;
                            var state = filterState.state;
                            var columnName = columnAddress.name;
                            var uniqueColumnData = data_1.getUniqColumnData(rawData, column, columnName);
                            var columnData = uniqueColumnData.map(function (value) { return ({
                                value: value,
                                checked: common_1.some(function (item) { return value === item.value; }, state),
                            }); });
                            return {
                                grid: instance_1.getInstance(id),
                                columnData: columnData,
                                columnInfo: allColumnMap[columnName],
                                columnAddress: columnAddress,
                                filters: filters,
                                isAllSelected: state.length === uniqueColumnData.length,
                            };
                        })(SelectFilterComp);


                        /***/ }),
                    /* 109 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.HeightResizeHandle = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var dom_1 = __webpack_require__(2);
                        var HeightResizeHandleComp = /** @class */ (function (_super) {
                            tslib_1.__extends(HeightResizeHandleComp, _super);
                            function HeightResizeHandleComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.dragStartY = -1;
                                _this.dragStartBodyHeight = -1;
                                _this.handleMouseDown = function (ev) {
                                    _this.dragStartY = ev.pageY;
                                    _this.dragStartBodyHeight = _this.props.bodyHeight;
                                    dom_1.setCursorStyle('row-resize');
                                    document.addEventListener('mousemove', _this.handleMouseMove);
                                    document.addEventListener('mouseup', _this.clearDocumentEvents);
                                    document.addEventListener('selectstart', _this.handleSelectStart);
                                };
                                _this.handleSelectStart = function (ev) {
                                    ev.preventDefault();
                                };
                                _this.handleMouseMove = function (ev) {
                                    var distance = ev.pageY - _this.dragStartY;
                                    _this.props.dispatch('setBodyHeight', _this.dragStartBodyHeight + distance);
                                };
                                _this.clearDocumentEvents = function () {
                                    dom_1.setCursorStyle('');
                                    document.removeEventListener('mousemove', _this.handleMouseMove);
                                    document.removeEventListener('mouseup', _this.clearDocumentEvents);
                                    document.removeEventListener('selectstart', _this.handleSelectStart);
                                };
                                return _this;
                            }
                            HeightResizeHandleComp.prototype.render = function () {
                                return (preact_1.h("div", { class: dom_1.cls('height-resize-handle'), onMouseDown: this.handleMouseDown },
                                    preact_1.h("button", null,
                                        preact_1.h("span", null))));
                            };
                            return HeightResizeHandleComp;
                        }(preact_1.Component));
                        exports.HeightResizeHandle = hoc_1.connect(function (_a) {
                            var dimension = _a.dimension;
                            return ({
                                bodyHeight: dimension.bodyHeight,
                            });
                        })(HeightResizeHandleComp);


                        /***/ }),
                    /* 110 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.Clipboard = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var hoc_1 = __webpack_require__(4);
                        var dom_1 = __webpack_require__(2);
                        var keyboard_1 = __webpack_require__(17);
                        var browser_1 = __webpack_require__(50);
                        var clipboard_1 = __webpack_require__(37);
                        var common_1 = __webpack_require__(0);
                        var KEYDOWN_LOCK_TIME = 10;
                        var ClipboardComp = /** @class */ (function (_super) {
                            tslib_1.__extends(ClipboardComp, _super);
                            function ClipboardComp() {
                                var _this = _super !== null && _super.apply(this, arguments) || this;
                                _this.isLocked = false;
                                _this.lock = function () {
                                    _this.isLocked = true;
                                    setTimeout(_this.unlock.bind(_this), KEYDOWN_LOCK_TIME);
                                };
                                /**
                                 * Unlock
                                 * @private
                                 */
                                _this.unlock = function () {
                                    _this.isLocked = false;
                                };
                                _this.onBlur = function () {
                                    _this.props.dispatch('setNavigating', false);
                                };
                                _this.dispatchKeyboardEvent = function (type, command) {
                                    var dispatch = _this.props.dispatch;
                                    switch (type) {
                                        case 'move':
                                            dispatch('selectionEnd');
                                            dispatch('moveFocus', command);
                                            dispatch('setScrollToFocus');
                                            break;
                                        case 'edit':
                                            dispatch('editFocus', command);
                                            dispatch('setScrollToFocus');
                                            break;
                                        case 'select':
                                            dispatch('moveSelection', command);
                                            dispatch('setScrollToSelection');
                                            break;
                                        case 'remove':
                                            dispatch('removeContent');
                                            break;
                                        /*
                     * Call directly because of timing issues
                     * - Step 1: When the keys(ctrl+c) are downed on grid, 'clipboard' is triggered.
                     * - Step 2: When 'clipboard' event is fired,
                     *           all browsers append copied data and focus to contenteditable element and
                     *           IE browsers set selection for triggering 'copy' event.
                     * - Step 3: Finally, when 'copy' event is fired on browsers,
                     *           setting copied data to ClipboardEvent.clipboardData or window.clipboardData(IE).
                     */
                                        case 'clipboard': {
                                            if (!_this.el) {
                                                return;
                                            }
                                            var store = _this.context.store;
                                            _this.el.innerHTML = clipboard_1.getText(store);
                                            if (dom_1.isSupportWindowClipboardData()) {
                                                dom_1.setClipboardSelection(_this.el.childNodes[0]);
                                            }
                                            break;
                                        }
                                    }
                                };
                                /**
                                 * Event handler for the keydown event
                                 * @param {Event} ev - Event
                                 * @private
                                 */
                                _this.onKeyDown = function (ev) {
                                    if (_this.isLocked) {
                                        ev.preventDefault();
                                        return;
                                    }
                                    var _a = keyboard_1.keyEventGenerate(ev), type = _a.type, command = _a.command;
                                    if (!type) {
                                        return;
                                    }
                                    _this.lock();
                                    if (type !== 'clipboard') {
                                        ev.preventDefault();
                                    }
                                    if (!(type === 'clipboard' && command === 'paste')) {
                                        _this.dispatchKeyboardEvent(type, command);
                                    }
                                };
                                _this.onCopy = function (ev) {
                                    if (!_this.el) {
                                        return;
                                    }
                                    var text = _this.el.innerHTML;
                                    if (dom_1.isSupportWindowClipboardData()) {
                                        window.clipboardData.setData('Text', text);
                                    }
                                    else if (ev.clipboardData) {
                                        ev.clipboardData.setData('text/plain', text);
                                    }
                                    ev.preventDefault();
                                };
                                _this.onPaste = function (ev) {
                                    var clipboardData = ev.clipboardData || window.clipboardData;
                                    if (!clipboardData) {
                                        return;
                                    }
                                    if (!browser_1.isEdge() && !dom_1.isSupportWindowClipboardData()) {
                                        ev.preventDefault();
                                        _this.pasteInOtherBrowsers(clipboardData);
                                    }
                                    else {
                                        _this.pasteInMSBrowser(clipboardData);
                                    }
                                };
                                return _this;
                            }
                            ClipboardComp.prototype.isClipboardFocused = function () {
                                return document.hasFocus() && document.activeElement === this.el;
                            };
                            /**
                             * Paste copied data in other browsers (chrome, safari, firefox)
                             * [if] condition is copying from ms-excel,
                             * [else] condition is copying from the grid or the copied data is plain text.
                             */
                            ClipboardComp.prototype.pasteInOtherBrowsers = function (clipboardData) {
                                if (!this.el) {
                                    return;
                                }
                                var el = this.el;
                                var html = clipboardData.getData('text/html');
                                var data;
                                if (html && html.indexOf('table') !== -1) {
                                    // step 1: Append copied data on contenteditable element to parsing correctly table data.
                                    el.innerHTML = html;
                                    // step 2: Make grid data from cell data of appended table element.
                                    var rows = el.querySelector('tbody').rows;
                                    data = dom_1.convertTableToData(rows);
                                    // step 3: Empty contenteditable element to reset.
                                    el.innerHTML = '';
                                }
                                else {
                                    data = common_1.convertTextToData(clipboardData.getData('text/plain'));
                                }
                                this.props.dispatch('paste', data);
                            };
                            /**
                             * Paste copied data in MS-browsers (IE, edge)
                             */
                            ClipboardComp.prototype.pasteInMSBrowser = function (clipboardData) {
                                var _this = this;
                                var data = common_1.convertTextToData(clipboardData.getData('Text'));
                                setTimeout(function () {
                                    if (!_this.el) {
                                        return;
                                    }
                                    var el = _this.el;
                                    if (el.querySelector('table')) {
                                        var rows = el.querySelector('tbody').rows;
                                        data = dom_1.convertTableToData(rows);
                                    }
                                    _this.props.dispatch('paste', data);
                                    el.innerHTML = '';
                                }, 0);
                            };
                            ClipboardComp.prototype.componentDidUpdate = function () {
                                var _this = this;
                                setTimeout(function () {
                                    var _a = _this.props, navigating = _a.navigating, editing = _a.editing, filtering = _a.filtering;
                                    if (_this.el &&
                                        navigating &&
                                        !filtering &&
                                        !editing &&
                                        !_this.isClipboardFocused() &&
                                        !browser_1.isMobile()) {
                                        // @TODO: apply polifyll or alternative for IE, safari
                                        _this.el.focus({ preventScroll: true });
                                    }
                                });
                            };
                            ClipboardComp.prototype.render = function () {
                                var _this = this;
                                return (preact_1.h("div", { class: dom_1.cls('clipboard'), onBlur: this.onBlur, onKeyDown: this.onKeyDown, onCopy: this.onCopy, onPaste: this.onPaste, contentEditable: true, ref: function (el) {
                                        _this.el = el;
                                    } }));
                            };
                            return ClipboardComp;
                        }(preact_1.Component));
                        exports.Clipboard = hoc_1.connect(function (_a) {
                            var focus = _a.focus, filterLayerState = _a.filterLayerState;
                            return ({
                                navigating: focus.navigating,
                                editing: !!focus.editingAddress,
                                filtering: !!filterLayerState.activeColumnAddress,
                            });
                        })(ClipboardComp);


                        /***/ }),
                    /* 111 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.Pagination = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var preact_1 = __webpack_require__(3);
                        var tui_pagination_1 = tslib_1.__importDefault(__webpack_require__(112));
                        var hoc_1 = __webpack_require__(4);
                        var dom_1 = __webpack_require__(2);
                        var common_1 = __webpack_require__(0);
                        var instance_1 = __webpack_require__(7);
                        var eventBus_1 = __webpack_require__(8);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var PaginationComp = /** @class */ (function (_super) {
                            tslib_1.__extends(PaginationComp, _super);
                            function PaginationComp() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            PaginationComp.prototype.shouldComponentUpdate = function (nextProps) {
                                return !common_1.shallowEqual(this.props.pageOptions, nextProps.pageOptions);
                            };
                            PaginationComp.prototype.componentDidMount = function () {
                                this.createPagination();
                            };
                            PaginationComp.prototype.componentWillReceiveProps = function (nextProps) {
                                if (!this.el || !this.tuiPagination) {
                                    return;
                                }
                                var pageOptions = nextProps.pageOptions;
                                var totalCount = pageOptions.totalCount, page = pageOptions.page, perPage = pageOptions.perPage;
                                if (!common_1.isNumber(totalCount) || !common_1.isNumber(page) || !common_1.isNumber(perPage)) {
                                    return;
                                }
                                if (this.props.pageOptions.perPage !== perPage ||
                                    this.props.pageOptions.totalCount !== totalCount) {
                                    this.tuiPagination.setItemsPerPage(perPage);
                                    this.tuiPagination.reset(totalCount);
                                }
                                if (this.tuiPagination.getCurrentPage() !== page) {
                                    this.removeEventListener();
                                    this.tuiPagination.movePageTo(page);
                                    this.addEventListener();
                                }
                            };
                            PaginationComp.prototype.componentWillUnmount = function () {
                                if (this.tuiPagination) {
                                    this.removeEventListener();
                                }
                            };
                            PaginationComp.prototype.createPagination = function () {
                                var _a = this.props, pageOptions = _a.pageOptions, paginationHolder = _a.paginationHolder, usageStatistics = _a.grid.usageStatistics;
                                var totalCount = pageOptions.totalCount, perPage = pageOptions.perPage, page = pageOptions.page, visiblePages = pageOptions.visiblePages;
                                var options = {
                                    totalItems: totalCount,
                                    itemsPerPage: perPage,
                                    page: page,
                                    visiblePages: visiblePages,
                                    usageStatistics: usageStatistics,
                                };
                                this.tuiPagination = new tui_pagination_1.default(this.el, options);
                                this.addEventListener();
                                paginationHolder.setPagination(this.tuiPagination);
                            };
                            PaginationComp.prototype.addEventListener = function () {
                                var _a = this.props, dataProvider = _a.dataProvider, pageOptions = _a.pageOptions, dispatch = _a.dispatch, eventBus = _a.eventBus;
                                this.tuiPagination.on('beforeMove', function (ev) {
                                    var page = ev.page;
                                    var gridEvent = new gridEvent_1.default({ page: page });
                                    /**
                                     * Occurs before moving the page.
                                     * @event Grid#beforePageMove
                                     * @property {number} page - Target page number
                                     * @property {Grid} instance - Current grid instance
                                     */
                                    eventBus.trigger('beforePageMove', gridEvent);
                                    if (!gridEvent.isStopped()) {
                                        if (pageOptions.useClient) {
                                            dispatch('movePage', page);
                                        }
                                        else {
                                            dataProvider.readData(page);
                                        }
                                    }
                                });
                                this.tuiPagination.on('afterMove', function (ev) {
                                    var gridEvent = new gridEvent_1.default({ page: ev.page });
                                    /**
                                     * Occurs after moving the page.
                                     * @event Grid#afterPageMove
                                     * @property {number} page - Target page number
                                     * @property {Grid} instance - Current grid instance
                                     */
                                    eventBus.trigger('afterPageMove', gridEvent);
                                });
                            };
                            PaginationComp.prototype.removeEventListener = function () {
                                this.tuiPagination.off('beforeMove');
                                this.tuiPagination.off('afterMove');
                            };
                            PaginationComp.prototype.render = function () {
                                var _this = this;
                                return (preact_1.h("div", { ref: function (el) {
                                        _this.el = el;
                                    }, class: "tui-pagination " + dom_1.cls('pagination') }));
                            };
                            return PaginationComp;
                        }(preact_1.Component));
                        exports.Pagination = hoc_1.connect(function (_a) {
                            var id = _a.id, data = _a.data;
                            return ({
                                pageOptions: data.pageOptions,
                                dataProvider: instance_1.getDataProvider(id),
                                paginationHolder: instance_1.getPaginationManager(id),
                                grid: instance_1.getInstance(id),
                                eventBus: eventBus_1.getEventBus(id),
                            });
                        })(PaginationComp);


                        /***/ }),
                    /* 112 */
                    /***/ (function(module, exports) {

                        module.exports = __WEBPACK_EXTERNAL_MODULE__112__;

                        /***/ }),
                    /* 113 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.createDispatcher = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var viewport = tslib_1.__importStar(__webpack_require__(22));
                        var dimension = tslib_1.__importStar(__webpack_require__(45));
                        var data = tslib_1.__importStar(__webpack_require__(14));
                        var column = tslib_1.__importStar(__webpack_require__(30));
                        var keyboard = tslib_1.__importStar(__webpack_require__(114));
                        var mouse = tslib_1.__importStar(__webpack_require__(116));
                        var focus = tslib_1.__importStar(__webpack_require__(18));
                        var summary = tslib_1.__importStar(__webpack_require__(23));
                        var selection = tslib_1.__importStar(__webpack_require__(15));
                        var renderState = tslib_1.__importStar(__webpack_require__(117));
                        var tree = tslib_1.__importStar(__webpack_require__(29));
                        var sort = tslib_1.__importStar(__webpack_require__(27));
                        var filter = tslib_1.__importStar(__webpack_require__(33));
                        var pagination = tslib_1.__importStar(__webpack_require__(34));
                        var dispatchMap = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, viewport), dimension), data), column), mouse), focus), keyboard), summary), selection), renderState), tree), sort), filter), pagination);
                        function createDispatcher(store) {
                            return function dispatch(fname) {
                                var args = [];
                                for (var _i = 1; _i < arguments.length; _i++) {
                                    args[_i - 1] = arguments[_i];
                                }
                                // @ts-ignore
                                dispatchMap[fname].apply(dispatchMap, tslib_1.__spreadArrays([store], args));
                            };
                        }
                        exports.createDispatcher = createDispatcher;


                        /***/ }),
                    /* 114 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.updateDataByKeyMap = exports.paste = exports.removeContent = exports.moveSelection = exports.moveTabFocus = exports.editFocus = exports.moveFocus = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var keyboard_1 = __webpack_require__(115);
                        var focus_1 = __webpack_require__(18);
                        var selection_1 = __webpack_require__(15);
                        var column_1 = __webpack_require__(10);
                        var rowSpan_1 = __webpack_require__(11);
                        var instance_1 = __webpack_require__(7);
                        var eventBus_1 = __webpack_require__(8);
                        var gridEvent_1 = tslib_1.__importDefault(__webpack_require__(9));
                        var data_1 = __webpack_require__(6);
                        var validation_1 = __webpack_require__(24);
                        var clipboard_1 = __webpack_require__(37);
                        var common_1 = __webpack_require__(0);
                        var summary_1 = __webpack_require__(23);
                        function moveFocus(store, command) {
                            var focus = store.focus, data = store.data, visibleColumnsWithRowHeader = store.column.visibleColumnsWithRowHeader, id = store.id;
                            var rowIndex = focus.rowIndex, columnIndex = focus.totalColumnIndex;
                            if (rowIndex === null || columnIndex === null) {
                                return;
                            }
                            var _a = keyboard_1.getNextCellIndex(store, command, [rowIndex, columnIndex]), nextRowIndex = _a[0], nextColumnIndex = _a[1];
                            var nextColumnName = visibleColumnsWithRowHeader[nextColumnIndex].name;
                            if (!column_1.isRowHeader(nextColumnName)) {
                                focus.navigating = true;
                                focus_1.changeFocus(store, data_1.getRowKeyByIndexWithPageRange(data, nextRowIndex), nextColumnName, id);
                            }
                        }
                        exports.moveFocus = moveFocus;
                        function editFocus(store, command) {
                            var _a = store.focus, rowKey = _a.rowKey, columnName = _a.columnName;
                            if (rowKey === null || columnName === null) {
                                return;
                            }
                            if (command === 'currentCell') {
                                focus_1.startEditing(store, rowKey, columnName);
                            }
                            else if (command === 'nextCell' || command === 'prevCell') {
                                // move prevCell or nextCell by tab keyMap
                                moveTabFocus(store, command);
                            }
                        }
                        exports.editFocus = editFocus;
                        function moveTabFocus(store, command) {
                            var focus = store.focus, data = store.data, column = store.column, id = store.id;
                            var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader;
                            var rowKey = focus.rowKey, columnName = focus.columnName, rowIndex = focus.rowIndex, columnIndex = focus.totalColumnIndex;
                            if (rowKey === null || columnName === null || rowIndex === null || columnIndex === null) {
                                return;
                            }
                            var _a = keyboard_1.getNextCellIndex(store, command, [rowIndex, columnIndex]), nextRowIndex = _a[0], nextColumnIndex = _a[1];
                            var nextRowKey = data_1.getRowKeyByIndexWithPageRange(data, nextRowIndex);
                            var nextColumnName = visibleColumnsWithRowHeader[nextColumnIndex].name;
                            if (!column_1.isRowHeader(nextColumnName)) {
                                focus.navigating = true;
                                focus_1.changeFocus(store, nextRowKey, nextColumnName, id);
                                if (focus.tabMode === 'moveAndEdit' &&
                                    focus.rowKey === nextRowKey &&
                                    focus.columnName === nextColumnName) {
                                    setTimeout(function () {
                                        focus_1.startEditing(store, nextRowKey, nextColumnName);
                                    });
                                }
                            }
                        }
                        exports.moveTabFocus = moveTabFocus;
                        function moveSelection(store, command) {
                            var _a;
                            var selection = store.selection, focus = store.focus, data = store.data, _b = store.column, visibleColumnsWithRowHeader = _b.visibleColumnsWithRowHeader, rowHeaderCount = _b.rowHeaderCount, id = store.id;
                            var filteredViewData = data.filteredViewData, sortState = data.sortState;
                            var focusRowIndex = focus.rowIndex, totalFocusColumnIndex = focus.totalColumnIndex;
                            var currentInputRange = selection.inputRange;
                            if (focusRowIndex === null || totalFocusColumnIndex === null) {
                                return;
                            }
                            if (!currentInputRange) {
                                currentInputRange = selection.inputRange = {
                                    row: [focusRowIndex, focusRowIndex],
                                    column: [totalFocusColumnIndex, totalFocusColumnIndex],
                                };
                            }
                            var rowLength = filteredViewData.length;
                            var columnLength = visibleColumnsWithRowHeader.length;
                            var rowStartIndex = currentInputRange.row[0];
                            var rowIndex = currentInputRange.row[1];
                            var columnStartIndex = currentInputRange.column[0];
                            var columnIndex = currentInputRange.column[1];
                            var nextCellIndexes;
                            if (command === 'all') {
                                rowStartIndex = 0;
                                columnStartIndex = rowHeaderCount;
                                nextCellIndexes = [rowLength - 1, columnLength - 1];
                            }
                            else {
                                nextCellIndexes = keyboard_1.getNextCellIndex(store, command, [rowIndex, columnIndex]);
                                if (rowSpan_1.isRowSpanEnabled(sortState)) {
                                    nextCellIndexes = keyboard_1.getNextCellIndexWithRowSpan(store, command, rowIndex, [columnStartIndex, columnIndex], nextCellIndexes);
                                }
                            }
                            var nextRowIndex = nextCellIndexes[0], nextColumnIndex = nextCellIndexes[1];
                            var nextColumnName = visibleColumnsWithRowHeader[nextColumnIndex].name;
                            var startRowIndex = rowStartIndex;
                            var endRowIndex = nextRowIndex;
                            if (command !== 'all') {
                                _a = rowSpan_1.getRowRangeWithRowSpan([startRowIndex, endRowIndex], [columnStartIndex, nextColumnIndex], visibleColumnsWithRowHeader, focus.rowIndex, data), startRowIndex = _a[0], endRowIndex = _a[1];
                            }
                            if (!column_1.isRowHeader(nextColumnName)) {
                                var inputRange = {
                                    row: [startRowIndex, endRowIndex],
                                    column: [columnStartIndex, nextColumnIndex],
                                };
                                selection_1.changeSelectionRange(selection, inputRange, id);
                            }
                        }
                        exports.moveSelection = moveSelection;
                        function removeContent(store) {
                            var column = store.column, data = store.data;
                            var range = keyboard_1.getRemoveRange(store);
                            if (!range) {
                                return;
                            }
                            var _a = range.column, columnStart = _a[0], columnEnd = _a[1], _b = range.row, rowStart = _b[0], rowEnd = _b[1];
                            var changeValueFns = [];
                            var prevChanges = [];
                            var nextChanges = [];
                            data.filteredRawData.slice(rowStart, rowEnd + 1).forEach(function (row, index) {
                                column.visibleColumnsWithRowHeader.slice(columnStart, columnEnd + 1).forEach(function (_a) {
                                    var name = _a.name;
                                    var rowIndex = index + rowStart;
                                    if (data_1.isEditableCell(data, column, rowIndex, name)) {
                                        var _b = data_1.createChangeInfo(store, row, name, '', rowIndex), prevChange = _b.prevChange, nextChange = _b.nextChange, changeValue = _b.changeValue;
                                        prevChanges.push(prevChange);
                                        nextChanges.push(nextChange);
                                        changeValueFns.push(changeValue);
                                    }
                                });
                            });
                            updateDataByKeyMap(store, 'delete', { prevChanges: prevChanges, nextChanges: nextChanges, changeValueFns: changeValueFns });
                        }
                        exports.removeContent = removeContent;
                        function applyCopiedData(store, copiedData, range) {
                            var data = store.data, column = store.column;
                            var filteredRawData = data.filteredRawData, filteredViewData = data.filteredViewData;
                            var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader;
                            var _a = range.row, startRowIndex = _a[0], endRowIndex = _a[1], _b = range.column, startColumnIndex = _b[0], endColumnIndex = _b[1];
                            var columnNames = common_1.mapProp('name', visibleColumnsWithRowHeader);
                            var changeValueFns = [];
                            var prevChanges = [];
                            var nextChanges = [];
                            for (var rowIndex = 0; rowIndex + startRowIndex <= endRowIndex; rowIndex += 1) {
                                var rawRowIndex = rowIndex + startRowIndex;
                                for (var columnIndex = 0; columnIndex + startColumnIndex <= endColumnIndex; columnIndex += 1) {
                                    var name = columnNames[columnIndex + startColumnIndex];
                                    if (filteredViewData.length && data_1.isEditableCell(data, column, rawRowIndex, name)) {
                                        var targetRow = filteredRawData[rawRowIndex];
                                        var _c = data_1.createChangeInfo(store, targetRow, name, copiedData[rowIndex][columnIndex], rawRowIndex), prevChange = _c.prevChange, nextChange = _c.nextChange, changeValue = _c.changeValue;
                                        prevChanges.push(prevChange);
                                        nextChanges.push(nextChange);
                                        changeValueFns.push(changeValue);
                                        summary_1.updateSummaryValueByCell(store, name, {
                                            orgValue: targetRow[name],
                                            value: copiedData[rowIndex][columnIndex],
                                        });
                                    }
                                }
                            }
                            updateDataByKeyMap(store, 'paste', { prevChanges: prevChanges, nextChanges: nextChanges, changeValueFns: changeValueFns });
                        }
                        function paste(store, copiedData) {
                            var selection = store.selection, id = store.id;
                            var originalRange = selection.originalRange;
                            if (originalRange) {
                                copiedData = clipboard_1.copyDataToRange(originalRange, copiedData);
                            }
                            var rangeToPaste = clipboard_1.getRangeToPaste(store, copiedData);
                            applyCopiedData(store, copiedData, rangeToPaste);
                            selection_1.changeSelectionRange(selection, rangeToPaste, id);
                        }
                        exports.paste = paste;
                        function updateDataByKeyMap(store, origin, changeInfo) {
                            var id = store.id, data = store.data, column = store.column;
                            var rawData = data.rawData, filteredRawData = data.filteredRawData;
                            var prevChanges = changeInfo.prevChanges, nextChanges = changeInfo.nextChanges, changeValueFns = changeInfo.changeValueFns;
                            var eventBus = eventBus_1.getEventBus(id);
                            var manager = instance_1.getDataManager(id);
                            var gridEvent = new gridEvent_1.default({ origin: origin, changes: prevChanges });
                            /**
                             * Occurs before one or more cells is changed
                             * @event Grid#beforeChange
                             * @property {string} origin - The type of change('paste', 'delete', 'cell')
                             * @property {Array.<object>} changes - rowKey, column name, original values and next values before changing the values
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('beforeChange', gridEvent);
                            if (gridEvent.isStopped()) {
                                return;
                            }
                            var index = null;
                            changeValueFns.forEach(function (changeValue) {
                                var targetRowIndex = changeValue();
                                if (index !== targetRowIndex) {
                                    index = targetRowIndex;
                                    manager.push('UPDATE', filteredRawData[index]);
                                }
                            });
                            validation_1.forceValidateUniquenessOfColumns(rawData, column);
                            gridEvent = new gridEvent_1.default({ origin: origin, changes: nextChanges });
                            /**
                             * Occurs after one or more cells is changed
                             * @event Grid#afterChange
                             * @property {string} origin - The type of change('paste', 'delete', 'cell')
                             * @property {Array.<object>} changes - rowKey, column name, previous values and changed values after changing the values
                             * @property {Grid} instance - Current grid instance
                             */
                            eventBus.trigger('afterChange', gridEvent);
                        }
                        exports.updateDataByKeyMap = updateDataByKeyMap;


                        /***/ }),
                    /* 115 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getNextCellIndexWithRowSpan = exports.getRemoveRange = exports.getNextCellIndex = void 0;
                        var common_1 = __webpack_require__(0);
                        var rowSpan_1 = __webpack_require__(11);
                        var selection_1 = __webpack_require__(19);
                        var data_1 = __webpack_require__(6);
                        function getPrevRowIndex(rowIndex, heights) {
                            var index = rowIndex;
                            while (index > 0) {
                                index -= 1;
                                if (heights[index]) {
                                    break;
                                }
                            }
                            return index;
                        }
                        function getNextRowIndex(rowIndex, heights) {
                            var index = rowIndex;
                            while (index < heights.length - 1) {
                                index += 1;
                                if (heights[index]) {
                                    break;
                                }
                            }
                            return index;
                        }
                        function getNextCellIndex(store, command, _a) {
                            var rowIndex = _a[0], columnIndex = _a[1];
                            var data = store.data, _b = store.column, visibleColumnsWithRowHeader = _b.visibleColumnsWithRowHeader, rowHeaderCount = _b.rowHeaderCount, heights = store.rowCoords.heights;
                            var sortState = data.sortState, filteredRawData = data.filteredRawData, pageRowRange = data.pageRowRange;
                            var lastRowIndex = (data_1.isClientPagination(data) ? pageRowRange[1] - pageRowRange[0] : filteredRawData.length) - 1;
                            var columnName = visibleColumnsWithRowHeader[columnIndex].name;
                            var lastRow = lastRowIndex === rowIndex;
                            var lastColumn = visibleColumnsWithRowHeader.length - 1 === columnIndex;
                            var firstRow = rowIndex === 0;
                            var firstColumn = columnIndex === rowHeaderCount;
                            switch (command) {
                                case 'up':
                                    if (rowSpan_1.isRowSpanEnabled(sortState)) {
                                        rowIndex = rowSpan_1.getRowSpanTopIndex(rowIndex, columnName, filteredRawData);
                                    }
                                    rowIndex = getPrevRowIndex(rowIndex, heights);
                                    break;
                                case 'down':
                                    if (rowSpan_1.isRowSpanEnabled(sortState)) {
                                        rowIndex = rowSpan_1.getRowSpanBottomIndex(rowIndex, columnName, filteredRawData);
                                    }
                                    rowIndex = getNextRowIndex(rowIndex, heights);
                                    break;
                                case 'left':
                                    columnIndex -= 1;
                                    break;
                                case 'right':
                                    columnIndex += 1;
                                    break;
                                case 'firstCell':
                                    columnIndex = rowHeaderCount;
                                    rowIndex = 0;
                                    break;
                                case 'lastCell':
                                    columnIndex = visibleColumnsWithRowHeader.length - 1;
                                    rowIndex = lastRowIndex;
                                    break;
                                case 'pageUp': {
                                    rowIndex = 0;
                                    break;
                                }
                                case 'pageDown': {
                                    rowIndex = lastRowIndex;
                                    break;
                                }
                                case 'firstColumn':
                                    columnIndex = rowHeaderCount;
                                    break;
                                case 'lastColumn':
                                    columnIndex = visibleColumnsWithRowHeader.length - 1;
                                    break;
                                case 'nextCell':
                                    if (lastRow && lastColumn) {
                                        break;
                                    }
                                    if (lastColumn) {
                                        if (rowSpan_1.isRowSpanEnabled(sortState)) {
                                            rowIndex = rowSpan_1.getRowSpanBottomIndex(rowIndex, columnName, filteredRawData);
                                        }
                                        rowIndex = getNextRowIndex(rowIndex, heights);
                                        columnIndex = rowHeaderCount;
                                    }
                                    else {
                                        columnIndex += 1;
                                    }
                                    break;
                                case 'prevCell':
                                    if (firstRow && firstColumn) {
                                        break;
                                    }
                                    if (firstColumn) {
                                        if (rowSpan_1.isRowSpanEnabled(sortState)) {
                                            rowIndex = rowSpan_1.getRowSpanTopIndex(rowIndex, columnName, filteredRawData);
                                        }
                                        rowIndex = getPrevRowIndex(rowIndex, heights);
                                        columnIndex = visibleColumnsWithRowHeader.length - 1;
                                    }
                                    else {
                                        columnIndex -= 1;
                                    }
                                    break;
                            }
                            rowIndex = common_1.clamp(rowIndex, 0, lastRowIndex);
                            columnIndex = common_1.clamp(columnIndex, 0, visibleColumnsWithRowHeader.length - 1);
                            return [rowIndex, columnIndex];
                        }
                        exports.getNextCellIndex = getNextCellIndex;
                        function getRemoveRange(store) {
                            var focus = store.focus, selection = store.selection;
                            var totalColumnIndex = focus.totalColumnIndex, originalRowIndex = focus.originalRowIndex;
                            var originalRange = selection.originalRange;
                            if (originalRange) {
                                return originalRange;
                            }
                            if (!common_1.isNull(totalColumnIndex) && !common_1.isNull(originalRowIndex)) {
                                return {
                                    column: [totalColumnIndex, totalColumnIndex],
                                    row: [originalRowIndex, originalRowIndex],
                                };
                            }
                            return null;
                        }
                        exports.getRemoveRange = getRemoveRange;
                        function getNextCellIndexWithRowSpan(store, command, currentRowIndex, columnRange, cellIndexes) {
                            var rowIndex = cellIndexes[0];
                            var columnIndex = cellIndexes[1];
                            var _a = selection_1.getSortedRange(columnRange), startColumnIndex = _a[0], endColumnIndex = _a[1];
                            for (var index = startColumnIndex; index <= endColumnIndex; index += 1) {
                                var nextRowIndex = getNextCellIndex(store, command, [currentRowIndex, index])[0];
                                if ((command === 'up' && nextRowIndex < rowIndex) ||
                                    (command === 'down' && nextRowIndex > rowIndex)) {
                                    rowIndex = nextRowIndex;
                                }
                            }
                            return [rowIndex, columnIndex];
                        }
                        exports.getNextCellIndexWithRowSpan = getNextCellIndexWithRowSpan;


                        /***/ }),
                    /* 116 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.dragMoveRowHeader = exports.mouseDownRowHeader = exports.dragMoveHeader = exports.mouseDownHeader = exports.mouseDownBody = exports.dragEnd = exports.dragMoveBody = exports.selectionEnd = exports.setNavigating = void 0;
                        var common_1 = __webpack_require__(0);
                        var column_1 = __webpack_require__(10);
                        var focus_1 = __webpack_require__(18);
                        var selection_1 = __webpack_require__(15);
                        var rowSpan_1 = __webpack_require__(11);
                        var selection_2 = __webpack_require__(19);
                        var data_1 = __webpack_require__(6);
                        var mouse_1 = __webpack_require__(51);
                        function stopAutoScroll(selection) {
                            var intervalIdForAutoScroll = selection.intervalIdForAutoScroll;
                            if (intervalIdForAutoScroll !== null) {
                                clearInterval(intervalIdForAutoScroll);
                                selection.intervalIdForAutoScroll = null;
                            }
                        }
                        function isAutoScrollable(overflowX, overflowY) {
                            return !(overflowX === 0 && overflowY === 0);
                        }
                        function adjustScrollLeft(overflowX, viewport) {
                            var scrollPixelScale = viewport.scrollPixelScale, scrollLeft = viewport.scrollLeft, maxScrollLeft = viewport.maxScrollLeft;
                            if (overflowX < 0) {
                                viewport.scrollLeft = Math.max(0, scrollLeft - scrollPixelScale);
                            }
                            else if (overflowX > 0) {
                                viewport.scrollLeft = Math.min(maxScrollLeft, scrollLeft + scrollPixelScale);
                            }
                        }
                        function adjustScrollTop(overflowY, viewport) {
                            var scrollTop = viewport.scrollTop, maxScrollTop = viewport.maxScrollTop, scrollPixelScale = viewport.scrollPixelScale;
                            if (overflowY < 0) {
                                viewport.scrollTop = Math.max(0, scrollTop - scrollPixelScale);
                            }
                            else if (overflowY > 0) {
                                viewport.scrollTop = Math.min(maxScrollTop, scrollTop + scrollPixelScale);
                            }
                        }
                        function adjustScroll(viewport, overflow) {
                            if (overflow.x) {
                                adjustScrollLeft(overflow.x, viewport);
                            }
                            if (overflow.y) {
                                adjustScrollTop(overflow.y, viewport);
                            }
                        }
                        function setScrolling(_a, bodyWidth, selection, dimension, viewport) {
                            var pageX = _a.pageX, pageY = _a.pageY;
                            var overflow = mouse_1.getOverflowFromMousePosition(pageX, pageY, bodyWidth, dimension);
                            stopAutoScroll(selection);
                            if (isAutoScrollable(overflow.x, overflow.y)) {
                                selection.intervalIdForAutoScroll = setInterval(adjustScroll.bind(null, viewport, overflow));
                            }
                        }
                        function setNavigating(_a, navigating) {
                            var focus = _a.focus;
                            focus.navigating = navigating;
                        }
                        exports.setNavigating = setNavigating;
                        function selectionEnd(_a) {
                            var selection = _a.selection;
                            selection.inputRange = null;
                        }
                        exports.selectionEnd = selectionEnd;
                        function updateSelection(store, dragData) {
                            var _a;
                            var viewport = store.viewport, selection = store.selection, column = store.column, id = store.id, data = store.data, focus = store.focus;
                            var scrollTop = viewport.scrollTop, scrollLeft = viewport.scrollLeft;
                            var pageX = dragData.pageX, pageY = dragData.pageY;
                            var curInputRange = selection.inputRange;
                            var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader;
                            var startRowIndex, startColumnIndex, endRowIndex;
                            var viewInfo = { pageX: pageX, pageY: pageY, scrollTop: scrollTop, scrollLeft: scrollLeft };
                            var endColumnIndex = mouse_1.findColumnIndexByPosition(store, viewInfo);
                            endRowIndex = mouse_1.findRowIndexByPosition(store, viewInfo);
                            if (curInputRange === null) {
                                var totalColumnIndex = focus.totalColumnIndex, rowIndex = focus.rowIndex;
                                startColumnIndex = totalColumnIndex;
                                startRowIndex = rowIndex;
                            }
                            else {
                                startRowIndex = curInputRange.row[0];
                                startColumnIndex = curInputRange.column[0];
                            }
                            if (startColumnIndex < 0 || endColumnIndex < 0 || startRowIndex < 0 || endRowIndex < 0) {
                                return;
                            }
                            _a = rowSpan_1.getRowRangeWithRowSpan([startRowIndex, endRowIndex], [startColumnIndex, endColumnIndex], visibleColumnsWithRowHeader, store.focus.rowIndex, data), startRowIndex = _a[0], endRowIndex = _a[1];
                            var inputRange = {
                                row: [startRowIndex, endRowIndex],
                                column: [startColumnIndex, endColumnIndex],
                            };
                            selection_1.changeSelectionRange(selection, inputRange, id);
                        }
                        function finishEditingByHeaderSelection(store, rowKey, columnName) {
                            var editingAddress = store.focus.editingAddress;
                            if (editingAddress) {
                                if (editingAddress.rowKey === rowKey && editingAddress.columnName === columnName) {
                                    focus_1.saveAndFinishEditing(store);
                                }
                            }
                        }
                        function dragMoveBody(store, dragStartData, dragData, elementInfo) {
                            var dimension = store.dimension, columnCoords = store.columnCoords, selection = store.selection, viewport = store.viewport;
                            var areaWidth = columnCoords.areaWidth;
                            var _a = mouse_1.getColumnNameRange(store, dragStartData, dragData, elementInfo), startColumnName = _a[0], endColumnName = _a[1];
                            if (!column_1.isRowHeader(startColumnName) && !column_1.isRowHeader(endColumnName)) {
                                updateSelection(store, dragData);
                                setScrolling(dragData, areaWidth.L + areaWidth.R, selection, dimension, viewport);
                            }
                        }
                        exports.dragMoveBody = dragMoveBody;
                        function dragEnd(_a) {
                            var selection = _a.selection;
                            stopAutoScroll(selection);
                        }
                        exports.dragEnd = dragEnd;
                        function mouseDownBody(store, elementInfo, eventInfo) {
                            var data = store.data, column = store.column, columnCoords = store.columnCoords, rowCoords = store.rowCoords, id = store.id;
                            var filteredRawData = data.filteredRawData;
                            if (!filteredRawData.length) {
                                return;
                            }
                            var pageX = eventInfo.pageX, pageY = eventInfo.pageY, shiftKey = eventInfo.shiftKey;
                            var visibleColumnsBySideWithRowHeader = column.visibleColumnsBySideWithRowHeader;
                            var side = elementInfo.side, scrollLeft = elementInfo.scrollLeft, scrollTop = elementInfo.scrollTop, left = elementInfo.left, top = elementInfo.top;
                            var offsetLeft = pageX - left + scrollLeft;
                            var offsetTop = pageY - top + scrollTop;
                            var columnIndex = common_1.findOffsetIndex(columnCoords.offsets[side], offsetLeft);
                            var columnName = visibleColumnsBySideWithRowHeader[side][columnIndex].name;
                            if (!column_1.isRowHeader(columnName)) {
                                if (shiftKey) {
                                    var dragData = { pageX: pageX, pageY: pageY };
                                    updateSelection(store, dragData);
                                }
                                else {
                                    var rowIndex = common_1.findOffsetIndex(rowCoords.offsets, offsetTop);
                                    selectionEnd(store);
                                    focus_1.changeFocus(store, data_1.getRowKeyByIndexWithPageRange(data, rowIndex), columnName, id);
                                }
                            }
                        }
                        exports.mouseDownBody = mouseDownBody;
                        function mouseDownHeader(store, name, parentHeader) {
                            var _a;
                            var data = store.data, selection = store.selection, id = store.id, column = store.column, rowCoords = store.rowCoords;
                            var filteredRawData = data.filteredRawData;
                            if (!filteredRawData.length) {
                                return;
                            }
                            var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader, complexColumnHeaders = column.complexColumnHeaders;
                            var endRowIndex = rowCoords.heights.length - 1;
                            var startColumnIndex, endColumnIndex, columnName;
                            if (parentHeader) {
                                _a = selection_2.getChildColumnRange(visibleColumnsWithRowHeader, complexColumnHeaders, name), startColumnIndex = _a[0], endColumnIndex = _a[1];
                                columnName = visibleColumnsWithRowHeader[startColumnIndex].name;
                            }
                            else {
                                startColumnIndex = endColumnIndex = common_1.findPropIndex('name', name, visibleColumnsWithRowHeader);
                                columnName = name;
                            }
                            var inputRange = {
                                row: [0, endRowIndex],
                                column: [startColumnIndex, endColumnIndex],
                            };
                            var rowKey = data_1.getRowKeyByIndexWithPageRange(data, 0);
                            finishEditingByHeaderSelection(store, rowKey, columnName);
                            focus_1.changeFocus(store, rowKey, columnName, id);
                            selection_1.changeSelectionRange(selection, inputRange, id);
                        }
                        exports.mouseDownHeader = mouseDownHeader;
                        function dragMoveHeader(store, dragData, startSelectedName) {
                            var dimension = store.dimension, viewport = store.viewport, columnCoords = store.columnCoords, selection = store.selection, column = store.column, id = store.id;
                            var scrollTop = viewport.scrollTop, scrollLeft = viewport.scrollLeft;
                            var areaWidth = columnCoords.areaWidth;
                            var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader, complexColumnHeaders = column.complexColumnHeaders;
                            var pageX = dragData.pageX, pageY = dragData.pageY;
                            var curInputRange = selection.inputRange;
                            if (common_1.isNull(curInputRange)) {
                                return;
                            }
                            var _a = selection_2.getChildColumnRange(visibleColumnsWithRowHeader, complexColumnHeaders, startSelectedName), startColumnIdx = _a[0], endColumnIdx = _a[1];
                            var viewInfo = { pageX: pageX, pageY: pageY, scrollTop: scrollTop, scrollLeft: scrollLeft };
                            var columnIndex = mouse_1.findColumnIndexByPosition(store, viewInfo);
                            var rowIndex = curInputRange.row[1];
                            if (columnIndex < startColumnIdx) {
                                startColumnIdx = columnIndex;
                            }
                            if (columnIndex > endColumnIdx) {
                                endColumnIdx = columnIndex;
                            }
                            if (columnIndex >= 0) {
                                var inputRange = {
                                    row: [0, rowIndex],
                                    column: [startColumnIdx, endColumnIdx],
                                };
                                selection_1.changeSelectionRange(selection, inputRange, id);
                                setScrolling(dragData, areaWidth.L + areaWidth.R, selection, dimension, viewport);
                            }
                        }
                        exports.dragMoveHeader = dragMoveHeader;
                        function mouseDownRowHeader(store, rowKey) {
                            var selection = store.selection, id = store.id, column = store.column, data = store.data;
                            var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader, rowHeaderCount = column.rowHeaderCount;
                            var rowIndex = data_1.findIndexByRowKey(data, column, id, rowKey);
                            var rowIndexPerPage = data_1.getRowIndexPerPage(data, rowIndex);
                            var endColumnIndex = visibleColumnsWithRowHeader.length - 1;
                            var _a = rowSpan_1.getRowRangeWithRowSpan([rowIndexPerPage, rowIndexPerPage], [rowHeaderCount, endColumnIndex], visibleColumnsWithRowHeader, null, data), startRowIndex = _a[0], endRowIndex = _a[1];
                            var inputRange = {
                                row: [startRowIndex, endRowIndex],
                                column: [rowHeaderCount, endColumnIndex],
                            };
                            var editingRowKey = data.filteredRawData[rowIndex].rowKey;
                            var editingColumnName = visibleColumnsWithRowHeader[rowHeaderCount].name;
                            finishEditingByHeaderSelection(store, editingRowKey, editingColumnName);
                            focus_1.changeFocus(store, editingRowKey, editingColumnName, id);
                            selection_1.changeSelectionRange(selection, inputRange, id);
                        }
                        exports.mouseDownRowHeader = mouseDownRowHeader;
                        function dragMoveRowHeader(store, dragData) {
                            var _a;
                            var viewport = store.viewport, selection = store.selection, id = store.id, data = store.data, column = store.column;
                            var scrollTop = viewport.scrollTop, scrollLeft = viewport.scrollLeft;
                            var visibleColumnsWithRowHeader = column.visibleColumnsWithRowHeader, rowHeaderCount = column.rowHeaderCount;
                            var pageX = dragData.pageX, pageY = dragData.pageY;
                            var curInputRange = selection.inputRange;
                            if (curInputRange === null) {
                                return;
                            }
                            var viewInfo = { pageX: pageX, pageY: pageY, scrollTop: scrollTop, scrollLeft: scrollLeft };
                            var columnIndex = curInputRange.column[1];
                            var startRowIndex = curInputRange.row[0];
                            var endRowIndex = mouse_1.findRowIndexByPosition(store, viewInfo);
                            _a = rowSpan_1.getRowRangeWithRowSpan([startRowIndex, endRowIndex], [rowHeaderCount, columnIndex], visibleColumnsWithRowHeader, null, data), startRowIndex = _a[0], endRowIndex = _a[1];
                            var inputRange = {
                                row: [startRowIndex, endRowIndex],
                                column: [rowHeaderCount, columnIndex],
                            };
                            selection_1.changeSelectionRange(selection, inputRange, id);
                        }
                        exports.dragMoveRowHeader = dragMoveRowHeader;


                        /***/ }),
                    /* 117 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.refreshRowHeight = exports.removeCellHeight = exports.setCellHeight = exports.setHoveredRowKeyByPosition = exports.setHoveredRowKey = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var observable_1 = __webpack_require__(5);
                        var mouse_1 = __webpack_require__(51);
                        var common_1 = __webpack_require__(0);
                        function setHoveredRowKey(_a, rowKey) {
                            var renderState = _a.renderState;
                            renderState.hoveredRowKey = rowKey;
                        }
                        exports.setHoveredRowKey = setHoveredRowKey;
                        function setHoveredRowKeyByPosition(store, viewInfo) {
                            var renderState = store.renderState, data = store.data, viewport = store.viewport;
                            var scrollLeft = viewport.scrollLeft, scrollTop = viewport.scrollTop;
                            var rowIndex = mouse_1.findRowIndexByPosition(store, tslib_1.__assign(tslib_1.__assign({}, viewInfo), { scrollLeft: scrollLeft, scrollTop: scrollTop }));
                            var rowKey = data.filteredRawData[rowIndex].rowKey;
                            if (renderState.hoveredRowKey !== rowKey) {
                                setHoveredRowKey(store, rowKey);
                            }
                        }
                        exports.setHoveredRowKeyByPosition = setHoveredRowKeyByPosition;
                        function setCellHeight(_a, columnName, rowIndex, height, defaultRowHeight) {
                            var renderState = _a.renderState;
                            var cellHeightMap = renderState.cellHeightMap;
                            if (!cellHeightMap[rowIndex]) {
                                cellHeightMap[rowIndex] = {};
                            }
                            cellHeightMap[rowIndex][columnName] = Math.max(height, defaultRowHeight);
                        }
                        exports.setCellHeight = setCellHeight;
                        function removeCellHeight(_a, rowIndex) {
                            var renderState = _a.renderState;
                            var cellHeightMap = renderState.cellHeightMap;
                            delete cellHeightMap[rowIndex];
                        }
                        exports.removeCellHeight = removeCellHeight;
                        function refreshRowHeight(store, rowIndex, rowHeight) {
                            var data = store.data, rowCoords = store.rowCoords, renderState = store.renderState;
                            var cellHeightMap = renderState.cellHeightMap;
                            var cellHeights = cellHeightMap[rowIndex];
                            if (common_1.isUndefined(cellHeights)) {
                                return;
                            }
                            var highestHeight = Object.keys(cellHeights).reduce(function (acc, columnName) { return Math.max(acc, cellHeights[columnName]); }, -1);
                            if (rowHeight !== highestHeight) {
                                data.rawData[rowIndex]._attributes.height = highestHeight;
                                rowCoords.heights[rowIndex] = highestHeight;
                                observable_1.notify(rowCoords, 'heights');
                            }
                        }
                        exports.refreshRowHeight = refreshRowHeight;


                        /***/ }),
                    /* 118 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        var tslib_1 = __webpack_require__(1);
                        var preset_1 = __webpack_require__(119);
                        var common_1 = __webpack_require__(0);
                        var dom_1 = __webpack_require__(2);
                        var styleGen = tslib_1.__importStar(__webpack_require__(120));
                        var STYLE_ELEMENT_ID = 'tui-grid-theme-style';
                        var presetOptions = {
                            default: preset_1.presetDefault,
                            striped: preset_1.striped,
                            clean: preset_1.clean,
                        };
                        var styleGenMethodMap = {
                            outline: styleGen.outline,
                            frozenBorder: styleGen.frozenBorder,
                            scrollbar: styleGen.scrollbar,
                            heightResizeHandle: styleGen.heightResizeHandle,
                            pagination: styleGen.pagination,
                            selection: styleGen.selection,
                        };
                        var styleGenAreaMethodMap = {
                            header: styleGen.headerArea,
                            body: styleGen.bodyArea,
                            summary: styleGen.summaryArea,
                        };
                        var styleGenRowMethodMap = {
                            odd: styleGen.rowOdd,
                            even: styleGen.rowEven,
                            dummy: styleGen.rowDummy,
                            hover: styleGen.rowHover,
                        };
                        var styleGenCellMethodMap = {
                            normal: styleGen.cell,
                            editable: styleGen.cellEditable,
                            header: styleGen.cellHeader,
                            rowHeader: styleGen.cellRowHeader,
                            summary: styleGen.cellSummary,
                            required: styleGen.cellRequired,
                            disabled: styleGen.cellDisabled,
                            invalid: styleGen.cellInvalid,
                            selectedHeader: styleGen.cellSelectedHeader,
                            selectedRowHeader: styleGen.cellSelectedRowHeader,
                            focused: styleGen.cellFocused,
                            focusedInactive: styleGen.cellFocusedInactive,
                            // deprecate
                            oddRow: styleGen.rowOdd,
                            evenRow: styleGen.rowEven,
                            currentRow: styleGen.cellCurrentRow,
                            dummy: styleGen.rowDummy,
                        };
                        function buildCssString(options) {
                            var area = options.area, cell = options.cell, row = options.row;
                            var styles = [];
                            Object.keys(styleGenMethodMap).forEach(function (key) {
                                var keyWithType = key;
                                var value = options[keyWithType];
                                if (value) {
                                    var fn = styleGen[keyWithType];
                                    styles.push(fn(value));
                                }
                            });
                            if (area) {
                                Object.keys(styleGenAreaMethodMap).forEach(function (key) {
                                    var keyWithType = key;
                                    var value = area[keyWithType];
                                    if (value) {
                                        var fn = styleGenAreaMethodMap[keyWithType];
                                        styles.push(fn(value));
                                    }
                                });
                            }
                            if (cell) {
                                Object.keys(styleGenCellMethodMap).forEach(function (key) {
                                    var keyWithType = key;
                                    var value = cell[keyWithType];
                                    if (value) {
                                        var fn = styleGenCellMethodMap[keyWithType];
                                        styles.push(fn(value));
                                    }
                                });
                            }
                            if (row) {
                                // Written later to override the row style in cell style
                                Object.keys(styleGenRowMethodMap).forEach(function (key) {
                                    var keyWithType = key;
                                    var value = row[keyWithType];
                                    if (value) {
                                        var fn = styleGenRowMethodMap[keyWithType];
                                        styles.push(fn(value));
                                    }
                                });
                            }
                            return styles.join('');
                        }
                        function setDocumentStyle(options) {
                            var cssString = buildCssString(options);
                            var elem = document.getElementById(STYLE_ELEMENT_ID);
                            if (elem && elem.parentNode) {
                                elem.parentNode.removeChild(elem);
                            }
                            dom_1.appendStyleElement(STYLE_ELEMENT_ID, cssString);
                        }
                        exports.default = {
                            /**
                             * Creates a style element using theme options identified by given name,
                             * and appends it to the document.
                             * @param themeName - preset theme name
                             * @param extOptions - if exist, extend preset theme options with it.
                             */
                            apply: function (themeName, extOptions) {
                                var options = presetOptions[themeName];
                                if (!options) {
                                    options = presetOptions['default'];
                                }
                                if (extOptions) {
                                    options = common_1.deepMergedCopy(options, extOptions);
                                }
                                setDocumentStyle(options);
                            },
                            /**
                             * Returns whether the style of a theme is applied.
                             */
                            isApplied: function () {
                                return !!document.getElementById(STYLE_ELEMENT_ID);
                            },
                        };


                        /***/ }),
                    /* 119 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.striped = exports.clean = exports.presetDefault = void 0;
                        var common_1 = __webpack_require__(0);
                        exports.presetDefault = {
                            selection: {
                                background: '#00A9ff',
                                border: '#00a9ff',
                            },
                            heightResizeHandle: {
                                border: '#fff',
                                background: '#fff',
                            },
                            pagination: {
                                border: 'transparent',
                                background: 'transparent',
                            },
                            scrollbar: {
                                border: '#eee',
                                background: '#fff',
                                emptySpace: '#f9f9f9',
                                thumb: '#ddd',
                                active: '#ddd',
                            },
                            outline: {
                                border: '#aaa',
                                showVerticalBorder: false,
                            },
                            frozenBorder: {
                                border: '#aaa',
                            },
                            area: {
                                header: {
                                    border: '#ccc',
                                    background: '#fff',
                                },
                                body: {
                                    background: '#fff',
                                },
                                summary: {
                                    border: '#eee',
                                    background: '#fff',
                                },
                            },
                            cell: {
                                normal: {
                                    background: '#f4f4f4',
                                    border: '#eee',
                                    text: '#333',
                                    showVerticalBorder: false,
                                    showHorizontalBorder: true,
                                },
                                header: {
                                    background: '#fff',
                                    border: '#eee',
                                    text: '#222',
                                    showVerticalBorder: true,
                                    showHorizontalBorder: true,
                                },
                                rowHeader: {
                                    background: '#fff',
                                    border: '#eee',
                                    text: '#333',
                                    showVerticalBorder: false,
                                    showHorizontalBorder: true,
                                },
                                summary: {
                                    background: '#fff',
                                    border: '#eee',
                                    text: '#333',
                                    showVerticalBorder: false,
                                },
                                selectedHeader: {
                                    background: '#e5f6ff',
                                },
                                selectedRowHeader: {
                                    background: '#e5f6ff',
                                },
                                focused: {
                                    border: '#00a9ff',
                                },
                                focusedInactive: {
                                    border: '#aaa',
                                },
                                required: {
                                    background: '#fffdeb',
                                },
                                editable: {
                                    background: '#fff',
                                },
                                disabled: {
                                    background: '#f9f9f9',
                                    text: '#c1c1c1',
                                },
                                dummy: {
                                    background: '#fff',
                                },
                                invalid: {
                                    background: '#ffe5e5',
                                },
                                evenRow: {},
                                oddRow: {},
                                currentRow: {},
                            },
                            rowHover: {
                                background: 'none',
                            },
                        };
                        exports.clean = common_1.deepMergedCopy(exports.presetDefault, {
                            outline: {
                                border: '#eee',
                                showVerticalBorder: false,
                            },
                            frozenBorder: {
                                border: '#ddd',
                            },
                            area: {
                                header: {
                                    border: '#eee',
                                    background: '#f9f9f9',
                                },
                                body: {
                                    background: '#fff',
                                },
                                summary: {
                                    border: '#fff',
                                    background: '#fff',
                                },
                            },
                            cell: {
                                normal: {
                                    background: '#fff',
                                    border: '#eee',
                                    showVerticalBorder: false,
                                    showHorizontalBorder: false,
                                },
                                header: {
                                    background: '#f9f9f9',
                                    border: '#eee',
                                    showVerticalBorder: true,
                                    showHorizontalBorder: true,
                                },
                                rowHeader: {
                                    border: '#eee',
                                    showVerticalBorder: false,
                                    showHorizontalBorder: false,
                                },
                            },
                        });
                        exports.striped = common_1.deepMergedCopy(exports.presetDefault, {
                            outline: {
                                border: '#eee',
                                showVerticalBorder: false,
                            },
                            frozenBorder: {
                                border: '#ccc',
                            },
                            area: {
                                header: {
                                    border: '#fff',
                                    background: '#eee',
                                },
                                body: {
                                    background: '#fff',
                                },
                                summary: {
                                    border: '#fff',
                                    background: '#fff',
                                },
                            },
                            cell: {
                                normal: {
                                    background: '#fff',
                                    border: '#fff',
                                    showVerticalBorder: false,
                                    showHorizontalBorder: false,
                                },
                                header: {
                                    background: '#eee',
                                    border: '#fff',
                                    showVerticalBorder: true,
                                    showHorizontalBorder: true,
                                },
                                rowHeader: {
                                    border: '#fff',
                                    showVerticalBorder: false,
                                    showHorizontalBorder: false,
                                },
                                oddRow: {
                                    background: '#fff',
                                },
                                evenRow: {
                                    background: '#f4f4f4',
                                },
                            },
                        });


                        /***/ }),
                    /* 120 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.cellCurrentRow = exports.cellInvalid = exports.cellDisabled = exports.cellRequired = exports.cellEditable = exports.cellFocusedInactive = exports.cellFocused = exports.cellSelectedRowHeader = exports.cellSelectedHeader = exports.rowDummy = exports.rowHover = exports.rowOdd = exports.rowEven = exports.cellSummary = exports.cellRowHeader = exports.cellHeader = exports.cell = exports.summaryArea = exports.bodyArea = exports.headerArea = exports.selection = exports.pagination = exports.heightResizeHandle = exports.scrollbar = exports.frozenBorder = exports.outline = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var dom_1 = __webpack_require__(2);
                        var cssRuleBuilder_1 = __webpack_require__(121);
                        function bgTextRuleString(className, options) {
                            var background = options.background, text = options.text;
                            return cssRuleBuilder_1.createClassRule(className).bg(background).text(text).build();
                        }
                        function bgBorderRuleString(className, options) {
                            var background = options.background, border = options.border;
                            return cssRuleBuilder_1.createClassRule(className).bg(background).border(border).build();
                        }
                        function outline(options) {
                            var border = options.border, showVerticalBorder = options.showVerticalBorder;
                            var borderTopRule = cssRuleBuilder_1.createClassRule('border-line-top').add('border-top', "1px solid " + border);
                            var borderBottomRule = cssRuleBuilder_1.createNestedClassRule(' .', ['no-scroll-x', 'border-line-bottom']).add('border-bottom', "1px solid " + border);
                            var rules = [borderTopRule, borderBottomRule];
                            var borderLeftRule, borderRightRule;
                            if (showVerticalBorder) {
                                borderLeftRule = cssRuleBuilder_1.createClassRule('border-line-left').add('border-left', "1px solid " + border);
                                borderRightRule = cssRuleBuilder_1.createNestedClassRule(' .', ['no-scroll-y', 'border-line-right']).add('border-right', "1px solid " + border);
                                rules = rules.concat([borderLeftRule, borderRightRule]);
                            }
                            return cssRuleBuilder_1.buildAll(rules);
                        }
                        exports.outline = outline;
                        function frozenBorder(options) {
                            return cssRuleBuilder_1.createClassRule('frozen-border').bg(options.border).build();
                        }
                        exports.frozenBorder = frozenBorder;
                        function scrollbar(options) {
                            var border = options.border, emptySpace = options.emptySpace;
                            var webkitScrollbarRules = cssRuleBuilder_1.createWebkitScrollbarRules("." + dom_1.cls('container'), options);
                            var ieScrollbarRule = cssRuleBuilder_1.createIEScrollbarRule("." + dom_1.cls('container'), options);
                            var xInnerBorderRule = cssRuleBuilder_1.createClassRule('border-line-bottom').add('border-bottom', "1px solid " + border);
                            var xOuterBorderRule = cssRuleBuilder_1.createClassRule('content-area').border(border);
                            var yInnerBorderRule = cssRuleBuilder_1.createClassRule('scrollbar-y-inner-border').bg(border);
                            var yOuterBorderRule = cssRuleBuilder_1.createClassRule('scrollbar-y-outer-border').bg(border);
                            var spaceRightTopRule = cssRuleBuilder_1.createClassRule('scrollbar-right-top').bg(emptySpace).border(border);
                            var spaceRightBottomRule = cssRuleBuilder_1.createClassRule('scrollbar-right-bottom')
                                .bg(emptySpace)
                                .border(border);
                            var spaceLeftBottomRule = cssRuleBuilder_1.createClassRule('scrollbar-left-bottom')
                                .bg(emptySpace)
                                .border(border);
                            var frozenBorderRule = cssRuleBuilder_1.createClassRule('scrollbar-frozen-border').bg(emptySpace).border(border);
                            return cssRuleBuilder_1.buildAll(tslib_1.__spreadArrays(webkitScrollbarRules, [
                                ieScrollbarRule,
                                xInnerBorderRule,
                                xOuterBorderRule,
                                yInnerBorderRule,
                                yOuterBorderRule,
                                spaceRightTopRule,
                                spaceRightBottomRule,
                                spaceLeftBottomRule,
                                frozenBorderRule,
                            ]));
                        }
                        exports.scrollbar = scrollbar;
                        function heightResizeHandle(options) {
                            return bgBorderRuleString('height-resize-handle', options);
                        }
                        exports.heightResizeHandle = heightResizeHandle;
                        function pagination(options) {
                            return bgBorderRuleString('pagination', options);
                        }
                        exports.pagination = pagination;
                        function selection(options) {
                            return bgBorderRuleString('layer-selection', options);
                        }
                        exports.selection = selection;
                        function headerArea(options) {
                            return cssRuleBuilder_1.createClassRule('header-area').bg(options.background).border(options.border).build();
                        }
                        exports.headerArea = headerArea;
                        function bodyArea(options) {
                            return cssRuleBuilder_1.createClassRule('body-area').bg(options.background).build();
                        }
                        exports.bodyArea = bodyArea;
                        function summaryArea(options) {
                            var border = options.border, background = options.background;
                            var contentAreaRule = cssRuleBuilder_1.createClassRule('summary-area').bg(background).border(border);
                            var bodyAreaRule = cssRuleBuilder_1.createNestedClassRule(' .', ['has-summary-top', 'body-area']).border(border);
                            return cssRuleBuilder_1.buildAll([contentAreaRule, bodyAreaRule]);
                        }
                        exports.summaryArea = summaryArea;
                        function cell(options) {
                            return cssRuleBuilder_1.createClassRule('cell')
                                .bg(options.background)
                                .border(options.border)
                                .borderWidth(options)
                                .text(options.text)
                                .build();
                        }
                        exports.cell = cell;
                        function cellHeader(options) {
                            var background = options.background, border = options.border, text = options.text;
                            var tableRule = cssRuleBuilder_1.createNestedClassRule(' .', [
                                'show-lside-area',
                                'lside-area',
                                'header-area',
                                'table',
                            ]).verticalBorderStyle(options, 'right');
                            var cellRule = cssRuleBuilder_1.createClassRule('cell-header')
                                .bg(background)
                                .border(border)
                                .borderWidth(options)
                                .text(text);
                            return cssRuleBuilder_1.buildAll([tableRule, cellRule]);
                        }
                        exports.cellHeader = cellHeader;
                        function cellRowHeader(options) {
                            var background = options.background, border = options.border, text = options.text;
                            var tableRule = cssRuleBuilder_1.createNestedClassRule(' .', [
                                'show-lside-area',
                                'lside-area',
                                'body-area',
                                'table',
                            ]).verticalBorderStyle(options, 'right');
                            var cellRule = cssRuleBuilder_1.createClassRule('cell-row-header')
                                .bg(background)
                                .border(border)
                                .borderWidth(options)
                                .text(text);
                            return cssRuleBuilder_1.buildAll([tableRule, cellRule]);
                        }
                        exports.cellRowHeader = cellRowHeader;
                        function cellSummary(options) {
                            var background = options.background, border = options.border, text = options.text;
                            var tableRule = cssRuleBuilder_1.createNestedClassRule(' .', [
                                'show-lside-area',
                                'lside-area',
                                'summary-area',
                                'table',
                            ]).verticalBorderStyle(options, 'right');
                            var cellRule = cssRuleBuilder_1.createClassRule('cell-summary')
                                .bg(background)
                                .border(border)
                                .borderWidth(options)
                                .text(text);
                            return cssRuleBuilder_1.buildAll([tableRule, cellRule]);
                        }
                        exports.cellSummary = cellSummary;
                        function rowEven(options) {
                            return cssRuleBuilder_1.create('.tui-grid-row-even>td').bg(options.background).build();
                        }
                        exports.rowEven = rowEven;
                        function rowOdd(options) {
                            return cssRuleBuilder_1.create('.tui-grid-row-odd>td').bg(options.background).build();
                        }
                        exports.rowOdd = rowOdd;
                        function rowHover(options) {
                            return cssRuleBuilder_1.create('.tui-grid-row-hover>.tui-grid-cell').bg(options.background).build();
                        }
                        exports.rowHover = rowHover;
                        function rowDummy(options) {
                            return bgTextRuleString('cell-dummy', options);
                        }
                        exports.rowDummy = rowDummy;
                        function cellSelectedHeader(options) {
                            return cssRuleBuilder_1.createNestedClassRule('.', ['cell-header', 'cell-selected'])
                                .bg(options.background)
                                .text(options.text)
                                .build();
                        }
                        exports.cellSelectedHeader = cellSelectedHeader;
                        function cellSelectedRowHeader(options) {
                            return cssRuleBuilder_1.createNestedClassRule('.', ['cell-row-header', 'cell-selected'])
                                .bg(options.background)
                                .text(options.text)
                                .build();
                        }
                        exports.cellSelectedRowHeader = cellSelectedRowHeader;
                        function cellFocused(options) {
                            var border = options.border;
                            var focusLayerRule = cssRuleBuilder_1.createClassRule('layer-focus-border').bg(border);
                            var editingLayerRule = cssRuleBuilder_1.createClassRule('layer-editing').border(border);
                            return cssRuleBuilder_1.buildAll([focusLayerRule, editingLayerRule]);
                        }
                        exports.cellFocused = cellFocused;
                        function cellFocusedInactive(options) {
                            return cssRuleBuilder_1.createNestedClassRule(' .', ['layer-focus-deactive', 'layer-focus-border'])
                                .bg(options.border)
                                .build();
                        }
                        exports.cellFocusedInactive = cellFocusedInactive;
                        function cellEditable(options) {
                            return bgTextRuleString('cell-editable', options);
                        }
                        exports.cellEditable = cellEditable;
                        function cellRequired(options) {
                            return bgTextRuleString('cell-required', options);
                        }
                        exports.cellRequired = cellRequired;
                        function cellDisabled(options) {
                            return bgTextRuleString('cell-disabled', options);
                        }
                        exports.cellDisabled = cellDisabled;
                        function cellInvalid(options) {
                            var background = options.background, text = options.text;
                            return cssRuleBuilder_1.createNestedClassRule('.', ['cell-invalid', 'cell']).bg(background).text(text).build();
                        }
                        exports.cellInvalid = cellInvalid;
                        function cellCurrentRow(options) {
                            return bgTextRuleString('cell-current-row', options);
                        }
                        exports.cellCurrentRow = cellCurrentRow;


                        /***/ }),
                    /* 121 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.buildAll = exports.createIEScrollbarRule = exports.createWebkitScrollbarRules = exports.createNestedClassRule = exports.createClassRule = exports.create = void 0;
                        var dom_1 = __webpack_require__(2);
                        var common_1 = __webpack_require__(0);
                        /**
                         * create css rule string and returns it
                         * @module {theme/cssBuilder}
                         * @param selector - css selector
                         * @param property - css property
                         * @param  value - css value
                         * @ignore
                         */
                        var CSSRuleBuilder = /** @class */ (function () {
                            function CSSRuleBuilder(selector) {
                                this.selector = '';
                                this.propValues = [];
                                this.init(selector);
                            }
                            CSSRuleBuilder.prototype.init = function (selector) {
                                if (!(typeof selector === 'string') || !selector) {
                                    throw new Error('The Selector must be a string and not be empty.');
                                }
                                this.selector = selector;
                                this.propValues = [];
                            };
                            /**
                             * Add a set of css property and value.
                             * @param property - css property
                             * @param  value - css value
                             */
                            CSSRuleBuilder.prototype.add = function (property, value) {
                                if (value) {
                                    this.propValues.push(property + ":" + value);
                                }
                                return this;
                            };
                            /**
                             * Shortcut for add('border-color', value)
                             */
                            CSSRuleBuilder.prototype.border = function (value) {
                                return this.add('border-color', value);
                            };
                            /**
                             * Add a border-width style to the rule.
                             * @param options - visible options
                             * @param [options.showVerticalBorder] - whether the vertical border is visible
                             * @param [options.showHorizontalBorder] - whether the horizontal border is visible
                             */
                            CSSRuleBuilder.prototype.borderWidth = function (options) {
                                var vertical = options.showVerticalBorder;
                                var horizontal = options.showHorizontalBorder;
                                var value;
                                if (common_1.isBoolean(vertical)) {
                                    value = vertical ? '1px' : '0';
                                    this.add('border-left-width', value).add('border-right-width', value);
                                }
                                if (common_1.isBoolean(horizontal)) {
                                    value = horizontal ? '1px' : '0';
                                    this.add('border-top-width', value).add('border-bottom-width', value);
                                }
                                return this;
                            };
                            /**
                             * Add a vertical border style to the rule.
                             * @param options - visible options
                             * @param [options.showVerticalBorder] - whether the vertical border is visible
                             * @param position - Position of the vertical border ('right' or 'left')
                             */
                            CSSRuleBuilder.prototype.verticalBorderStyle = function (options, position) {
                                var vertical = options.showVerticalBorder;
                                var value;
                                if (common_1.isBoolean(vertical) && position) {
                                    value = vertical ? 'solid' : 'hidden';
                                    this.add("border-" + position + "-style", value);
                                }
                                return this;
                            };
                            /**
                             * Shortcut for add('background-color', value)
                             */
                            CSSRuleBuilder.prototype.bg = function (value) {
                                return this.add('background-color', value);
                            };
                            /**
                             * Shortcut for add('color', value)
                             */
                            CSSRuleBuilder.prototype.text = function (value) {
                                return this.add('color', value);
                            };
                            /**
                             * Create a CSS rule string with a selector and prop-values.
                             */
                            CSSRuleBuilder.prototype.build = function () {
                                var result = '';
                                if (this.propValues.length) {
                                    result = this.selector + "{" + this.propValues.join(';') + "}";
                                }
                                return result;
                            };
                            return CSSRuleBuilder;
                        }());
                        /**
                         * Creates new Builder instance.
                         */
                        function create(selector) {
                            return new CSSRuleBuilder(selector);
                        }
                        exports.create = create;
                        /**
                         * Creates a new Builder instance with a class name selector.
                         */
                        function createClassRule(className) {
                            return create("." + dom_1.cls(className));
                        }
                        exports.createClassRule = createClassRule;
                        /**
                         * Creates a new Builder instance with a nested class name.
                         * @param selector - selector to compose class names
                         * @param classNames - classNames
                         */
                        function createNestedClassRule(selector, classNames) {
                            return create("." + classNames.map(function (className) { return dom_1.cls(className); }).join(selector));
                        }
                        exports.createNestedClassRule = createNestedClassRule;
                        /**
                         * Creates an array of new Builder instances for the -webkit-scrollbar styles.
                         */
                        function createWebkitScrollbarRules(selector, options) {
                            return [
                                create(selector + " ::-webkit-scrollbar").bg(options.background),
                                create(selector + " ::-webkit-scrollbar-thumb").bg(options.thumb),
                                create(selector + " ::-webkit-scrollbar-thumb:hover").bg(options.active),
                            ];
                        }
                        exports.createWebkitScrollbarRules = createWebkitScrollbarRules;
                        /**
                         * Creates a builder instance for the IE scrollbar styles.
                         */
                        function createIEScrollbarRule(selector, options) {
                            var bgProps = [
                                'scrollbar-3dlight-color',
                                'scrollbar-darkshadow-color',
                                'scrollbar-track-color',
                                'scrollbar-shadow-color',
                            ];
                            var thumbProps = ['scrollbar-face-color', 'scrollbar-highlight-color'];
                            var ieScrollbarRule = create(selector);
                            bgProps.forEach(function (prop) {
                                ieScrollbarRule.add(prop, options.background);
                            });
                            thumbProps.forEach(function (prop) {
                                ieScrollbarRule.add(prop, options.thumb);
                            });
                            ieScrollbarRule.add('scrollbar-arrow-color', options.active);
                            return ieScrollbarRule;
                        }
                        exports.createIEScrollbarRule = createIEScrollbarRule;
                        /**
                         * Build all rules and returns the concatenated string.
                         */
                        function buildAll(rules) {
                            return rules
                                .map(function (rule) {
                                    return rule.build();
                                })
                                .join('');
                        }
                        exports.buildAll = buildAll;


                        /***/ }),
                    /* 122 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.getInvalidRows = void 0;
                        var lazyObservable_1 = __webpack_require__(26);
                        function getInvalidRows(store) {
                            // @TODO: find more practical way to make observable
                            lazyObservable_1.createObservableData(store, true);
                            var data = store.data, column = store.column;
                            var invalidRows = [];
                            data.viewData.forEach(function (_a) {
                                var rowKey = _a.rowKey, valueMap = _a.valueMap;
                                var invalidColumns = column.validationColumns.filter(function (_a) {
                                    var name = _a.name;
                                    return !!valueMap[name].invalidStates.length;
                                });
                                if (invalidColumns.length) {
                                    var errors = invalidColumns.map(function (_a) {
                                        var name = _a.name;
                                        var invalidStates = valueMap[name].invalidStates;
                                        return {
                                            columnName: name,
                                            errorInfo: invalidStates,
                                            errorCode: invalidStates.map(function (_a) {
                                                var code = _a.code;
                                                return code;
                                            }),
                                        };
                                    });
                                    invalidRows.push({ rowKey: rowKey, errors: errors });
                                }
                            });
                            return invalidRows;
                        }
                        exports.getInvalidRows = getInvalidRows;


                        /***/ }),
                    /* 123 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.createProvider = void 0;
                        var common_1 = __webpack_require__(0);
                        var mutationRequest_1 = __webpack_require__(124);
                        var getterRequest_1 = __webpack_require__(127);
                        var ajaxConfig_1 = __webpack_require__(38);
                        function createConfig(store, dispatch, dataSource) {
                            var lastRequiredData = { perPage: store.data.pageOptions.perPage };
                            var requestParams = {};
                            var api = dataSource.api, _a = dataSource.hideLoadingBar, hideLoadingBar = _a === void 0 ? false : _a;
                            var ajaxConfig = ajaxConfig_1.createAjaxConfig(dataSource);
                            Object.keys(api).forEach(function (key) {
                                api[key] = common_1.deepMergedCopy(ajaxConfig, api[key]);
                            });
                            var getLastRequiredData = function () { return lastRequiredData; };
                            var setLastRequiredData = function (params) {
                                lastRequiredData = params;
                            };
                            var getRequestParams = function () { return requestParams; };
                            var setRequestParams = function (params) {
                                requestParams = params;
                            };
                            return {
                                api: api,
                                hideLoadingBar: hideLoadingBar,
                                store: store,
                                dispatch: dispatch,
                                setLastRequiredData: setLastRequiredData,
                                getLastRequiredData: getLastRequiredData,
                                setRequestParams: setRequestParams,
                                getRequestParams: getRequestParams,
                            };
                        }
                        function createFallbackProvider() {
                            // dummy function
                            var errorFn = function () {
                                throw new Error('Cannot execute server side API. To use this API, DataSource should be set');
                            };
                            return {
                                request: errorFn,
                                readData: errorFn,
                                reloadData: errorFn,
                                setRequestParams: errorFn,
                                sort: errorFn,
                                unsort: errorFn,
                            };
                        }
                        function createProvider(store, dispatch, data) {
                            var provider = createFallbackProvider();
                            if (!Array.isArray(data) && common_1.isObject(data)) {
                                var api = data.api, _a = data.initialRequest, initialRequest = _a === void 0 ? true : _a;
                                if (!common_1.isObject(api === null || api === void 0 ? void 0 : api.readData)) {
                                    throw new Error('GET API should be configured in DataSource to get data');
                                }
                                var config = createConfig(store, dispatch, data);
                                // set curried function
                                provider.request = mutationRequest_1.request.bind(null, config);
                                provider.readData = getterRequest_1.readData.bind(null, config);
                                provider.reloadData = getterRequest_1.reloadData.bind(null, config);
                                provider.sort = getterRequest_1.sort.bind(null, config);
                                provider.unsort = getterRequest_1.unsort.bind(null, config);
                                provider.setRequestParams = config.setRequestParams;
                                if (initialRequest) {
                                    getterRequest_1.readData(config, 1, api.readData.initParams);
                                }
                            }
                            return provider;
                        }
                        exports.createProvider = createProvider;


                        /***/ }),
                    /* 124 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.request = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var common_1 = __webpack_require__(0);
                        var gridAjax_1 = __webpack_require__(52);
                        var eventBus_1 = __webpack_require__(8);
                        var instance_1 = __webpack_require__(7);
                        var modifiedDataManager_1 = __webpack_require__(53);
                        var data_1 = __webpack_require__(6);
                        var confirm_1 = __webpack_require__(126);
                        var ajaxConfig_1 = __webpack_require__(38);
                        var requestTypeCodeMap = {
                            createData: 'CREATE',
                            updateData: 'UPDATE',
                            deleteData: 'DELETE',
                            modifyData: 'MODIFY',
                        };
                        function createRequestParams(store, type, requestOptions) {
                            var column = store.column, data = store.data, id = store.id;
                            var checkedOnly = requestOptions.checkedOnly, modifiedOnly = requestOptions.modifiedOnly;
                            var modifiedOptions = { checkedOnly: checkedOnly, ignoredColumns: column.ignoredColumns };
                            if (modifiedOnly) {
                                var manager = instance_1.getDataManager(id);
                                return type === 'MODIFY'
                                    ? manager.getAllModifiedData(modifiedOptions)
                                    : manager.getModifiedData(type, modifiedOptions);
                            }
                            return { rows: modifiedDataManager_1.getDataWithOptions(data.rawData, modifiedOptions) };
                        }
                        function createRequestOptions(ajaxConfig, requestOptions) {
                            if (requestOptions === void 0) { requestOptions = {}; }
                            var defaultOptions = {
                                checkedOnly: false,
                                modifiedOnly: true,
                                showConfirm: true,
                                withCredentials: ajaxConfig.withCredentials,
                            };
                            return tslib_1.__assign(tslib_1.__assign({}, defaultOptions), requestOptions);
                        }
                        function send(config, sendOptions) {
                            var store = config.store, dispatch = config.dispatch, hideLoadingBar = config.hideLoadingBar, getRequestParams = config.getRequestParams;
                            var id = store.id;
                            var commonRequestParams = getRequestParams();
                            var manager = instance_1.getDataManager(id);
                            var url = sendOptions.url, method = sendOptions.method, options = sendOptions.options, params = sendOptions.params, requestTypeCode = sendOptions.requestTypeCode, ajaxConfig = sendOptions.ajaxConfig;
                            var showConfirm = options.showConfirm, withCredentials = options.withCredentials;
                            if (!showConfirm || confirm_1.confirmMutation(requestTypeCode, params)) {
                                var callback = function () { return dispatch('setLoadingState', data_1.getLoadingState(store.data.rawData)); };
                                if (!hideLoadingBar) {
                                    dispatch('setLoadingState', 'LOADING');
                                }
                                gridAjax_1.gridAjax(tslib_1.__assign(tslib_1.__assign({ method: method, url: common_1.isFunction(url) ? url() : url, params: tslib_1.__assign(tslib_1.__assign({}, commonRequestParams), params), success: function () { return manager.clearSpecificRows(params); }, preCallback: callback, postCallback: callback, eventBus: eventBus_1.getEventBus(id) }, ajaxConfig), { withCredentials: common_1.isUndefined(withCredentials) ? ajaxConfig.withCredentials : withCredentials }));
                            }
                        }
                        function request(config, requestType, requestOptions) {
                            var _a, _b;
                            var store = config.store, api = config.api;
                            var url = requestOptions.url || ((_a = api[requestType]) === null || _a === void 0 ? void 0 : _a.url);
                            var method = requestOptions.method || ((_b = api[requestType]) === null || _b === void 0 ? void 0 : _b.method);
                            if (!url || !method) {
                                throw new Error('url and method should be essential for request.');
                            }
                            var requestTypeCode = requestTypeCodeMap[requestType];
                            var ajaxConfig = ajaxConfig_1.createAjaxConfig(api[requestType] || {});
                            var options = createRequestOptions(ajaxConfig, requestOptions);
                            var params = createRequestParams(store, requestTypeCode, options);
                            send(config, { url: url, method: method, options: options, params: params, requestTypeCode: requestTypeCode, ajaxConfig: ajaxConfig });
                        }
                        exports.request = request;


                        /***/ }),
                    /* 125 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.serialize = void 0;
                        var common_1 = __webpack_require__(0);
                        /**
                         * 1. Array format
                         *
                         * The default array format to serialize is 'bracket'.
                         * However in case of nested array, only the deepest format follows the 'bracket', the rest follow 'indice' format.
                         *
                         * - basic
                         *   { a: [1, 2, 3] } => a[]=1&a[]=2&a[]=3
                         * - nested
                         *   { a: [1, 2, [3]] } => a[]=1&a[]=2&a[2][]=3
                         *
                         * 2. Object format
                         *
                         * The default object format to serialize is 'bracket' notation and doesn't allow the 'dot' notation.
                         *
                         * - basic
                         *   { a: { b: 1, c: 2 } } => a[b]=1&a[c]=2
                         */
                        function encodePairs(key, value) {
                            return encodeURIComponent(key) + "=" + encodeURIComponent(common_1.isNil(value) ? '' : value);
                        }
                        function serializeParams(key, value, serializedList) {
                            if (Array.isArray(value)) {
                                value.forEach(function (arrVal, index) {
                                    serializeParams(key + "[" + (common_1.isObject(arrVal) ? index : '') + "]", arrVal, serializedList);
                                });
                            }
                            else if (common_1.isObject(value)) {
                                Object.keys(value).forEach(function (objKey) {
                                    serializeParams(key + "[" + objKey + "]", value[objKey], serializedList);
                                });
                            }
                            else {
                                serializedList.push(encodePairs(key, value));
                            }
                        }
                        function serialize(params) {
                            if (!params || common_1.isEmpty(params)) {
                                return '';
                            }
                            var serializedList = [];
                            Object.keys(params).forEach(function (key) {
                                serializeParams(key, params[key], serializedList);
                            });
                            return serializedList.join('&');
                        }
                        exports.serialize = serialize;


                        /***/ }),
                    /* 126 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.confirmMutation = void 0;
                        var message_1 = __webpack_require__(54);
                        function confirmMutation(type, params) {
                            var count = Object.keys(params).reduce(function (acc, key) { return acc + params[key].length; }, 0);
                            return count ? confirm(message_1.getConfirmMessage(type, count)) : alert(message_1.getAlertMessage(type));
                        }
                        exports.confirmMutation = confirmMutation;


                        /***/ }),
                    /* 127 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.unsort = exports.sort = exports.reloadData = exports.readData = void 0;
                        var tslib_1 = __webpack_require__(1);
                        var tree_1 = __webpack_require__(29);
                        var tree_2 = __webpack_require__(21);
                        var common_1 = __webpack_require__(0);
                        var gridAjax_1 = __webpack_require__(52);
                        var eventBus_1 = __webpack_require__(8);
                        var data_1 = __webpack_require__(6);
                        var ajaxConfig_1 = __webpack_require__(38);
                        var sort_1 = __webpack_require__(27);
                        var sort_2 = __webpack_require__(41);
                        function validateResponse(responseData) {
                            if (common_1.isUndefined(responseData)) {
                                throw new Error('The response data is empty to rerender grid');
                            }
                        }
                        function handleSuccessReadData(config, response) {
                            var dispatch = config.dispatch, getLastRequiredData = config.getLastRequiredData, store = config.store;
                            var responseData = response.data;
                            var _a = getLastRequiredData(), perPage = _a.perPage, _b = _a.sortColumn, sortColumn = _b === void 0 ? 'sortKey' : _b, _c = _a.sortAscending, sortAscending = _c === void 0 ? true : _c;
                            validateResponse(responseData);
                            var contents = responseData.contents, pagination = responseData.pagination;
                            if (data_1.isScrollPagination(store.data)) {
                                dispatch('appendRows', contents);
                            }
                            else {
                                var options = {};
                                if (sortColumn !== 'sortKey') {
                                    options.sortState = { columnName: sortColumn, ascending: sortAscending, multiple: true };
                                }
                                dispatch('resetData', contents, options);
                            }
                            if (pagination) {
                                dispatch('updatePageOptions', tslib_1.__assign(tslib_1.__assign({}, pagination), { perPage: perPage }));
                            }
                        }
                        function handleSuccessReadTreeData(config, response) {
                            var dispatch = config.dispatch, store = config.store, getLastRequiredData = config.getLastRequiredData;
                            var responseData = response.data;
                            validateResponse(responseData);
                            var parentRowKey = getLastRequiredData().parentRowKey;
                            var column = store.column, id = store.id, data = store.data;
                            responseData.contents.forEach(function (row) { return dispatch('appendTreeRow', row, { parentRowKey: parentRowKey }); });
                            var row = data_1.findRowByRowKey(data, column, id, parentRowKey);
                            if (row && !tree_2.getChildRowKeys(row).length) {
                                tree_1.removeExpandedAttr(row);
                            }
                        }
                        function readData(config, page, data, resetData) {
                            if (data === void 0) { data = {}; }
                            if (resetData === void 0) { resetData = false; }
                            var store = config.store, getLastRequiredData = config.getLastRequiredData;
                            var lastRequiredData = getLastRequiredData();
                            var treeColumnName = store.column.treeColumnName;
                            var perPage = store.data.pageOptions.perPage;
                            var params = resetData ? tslib_1.__assign(tslib_1.__assign({ perPage: perPage }, data), { page: page }) : tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, lastRequiredData), data), { page: page });
                            var successCallback = handleSuccessReadData;
                            if (treeColumnName && !common_1.isUndefined(data.parentRowKey)) {
                                successCallback = handleSuccessReadTreeData;
                                delete params.page;
                                delete params.perPage;
                            }
                            sendRequest(config, params, successCallback);
                        }
                        exports.readData = readData;
                        function reloadData(config) {
                            readData(config, config.getLastRequiredData().page || 1);
                        }
                        exports.reloadData = reloadData;
                        function sort(config, sortColumn, sortAscending, cancelable) {
                            var store = config.store;
                            var cancelSort = sort_2.isCancelSort(store, sortColumn, sortAscending, cancelable);
                            var gridEvent = sort_1.emitBeforeSort(store, cancelSort, {
                                columnName: sortColumn,
                                ascending: sortAscending,
                                multiple: false,
                            });
                            if (gridEvent.isStopped()) {
                                return;
                            }
                            var params = { perPage: store.data.pageOptions.perPage, page: 1 };
                            if (!cancelSort) {
                                params.sortColumn = sortColumn;
                                params.sortAscending = sortAscending;
                            }
                            var successCallback = function (successConfig, response) {
                                handleSuccessReadData(successConfig, response);
                                sort_1.emitAfterSort(store, cancelSort, sortColumn);
                            };
                            sendRequest(config, params, successCallback);
                        }
                        exports.sort = sort;
                        function unsort(config, sortColumn) {
                            if (sortColumn === void 0) { sortColumn = 'sortKey'; }
                            var store = config.store;
                            var gridEvent = sort_1.emitBeforeSort(store, true, {
                                columnName: sortColumn,
                                multiple: false,
                            });
                            if (gridEvent.isStopped()) {
                                return;
                            }
                            var params = { perPage: store.data.pageOptions.perPage, page: 1 };
                            var successCallback = function (successConfig, response) {
                                handleSuccessReadData(successConfig, response);
                                sort_1.emitAfterSort(store, true, sortColumn);
                            };
                            sendRequest(config, params, successCallback);
                        }
                        exports.unsort = unsort;
                        function sendRequest(config, params, successCallback) {
                            var store = config.store, dispatch = config.dispatch, api = config.api, setLastRequiredData = config.setLastRequiredData, hideLoadingBar = config.hideLoadingBar, getRequestParams = config.getRequestParams;
                            var commonRequestParams = getRequestParams();
                            var ajaxConfig = ajaxConfig_1.createAjaxConfig(api.readData);
                            var _a = api.readData, method = _a.method, url = _a.url;
                            var callback = function () { return dispatch('setLoadingState', data_1.getLoadingState(store.data.rawData)); };
                            setLastRequiredData(params);
                            if (!hideLoadingBar) {
                                dispatch('setLoadingState', 'LOADING');
                            }
                            gridAjax_1.gridAjax(tslib_1.__assign({ method: method, url: common_1.isFunction(url) ? url() : url, params: tslib_1.__assign(tslib_1.__assign({}, commonRequestParams), params), success: successCallback.bind(null, config), preCallback: callback, postCallback: callback, eventBus: eventBus_1.getEventBus(store.id) }, ajaxConfig));
                        }


                        /***/ }),
                    /* 128 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.createPaginationManager = void 0;
                        function createPaginationManager() {
                            var pagination = null;
                            return {
                                setPagination: function (targetPagination) {
                                    pagination = targetPagination;
                                },
                                getPagination: function () {
                                    return pagination;
                                },
                            };
                        }
                        exports.createPaginationManager = createPaginationManager;


                        /***/ }),
                    /* 129 */
                    /***/ (function(module, exports, __webpack_require__) {

                        Object.defineProperty(exports, "__esModule", { value: true });
                        exports.sendHostname = void 0;
                        var MS_7_DAYS = 7 * 24 * 60 * 60 * 1000;
                        function isExpired(date) {
                            var now = new Date().getTime();
                            return now - date > MS_7_DAYS;
                        }
                        function imagePing(url, trackingInfo) {
                            var queryString = Object.keys(trackingInfo)
                                .map(function (id, index) {
                                    var idWithType = id;
                                    return "" + (index ? '&' : '') + idWithType + "=" + trackingInfo[idWithType];
                                })
                                .join('');
                            var trackingElement = document.createElement('img');
                            trackingElement.src = url + "?" + queryString;
                            trackingElement.style.display = 'none';
                            document.body.appendChild(trackingElement);
                            document.body.removeChild(trackingElement);
                            return trackingElement;
                        }
                        function sendHostname() {
                            var hostname = location.hostname;
                            var applicationKeyForStorage = "TOAST UI grid for " + hostname + ": Statistics";
                            var date = window.localStorage.getItem(applicationKeyForStorage);
                            if (date && !isExpired(Number(date))) {
                                return;
                            }
                            window.localStorage.setItem(applicationKeyForStorage, String(new Date().getTime()));
                            setTimeout(function () {
                                if (document.readyState === 'interactive' || document.readyState === 'complete') {
                                    imagePing('https://www.google-analytics.com/collect', {
                                        v: 1,
                                        t: 'event',
                                        tid: 'UA-129951906-1',
                                        cid: hostname,
                                        dp: hostname,
                                        dh: 'grid',
                                        el: 'grid',
                                        ec: 'use',
                                    });
                                }
                            }, 1000);
                        }
                        exports.sendHostname = sendHostname;


                        /***/ }),
                    /* 130 */
                    /***/ (function(module, exports, __webpack_require__) {

                        // extracted by mini-css-extract-plugin

                        /***/ })
                    /******/ ]);
        });
    });

    var tuiGrid$2 = /*@__PURE__*/getDefaultExportFromCjs(tuiGrid$1);

    function createGridData(store) {
        const rows = [];
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach((table) => {
            table.columns.forEach((column) => {
                rows.push({
                    tableId: table.id,
                    columnId: column.id,
                    tableName: table.name,
                    tableComment: table.comment,
                    option: columnOptionToSimpleKeyToString(column.option),
                    name: column.name,
                    dataType: column.dataType,
                    default: column.default,
                    comment: column.comment,
                });
            });
        });
        return rows;
    }
    function columnOptionToSimpleKeyToString(option) {
        const keys = [];
        if (option.primaryKey) {
            keys.push("PK");
        }
        if (option.notNull) {
            keys.push("NN");
        }
        if (option.unique) {
            keys.push("UQ");
        }
        if (option.autoIncrement) {
            keys.push("AI");
        }
        return keys.join(",");
    }
    function changeColumnOptionList(oldValue, newValue) {
        const changeSimpleOptions = [];
        const oldSimpleOptions = oldValue.split(",");
        const newSimpleOptions = newValue.split(",");
        oldSimpleOptions.forEach((oldValue) => {
            if (!newSimpleOptions.some((newValue) => newValue === oldValue)) {
                changeSimpleOptions.push(oldValue);
            }
        });
        newSimpleOptions.forEach((newValue) => {
            if (!oldSimpleOptions.some((oldValue) => oldValue === newValue)) {
                changeSimpleOptions.push(newValue);
            }
        });
        return changeSimpleOptions;
    }
    function currentColumnOptionList(columnOption) {
        const currentSimpleOptions = [];
        if (columnOption.primaryKey) {
            currentSimpleOptions.push("PK");
        }
        if (columnOption.notNull) {
            currentSimpleOptions.push("NN");
        }
        if (columnOption.unique) {
            currentSimpleOptions.push("UQ");
        }
        if (columnOption.autoIncrement) {
            currentSimpleOptions.push("AI");
        }
        return currentSimpleOptions;
    }
    function filterGridData(store) {
        const rows = createGridData(store);
        const { filterStateList, filterOperatorType } = store.editorState;
        const activeFilterStateList = filterStateList.filter((filterState) => filterState.value !== "");
        if (activeFilterStateList.length !== 0) {
            return rows.filter((row) => filterMatch(row, activeFilterStateList, filterOperatorType));
        }
        else {
            return rows;
        }
    }
    function filterMatch(row, filterStateList, filterOperatorType) {
        let result = false;
        if (filterOperatorType === "OR") {
            result = filterStateList.some((filterState) => filterValueMatch(row[filterState.columnType], filterState));
        }
        else {
            result = !filterStateList.some((filterState) => !filterValueMatch(row[filterState.columnType], filterState));
        }
        return result;
    }
    function filterValueMatch(value, filterState) {
        let result = false;
        switch (filterState.filterCode) {
            case "eq":
                result = value === filterState.value;
                break;
            case "ne":
                result = value !== filterState.value;
                break;
            case "contain":
                result = value.indexOf(filterState.value) !== -1;
                break;
            case "start":
                result = value.indexOf(filterState.value) === 0;
                break;
            case "end":
                const lastIndex = value.lastIndexOf(filterState.value);
                result = value.length === lastIndex + filterState.value.length;
                break;
        }
        return result;
    }

    class GridTextRender {
        constructor(props) {
            this.el = document.createElement("div");
            this.el.classList.add("vuerd-grid-text");
            this.render(props);
        }
        getElement() {
            return this.el;
        }
        render(props) {
            this.el.innerText = this.getValue(props);
        }
        getValue(props) {
            const { placeholder } = props.columnInfo.renderer.options;
            const value = String(props.value);
            if (value.trim() === "") {
                this.el.classList.add("placeholder");
                return placeholder;
            }
            else {
                this.el.classList.remove("placeholder");
                return value;
            }
        }
    }

    class GridTextEditor {
        constructor(props) {
            this.onBlur = () => {
                this.props.grid.finishEditing(this.props.rowKey, this.el.value);
            };
            const { placeholder } = props.columnInfo.renderer.options;
            this.props = props;
            this.el = document.createElement("input");
            this.el.classList.add("vuerd-grid-input");
            this.el.type = "text";
            this.el.spellcheck = false;
            this.el.value = String(props.value);
            this.el.addEventListener("blur", this.onBlur);
            if (placeholder) {
                this.el.placeholder = placeholder;
            }
        }
        getElement() {
            return this.el;
        }
        getValue() {
            return this.el.value;
        }
        mounted() {
            this.el.focus();
        }
        beforeDestroy() {
            this.el.removeEventListener("blur", this.onBlur);
        }
    }

    class GridColumnOptionEditor {
        constructor(props) {
            this.onBlur = () => {
                this.props.grid.finishEditing(this.props.rowKey, this.el.value);
            };
            this.onKeydown = (event) => {
                this.props.portalEditingKeydown(event);
            };
            this.props = props;
            this.el = document.createElement("vuerd-grid-column-option-editor");
            this.el.value = String(props.value);
            this.el.addEventListener("blur", this.onBlur);
            this.el.addEventListener("keydown", this.onKeydown);
        }
        getElement() {
            return this.el;
        }
        getValue() {
            return this.el.value;
        }
        beforeDestroy() {
            this.el.removeEventListener("blur", this.onBlur);
            this.el.removeEventListener("keydown", this.onKeydown);
        }
    }

    class GridColumnDataTypeEditor {
        constructor(props) {
            this.onBlur = () => {
                this.props.grid.finishEditing(this.props.rowKey, this.el.value);
            };
            this.props = props;
            this.el = document.createElement("vuerd-grid-column-data-type-editor");
            this.el.value = String(props.value);
            this.el.addEventListener("blur", this.onBlur);
        }
        getElement() {
            return this.el;
        }
        getValue() {
            return this.el.value;
        }
        beforeDestroy() {
            this.el.removeEventListener("blur", this.onBlur);
        }
    }

    let ColumnOptionEditor = class ColumnOptionEditor extends EditorElement {
        constructor() {
            super(...arguments);
            this.options = [
                {
                    name: "Primary Key",
                    simpleOption: "PK",
                    checked: false,
                    active: true,
                },
                {
                    name: "Not Null",
                    simpleOption: "NN",
                    checked: false,
                    active: false,
                },
                {
                    name: "Unique",
                    simpleOption: "UQ",
                    checked: false,
                    active: false,
                },
                {
                    name: "Auto Increment",
                    simpleOption: "AI",
                    checked: false,
                    active: false,
                },
            ];
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-grid-column-option-editor")) {
                    this.dispatchEvent(new Event("blur"));
                }
            };
        }
        get index() {
            let index = 0;
            this.options.forEach((option, i) => {
                if (option.active) {
                    index = i;
                }
            });
            return index;
        }
        get value() {
            return this.options
                .filter((option) => option.checked)
                .map((option) => option.simpleOption)
                .join(",");
        }
        set value(simpleString) {
            simpleString.split(",").forEach((simple) => {
                const option = this.options.find((option) => option.simpleOption === simple);
                if (option) {
                    option.checked = true;
                }
            });
        }
        connectedCallback() {
            super.connectedCallback();
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.subscriptionList.push(fromEvent(editor, "mousedown").subscribe(this.onMousedown));
        }
        firstUpdated() {
            this.onActive(0);
        }
        updated() {
            this.onFocus();
        }
        render() {
            return html `
      <ul class="vuerd-grid-column-option-editor" @keydown=${this.onKeydown}>
        ${this.options.map((option, index) => html `
            <li
              class=${classMap({
                active: option.active,
            })}
              @click=${() => this.onChecked(option.simpleOption)}
              @mouseover=${() => this.onActive(index)}
            >
              <input
                type="checkbox"
                ?checked=${option.checked}
                @change=${(event) => this.onChange(event, option.simpleOption)}
              />
              <span>${option.name}</span>
            </li>
          `)}
      </ul>
    `;
        }
        onChecked(simpleOption) {
            this.options.forEach((option) => {
                if (option.simpleOption === simpleOption) {
                    option.checked = !option.checked;
                }
            });
            this.requestUpdate();
        }
        onChange(event, simpleOption) {
            const el = event.target;
            this.options.forEach((option) => {
                if (option.simpleOption === simpleOption) {
                    option.checked = el.checked;
                }
            });
            this.requestUpdate();
        }
        onKeydown(event) {
            if (moveKeys.some((moveKey) => moveKey === event.key)) {
                event.preventDefault();
                const move = event.key === "ArrowUp" || event.key === "ArrowLeft" ? -1 : 1;
                let index = this.index + move;
                if (index < 0) {
                    index = this.options.length - 1;
                }
                else if (index > this.options.length - 1) {
                    index = 0;
                }
                this.onActive(index);
            }
        }
        onActive(index) {
            this.options.forEach((option, i) => {
                option.active = i === index;
            });
            this.requestUpdate();
        }
        onFocus() {
            const input = this.renderRoot.querySelectorAll("input")[this.index];
            input === null || input === void 0 ? void 0 : input.focus();
        }
    };
    ColumnOptionEditor = __decorate([
        customElement("vuerd-grid-column-option-editor")
    ], ColumnOptionEditor);

    let ColumnDataTypeEditor = class ColumnDataTypeEditor extends EditorElement {
        constructor() {
            super(...arguments);
            this.value = "";
            this.hints = [];
            this.startFilter = true;
            this.flipAnimation = new FlipAnimation(this.renderRoot, ".vuerd-grid-data-type-hint", "vuerd-grid-data-type-hint-move");
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-grid-column-data-type-editor")) {
                    this.dispatchEvent(new Event("blur"));
                }
            };
        }
        get dataTypeHints() {
            const { canvasState } = this.context.store;
            let dataTypeHints = [];
            for (const databaseHint of databaseHints) {
                if (databaseHint.database === canvasState.database) {
                    dataTypeHints = databaseHint.dataTypeHints;
                    break;
                }
            }
            return dataTypeHints;
        }
        get activeIndex() {
            let index = null;
            for (let i = 0; i < this.hints.length; i++) {
                if (this.hints[i].active) {
                    index = i;
                    break;
                }
            }
            return index;
        }
        connectedCallback() {
            super.connectedCallback();
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.hintFilter();
            this.subscriptionList.push(fromEvent(editor, "mousedown").subscribe(this.onMousedown));
        }
        firstUpdated() {
            const input = this.renderRoot.querySelector("input");
            input === null || input === void 0 ? void 0 : input.focus();
        }
        updated(changedProperties) {
            changedProperties.forEach((oldValue, propName) => {
                switch (propName) {
                    case "value":
                        this.flipAnimation.snapshot();
                        this.hintFilter();
                        break;
                    case "hints":
                        this.flipAnimation.play();
                        break;
                }
            });
        }
        render() {
            return html `
      <div class="vuerd-grid-column-data-type-editor">
        <input
          class="vuerd-grid-input"
          type="text"
          spellcheck="false"
          placeholder="dataType"
          .value=${this.value}
          @keydown=${this.onKeydown}
          @input=${this.onInput}
        />
        <ul class="vuerd-grid-column-data-type-hint">
          ${repeat$1(this.hints, (hint) => hint.name, (hint) => {
                return html `
                <li
                  class=${classMap({
                    "vuerd-grid-data-type-hint": true,
                    active: hint.active,
                })}
                  @click=${() => this.onSelectHint(hint)}
                >
                  ${unsafeHTML(hint.html)}
                </li>
              `;
            })}
        </ul>
      </div>
    `;
        }
        onInput(event) {
            const input = event.target;
            this.value = input.value;
            this.onStartFilter();
        }
        onKeydown(event) {
            switch (event.key) {
                case "ArrowUp":
                    this.onArrowUp(event);
                    break;
                case "ArrowDown":
                    this.onArrowDown(event);
                    break;
                case "ArrowLeft":
                    this.onArrowLeft(event);
                    break;
                case "ArrowRight":
                    this.onArrowRight(event);
                    break;
            }
        }
        onArrowUp(event) {
            if (this.hints.length !== 0) {
                event.preventDefault();
            }
            const index = this.activeIndex;
            if (index !== null && index !== 0) {
                this.hints[index].active = false;
                this.hints[index - 1].active = true;
                this.requestUpdate();
            }
            else if (this.hints.length !== 0) {
                if (index === 0) {
                    this.hints[index].active = false;
                }
                this.hints[this.hints.length - 1].active = true;
                this.requestUpdate();
            }
        }
        onArrowDown(event) {
            if (this.hints.length !== 0) {
                event.preventDefault();
            }
            const index = this.activeIndex;
            if (index !== null && index !== this.hints.length - 1) {
                this.hints[index].active = false;
                this.hints[index + 1].active = true;
                this.requestUpdate();
            }
            else if (this.hints.length !== 0) {
                if (index === this.hints.length - 1) {
                    this.hints[index].active = false;
                }
                this.hints[0].active = true;
                this.requestUpdate();
            }
        }
        onArrowLeft(event) {
            this.activeEnd();
            this.requestUpdate();
        }
        onArrowRight(event) {
            const index = this.activeIndex;
            if (index !== null) {
                event.preventDefault();
                this.startFilter = false;
                this.value = this.hints[index].name;
            }
        }
        onStartFilter() {
            this.startFilter = true;
        }
        onSelectHint(hint) {
            this.startFilter = false;
            this.activeEnd();
            this.value = hint.name;
            const input = this.renderRoot.querySelector("input");
            if (input) {
                const len = input.value.length;
                input.selectionStart = len;
                input.selectionEnd = len;
                input.focus();
            }
        }
        hintFilter() {
            if (this.startFilter) {
                if (this.value.trim() === "") {
                    this.hints = this.dataTypeHints.map((dataTypeHint) => {
                        return {
                            name: dataTypeHint.name,
                            html: dataTypeHint.name,
                            active: false,
                        };
                    });
                }
                else {
                    this.hints = this.dataTypeHints
                        .filter((dataTypeHint) => dataTypeHint.name
                            .toLowerCase()
                            .indexOf(this.value.toLowerCase()) !== -1)
                        .map((dataTypeHint) => {
                            return {
                                name: dataTypeHint.name,
                                html: markToHTML("vuerd-mark", dataTypeHint.name, this.value),
                                active: false,
                            };
                        });
                }
            }
        }
        activeEnd() {
            this.hints.forEach((hint) => (hint.active = false));
        }
    };
    __decorate([
        property({ type: String })
    ], ColumnDataTypeEditor.prototype, "value", void 0);
    __decorate([
        property({ type: Array })
    ], ColumnDataTypeEditor.prototype, "hints", void 0);
    ColumnDataTypeEditor = __decorate([
        customElement("vuerd-grid-column-data-type-editor")
    ], ColumnDataTypeEditor);

    const PADDING$1 = 10 * 2;
    const HEIGHT$1 = 30;
    let Filter$1 = class Filter extends EditorElement {
        constructor() {
            super(...arguments);
            this.animation = true;
            this.top = 0;
            this.draggable$ = new Subject();
            this.operatorList = [];
            this.animationFrame = new AnimationFrame(200);
            this.subDraggableFilterState = [];
            this.flipAnimation = new FlipAnimation(this.renderRoot, ".vuerd-grid-filter-state", "vuerd-grid-filter-state-move");
            this.onClose = () => {
                this.animation = true;
                this.animationFrame
                    .play({ top: this.top }, { top: -1 * (this.height + PADDING$1) })
                    .update((value) => {
                        this.top = value.top;
                    })
                    .complete(() => {
                        this.dispatchEvent(new CustomEvent("close"));
                    })
                    .start();
            };
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-grid-filter")) {
                    this.onClose();
                }
            };
            this.onDragoverGroupFilterState = (event) => {
                this.draggable$.next(event);
            };
            this.onDragoverFilterState = (event) => {
                const { store } = this.context;
                const { draggableFilterState } = store.editorState;
                const { filterStateId } = event.detail;
                if (draggableFilterState &&
                    !draggableFilterState.filterStateIds.some((id) => id === filterStateId)) {
                    this.flipAnimation.snapshot();
                    store.dispatch(moveFilterState(draggableFilterState.filterStateIds, filterStateId));
                }
            };
        }
        get height() {
            const { filterStateList } = this.context.store.editorState;
            return filterStateList.length * SIZE_COLUMN_HEIGHT + HEIGHT$1;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus } = this.context;
            const { filterStateList } = this.context.store.editorState;
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.subscriptionList.push(this.draggable$
                .pipe(debounceTime(50))
                .subscribe(this.onDragoverFilterState), fromEvent(editor, "mousedown").subscribe(this.onMousedown), store.observe(filterStateList, () => this.requestUpdate()), store.observe(store.editorState.focusFilter, () => this.requestUpdate()), store.observe(store.editorState, (name) => {
                const { draggableFilterState } = store.editorState;
                switch (name) {
                    case "editFilter":
                        this.requestUpdate();
                        break;
                    case "draggableFilterState":
                        if (draggableFilterState) {
                            if (this.subDraggableFilterState.length === 0) {
                                this.onDraggableFilterState();
                            }
                        }
                        else {
                            this.onDraggableEndFilterState();
                            this.requestUpdate();
                        }
                        break;
                }
            }), eventBus.on(Bus.Filter.close).subscribe(this.onClose));
            this.top = -1 * (this.height + PADDING$1);
            filterOperatorTypes.forEach((operatorType) => {
                this.operatorList.push({
                    name: operatorType,
                    value: operatorType,
                });
            });
        }
        firstUpdated() {
            this.animationFrame
                .play({ top: -1 * (this.height + PADDING$1) }, { top: SIZE_MENUBAR_HEIGHT })
                .update((value) => {
                    this.top = value.top;
                })
                .complete(() => {
                    this.animation = false;
                })
                .start();
        }
        updated(changedProperties) {
            this.flipAnimation.play();
        }
        render() {
            const { filterStateList } = this.context.store.editorState;
            const { filterOperatorType } = this.context.store.editorState;
            const { keymap } = this.context;
            const keymapAddColumn = keymapOptionToString(keymap.addColumn[0]);
            const keymapStop = keymapOptionToString(keymap.stop[0]);
            return html `
      <div
        class="vuerd-grid-filter"
        style=${styleMap({
                top: `${this.top}px`,
                height: `${this.height}px`,
            })}
      >
        <div class="vuerd-grid-filter-header">
          <h3>Filter</h3>
          <vuerd-grid-filter-radio-editor
            .items=${this.operatorList}
            .value=${filterOperatorType}
            .focusState=${this.focusFilter()}
            .edit=${this.editFilter()}
            width="60"
            placeholder="operatorType"
            @blur=${this.onBlur}
            @change=${this.onChange}
            @mousedown=${this.onFocus}
            @dblclick=${this.onEdit}
          ></vuerd-grid-filter-radio-editor>
          <vuerd-icon
            class="vuerd-button"
            title=${keymapStop}
            icon="times"
            size="12"
            @click=${this.onClose}
          ></vuerd-icon>
          <vuerd-icon
            class="vuerd-button"
            title=${keymapAddColumn}
            icon="plus"
            size="12"
            @click=${this.onAddFilterState}
          ></vuerd-icon>
        </div>
        <div class="vuerd-grid-filter-body">
          ${repeat$1(filterStateList, (filterState) => filterState.id, (filterState) => html `
                <vuerd-grid-filter-state
                  .select=${this.selectFilterState(filterState)}
                  .draggable=${this.draggableFilterState(filterState)}
                  .filterState=${filterState}
                  .focusColumnType=${this.focusFilterState(filterState, "columnType")}
                  .focusFilterCode=${this.focusFilterState(filterState, "filterCode")}
                  .focusValue=${this.focusFilterState(filterState, "value")}
                  .editColumnType=${this.editFilterState(filterState, "columnType")}
                  .editFilterCode=${this.editFilterState(filterState, "filterCode")}
                  .editValue=${this.editFilterState(filterState, "value")}
                ></vuerd-grid-filter-state>
              `)}
        </div>
      </div>
    `;
        }
        onAddFilterState() {
            const selection = window.getSelection();
            if (selection) {
                selection.removeAllRanges();
            }
            const { store } = this.context;
            store.dispatch(addFilterState());
        }
        onFocus() {
            const { store } = this.context;
            const { editFilter } = store.editorState;
            if (editFilter === null || editFilter.focusType !== "filterOperatorType") {
                store.dispatch(focusTargetFilter("filterOperatorType"));
            }
        }
        onEdit() {
            const { store } = this.context;
            const { editFilter: editFilter$1, focusFilter } = store.editorState;
            if (focusFilter !== null && editFilter$1 === null) {
                store.dispatch(editFilter("filterOperatorType"));
            }
        }
        onBlur(event) {
            const { store } = this.context;
            store.dispatch(editFilterEnd());
        }
        onChange(event) {
            const { store } = this.context;
            store.dispatch(changeFilterOperatorType(event.detail.value));
        }
        onDraggableFilterState() {
            const nodeList = this.renderRoot.querySelectorAll("vuerd-grid-filter-state");
            nodeList.forEach((node) => {
                this.subDraggableFilterState.push(fromEvent(node, "dragover")
                    .pipe(throttleTime(300))
                    .subscribe(this.onDragoverGroupFilterState));
            });
        }
        onDraggableEndFilterState() {
            this.subDraggableFilterState.forEach((sub) => sub.unsubscribe());
            this.subDraggableFilterState = [];
        }
        focusFilter() {
            const { focusFilter } = this.context.store.editorState;
            return focusFilter !== null && focusFilter.focusFilterOperatorType;
        }
        editFilter() {
            const { editFilter } = this.context.store.editorState;
            return (editFilter !== null &&
                !editFilter.id &&
                editFilter.focusType === "filterOperatorType");
        }
        focusFilterState(filterState, focusType) {
            const { focusFilter } = this.context.store.editorState;
            return ((focusFilter === null || focusFilter === void 0 ? void 0 : focusFilter.currentFocusId) === filterState.id &&
                focusFilter.currentFocus === focusType);
        }
        editFilterState(filterState, focusType) {
            const { editFilter } = this.context.store.editorState;
            return (editFilter !== null &&
                (editFilter === null || editFilter === void 0 ? void 0 : editFilter.id) === filterState.id &&
                editFilter.focusType === focusType);
        }
        selectFilterState(filterState) {
            var _a;
            const { focusFilter } = this.context.store.editorState;
            return (focusFilter !== null &&
                ((_a = getData(focusFilter.focusFilterStateList, filterState.id)) === null || _a === void 0 ? void 0 : _a.select) === true);
        }
        draggableFilterState(filterState) {
            const { draggableFilterState } = this.context.store.editorState;
            return (draggableFilterState !== null &&
                draggableFilterState.filterStateIds.some((id) => id === filterState.id));
        }
    };
    __decorate([
        property({ type: Boolean })
    ], Filter$1.prototype, "animation", void 0);
    __decorate([
        property({ type: Number })
    ], Filter$1.prototype, "top", void 0);
    Filter$1 = __decorate([
        customElement("vuerd-grid-filter")
    ], Filter$1);

    let FilterState = class FilterState extends EditorElement {
        constructor() {
            super(...arguments);
            this.select = false;
            this.draggable = false;
            this.focusColumnType = false;
            this.focusFilterCode = false;
            this.focusValue = false;
            this.editColumnType = false;
            this.editFilterCode = false;
            this.editValue = false;
            this.columnTypes = [];
            this.filterCodeList = [];
        }
        connectedCallback() {
            super.connectedCallback();
            filterColumnTypes.forEach((filterColumnType) => {
                this.columnTypes.push({
                    name: filterColumnType,
                    value: filterColumnType,
                });
            });
            textFilterCodeList.forEach((textFilterCode) => {
                this.filterCodeList.push({
                    name: textFilterCode,
                    value: textFilterCode,
                });
            });
        }
        render() {
            const { keymap } = this.context;
            const keymapRemoveColumn = keymapOptionToString(keymap.removeColumn[0]);
            return html `
      <div
        class=${classMap({
                "vuerd-grid-filter-state": true,
                select: this.select,
                draggable: this.draggable,
            })}
        data-id=${this.filterState.id}
        draggable="true"
        @dragstart=${this.onDragstart}
        @dragend=${this.onDragend}
        @dragover=${this.onDragover}
      >
        <vuerd-grid-filter-radio-editor
          .items=${this.columnTypes}
          .value=${this.filterState.columnType}
          .focusState=${this.focusColumnType}
          .edit=${this.editColumnType}
          .select=${this.select}
          width="120"
          placeholder="columnType"
          @blur=${this.onBlur}
          @change=${(event) => this.onChange(event, "columnType")}
          @mousedown=${(event) => this.onFocus(event, "columnType")}
          @dblclick=${(event) => this.onEdit(event, "columnType")}
        ></vuerd-grid-filter-radio-editor>
        <vuerd-grid-filter-radio-editor
          .items=${this.filterCodeList}
          .value=${this.filterState.filterCode}
          .focusState=${this.focusFilterCode}
          .edit=${this.editFilterCode}
          .select=${this.select}
          width="75"
          placeholder="filterCode"
          @blur=${this.onBlur}
          @change=${(event) => this.onChange(event, "filterCode")}
          @mousedown=${(event) => this.onFocus(event, "filterCode")}
          @dblclick=${(event) => this.onEdit(event, "filterCode")}
        ></vuerd-grid-filter-radio-editor>
        <vuerd-grid-filter-text-editor
          .value=${this.filterState.value}
          .focusState=${this.focusValue}
          .edit=${this.editValue}
          .select=${this.select}
          placeholder="value"
          @blur=${this.onBlur}
          @input=${this.onInput}
          @mousedown=${(event) => this.onFocus(event, "value")}
          @dblclick=${(event) => this.onEdit(event, "value")}
        ></vuerd-grid-filter-text-editor>
        <vuerd-icon
          class="vuerd-button"
          title=${keymapRemoveColumn}
          icon="times"
          size="9"
          @click=${this.onRemoveFilterState}
        ></vuerd-icon>
      </div>
    `;
        }
        onRemoveFilterState() {
            const { store } = this.context;
            store.dispatch(removeFilterState([this.filterState.id]));
        }
        onFocus(event, focusType) {
            const { store } = this.context;
            const { focusFilter, editFilter } = store.editorState;
            if (editFilter === null ||
                editFilter.focusType !== focusType ||
                (focusFilter === null || focusFilter === void 0 ? void 0 : focusFilter.currentFocusId) !== this.filterState.id) {
                store.dispatch(focusTargetFilterState(this.filterState.id, focusType, event.ctrlKey || event.metaKey, event.shiftKey));
            }
        }
        onEdit(event, focusType) {
            const { store } = this.context;
            const { editFilter: editFilter$1, focusFilter } = store.editorState;
            if (focusFilter !== null && editFilter$1 === null) {
                store.dispatch(editFilter(focusType, this.filterState.id));
            }
        }
        onBlur(event) {
            const { store } = this.context;
            store.dispatch(editFilterEnd());
        }
        onInput(event) {
            const { store } = this.context;
            const input = event.target;
            store.dispatch(changeFilterStateValue(this.filterState.id, input.value));
        }
        onChange(event, focusType) {
            const { store } = this.context;
            switch (focusType) {
                case "columnType":
                    store.dispatch(changeFilterStateColumnType(this.filterState.id, event.detail.value));
                    break;
                case "filterCode":
                    store.dispatch(changeFilterStateFilterCode(this.filterState.id, event.detail.value));
                    break;
            }
        }
        onDragstart(event) {
            const { store } = this.context;
            store.dispatch(draggableFilterState(store, this.filterState.id, event.ctrlKey || event.metaKey));
        }
        onDragend(event) {
            const { store } = this.context;
            store.dispatch(draggableFilterStateEnd());
        }
        onDragover(event) {
            this.dispatchEvent(new CustomEvent("dragover", {
                detail: {
                    filterStateId: this.filterState.id,
                },
            }));
        }
    };
    __decorate([
        property({ type: Boolean })
    ], FilterState.prototype, "select", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterState.prototype, "draggable", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterState.prototype, "focusColumnType", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterState.prototype, "focusFilterCode", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterState.prototype, "focusValue", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterState.prototype, "editColumnType", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterState.prototype, "editFilterCode", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterState.prototype, "editValue", void 0);
    FilterState = __decorate([
        customElement("vuerd-grid-filter-state")
    ], FilterState);

    let FilterTextEditor = class FilterTextEditor extends EditorElement {
        constructor() {
            super(...arguments);
            this.edit = false;
            this.focusState = false;
            this.select = false;
            this.value = "";
            this.placeholder = "";
        }
        get classMap() {
            return {
                "vuerd-grid-filter-text-editor": true,
                placeholder: this.value.trim() === "" && !this.edit,
                focus: this.focusState && !this.edit,
                edit: this.edit,
                select: this.select,
            };
        }
        get placeholderValue() {
            if (this.value.trim() === "") {
                return this.placeholder;
            }
            return this.value;
        }
        updated(changedProperties) {
            changedProperties.forEach((oldValue, propName) => {
                switch (propName) {
                    case "edit":
                        if (this.edit) {
                            const input = this.renderRoot.querySelector("input");
                            if (input) {
                                const len = input.value.length;
                                input.selectionStart = len;
                                input.selectionEnd = len;
                                input.focus();
                            }
                        }
                        break;
                }
            });
        }
        render() {
            return this.edit
                ? html `
          <input
            class=${classMap(this.classMap)}
            type="text"
            spellcheck="false"
            .value=${this.value}
            placeholder=${this.placeholder}
            @blur=${this.onBlur}
          />
        `
                : html `
          <div class=${classMap(this.classMap)}>
            <span>${this.placeholderValue}</span>
          </div>
        `;
        }
        onBlur(event) {
            this.dispatchEvent(new Event("blur"));
        }
    };
    __decorate([
        property({ type: Boolean })
    ], FilterTextEditor.prototype, "edit", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterTextEditor.prototype, "focusState", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterTextEditor.prototype, "select", void 0);
    __decorate([
        property({ type: String })
    ], FilterTextEditor.prototype, "value", void 0);
    __decorate([
        property({ type: String })
    ], FilterTextEditor.prototype, "placeholder", void 0);
    FilterTextEditor = __decorate([
        customElement("vuerd-grid-filter-text-editor")
    ], FilterTextEditor);

    let FilterRadioEditor = class FilterRadioEditor extends EditorElement {
        constructor() {
            super(...arguments);
            this.width = 100;
            this.edit = false;
            this.focusState = false;
            this.select = false;
            this.value = "";
            this.placeholder = "";
            this.activeIndex = 0;
            this.items = [];
            this.subKeydown = null;
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-grid-filter-radio-editor")) {
                    this.dispatchEvent(new Event("blur"));
                }
            };
            this.onKeydown = (event) => {
                if (moveKeys.some((moveKey) => moveKey === event.key)) {
                    event.preventDefault();
                    const move = event.key === "ArrowUp" || event.key === "ArrowLeft" ? -1 : 1;
                    let index = this.activeIndex + move;
                    if (index < 0) {
                        index = this.items.length - 1;
                    }
                    else if (index > this.items.length - 1) {
                        index = 0;
                    }
                    this.onActiveIndex(index);
                }
                else if (event.code === "Space") {
                    this.onClick(this.items[this.activeIndex]);
                }
            };
        }
        get placeholderValue() {
            if (this.value.trim() === "") {
                return this.placeholder;
            }
            return this.value;
        }
        connectedCallback() {
            super.connectedCallback();
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.subscriptionList.push(fromEvent(editor, "mousedown").subscribe(this.onMousedown));
            this.items.forEach((item, i) => {
                if (item.value === this.value) {
                    this.activeIndex = i;
                }
            });
        }
        updated(changedProperties) {
            changedProperties.forEach((oldValue, propName) => {
                var _a, _b;
                switch (propName) {
                    case "edit":
                        if (this.edit) {
                            const { helper } = this.context;
                            (_a = this.subKeydown) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                            this.subKeydown = helper.keydown$.subscribe(this.onKeydown);
                        }
                        else {
                            (_b = this.subKeydown) === null || _b === void 0 ? void 0 : _b.unsubscribe();
                        }
                        break;
                }
            });
        }
        disconnectedCallback() {
            var _a;
            (_a = this.subKeydown) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            super.disconnectedCallback();
        }
        render() {
            return html `
      <div
        class=${classMap({
                "vuerd-grid-filter-radio-editor": true,
                placeholder: this.value.trim() === "" && !this.edit,
                focus: this.focusState && !this.edit,
                edit: this.edit,
                select: this.select,
            })}
        style=${styleMap({
                width: `${this.width}px`,
            })}
      >
        <span>${this.placeholderValue}</span>
        ${this.edit
                ? html `
              <ul class="vuerd-grid-filter-radio-editor-box">
                ${this.items.map((item, index) => html `
                      <li
                        class=${classMap({
                    active: this.activeIndex === index,
                })}
                        @click=${() => this.onClick(item)}
                        @mouseover=${() => this.onActiveIndex(index)}
                      >
                        ${this.value === item.value
                    ? html `
                              <span class="icon">
                                <vuerd-icon icon="check" size="12"></vuerd-icon>
                              </span>
                            `
                    : html `<span class="icon"></span>`}
                        <span>${item.name}</span>
                      </li>
                    `)}
              </ul>
            `
                : ""}
      </div>
    `;
        }
        onClick(item) {
            if (this.value !== item.value) {
                this.value = item.value;
                this.dispatchEvent(new CustomEvent("change", {
                    detail: {
                        value: item.value,
                    },
                }));
            }
        }
        onActiveIndex(index) {
            this.activeIndex = index;
        }
    };
    __decorate([
        property({ type: Number })
    ], FilterRadioEditor.prototype, "width", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterRadioEditor.prototype, "edit", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterRadioEditor.prototype, "focusState", void 0);
    __decorate([
        property({ type: Boolean })
    ], FilterRadioEditor.prototype, "select", void 0);
    __decorate([
        property({ type: String })
    ], FilterRadioEditor.prototype, "value", void 0);
    __decorate([
        property({ type: String })
    ], FilterRadioEditor.prototype, "placeholder", void 0);
    __decorate([
        property({ type: Number })
    ], FilterRadioEditor.prototype, "activeIndex", void 0);
    FilterRadioEditor = __decorate([
        customElement("vuerd-grid-filter-radio-editor")
    ], FilterRadioEditor);

    const GRID_HEADER_HEIGHT = 40;
    const HEADER_HEIGHT = GRID_HEADER_HEIGHT + SIZE_MENUBAR_HEIGHT;
    let Grid = class Grid extends EditorElement {
        constructor() {
            super(...arguments);
            this.height = defaultHeight;
            this.deleteBatchExecuting = false;
            this.changeBatchExecuting = false;
            this.deleteDataTypeSyncExecuting = false;
            this.changeDataTypeSyncExecuting = false;
            this.filter$ = new Subject();
            this.subFilterStateList = [];
            this.edit = false;
            this.gridColumns = [
                {
                    header: " ",
                    name: "tableName",
                    renderer: { type: GridTextRender, options: { placeholder: "" } },
                    editor: { type: GridTextEditor, options: { placeholder: "" } },
                },
                {
                    header: " ",
                    name: "tableComment",
                    renderer: { type: GridTextRender, options: { placeholder: "" } },
                    editor: { type: GridTextEditor, options: { placeholder: "" } },
                },
                {
                    header: "",
                    name: "option",
                    minWidth: 100,
                    renderer: { type: GridTextRender, options: { placeholder: "" } },
                    editor: { type: GridColumnOptionEditor },
                },
                {
                    header: "",
                    name: "name",
                    renderer: { type: GridTextRender, options: { placeholder: "" } },
                    editor: { type: GridTextEditor, options: { placeholder: "" } },
                },
                {
                    header: "",
                    name: "dataType",
                    minWidth: 200,
                    renderer: { type: GridTextRender, options: { placeholder: "" } },
                    editor: { type: GridColumnDataTypeEditor },
                },
                {
                    header: "",
                    name: "default",
                    renderer: { type: GridTextRender, options: { placeholder: "" } },
                    editor: { type: GridTextEditor, options: { placeholder: "" } },
                },
                {
                    header: "",
                    name: "comment",
                    renderer: { type: GridTextRender, options: { placeholder: "" } },
                    editor: { type: GridTextEditor, options: { placeholder: "" } },
                },
            ];
            this.onEditingStart = () => {
                this.edit = true;
            };
            this.onEditingFinish = () => {
                this.edit = false;
            };
            this.onAfterChange = (event) => {
                const { store, helper } = this.context;
                const { setting } = store.canvasState;
                const { value, prevValue, rowKey } = event;
                const row = this.grid.getRow(rowKey);
                if (row) {
                    const { tableId, columnId } = row;
                    switch (event.columnName) {
                        case "tableName":
                            if (!this.deleteBatchExecuting && !this.changeBatchExecuting) {
                                this.changeBatchExecuting = true;
                                store.dispatch(changeTableName(helper, tableId, value));
                                this.grid
                                    .findRows((row) => row.tableId === tableId && row.rowKey !== rowKey)
                                    .forEach((row) => {
                                        this.grid.setValue(row.rowKey, "tableName", value);
                                    });
                                this.changeBatchExecuting = false;
                            }
                            break;
                        case "tableComment":
                            if (!this.deleteBatchExecuting && !this.changeBatchExecuting) {
                                this.changeBatchExecuting = true;
                                store.dispatch(changeTableComment(helper, tableId, value));
                                this.grid
                                    .findRows((row) => row.tableId === tableId && row.rowKey !== rowKey)
                                    .forEach((row) => {
                                        this.grid.setValue(row.rowKey, "tableComment", value);
                                    });
                                this.changeBatchExecuting = false;
                            }
                            break;
                        case "option":
                            const changeOptions = changeColumnOptionList(prevValue, value);
                            const batchCommand = [];
                            this.batchCommandColumnOption(batchCommand, changeOptions, tableId, columnId);
                            if (batchCommand.length !== 0) {
                                store.dispatch(...batchCommand);
                            }
                            break;
                        case "name":
                            store.dispatch(changeColumnName(helper, tableId, columnId, value));
                            break;
                        case "dataType":
                            if (!this.deleteDataTypeSyncExecuting &&
                                !this.changeDataTypeSyncExecuting) {
                                this.changeDataTypeSyncExecuting = true;
                                const { tables } = this.context.store.tableState;
                                const { relationships } = this.context.store.relationshipState;
                                const column = getColumn(tables, tableId, columnId);
                                if (column) {
                                    store.dispatch(changeColumnDataType(helper, tableId, columnId, value));
                                    if (setting.relationshipDataTypeSync) {
                                        // DataTypeSync
                                        const columnIds = getDataTypeSyncColumns([column], tables, relationships).map((column) => column.id);
                                        this.grid
                                            .findRows((row) => columnIds.some((columnId) => columnId === row.columnId) &&
                                                row.rowKey !== rowKey)
                                            .forEach((row) => {
                                                this.grid.setValue(row.rowKey, "dataType", value);
                                            });
                                    }
                                }
                                this.changeDataTypeSyncExecuting = false;
                            }
                            break;
                        case "default":
                            store.dispatch(changeColumnDefault(helper, tableId, columnId, value));
                            break;
                        case "comment":
                            store.dispatch(changeColumnComment(helper, tableId, columnId, value));
                            break;
                    }
                }
                this.grid.clearModifiedData();
            };
        }
        get gridHeight() {
            return this.height - HEADER_HEIGHT;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, helper, keymap, eventBus } = this.context;
            this.subscriptionList.push(this.filter$.pipe(debounceTime(200)).subscribe(() => this.onFilter()), helper.keydown$.subscribe((event) => {
                if (!this.edit &&
                    (event.key === "Delete" || event.key === "Backspace")) {
                    const updatedRows = this.grid.getModifiedRows().updatedRows;
                    if (updatedRows) {
                        const { tables } = this.context.store.tableState;
                        const { relationships } = this.context.store.relationshipState;
                        const { setting } = this.context.store.canvasState;
                        const batchCommand = [];
                        const batchGridDataType = [];
                        const batchGridTableName = [];
                        const batchGridTableComment = [];
                        updatedRows.forEach((row) => {
                            const { rowKey, tableId, columnId, tableName, tableComment, option, name, dataType, comment, } = row;
                            const table = getData(tables, tableId);
                            const column = getColumn(tables, tableId, columnId);
                            if (table && column) {
                                if (tableName === "" && tableName !== table.name) {
                                    if (this.isCommandTable(batchCommand, "table.changeName", tableId)) {
                                        batchCommand.push(changeTableName(helper, tableId, ""));
                                        batchGridTableName.push({
                                            tableId,
                                            rowKey,
                                        });
                                    }
                                }
                                if (tableComment === "" && tableComment !== table.comment) {
                                    if (this.isCommandTable(batchCommand, "table.changeComment", tableId)) {
                                        batchCommand.push(changeTableComment(helper, tableId, ""));
                                        batchGridTableComment.push({
                                            tableId,
                                            rowKey,
                                        });
                                    }
                                }
                                if (option === "") {
                                    const changeOptions = currentColumnOptionList(column.option);
                                    this.batchCommandColumnOption(batchCommand, changeOptions, tableId, columnId);
                                }
                                if (name === "" && name !== column.name) {
                                    batchCommand.push(changeColumnName(helper, tableId, columnId, ""));
                                }
                                if (dataType === "" && dataType !== column.dataType) {
                                    batchCommand.push(changeColumnDataType(helper, tableId, columnId, ""));
                                    if (setting.relationshipDataTypeSync) {
                                        // DataTypeSync
                                        const columnIds = getDataTypeSyncColumns([column], tables, relationships).map((column) => column.id);
                                        batchGridDataType.push(this.grid.findRows((row) => columnIds.some((columnId) => columnId === row.columnId) && row.rowKey !== rowKey));
                                    }
                                }
                                if (row.default === "" && row.default !== column.default) {
                                    batchCommand.push(changeColumnDefault(helper, tableId, columnId, ""));
                                }
                                if (comment === "" && row.comment !== column.comment) {
                                    batchCommand.push(changeColumnComment(helper, tableId, columnId, ""));
                                }
                            }
                        });
                        store.dispatch(...batchCommand);
                        this.deleteDataTypeSyncExecuting = true;
                        batchGridDataType.forEach((rows) => {
                            rows.forEach((row) => {
                                this.grid.setValue(row.rowKey, "dataType", "");
                            });
                        });
                        this.deleteDataTypeSyncExecuting = false;
                        this.deleteBatchExecuting = true;
                        batchGridTableName.forEach(({ tableId, rowKey }) => {
                            this.grid
                                .findRows((row) => row.tableId === tableId && row.rowKey !== rowKey)
                                .forEach((row) => {
                                    this.grid.setValue(row.rowKey, "tableName", "");
                                });
                        });
                        batchGridTableComment.forEach(({ tableId, rowKey }) => {
                            this.grid
                                .findRows((row) => row.tableId === tableId && row.rowKey !== rowKey)
                                .forEach((row) => {
                                    this.grid.setValue(row.rowKey, "tableComment", "");
                                });
                        });
                        this.deleteBatchExecuting = false;
                        this.grid.clearModifiedData();
                    }
                }
                const { focusFilter, filterActive, editFilter: editFilter$1 } = store.editorState;
                if (filterActive &&
                    focusFilter !== null &&
                    editFilter$1 === null &&
                    moveKeys.some((moveKey) => moveKey === event.key)) {
                    store.dispatch(focusMoveFilter(event.key, event.shiftKey));
                }
                if (filterActive && focusFilter !== null && event.key === "Tab") {
                    event.preventDefault();
                    store.dispatch(focusMoveFilter("Tab", event.shiftKey));
                    // TODO: Refactoring edit
                    setTimeout(() => {
                        store.dispatch(editFilter(focusFilter.currentFocus, focusFilter.currentFocusId));
                    }, 0);
                }
                if (filterActive && keymapMatch(event, keymap.addColumn)) {
                    store.dispatch(addFilterState());
                }
                if (filterActive &&
                    focusFilter !== null &&
                    keymapMatch(event, keymap.removeColumn)) {
                    const filterStateList = focusFilter.selectFilterStateList;
                    if (filterStateList.length !== 0) {
                        store.dispatch(removeFilterState(filterStateList.map((filterState) => filterState.id)));
                    }
                }
                if (editFilter$1 === null && keymapMatch(event, keymap.selectAllColumn)) {
                    store.dispatch(selectAllFilterState$1());
                }
                if (focusFilter !== null && keymapMatch(event, keymap.edit)) {
                    if (editFilter$1 === null) {
                        store.dispatch(editFilter(focusFilter.currentFocus, focusFilter.currentFocusId));
                    }
                    else {
                        store.dispatch(editFilterEnd());
                    }
                }
                if (keymapMatch(event, keymap.find)) {
                    this.grid.blur();
                    eventBus.emit(Bus.Menubar.filter);
                }
                if (filterActive && keymapMatch(event, keymap.stop)) {
                    this.grid.focus(0, "tableName");
                }
            }), store.observe(store.editorState.filterStateList, () => {
                this.unsubscribeFilterStateList();
                this.observeFilterStateList();
                this.filter$.next();
            }), store.observe(store.editorState, (name) => {
                switch (name) {
                    case "filterOperatorType":
                        this.filter$.next();
                        break;
                }
            }));
        }
        firstUpdated() {
            const container = this.renderRoot.querySelector(".vuerd-grid");
            const gridDefaultColumn = {
                sortingType: "asc",
                sortable: true,
                onAfterChange: this.onAfterChange,
            };
            this.gridColumns.forEach((gridColumn) => {
                gridColumn = Object.assign(gridColumn, gridDefaultColumn);
            });
            this.grid = new tuiGrid$2({
                el: container,
                usageStatistics: false,
                bodyHeight: this.gridHeight,
                columnOptions: {
                    frozenCount: 1,
                    frozenBorderWidth: 0,
                    minWidth: 300,
                },
                columns: this.gridColumns,
                data: [],
            });
            this.onFilter();
            this.grid.on("editingStart", this.onEditingStart);
            this.grid.on("editingFinish", this.onEditingFinish);
            this.grid.focus(0, "tableName");
        }
        updated(changedProperties) {
            changedProperties.forEach((oldValue, propName) => {
                switch (propName) {
                    case "height":
                        this.grid.setBodyHeight(this.gridHeight);
                        break;
                }
            });
        }
        disconnectedCallback() {
            this.grid.off("editingStart", this.onEditingStart);
            this.grid.off("editingFinish", this.onEditingFinish);
            this.grid.destroy();
            super.disconnectedCallback();
        }
        render() {
            return html `<div class="vuerd-grid"></div>`;
        }
        onFilter() {
            const { store } = this.context;
            const rows = filterGridData(store);
            if (rows.length === 0) {
                this.grid.resetData([]);
            }
            else {
                this.grid.resetData(rows);
            }
        }
        batchCommandColumnOption(batchCommand, changeOptions, tableId, columnId) {
            const { store } = this.context;
            changeOptions.forEach((simpleOption) => {
                switch (simpleOption) {
                    case "PK":
                        batchCommand.push(changeColumnPrimaryKey(store, tableId, columnId));
                        break;
                    case "NN":
                        batchCommand.push(changeColumnNotNull(store, tableId, columnId));
                        break;
                    case "UQ":
                        batchCommand.push(changeColumnUnique(store, tableId, columnId));
                        break;
                    case "AI":
                        batchCommand.push(changeColumnAutoIncrement(store, tableId, columnId));
                        break;
                }
            });
        }
        isCommandTable(batchCommand, commandType, tableId) {
            return !batchCommand.some((command) => {
                if (command.type === commandType) {
                    const data = command.data;
                    return data.tableId === tableId;
                }
                return false;
            });
        }
        observeFilterStateList() {
            const { store } = this.context;
            const { filterStateList } = this.context.store.editorState;
            filterStateList.forEach((filterState) => {
                this.subFilterStateList.push(store.observe(filterState, () => this.filter$.next()));
            });
        }
        unsubscribeFilterStateList() {
            this.subFilterStateList.forEach((sub) => sub.unsubscribe());
            this.subFilterStateList = [];
        }
    };
    __decorate([
        property({ type: Number })
    ], Grid.prototype, "height", void 0);
    Grid = __decorate([
        customElement("vuerd-grid")
    ], Grid);

    function convertVisualization(store) {
        const { tableState, relationshipState } = store;
        const data = {
            nodes: [],
            links: [],
        };
        const tables = tableState.tables;
        const relationships = relationshipState.relationships;
        tables.forEach((table) => {
            data.nodes.push({
                id: table.id,
                name: table.name,
                group: "table",
            });
            table.columns.forEach((column) => {
                data.nodes.push({
                    id: column.id,
                    name: column.name,
                    group: "column",
                    tableId: table.id,
                });
                data.links.push({
                    source: table.id,
                    target: column.id,
                });
            });
        });
        relationships.forEach((relationship) => {
            const { start, end } = relationship;
            if (start.tableId !== end.tableId &&
                isLink(data.links, start.tableId, end.tableId)) {
                data.links.push({
                    source: start.tableId,
                    target: end.tableId,
                });
            }
        });
        return data;
    }
    function isLink(links, startTableId, endTableId) {
        let result = true;
        for (const link of links) {
            if (link.source === startTableId && link.target === endTableId) {
                result = false;
                break;
            }
        }
        return result;
    }
    /**
     * https://observablehq.com/@d3/disjoint-force-directed-graph
     */
    const scale = ordinal(schemeCategory10);
    function onDrag(simulation, eventBus) {
        return drag()
            .on("start", (d) => {
                if (!event.active)
                    simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
                eventBus.emit(Bus.Visualization.dragStart);
            })
            .on("drag", (d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on("end", (d) => {
                if (!event.active)
                    simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
                eventBus.emit(Bus.Visualization.dragEnd);
            });
    }
    function createVisualization(store, eventBus) {
        const data = convertVisualization(store);
        const links = data.links.map((d) => Object.create(d));
        const nodes = data.nodes.map((d) => Object.create(d));
        const simulation = forceSimulation(nodes)
            .force("link", forceLink(links).id((d) => d.id))
            .force("charge", forceManyBody())
            .force("x", forceX())
            .force("y", forceY());
        const svg = create("svg");
        const link = svg
            .append("g")
            .attr("stroke", "#999")
            .attr("stroke-opacity", 0.6)
            .selectAll("line")
            .data(links)
            .join("line")
            .attr("stroke-width", Math.sqrt(2));
        const node = svg
            .append("g")
            .attr("stroke", "#fff")
            .attr("stroke-width", 1.5)
            .selectAll("circle")
            .data(nodes)
            .join("circle")
            .attr("r", 5)
            .attr("fill", (d) => scale(d.group))
            .call(onDrag(simulation, eventBus));
        node.on("mouseover", (d) => {
            const node = data.nodes[d.index];
            let tableId = null;
            let columnId = null;
            if (node.group === "table") {
                tableId = node.id;
            }
            else if (node.group === "column" && node.tableId) {
                tableId = node.tableId;
                columnId = node.id;
            }
            eventBus.emit(Bus.Visualization.startPreview, {
                tableId,
                columnId,
            });
        });
        node.on("mouseleave", () => {
            eventBus.emit(Bus.Visualization.endPreview);
        });
        simulation.on("tick", () => {
            link
                .attr("x1", (d) => d.source.x)
                .attr("y1", (d) => d.source.y)
                .attr("x2", (d) => d.target.x)
                .attr("y2", (d) => d.target.y);
            node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
        });
        return svg;
    }

    let Table$3 = class Table extends EditorElement {
        constructor() {
            super(...arguments);
            this.columnId = null;
            this.top = 0;
            this.left = 0;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(this.table.ui, () => this.requestUpdate()), store.observe(this.table.columns, () => this.requestUpdate()), store.observe(store.canvasState.show, () => this.requestUpdate()));
        }
        render() {
            const { show } = this.context.store.canvasState;
            const widthColumn = this.table.maxWidthColumn();
            return html `
      <div
        class="vuerd-table"
        style=${styleMap({
                top: `${this.top}px`,
                left: `${this.left}px`,
                width: `${this.table.width()}px`,
                height: `${this.table.height()}px`,
            })}
      >
        <div class="vuerd-table-header">
          <div class="vuerd-table-header-top"></div>
          <div class="vuerd-table-header-body">
            <vuerd-input-edit
              class="vuerd-table-name"
              .width=${this.table.ui.widthName}
              .value=${this.table.name}
              placeholder="table"
            ></vuerd-input-edit>
            ${show.tableComment
                ? html `
                  <vuerd-input-edit
                    class="vuerd-table-comment"
                    .width=${this.table.ui.widthComment}
                    .value=${this.table.comment}
                    placeholder="comment"
                  ></vuerd-input-edit>
                `
                : ""}
          </div>
        </div>
        <div class="vuerd-table-body">
          ${repeat$1(this.table.columns, (column) => column.id, (column) => html `
                <vuerd-visualization-column
                  .column=${column}
                  .active=${this.columnId === column.id}
                  .widthName=${widthColumn.name}
                  .widthDataType=${widthColumn.dataType}
                  .widthNotNull=${widthColumn.notNull}
                  .widthDefault=${widthColumn.default}
                  .widthComment=${widthColumn.comment}
                  @request-update=${() => this.requestUpdate()}
                ></vuerd-visualization-column>
              `)}
        </div>
      </div>
    `;
        }
    };
    Table$3 = __decorate([
        customElement("vuerd-visualization-table")
    ], Table$3);

    let Column$2 = class Column extends EditorElement {
        constructor() {
            super(...arguments);
            this.active = false;
            this.widthName = SIZE_MIN_WIDTH;
            this.widthDataType = SIZE_MIN_WIDTH;
            this.widthNotNull = SIZE_MIN_WIDTH;
            this.widthDefault = SIZE_MIN_WIDTH;
            this.widthComment = SIZE_MIN_WIDTH;
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            this.subscriptionList.push(store.observe(store.canvasState.show, () => this.requestUpdate()), store.observe(this.column.ui, (name) => {
                switch (name) {
                    case "widthName":
                    case "widthComment":
                    case "widthDataType":
                    case "widthDefault":
                        this.dispatchEvent(new CustomEvent("request-update"));
                        break;
                }
            }));
        }
        render() {
            const { show, setting } = this.context.store.canvasState;
            const { ui, option } = this.column;
            const columns = [];
            setting.columnOrder.forEach((columnType) => {
                switch (columnType) {
                    case "columnName":
                        columns.push(html `
            <vuerd-input-edit
              .width=${this.widthName}
              .value=${this.column.name}
              .active=${this.active}
              placeholder="column"
            ></vuerd-input-edit>
          `);
                        break;
                    case "columnDataType":
                        if (show.columnDataType) {
                            columns.push(html `
              <vuerd-input-edit
                .width=${this.widthDataType}
                .value=${this.column.dataType}
                .active=${this.active}
                placeholder="dataType"
              ></vuerd-input-edit>
            `);
                        }
                        break;
                    case "columnNotNull":
                        if (show.columnNotNull) {
                            columns.push(html `
              <vuerd-column-not-null
                .columnOption=${this.column.option}
              ></vuerd-column-not-null>
            `);
                        }
                        break;
                    case "columnDefault":
                        if (show.columnDefault) {
                            columns.push(html `
              <vuerd-input-edit
                .width=${this.widthDefault}
                .value=${this.column.default}
                .active=${this.active}
                placeholder="default"
              ></vuerd-input-edit>
            `);
                        }
                        break;
                    case "columnComment":
                        if (show.columnComment) {
                            columns.push(html `
              <vuerd-input-edit
                .width=${this.widthComment}
                .value=${this.column.comment}
                .active=${this.active}
                placeholder="comment"
              ></vuerd-input-edit>
            `);
                        }
                        break;
                    case "columnUnique":
                        if (show.columnUnique) {
                            columns.push(html `
              <vuerd-column-unique
                .columnOption=${option}
              ></vuerd-column-unique>
            `);
                        }
                        break;
                    case "columnAutoIncrement":
                        if (show.columnAutoIncrement) {
                            columns.push(html `
              <vuerd-column-auto-increment
                .columnOption=${option}
              ></vuerd-column-auto-increment>
            `);
                        }
                        break;
                }
            });
            return html `
      <div
        class=${classMap({
                "vuerd-column": true,
                active: this.active,
            })}
      >
        <vuerd-column-key .columnUI=${ui}></vuerd-column-key>
        ${columns}
      </div>
    `;
        }
    };
    __decorate([
        property({ type: Boolean })
    ], Column$2.prototype, "active", void 0);
    __decorate([
        property({ type: Number })
    ], Column$2.prototype, "widthName", void 0);
    __decorate([
        property({ type: Number })
    ], Column$2.prototype, "widthDataType", void 0);
    __decorate([
        property({ type: Number })
    ], Column$2.prototype, "widthNotNull", void 0);
    __decorate([
        property({ type: Number })
    ], Column$2.prototype, "widthDefault", void 0);
    __decorate([
        property({ type: Number })
    ], Column$2.prototype, "widthComment", void 0);
    Column$2 = __decorate([
        customElement("vuerd-visualization-column")
    ], Column$2);

    const HEIGHT$2 = 1200;
    const MARGIN$1 = 20;
    let Visualization$1 = class Visualization extends EditorElement {
        constructor() {
            super(...arguments);
            this.width = defaultWidth;
            this.preview = false;
            this.drag = false;
            this.table = null;
            this.columnId = null;
            this.x = 0;
            this.y = 0;
            this.onStartPreview = (event) => {
                const { tableId, columnId } = event.detail;
                const { tables } = this.context.store.tableState;
                this.preview = true;
                this.table = getData(tables, tableId);
                this.columnId = columnId;
            };
            this.onEndPreview = (event) => {
                this.preview = false;
            };
            this.onDragStart = (event) => {
                this.drag = true;
            };
            this.onDragEnd = (event) => {
                this.drag = false;
            };
        }
        get visualization() {
            return this.renderRoot.querySelector(".vuerd-visualization");
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus } = this.context;
            this.selection = createVisualization(store, eventBus);
            this.setViewBox();
            this.subscriptionList.push(eventBus
                .on(Bus.Visualization.startPreview)
                .subscribe(this.onStartPreview), eventBus.on(Bus.Visualization.endPreview).subscribe(this.onEndPreview), eventBus.on(Bus.Visualization.dragStart).subscribe(this.onDragStart), eventBus.on(Bus.Visualization.dragEnd).subscribe(this.onDragEnd));
        }
        updated(changedProperties) {
            changedProperties.forEach((oldValue, propName) => {
                switch (propName) {
                    case "width":
                        this.setViewBox();
                        break;
                }
            });
        }
        render() {
            return html `
      <div class="vuerd-visualization" @mousemove=${this.onMousemove}>
        ${this.selection.node()}
        ${this.table && !this.drag && this.preview
                ? html `
              <vuerd-visualization-table
                .table=${this.table}
                .columnId=${this.columnId}
                .top=${this.y - MARGIN$1}
                .left=${this.x + MARGIN$1}
              ></vuerd-visualization-table>
            `
                : ""}
      </div>
    `;
        }
        onMousemove(event) {
            const visualization = this.visualization;
            this.x = event.x;
            this.y = event.y;
            if (visualization) {
                this.x += visualization.scrollLeft;
                this.y += visualization.scrollTop;
            }
        }
        setViewBox() {
            this.selection.attr("viewBox", [
                -this.width / 2,
                -HEIGHT$2 / 2,
                this.width,
                HEIGHT$2,
            ]);
        }
    };
    __decorate([
        property({ type: Number })
    ], Visualization$1.prototype, "width", void 0);
    __decorate([
        property({ type: Boolean })
    ], Visualization$1.prototype, "preview", void 0);
    __decorate([
        property({ type: Boolean })
    ], Visualization$1.prototype, "drag", void 0);
    __decorate([
        property({ type: Object })
    ], Visualization$1.prototype, "table", void 0);
    __decorate([
        property({ type: String })
    ], Visualization$1.prototype, "columnId", void 0);
    Visualization$1 = __decorate([
        customElement("vuerd-visualization")
    ], Visualization$1);

    function deepFreeze(obj) {
        if (obj instanceof Map) {
            obj.clear = obj.delete = obj.set = function () {
                throw new Error('map is read-only');
            };
        } else if (obj instanceof Set) {
            obj.add = obj.clear = obj.delete = function () {
                throw new Error('set is read-only');
            };
        }

        // Freeze self
        Object.freeze(obj);

        Object.getOwnPropertyNames(obj).forEach(function (name) {
            var prop = obj[name];

            // Freeze prop if it is an object
            if (typeof prop == 'object' && !Object.isFrozen(prop)) {
                deepFreeze(prop);
            }
        });

        return obj;
    }

    var deepFreezeEs6 = deepFreeze;
    var _default = deepFreeze;
    deepFreezeEs6.default = _default;

    class Response {
        /**
         * @param {CompiledMode} mode
         */
        constructor(mode) {
            // eslint-disable-next-line no-undefined
            if (mode.data === undefined) mode.data = {};

            this.data = mode.data;
        }

        ignoreMatch() {
            this.ignore = true;
        }
    }

    /**
     * @param {string} value
     * @returns {string}
     */
    function escapeHTML(value) {
        return value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }

    /**
     * performs a shallow merge of multiple objects into one
     *
     * @template T
     * @param {T} original
     * @param {Record<string,any>[]} objects
     * @returns {T} a single new object
     */
    function inherit$1(original, ...objects) {
        /** @type Record<string,any> */
        const result = Object.create(null);

        for (const key in original) {
            result[key] = original[key];
        }
        objects.forEach(function(obj) {
            for (const key in obj) {
                result[key] = obj[key];
            }
        });
        return /** @type {T} */ (result);
    }

    /* Stream merging */

    /**
     * @typedef Event
     * @property {'start'|'stop'} event
     * @property {number} offset
     * @property {Node} node
     */

    /**
     * @param {Node} node
     */
    function tag(node) {
        return node.nodeName.toLowerCase();
    }

    /**
     * @param {Node} node
     */
    function nodeStream(node) {
        /** @type Event[] */
        const result = [];
        (function _nodeStream(node, offset) {
            for (let child = node.firstChild; child; child = child.nextSibling) {
                if (child.nodeType === 3) {
                    offset += child.nodeValue.length;
                } else if (child.nodeType === 1) {
                    result.push({
                        event: 'start',
                        offset: offset,
                        node: child
                    });
                    offset = _nodeStream(child, offset);
                    // Prevent void elements from having an end tag that would actually
                    // double them in the output. There are more void elements in HTML
                    // but we list only those realistically expected in code display.
                    if (!tag(child).match(/br|hr|img|input/)) {
                        result.push({
                            event: 'stop',
                            offset: offset,
                            node: child
                        });
                    }
                }
            }
            return offset;
        })(node, 0);
        return result;
    }

    /**
     * @param {any} original - the original stream
     * @param {any} highlighted - stream of the highlighted source
     * @param {string} value - the original source itself
     */
    function mergeStreams(original, highlighted, value) {
        let processed = 0;
        let result = '';
        const nodeStack = [];

        function selectStream() {
            if (!original.length || !highlighted.length) {
                return original.length ? original : highlighted;
            }
            if (original[0].offset !== highlighted[0].offset) {
                return (original[0].offset < highlighted[0].offset) ? original : highlighted;
            }

            /*
        To avoid starting the stream just before it should stop the order is
        ensured that original always starts first and closes last:

        if (event1 == 'start' && event2 == 'start')
          return original;
        if (event1 == 'start' && event2 == 'stop')
          return highlighted;
        if (event1 == 'stop' && event2 == 'start')
          return original;
        if (event1 == 'stop' && event2 == 'stop')
          return highlighted;

        ... which is collapsed to:
        */
            return highlighted[0].event === 'start' ? original : highlighted;
        }

        /**
         * @param {Node} node
         */
        function open(node) {
            /** @param {Attr} attr */
            function attributeString(attr) {
                return ' ' + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
            }
            // @ts-ignore
            result += '<' + tag(node) + [].map.call(node.attributes, attributeString).join('') + '>';
        }

        /**
         * @param {Node} node
         */
        function close(node) {
            result += '</' + tag(node) + '>';
        }

        /**
         * @param {Event} event
         */
        function render(event) {
            (event.event === 'start' ? open : close)(event.node);
        }

        while (original.length || highlighted.length) {
            let stream = selectStream();
            result += escapeHTML(value.substring(processed, stream[0].offset));
            processed = stream[0].offset;
            if (stream === original) {
                /*
          On any opening or closing tag of the original markup we first close
          the entire highlighted node stack, then render the original tag along
          with all the following original tags at the same offset and then
          reopen all the tags on the highlighted stack.
          */
                nodeStack.reverse().forEach(close);
                do {
                    render(stream.splice(0, 1)[0]);
                    stream = selectStream();
                } while (stream === original && stream.length && stream[0].offset === processed);
                nodeStack.reverse().forEach(open);
            } else {
                if (stream[0].event === 'start') {
                    nodeStack.push(stream[0].node);
                } else {
                    nodeStack.pop();
                }
                render(stream.splice(0, 1)[0]);
            }
        }
        return result + escapeHTML(value.substr(processed));
    }

    var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        escapeHTML: escapeHTML,
        inherit: inherit$1,
        nodeStream: nodeStream,
        mergeStreams: mergeStreams
    });

    /**
     * @typedef {object} Renderer
     * @property {(text: string) => void} addText
     * @property {(node: Node) => void} openNode
     * @property {(node: Node) => void} closeNode
     * @property {() => string} value
     */

    /** @typedef {{kind?: string, sublanguage?: boolean}} Node */
    /** @typedef {{walk: (r: Renderer) => void}} Tree */
    /** */

    const SPAN_CLOSE = '</span>';

    /**
     * Determines if a node needs to be wrapped in <span>
     *
     * @param {Node} node */
    const emitsWrappingTags = (node) => {
        return !!node.kind;
    };

    /** @type {Renderer} */
    class HTMLRenderer {
        /**
         * Creates a new HTMLRenderer
         *
         * @param {Tree} parseTree - the parse tree (must support `walk` API)
         * @param {{classPrefix: string}} options
         */
        constructor(parseTree, options) {
            this.buffer = "";
            this.classPrefix = options.classPrefix;
            parseTree.walk(this);
        }

        /**
         * Adds texts to the output stream
         *
         * @param {string} text */
        addText(text) {
            this.buffer += escapeHTML(text);
        }

        /**
         * Adds a node open to the output stream (if needed)
         *
         * @param {Node} node */
        openNode(node) {
            if (!emitsWrappingTags(node)) return;

            let className = node.kind;
            if (!node.sublanguage) {
                className = `${this.classPrefix}${className}`;
            }
            this.span(className);
        }

        /**
         * Adds a node close to the output stream (if needed)
         *
         * @param {Node} node */
        closeNode(node) {
            if (!emitsWrappingTags(node)) return;

            this.buffer += SPAN_CLOSE;
        }

        /**
         * returns the accumulated buffer
         */
        value() {
            return this.buffer;
        }

        // helpers

        /**
         * Builds a span element
         *
         * @param {string} className */
        span(className) {
            this.buffer += `<span class="${className}">`;
        }
    }

    /** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */
    /** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */
    /**  */

    class TokenTree {
        constructor() {
            /** @type DataNode */
            this.rootNode = { children: [] };
            this.stack = [this.rootNode];
        }

        get top() {
            return this.stack[this.stack.length - 1];
        }

        get root() { return this.rootNode; }

        /** @param {Node} node */
        add(node) {
            this.top.children.push(node);
        }

        /** @param {string} kind */
        openNode(kind) {
            /** @type Node */
            const node = { kind, children: [] };
            this.add(node);
            this.stack.push(node);
        }

        closeNode() {
            if (this.stack.length > 1) {
                return this.stack.pop();
            }
            // eslint-disable-next-line no-undefined
            return undefined;
        }

        closeAllNodes() {
            while (this.closeNode());
        }

        toJSON() {
            return JSON.stringify(this.rootNode, null, 4);
        }

        /**
         * @typedef { import("./html_renderer").Renderer } Renderer
         * @param {Renderer} builder
         */
        walk(builder) {
            // this does not
            return this.constructor._walk(builder, this.rootNode);
            // this works
            // return TokenTree._walk(builder, this.rootNode);
        }

        /**
         * @param {Renderer} builder
         * @param {Node} node
         */
        static _walk(builder, node) {
            if (typeof node === "string") {
                builder.addText(node);
            } else if (node.children) {
                builder.openNode(node);
                node.children.forEach((child) => this._walk(builder, child));
                builder.closeNode(node);
            }
            return builder;
        }

        /**
         * @param {Node} node
         */
        static _collapse(node) {
            if (typeof node === "string") return;
            if (!node.children) return;

            if (node.children.every(el => typeof el === "string")) {
                // node.text = node.children.join("");
                // delete node.children;
                node.children = [node.children.join("")];
            } else {
                node.children.forEach((child) => {
                    TokenTree._collapse(child);
                });
            }
        }
    }

    /**
     Currently this is all private API, but this is the minimal API necessary
     that an Emitter must implement to fully support the parser.

     Minimal interface:

     - addKeyword(text, kind)
     - addText(text)
     - addSublanguage(emitter, subLanguageName)
     - finalize()
     - openNode(kind)
     - closeNode()
     - closeAllNodes()
     - toHTML()

     */

    /**
     * @implements {Emitter}
     */
    class TokenTreeEmitter extends TokenTree {
        /**
         * @param {*} options
         */
        constructor(options) {
            super();
            this.options = options;
        }

        /**
         * @param {string} text
         * @param {string} kind
         */
        addKeyword(text, kind) {
            if (text === "") { return; }

            this.openNode(kind);
            this.addText(text);
            this.closeNode();
        }

        /**
         * @param {string} text
         */
        addText(text) {
            if (text === "") { return; }

            this.add(text);
        }

        /**
         * @param {Emitter & {root: DataNode}} emitter
         * @param {string} name
         */
        addSublanguage(emitter, name) {
            /** @type DataNode */
            const node = emitter.root;
            node.kind = name;
            node.sublanguage = true;
            this.add(node);
        }

        toHTML() {
            const renderer = new HTMLRenderer(this, this.options);
            return renderer.value();
        }

        finalize() {
            return true;
        }
    }

    /**
     * @param {string} value
     * @returns {RegExp}
     * */
    function escape(value) {
        return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'm');
    }

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function source(re) {
        if (!re) return null;
        if (typeof re === "string") return re;

        return re.source;
    }

    /**
     * @param {...(RegExp | string) } args
     * @returns {string}
     */
    function concat(...args) {
        const joined = args.map((x) => source(x)).join("");
        return joined;
    }

    /**
     * @param {RegExp} re
     * @returns {number}
     */
    function countMatchGroups(re) {
        return (new RegExp(re.toString() + '|')).exec('').length - 1;
    }

    /**
     * Does lexeme start with a regular expression match at the beginning
     * @param {RegExp} re
     * @param {string} lexeme
     */
    function startsWith(re, lexeme) {
        const match = re && re.exec(lexeme);
        return match && match.index === 0;
    }

    // join logically computes regexps.join(separator), but fixes the
    // backreferences so they continue to match.
    // it also places each individual regular expression into it's own
    // match group, keeping track of the sequencing of those match groups
    // is currently an exercise for the caller. :-)
    /**
     * @param {(string | RegExp)[]} regexps
     * @param {string} separator
     * @returns {string}
     */
    function join(regexps, separator = "|") {
        // backreferenceRe matches an open parenthesis or backreference. To avoid
        // an incorrect parse, it additionally matches the following:
        // - [...] elements, where the meaning of parentheses and escapes change
        // - other escape sequences, so we do not misparse escape sequences as
        //   interesting elements
        // - non-matching or lookahead parentheses, which do not capture. These
        //   follow the '(' with a '?'.
        const backreferenceRe = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
        let numCaptures = 0;
        let ret = '';
        for (let i = 0; i < regexps.length; i++) {
            numCaptures += 1;
            const offset = numCaptures;
            let re = source(regexps[i]);
            if (i > 0) {
                ret += separator;
            }
            ret += "(";
            while (re.length > 0) {
                const match = backreferenceRe.exec(re);
                if (match == null) {
                    ret += re;
                    break;
                }
                ret += re.substring(0, match.index);
                re = re.substring(match.index + match[0].length);
                if (match[0][0] === '\\' && match[1]) {
                    // Adjust the backreference.
                    ret += '\\' + String(Number(match[1]) + offset);
                } else {
                    ret += match[0];
                    if (match[0] === '(') {
                        numCaptures++;
                    }
                }
            }
            ret += ")";
        }
        return ret;
    }

    // Common regexps
    const IDENT_RE = '[a-zA-Z]\\w*';
    const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
    const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
    const C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
    const BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
    const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

    /**
     * @param { Partial<Mode> & {binary?: string | RegExp} } opts
     */
    const SHEBANG = (opts = {}) => {
        const beginShebang = /^#![ ]*\//;
        if (opts.binary) {
            opts.begin = concat(
                beginShebang,
                /.*\b/,
                opts.binary,
                /\b.*/);
        }
        return inherit$1({
            className: 'meta',
            begin: beginShebang,
            end: /$/,
            relevance: 0,
            /** @type {ModeCallback} */
            "on:begin": (m, resp) => {
                if (m.index !== 0) resp.ignoreMatch();
            }
        }, opts);
    };

    // Common modes
    const BACKSLASH_ESCAPE = {
        begin: '\\\\[\\s\\S]', relevance: 0
    };
    const APOS_STRING_MODE = {
        className: 'string',
        begin: '\'',
        end: '\'',
        illegal: '\\n',
        contains: [BACKSLASH_ESCAPE]
    };
    const QUOTE_STRING_MODE = {
        className: 'string',
        begin: '"',
        end: '"',
        illegal: '\\n',
        contains: [BACKSLASH_ESCAPE]
    };
    const PHRASAL_WORDS_MODE = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    /**
     * Creates a comment mode
     *
     * @param {string | RegExp} begin
     * @param {string | RegExp} end
     * @param {Mode | {}} [modeOptions]
     * @returns {Partial<Mode>}
     */
    const COMMENT = function(begin, end, modeOptions = {}) {
        const mode = inherit$1(
            {
                className: 'comment',
                begin,
                end,
                contains: []
            },
            modeOptions
        );
        mode.contains.push(PHRASAL_WORDS_MODE);
        mode.contains.push({
            className: 'doctag',
            begin: '(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):',
            relevance: 0
        });
        return mode;
    };
    const C_LINE_COMMENT_MODE = COMMENT('//', '$');
    const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
    const HASH_COMMENT_MODE = COMMENT('#', '$');
    const NUMBER_MODE = {
        className: 'number',
        begin: NUMBER_RE,
        relevance: 0
    };
    const C_NUMBER_MODE = {
        className: 'number',
        begin: C_NUMBER_RE,
        relevance: 0
    };
    const BINARY_NUMBER_MODE = {
        className: 'number',
        begin: BINARY_NUMBER_RE,
        relevance: 0
    };
    const CSS_NUMBER_MODE = {
        className: 'number',
        begin: NUMBER_RE + '(' +
            '%|em|ex|ch|rem' +
            '|vw|vh|vmin|vmax' +
            '|cm|mm|in|pt|pc|px' +
            '|deg|grad|rad|turn' +
            '|s|ms' +
            '|Hz|kHz' +
            '|dpi|dpcm|dppx' +
            ')?',
        relevance: 0
    };
    const REGEXP_MODE = {
        // this outer rule makes sure we actually have a WHOLE regex and not simply
        // an expression such as:
        //
        //     3 / something
        //
        // (which will then blow up when regex's `illegal` sees the newline)
        begin: /(?=\/[^/\n]*\/)/,
        contains: [{
            className: 'regexp',
            begin: /\//,
            end: /\/[gimuy]*/,
            illegal: /\n/,
            contains: [
                BACKSLASH_ESCAPE,
                {
                    begin: /\[/,
                    end: /\]/,
                    relevance: 0,
                    contains: [BACKSLASH_ESCAPE]
                }
            ]
        }]
    };
    const TITLE_MODE = {
        className: 'title',
        begin: IDENT_RE,
        relevance: 0
    };
    const UNDERSCORE_TITLE_MODE = {
        className: 'title',
        begin: UNDERSCORE_IDENT_RE,
        relevance: 0
    };
    const METHOD_GUARD = {
        // excludes method names from keyword processing
        begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
        relevance: 0
    };

    /**
     * Adds end same as begin mechanics to a mode
     *
     * Your mode must include at least a single () match group as that first match
     * group is what is used for comparison
     * @param {Partial<Mode>} mode
     */
    const END_SAME_AS_BEGIN = function(mode) {
        return Object.assign(mode,
            {
                /** @type {ModeCallback} */
                'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },
                /** @type {ModeCallback} */
                'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }
            });
    };

    var MODES = /*#__PURE__*/Object.freeze({
        __proto__: null,
        IDENT_RE: IDENT_RE,
        UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,
        NUMBER_RE: NUMBER_RE,
        C_NUMBER_RE: C_NUMBER_RE,
        BINARY_NUMBER_RE: BINARY_NUMBER_RE,
        RE_STARTERS_RE: RE_STARTERS_RE,
        SHEBANG: SHEBANG,
        BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,
        APOS_STRING_MODE: APOS_STRING_MODE,
        QUOTE_STRING_MODE: QUOTE_STRING_MODE,
        PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,
        COMMENT: COMMENT,
        C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,
        C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,
        HASH_COMMENT_MODE: HASH_COMMENT_MODE,
        NUMBER_MODE: NUMBER_MODE,
        C_NUMBER_MODE: C_NUMBER_MODE,
        BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,
        CSS_NUMBER_MODE: CSS_NUMBER_MODE,
        REGEXP_MODE: REGEXP_MODE,
        TITLE_MODE: TITLE_MODE,
        UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,
        METHOD_GUARD: METHOD_GUARD,
        END_SAME_AS_BEGIN: END_SAME_AS_BEGIN
    });

    // keywords that should have no default relevance value
    const COMMON_KEYWORDS = [
        'of',
        'and',
        'for',
        'in',
        'not',
        'or',
        'if',
        'then',
        'parent', // common variable name
        'list', // common variable name
        'value' // common variable name
    ];

    // compilation

    /**
     * Compiles a language definition result
     *
     * Given the raw result of a language definition (Language), compiles this so
     * that it is ready for highlighting code.
     * @param {Language} language
     * @returns {CompiledLanguage}
     */
    function compileLanguage(language) {
        /**
         * Builds a regex with the case sensativility of the current language
         *
         * @param {RegExp | string} value
         * @param {boolean} [global]
         */
        function langRe(value, global) {
            return new RegExp(
                source(value),
                'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
            );
        }

        /**
         Stores multiple regular expressions and allows you to quickly search for
         them all in a string simultaneously - returning the first match.  It does
         this by creating a huge (a|b|c) regex - each individual item wrapped with ()
         and joined by `|` - using match groups to track position.  When a match is
         found checking which position in the array has content allows us to figure
         out which of the original regexes / match groups triggered the match.

         The match object itself (the result of `Regex.exec`) is returned but also
         enhanced by merging in any meta-data that was registered with the regex.
         This is how we keep track of which mode matched, and what type of rule
         (`illegal`, `begin`, end, etc).
         */
        class MultiRegex {
            constructor() {
                this.matchIndexes = {};
                // @ts-ignore
                this.regexes = [];
                this.matchAt = 1;
                this.position = 0;
            }

            // @ts-ignore
            addRule(re, opts) {
                opts.position = this.position++;
                // @ts-ignore
                this.matchIndexes[this.matchAt] = opts;
                this.regexes.push([opts, re]);
                this.matchAt += countMatchGroups(re) + 1;
            }

            compile() {
                if (this.regexes.length === 0) {
                    // avoids the need to check length every time exec is called
                    // @ts-ignore
                    this.exec = () => null;
                }
                const terminators = this.regexes.map(el => el[1]);
                this.matcherRe = langRe(join(terminators), true);
                this.lastIndex = 0;
            }

            /** @param {string} s */
            exec(s) {
                this.matcherRe.lastIndex = this.lastIndex;
                const match = this.matcherRe.exec(s);
                if (!match) { return null; }

                // eslint-disable-next-line no-undefined
                const i = match.findIndex((el, i) => i > 0 && el !== undefined);
                // @ts-ignore
                const matchData = this.matchIndexes[i];
                // trim off any earlier non-relevant match groups (ie, the other regex
                // match groups that make up the multi-matcher)
                match.splice(0, i);

                return Object.assign(match, matchData);
            }
        }

        /*
        Created to solve the key deficiently with MultiRegex - there is no way to
        test for multiple matches at a single location.  Why would we need to do
        that?  In the future a more dynamic engine will allow certain matches to be
        ignored.  An example: if we matched say the 3rd regex in a large group but
        decided to ignore it - we'd need to started testing again at the 4th
        regex... but MultiRegex itself gives us no real way to do that.

        So what this class creates MultiRegexs on the fly for whatever search
        position they are needed.

        NOTE: These additional MultiRegex objects are created dynamically.  For most
        grammars most of the time we will never actually need anything more than the
        first MultiRegex - so this shouldn't have too much overhead.

        Say this is our search group, and we match regex3, but wish to ignore it.

          regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0

        What we need is a new MultiRegex that only includes the remaining
        possibilities:

          regex4 | regex5                               ' ie, startAt = 3

        This class wraps all that complexity up in a simple API... `startAt` decides
        where in the array of expressions to start doing the matching. It
        auto-increments, so if a match is found at position 2, then startAt will be
        set to 3.  If the end is reached startAt will return to 0.

        MOST of the time the parser will be setting startAt manually to 0.
      */
        class ResumableMultiRegex {
            constructor() {
                // @ts-ignore
                this.rules = [];
                // @ts-ignore
                this.multiRegexes = [];
                this.count = 0;

                this.lastIndex = 0;
                this.regexIndex = 0;
            }

            // @ts-ignore
            getMatcher(index) {
                if (this.multiRegexes[index]) return this.multiRegexes[index];

                const matcher = new MultiRegex();
                this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
                matcher.compile();
                this.multiRegexes[index] = matcher;
                return matcher;
            }

            resumingScanAtSamePosition() {
                return this.regexIndex !== 0;
            }

            considerAll() {
                this.regexIndex = 0;
            }

            // @ts-ignore
            addRule(re, opts) {
                this.rules.push([re, opts]);
                if (opts.type === "begin") this.count++;
            }

            /** @param {string} s */
            exec(s) {
                const m = this.getMatcher(this.regexIndex);
                m.lastIndex = this.lastIndex;
                let result = m.exec(s);

                // The following is because we have no easy way to say "resume scanning at the
                // existing position but also skip the current rule ONLY". What happens is
                // all prior rules are also skipped which can result in matching the wrong
                // thing. Example of matching "booger":

                // our matcher is [string, "booger", number]
                //
                // ....booger....

                // if "booger" is ignored then we'd really need a regex to scan from the
                // SAME position for only: [string, number] but ignoring "booger" (if it
                // was the first match), a simple resume would scan ahead who knows how
                // far looking only for "number", ignoring potential string matches (or
                // future "booger" matches that might be valid.)

                // So what we do: We execute two matchers, one resuming at the same
                // position, but the second full matcher starting at the position after:

                //     /--- resume first regex match here (for [number])
                //     |/---- full match here for [string, "booger", number]
                //     vv
                // ....booger....

                // Which ever results in a match first is then used. So this 3-4 step
                // process essentially allows us to say "match at this position, excluding
                // a prior rule that was ignored".
                //
                // 1. Match "booger" first, ignore. Also proves that [string] does non match.
                // 2. Resume matching for [number]
                // 3. Match at index + 1 for [string, "booger", number]
                // 4. If #2 and #3 result in matches, which came first?
                if (this.resumingScanAtSamePosition()) {
                    if (result && result.index === this.lastIndex) ; else { // use the second matcher result
                        const m2 = this.getMatcher(0);
                        m2.lastIndex = this.lastIndex + 1;
                        result = m2.exec(s);
                    }
                }

                if (result) {
                    this.regexIndex += result.position + 1;
                    if (this.regexIndex === this.count) {
                        // wrap-around to considering all matches again
                        this.considerAll();
                    }
                }

                return result;
            }
        }

        /**
         * Given a mode, builds a huge ResumableMultiRegex that can be used to walk
         * the content and find matches.
         *
         * @param {CompiledMode} mode
         * @returns {ResumableMultiRegex}
         */
        function buildModeRegex(mode) {
            const mm = new ResumableMultiRegex();

            mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: "begin" }));

            if (mode.terminator_end) {
                mm.addRule(mode.terminator_end, { type: "end" });
            }
            if (mode.illegal) {
                mm.addRule(mode.illegal, { type: "illegal" });
            }

            return mm;
        }

        // TODO: We need negative look-behind support to do this properly
        /**
         * Skip a match if it has a preceding dot
         *
         * This is used for `beginKeywords` to prevent matching expressions such as
         * `bob.keyword.do()`. The mode compiler automatically wires this up as a
         * special _internal_ 'on:begin' callback for modes with `beginKeywords`
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        function skipIfhasPrecedingDot(match, response) {
            const before = match.input[match.index - 1];
            if (before === ".") {
                response.ignoreMatch();
            }
        }

        /** skip vs abort vs ignore
         *
         * @skip   - The mode is still entered and exited normally (and contains rules apply),
         *           but all content is held and added to the parent buffer rather than being
         *           output when the mode ends.  Mostly used with `sublanguage` to build up
         *           a single large buffer than can be parsed by sublanguage.
         *
         *             - The mode begin ands ends normally.
         *             - Content matched is added to the parent mode buffer.
         *             - The parser cursor is moved forward normally.
         *
         * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it
         *           never matched) but DOES NOT continue to match subsequent `contains`
         *           modes.  Abort is bad/suboptimal because it can result in modes
         *           farther down not getting applied because an earlier rule eats the
         *           content but then aborts.
         *
         *             - The mode does not begin.
         *             - Content matched by `begin` is added to the mode buffer.
         *             - The parser cursor is moved forward accordingly.
         *
         * @ignore - Ignores the mode (as if it never matched) and continues to match any
         *           subsequent `contains` modes.  Ignore isn't technically possible with
         *           the current parser implementation.
         *
         *             - The mode does not begin.
         *             - Content matched by `begin` is ignored.
         *             - The parser cursor is not moved forward.
         */

        /**
         * Compiles an individual mode
         *
         * This can raise an error if the mode contains certain detectable known logic
         * issues.
         * @param {Mode} mode
         * @param {CompiledMode | null} [parent]
         * @returns {CompiledMode | never}
         */
        function compileMode(mode, parent) {
            const cmode = /** @type CompiledMode */ (mode);
            if (mode.compiled) return cmode;
            mode.compiled = true;

            // __beforeBegin is considered private API, internal use only
            mode.__beforeBegin = null;

            mode.keywords = mode.keywords || mode.beginKeywords;

            let keywordPattern = null;
            if (typeof mode.keywords === "object") {
                keywordPattern = mode.keywords.$pattern;
                delete mode.keywords.$pattern;
            }

            if (mode.keywords) {
                mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
            }

            // both are not allowed
            if (mode.lexemes && keywordPattern) {
                throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
            }

            // `mode.lexemes` was the old standard before we added and now recommend
            // using `keywords.$pattern` to pass the keyword pattern
            cmode.keywordPatternRe = langRe(mode.lexemes || keywordPattern || /\w+/, true);

            if (parent) {
                if (mode.beginKeywords) {
                    // for languages with keywords that include non-word characters checking for
                    // a word boundary is not sufficient, so instead we check for a word boundary
                    // or whitespace - this does no harm in any case since our keyword engine
                    // doesn't allow spaces in keywords anyways and we still check for the boundary
                    // first
                    mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)';
                    mode.__beforeBegin = skipIfhasPrecedingDot;
                }
                if (!mode.begin) mode.begin = /\B|\b/;
                cmode.beginRe = langRe(mode.begin);
                if (mode.endSameAsBegin) mode.end = mode.begin;
                if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
                if (mode.end) cmode.endRe = langRe(mode.end);
                cmode.terminator_end = source(mode.end) || '';
                if (mode.endsWithParent && parent.terminator_end) {
                    cmode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
                }
            }
            if (mode.illegal) cmode.illegalRe = langRe(mode.illegal);
            // eslint-disable-next-line no-undefined
            if (mode.relevance === undefined) mode.relevance = 1;
            if (!mode.contains) mode.contains = [];

            mode.contains = [].concat(...mode.contains.map(function(c) {
                return expandOrCloneMode(c === 'self' ? mode : c);
            }));
            mode.contains.forEach(function(c) { compileMode(/** @type Mode */ (c), cmode); });

            if (mode.starts) {
                compileMode(mode.starts, parent);
            }

            cmode.matcher = buildModeRegex(cmode);
            return cmode;
        }

        // self is not valid at the top-level
        if (language.contains && language.contains.includes('self')) {
            throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        }

        // we need a null object, which inherit will guarantee
        language.classNameAliases = inherit$1(language.classNameAliases || {});

        return compileMode(/** @type Mode */ (language));
    }

    /**
     * Determines if a mode has a dependency on it's parent or not
     *
     * If a mode does have a parent dependency then often we need to clone it if
     * it's used in multiple places so that each copy points to the correct parent,
     * where-as modes without a parent can often safely be re-used at the bottom of
     * a mode chain.
     *
     * @param {Mode | null} mode
     * @returns {boolean} - is there a dependency on the parent?
     * */
    function dependencyOnParent(mode) {
        if (!mode) return false;

        return mode.endsWithParent || dependencyOnParent(mode.starts);
    }

    /**
     * Expands a mode or clones it if necessary
     *
     * This is necessary for modes with parental dependenceis (see notes on
     * `dependencyOnParent`) and for nodes that have `variants` - which must then be
     * exploded into their own individual modes at compile time.
     *
     * @param {Mode} mode
     * @returns {Mode | Mode[]}
     * */
    function expandOrCloneMode(mode) {
        if (mode.variants && !mode.cached_variants) {
            mode.cached_variants = mode.variants.map(function(variant) {
                return inherit$1(mode, { variants: null }, variant);
            });
        }

        // EXPAND
        // if we have variants then essentially "replace" the mode with the variants
        // this happens in compileMode, where this function is called from
        if (mode.cached_variants) {
            return mode.cached_variants;
        }

        // CLONE
        // if we have dependencies on parents then we need a unique
        // instance of ourselves, so we can be reused with many
        // different parents without issue
        if (dependencyOnParent(mode)) {
            return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
        }

        if (Object.isFrozen(mode)) {
            return inherit$1(mode);
        }

        // no special dependency issues, just return ourselves
        return mode;
    }

    /***********************************************
     Keywords
     ***********************************************/

    /**
     * Given raw keywords from a language definition, compile them.
     *
     * @param {string | Record<string,string>} rawKeywords
     * @param {boolean} caseInsensitive
     */
    function compileKeywords(rawKeywords, caseInsensitive) {
        /** @type KeywordDict */
        const compiledKeywords = {};

        if (typeof rawKeywords === 'string') { // string
            splitAndCompile('keyword', rawKeywords);
        } else {
            Object.keys(rawKeywords).forEach(function(className) {
                splitAndCompile(className, rawKeywords[className]);
            });
        }
        return compiledKeywords;

        // ---

        /**
         * Compiles an individual list of keywords
         *
         * Ex: "for if when while|5"
         *
         * @param {string} className
         * @param {string} keywordList
         */
        function splitAndCompile(className, keywordList) {
            if (caseInsensitive) {
                keywordList = keywordList.toLowerCase();
            }
            keywordList.split(' ').forEach(function(keyword) {
                const pair = keyword.split('|');
                compiledKeywords[pair[0]] = [className, scoreForKeyword(pair[0], pair[1])];
            });
        }
    }

    /**
     * Returns the proper score for a given keyword
     *
     * Also takes into account comment keywords, which will be scored 0 UNLESS
     * another score has been manually assigned.
     * @param {string} keyword
     * @param {string} [providedScore]
     */
    function scoreForKeyword(keyword, providedScore) {
        // manual scores always win over common keywords
        // so you can force a score of 1 if you really insist
        if (providedScore) {
            return Number(providedScore);
        }

        return commonKeyword(keyword) ? 0 : 1;
    }

    /**
     * Determines if a given keyword is common or not
     *
     * @param {string} keyword */
    function commonKeyword(keyword) {
        return COMMON_KEYWORDS.includes(keyword.toLowerCase());
    }

    var version = "10.4.0";

    // @ts-nocheck

    function hasValueOrEmptyAttribute(value) {
        return Boolean(value || value === "");
    }

    function BuildVuePlugin(hljs) {
        const Component = {
            props: ["language", "code", "autodetect"],
            data: function() {
                return {
                    detectedLanguage: "",
                    unknownLanguage: false
                };
            },
            computed: {
                className() {
                    if (this.unknownLanguage) return "";

                    return "hljs " + this.detectedLanguage;
                },
                highlighted() {
                    // no idea what language to use, return raw code
                    if (!this.autoDetect && !hljs.getLanguage(this.language)) {
                        console.warn(`The language "${this.language}" you specified could not be found.`);
                        this.unknownLanguage = true;
                        return escapeHTML(this.code);
                    }

                    let result;
                    if (this.autoDetect) {
                        result = hljs.highlightAuto(this.code);
                        this.detectedLanguage = result.language;
                    } else {
                        result = hljs.highlight(this.language, this.code, this.ignoreIllegals);
                        this.detectedLanguage = this.language;
                    }
                    return result.value;
                },
                autoDetect() {
                    return !this.language || hasValueOrEmptyAttribute(this.autodetect);
                },
                ignoreIllegals() {
                    return true;
                }
            },
            // this avoids needing to use a whole Vue compilation pipeline just
            // to build Highlight.js
            render(createElement) {
                return createElement("pre", {}, [
                    createElement("code", {
                        class: this.className,
                        domProps: { innerHTML: this.highlighted }})
                ]);
            }
            // template: `<pre><code :class="className" v-html="highlighted"></code></pre>`
        };

        const VuePlugin = {
            install(Vue) {
                Vue.component('highlightjs', Component);
            }
        };

        return { Component, VuePlugin };
    }

    /*
    Syntax highlighting with language autodetection.
    https://highlightjs.org/
    */

    const escape$1 = escapeHTML;
    const inherit$1$1 = inherit$1;

    const { nodeStream: nodeStream$1, mergeStreams: mergeStreams$1 } = utils;
    const NO_MATCH = Symbol("nomatch");

    /**
     * @param {any} hljs - object that is extended (legacy)
     * @returns {HLJSApi}
     */
    const HLJS = function(hljs) {
        // Convenience variables for build-in objects
        /** @type {unknown[]} */
        const ArrayProto = [];

        // Global internal variables used within the highlight.js library.
        /** @type {Record<string, Language>} */
        const languages = Object.create(null);
        /** @type {Record<string, string>} */
        const aliases = Object.create(null);
        /** @type {HLJSPlugin[]} */
        const plugins = [];

        // safe/production mode - swallows more errors, tries to keep running
        // even if a single syntax or parse hits a fatal error
        let SAFE_MODE = true;
        const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
        const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
        /** @type {Language} */
        const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };

        // Global options used when within external APIs. This is modified when
        // calling the `hljs.configure` function.
        /** @type HLJSOptions */
        let options = {
            noHighlightRe: /^(no-?highlight)$/i,
            languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
            classPrefix: 'hljs-',
            tabReplace: null,
            useBR: false,
            languages: null,
            // beta configuration options, subject to change, welcome to discuss
            // https://github.com/highlightjs/highlight.js/issues/1086
            __emitter: TokenTreeEmitter
        };

        /* Utility functions */

        /**
         * Tests a language name to see if highlighting should be skipped
         * @param {string} languageName
         */
        function shouldNotHighlight(languageName) {
            return options.noHighlightRe.test(languageName);
        }

        /**
         * @param {HighlightedHTMLElement} block - the HTML element to determine language for
         */
        function blockLanguage(block) {
            let classes = block.className + ' ';

            classes += block.parentNode ? block.parentNode.className : '';

            // language-* takes precedence over non-prefixed class names.
            const match = options.languageDetectRe.exec(classes);
            if (match) {
                const language = getLanguage(match[1]);
                if (!language) {
                    console.warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
                    console.warn("Falling back to no-highlight mode for this block.", block);
                }
                return language ? match[1] : 'no-highlight';
            }

            return classes
                .split(/\s+/)
                .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
        }

        /**
         * Core highlighting function.
         *
         * @param {string} languageName - the language to use for highlighting
         * @param {string} code - the code to highlight
         * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
         * @param {CompiledMode} [continuation] - current continuation mode, if any
         *
         * @returns {HighlightResult} Result - an object that represents the result
         * @property {string} language - the language name
         * @property {number} relevance - the relevance score
         * @property {string} value - the highlighted HTML code
         * @property {string} code - the original raw code
         * @property {CompiledMode} top - top of the current mode stack
         * @property {boolean} illegal - indicates whether any illegal matches were found
         */
        function highlight(languageName, code, ignoreIllegals, continuation) {
            /** @type {{ code: string, language: string, result?: any }} */
            const context = {
                code,
                language: languageName
            };
            // the plugin can change the desired language or the code to be highlighted
            // just be changing the object it was passed
            fire("before:highlight", context);

            // a before plugin can usurp the result completely by providing it's own
            // in which case we don't even need to call highlight
            const result = context.result ?
                context.result :
                _highlight(context.language, context.code, ignoreIllegals, continuation);

            result.code = context.code;
            // the plugin can change anything in result to suite it
            fire("after:highlight", result);

            return result;
        }

        /**
         * private highlight that's used internally and does not fire callbacks
         *
         * @param {string} languageName - the language to use for highlighting
         * @param {string} code - the code to highlight
         * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
         * @param {CompiledMode} [continuation] - current continuation mode, if any
         * @returns {HighlightResult} - result of the highlight operation
         */
        function _highlight(languageName, code, ignoreIllegals, continuation) {
            const codeToHighlight = code;

            /**
             * Return keyword data if a match is a keyword
             * @param {CompiledMode} mode - current mode
             * @param {RegExpMatchArray} match - regexp match data
             * @returns {KeywordData | false}
             */
            function keywordData(mode, match) {
                const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];
                return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
            }

            function processKeywords() {
                if (!top.keywords) {
                    emitter.addText(modeBuffer);
                    return;
                }

                let lastIndex = 0;
                top.keywordPatternRe.lastIndex = 0;
                let match = top.keywordPatternRe.exec(modeBuffer);
                let buf = "";

                while (match) {
                    buf += modeBuffer.substring(lastIndex, match.index);
                    const data = keywordData(top, match);
                    if (data) {
                        const [kind, keywordRelevance] = data;
                        emitter.addText(buf);
                        buf = "";

                        relevance += keywordRelevance;
                        const cssClass = language.classNameAliases[kind] || kind;
                        emitter.addKeyword(match[0], cssClass);
                    } else {
                        buf += match[0];
                    }
                    lastIndex = top.keywordPatternRe.lastIndex;
                    match = top.keywordPatternRe.exec(modeBuffer);
                }
                buf += modeBuffer.substr(lastIndex);
                emitter.addText(buf);
            }

            function processSubLanguage() {
                if (modeBuffer === "") return;
                /** @type HighlightResult */
                let result = null;

                if (typeof top.subLanguage === 'string') {
                    if (!languages[top.subLanguage]) {
                        emitter.addText(modeBuffer);
                        return;
                    }
                    result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
                    continuations[top.subLanguage] = /** @type {CompiledMode} */ (result.top);
                } else {
                    result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
                }

                // Counting embedded language score towards the host language may be disabled
                // with zeroing the containing mode relevance. Use case in point is Markdown that
                // allows XML everywhere and makes every XML snippet to have a much larger Markdown
                // score.
                if (top.relevance > 0) {
                    relevance += result.relevance;
                }
                emitter.addSublanguage(result.emitter, result.language);
            }

            function processBuffer() {
                if (top.subLanguage != null) {
                    processSubLanguage();
                } else {
                    processKeywords();
                }
                modeBuffer = '';
            }

            /**
             * @param {Mode} mode - new mode to start
             */
            function startNewMode(mode) {
                if (mode.className) {
                    emitter.openNode(language.classNameAliases[mode.className] || mode.className);
                }
                top = Object.create(mode, { parent: { value: top } });
                return top;
            }

            /**
             * @param {CompiledMode } mode - the mode to potentially end
             * @param {RegExpMatchArray} match - the latest match
             * @param {string} matchPlusRemainder - match plus remainder of content
             * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode
             */
            function endOfMode(mode, match, matchPlusRemainder) {
                let matched = startsWith(mode.endRe, matchPlusRemainder);

                if (matched) {
                    if (mode["on:end"]) {
                        const resp = new Response(mode);
                        mode["on:end"](match, resp);
                        if (resp.ignore) matched = false;
                    }

                    if (matched) {
                        while (mode.endsParent && mode.parent) {
                            mode = mode.parent;
                        }
                        return mode;
                    }
                }
                // even if on:end fires an `ignore` it's still possible
                // that we might trigger the end node because of a parent mode
                if (mode.endsWithParent) {
                    return endOfMode(mode.parent, match, matchPlusRemainder);
                }
            }

            /**
             * Handle matching but then ignoring a sequence of text
             *
             * @param {string} lexeme - string containing full match text
             */
            function doIgnore(lexeme) {
                if (top.matcher.regexIndex === 0) {
                    // no more regexs to potentially match here, so we move the cursor forward one
                    // space
                    modeBuffer += lexeme[0];
                    return 1;
                } else {
                    // no need to move the cursor, we still have additional regexes to try and
                    // match at this very spot
                    resumeScanAtSamePosition = true;
                    return 0;
                }
            }

            /**
             * Handle the start of a new potential mode match
             *
             * @param {EnhancedMatch} match - the current match
             * @returns {number} how far to advance the parse cursor
             */
            function doBeginMatch(match) {
                const lexeme = match[0];
                const newMode = match.rule;

                const resp = new Response(newMode);
                // first internal before callbacks, then the public ones
                const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
                for (const cb of beforeCallbacks) {
                    if (!cb) continue;
                    cb(match, resp);
                    if (resp.ignore) return doIgnore(lexeme);
                }

                if (newMode && newMode.endSameAsBegin) {
                    newMode.endRe = escape(lexeme);
                }

                if (newMode.skip) {
                    modeBuffer += lexeme;
                } else {
                    if (newMode.excludeBegin) {
                        modeBuffer += lexeme;
                    }
                    processBuffer();
                    if (!newMode.returnBegin && !newMode.excludeBegin) {
                        modeBuffer = lexeme;
                    }
                }
                startNewMode(newMode);
                // if (mode["after:begin"]) {
                //   let resp = new Response(mode);
                //   mode["after:begin"](match, resp);
                // }
                return newMode.returnBegin ? 0 : lexeme.length;
            }

            /**
             * Handle the potential end of mode
             *
             * @param {RegExpMatchArray} match - the current match
             */
            function doEndMatch(match) {
                const lexeme = match[0];
                const matchPlusRemainder = codeToHighlight.substr(match.index);

                const endMode = endOfMode(top, match, matchPlusRemainder);
                if (!endMode) { return NO_MATCH; }

                const origin = top;
                if (origin.skip) {
                    modeBuffer += lexeme;
                } else {
                    if (!(origin.returnEnd || origin.excludeEnd)) {
                        modeBuffer += lexeme;
                    }
                    processBuffer();
                    if (origin.excludeEnd) {
                        modeBuffer = lexeme;
                    }
                }
                do {
                    if (top.className) {
                        emitter.closeNode();
                    }
                    if (!top.skip && !top.subLanguage) {
                        relevance += top.relevance;
                    }
                    top = top.parent;
                } while (top !== endMode.parent);
                if (endMode.starts) {
                    if (endMode.endSameAsBegin) {
                        endMode.starts.endRe = endMode.endRe;
                    }
                    startNewMode(endMode.starts);
                }
                return origin.returnEnd ? 0 : lexeme.length;
            }

            function processContinuations() {
                const list = [];
                for (let current = top; current !== language; current = current.parent) {
                    if (current.className) {
                        list.unshift(current.className);
                    }
                }
                list.forEach(item => emitter.openNode(item));
            }

            /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */
            let lastMatch = {};

            /**
             *  Process an individual match
             *
             * @param {string} textBeforeMatch - text preceeding the match (since the last match)
             * @param {EnhancedMatch} [match] - the match itself
             */
            function processLexeme(textBeforeMatch, match) {
                const lexeme = match && match[0];

                // add non-matched text to the current mode buffer
                modeBuffer += textBeforeMatch;

                if (lexeme == null) {
                    processBuffer();
                    return 0;
                }

                // we've found a 0 width match and we're stuck, so we need to advance
                // this happens when we have badly behaved rules that have optional matchers to the degree that
                // sometimes they can end up matching nothing at all
                // Ref: https://github.com/highlightjs/highlight.js/issues/2140
                if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
                    // spit the "skipped" character that our regex choked on back into the output sequence
                    modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
                    if (!SAFE_MODE) {
                        /** @type {AnnotatedError} */
                        const err = new Error('0 width match regex');
                        err.languageName = languageName;
                        err.badRule = lastMatch.rule;
                        throw err;
                    }
                    return 1;
                }
                lastMatch = match;

                if (match.type === "begin") {
                    return doBeginMatch(match);
                } else if (match.type === "illegal" && !ignoreIllegals) {
                    // illegal match, we do not continue processing
                    /** @type {AnnotatedError} */
                    const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
                    err.mode = top;
                    throw err;
                } else if (match.type === "end") {
                    const processed = doEndMatch(match);
                    if (processed !== NO_MATCH) {
                        return processed;
                    }
                }

                // edge case for when illegal matches $ (end of line) which is technically
                // a 0 width match but not a begin/end match so it's not caught by the
                // first handler (when ignoreIllegals is true)
                if (match.type === "illegal" && lexeme === "") {
                    // advance so we aren't stuck in an infinite loop
                    return 1;
                }

                // infinite loops are BAD, this is a last ditch catch all. if we have a
                // decent number of iterations yet our index (cursor position in our
                // parsing) still 3x behind our index then something is very wrong
                // so we bail
                if (iterations > 100000 && iterations > match.index * 3) {
                    const err = new Error('potential infinite loop, way more iterations than matches');
                    throw err;
                }

                /*
          Why might be find ourselves here?  Only one occasion now.  An end match that was
          triggered but could not be completed.  When might this happen?  When an `endSameasBegin`
          rule sets the end rule to a specific match.  Since the overall mode termination rule that's
          being used to scan the text isn't recompiled that means that any match that LOOKS like
          the end (but is not, because it is not an exact match to the beginning) will
          end up here.  A definite end match, but when `doEndMatch` tries to "reapply"
          the end rule and fails to match, we wind up here, and just silently ignore the end.

          This causes no real harm other than stopping a few times too many.
          */

                modeBuffer += lexeme;
                return lexeme.length;
            }

            const language = getLanguage(languageName);
            if (!language) {
                console.error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
                throw new Error('Unknown language: "' + languageName + '"');
            }

            const md = compileLanguage(language);
            let result = '';
            /** @type {CompiledMode} */
            let top = continuation || md;
            /** @type Record<string,CompiledMode> */
            const continuations = {}; // keep continuations for sub-languages
            const emitter = new options.__emitter(options);
            processContinuations();
            let modeBuffer = '';
            let relevance = 0;
            let index = 0;
            let iterations = 0;
            let resumeScanAtSamePosition = false;

            try {
                top.matcher.considerAll();

                for (;;) {
                    iterations++;
                    if (resumeScanAtSamePosition) {
                        // only regexes not matched previously will now be
                        // considered for a potential match
                        resumeScanAtSamePosition = false;
                    } else {
                        top.matcher.considerAll();
                    }
                    top.matcher.lastIndex = index;

                    const match = top.matcher.exec(codeToHighlight);
                    // console.log("match", match[0], match.rule && match.rule.begin)

                    if (!match) break;

                    const beforeMatch = codeToHighlight.substring(index, match.index);
                    const processedCount = processLexeme(beforeMatch, match);
                    index = match.index + processedCount;
                }
                processLexeme(codeToHighlight.substr(index));
                emitter.closeAllNodes();
                emitter.finalize();
                result = emitter.toHTML();

                return {
                    relevance: relevance,
                    value: result,
                    language: languageName,
                    illegal: false,
                    emitter: emitter,
                    top: top
                };
            } catch (err) {
                if (err.message && err.message.includes('Illegal')) {
                    return {
                        illegal: true,
                        illegalBy: {
                            msg: err.message,
                            context: codeToHighlight.slice(index - 100, index + 100),
                            mode: err.mode
                        },
                        sofar: result,
                        relevance: 0,
                        value: escape$1(codeToHighlight),
                        emitter: emitter
                    };
                } else if (SAFE_MODE) {
                    return {
                        illegal: false,
                        relevance: 0,
                        value: escape$1(codeToHighlight),
                        emitter: emitter,
                        language: languageName,
                        top: top,
                        errorRaised: err
                    };
                } else {
                    throw err;
                }
            }
        }

        /**
         * returns a valid highlight result, without actually doing any actual work,
         * auto highlight starts with this and it's possible for small snippets that
         * auto-detection may not find a better match
         * @param {string} code
         * @returns {HighlightResult}
         */
        function justTextHighlightResult(code) {
            const result = {
                relevance: 0,
                emitter: new options.__emitter(options),
                value: escape$1(code),
                illegal: false,
                top: PLAINTEXT_LANGUAGE
            };
            result.emitter.addText(code);
            return result;
        }

        /**
         Highlighting with language detection. Accepts a string with the code to
         highlight. Returns an object with the following properties:

         - language (detected language)
         - relevance (int)
         - value (an HTML string with highlighting markup)
         - second_best (object with the same structure for second-best heuristically
         detected language, may be absent)

         @param {string} code
         @param {Array<string>} [languageSubset]
         @returns {AutoHighlightResult}
         */
        function highlightAuto(code, languageSubset) {
            languageSubset = languageSubset || options.languages || Object.keys(languages);
            const plaintext = justTextHighlightResult(code);

            const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>
                _highlight(name, code, false)
            );
            results.unshift(plaintext); // plaintext is always an option

            const sorted = results.sort((a, b) => {
                // sort base on relevance
                if (a.relevance !== b.relevance) return b.relevance - a.relevance;

                // always award the tie to the base language
                // ie if C++ and Arduino are tied, it's more likely to be C++
                if (a.language && b.language) {
                    if (getLanguage(a.language).supersetOf === b.language) {
                        return 1;
                    } else if (getLanguage(b.language).supersetOf === a.language) {
                        return -1;
                    }
                }

                // otherwise say they are equal, which has the effect of sorting on
                // relevance while preserving the original ordering - which is how ties
                // have historically been settled, ie the language that comes first always
                // wins in the case of a tie
                return 0;
            });

            const [best, secondBest] = sorted;

            /** @type {AutoHighlightResult} */
            const result = best;
            result.second_best = secondBest;

            return result;
        }

        /**
         Post-processing of the highlighted markup:

         - replace TABs with something more useful
         - replace real line-breaks with '<br>' for non-pre containers

         @param {string} html
         @returns {string}
         */
        function fixMarkup(html) {
            if (!(options.tabReplace || options.useBR)) {
                return html;
            }

            return html.replace(fixMarkupRe, match => {
                if (match === '\n') {
                    return options.useBR ? '<br>' : match;
                } else if (options.tabReplace) {
                    return match.replace(/\t/g, options.tabReplace);
                }
                return match;
            });
        }

        /**
         * Builds new class name for block given the language name
         *
         * @param {string} prevClassName
         * @param {string} [currentLang]
         * @param {string} [resultLang]
         */
        function buildClassName(prevClassName, currentLang, resultLang) {
            const language = currentLang ? aliases[currentLang] : resultLang;
            const result = [prevClassName.trim()];

            if (!prevClassName.match(/\bhljs\b/)) {
                result.push('hljs');
            }

            if (!prevClassName.includes(language)) {
                result.push(language);
            }

            return result.join(' ').trim();
        }

        /**
         * Applies highlighting to a DOM node containing code. Accepts a DOM node and
         * two optional parameters for fixMarkup.
         *
         * @param {HighlightedHTMLElement} element - the HTML element to highlight
         */
        function highlightBlock(element) {
            /** @type HTMLElement */
            let node = null;
            const language = blockLanguage(element);

            if (shouldNotHighlight(language)) return;

            fire("before:highlightBlock",
                { block: element, language: language });

            if (options.useBR) {
                node = document.createElement('div');
                node.innerHTML = element.innerHTML.replace(/\n/g, '').replace(/<br[ /]*>/g, '\n');
            } else {
                node = element;
            }
            const text = node.textContent;
            const result = language ? highlight(language, text, true) : highlightAuto(text);

            const originalStream = nodeStream$1(node);
            if (originalStream.length) {
                const resultNode = document.createElement('div');
                resultNode.innerHTML = result.value;
                result.value = mergeStreams$1(originalStream, nodeStream$1(resultNode), text);
            }
            result.value = fixMarkup(result.value);

            fire("after:highlightBlock", { block: element, result: result });

            element.innerHTML = result.value;
            element.className = buildClassName(element.className, language, result.language);
            element.result = {
                language: result.language,
                // TODO: remove with version 11.0
                re: result.relevance,
                relavance: result.relevance
            };
            if (result.second_best) {
                element.second_best = {
                    language: result.second_best.language,
                    // TODO: remove with version 11.0
                    re: result.second_best.relevance,
                    relavance: result.second_best.relevance
                };
            }
        }

        /**
         * Updates highlight.js global options with the passed options
         *
         * @param {Partial<HLJSOptions>} userOptions
         */
        function configure(userOptions) {
            if (userOptions.useBR) {
                console.warn("'useBR' option is deprecated and will be removed entirely in v11.0");
                console.warn("Please see https://github.com/highlightjs/highlight.js/issues/2559");
            }
            options = inherit$1$1(options, userOptions);
        }

        /**
         * Highlights to all <pre><code> blocks on a page
         *
         * @type {Function & {called?: boolean}}
         */
        const initHighlighting = () => {
            if (initHighlighting.called) return;
            initHighlighting.called = true;

            const blocks = document.querySelectorAll('pre code');
            ArrayProto.forEach.call(blocks, highlightBlock);
        };

        // Higlights all when DOMContentLoaded fires
        function initHighlightingOnLoad() {
            // @ts-ignore
            window.addEventListener('DOMContentLoaded', initHighlighting, false);
        }

        /**
         * Register a language grammar module
         *
         * @param {string} languageName
         * @param {LanguageFn} languageDefinition
         */
        function registerLanguage(languageName, languageDefinition) {
            let lang = null;
            try {
                lang = languageDefinition(hljs);
            } catch (error) {
                console.error("Language definition for '{}' could not be registered.".replace("{}", languageName));
                // hard or soft error
                if (!SAFE_MODE) { throw error; } else { console.error(error); }
                // languages that have serious errors are replaced with essentially a
                // "plaintext" stand-in so that the code blocks will still get normal
                // css classes applied to them - and one bad language won't break the
                // entire highlighter
                lang = PLAINTEXT_LANGUAGE;
            }
            // give it a temporary name if it doesn't have one in the meta-data
            if (!lang.name) lang.name = languageName;
            languages[languageName] = lang;
            lang.rawDefinition = languageDefinition.bind(null, hljs);

            if (lang.aliases) {
                registerAliases(lang.aliases, { languageName });
            }
        }

        /**
         * @returns {string[]} List of language internal names
         */
        function listLanguages() {
            return Object.keys(languages);
        }

        /**
         intended usage: When one language truly requires another

         Unlike `getLanguage`, this will throw when the requested language
         is not available.

         @param {string} name - name of the language to fetch/require
         @returns {Language | never}
         */
        function requireLanguage(name) {
            console.warn("requireLanguage is deprecated and will be removed entirely in the future.");
            console.warn("Please see https://github.com/highlightjs/highlight.js/pull/2844");

            const lang = getLanguage(name);
            if (lang) { return lang; }

            const err = new Error('The \'{}\' language is required, but not loaded.'.replace('{}', name));
            throw err;
        }

        /**
         * @param {string} name - name of the language to retrieve
         * @returns {Language | undefined}
         */
        function getLanguage(name) {
            name = (name || '').toLowerCase();
            return languages[name] || languages[aliases[name]];
        }

        /**
         *
         * @param {string|string[]} aliasList - single alias or list of aliases
         * @param {{languageName: string}} opts
         */
        function registerAliases(aliasList, { languageName }) {
            if (typeof aliasList === 'string') {
                aliasList = [aliasList];
            }
            aliasList.forEach(alias => { aliases[alias] = languageName; });
        }

        /**
         * Determines if a given language has auto-detection enabled
         * @param {string} name - name of the language
         */
        function autoDetection(name) {
            const lang = getLanguage(name);
            return lang && !lang.disableAutodetect;
        }

        /**
         * @param {HLJSPlugin} plugin
         */
        function addPlugin(plugin) {
            plugins.push(plugin);
        }

        /**
         *
         * @param {PluginEvent} event
         * @param {any} args
         */
        function fire(event, args) {
            const cb = event;
            plugins.forEach(function(plugin) {
                if (plugin[cb]) {
                    plugin[cb](args);
                }
            });
        }

        /**
         Note: fixMarkup is deprecated and will be removed entirely in v11

         @param {string} arg
         @returns {string}
         */
        function deprecateFixMarkup(arg) {
            console.warn("fixMarkup is deprecated and will be removed entirely in v11.0");
            console.warn("Please see https://github.com/highlightjs/highlight.js/issues/2534");

            return fixMarkup(arg);
        }

        /* Interface definition */
        Object.assign(hljs, {
            highlight,
            highlightAuto,
            fixMarkup: deprecateFixMarkup,
            highlightBlock,
            configure,
            initHighlighting,
            initHighlightingOnLoad,
            registerLanguage,
            listLanguages,
            getLanguage,
            registerAliases,
            requireLanguage,
            autoDetection,
            inherit: inherit$1$1,
            addPlugin,
            // plugins for frameworks
            vuePlugin: BuildVuePlugin(hljs).VuePlugin
        });

        hljs.debugMode = function() { SAFE_MODE = false; };
        hljs.safeMode = function() { SAFE_MODE = true; };
        hljs.versionString = version;

        for (const key in MODES) {
            // @ts-ignore
            if (typeof MODES[key] === "object") {
                // @ts-ignore
                deepFreezeEs6(MODES[key]);
            }
        }

        // merge all the modes/regexs into our main object
        Object.assign(hljs, MODES);

        return hljs;
    };

    // export an "instance" of the highlighter
    var highlight = HLJS({});

    var core = highlight;

    /*
     Language: SQL
     Contributors: Nikolay Lisienko <info@neor.ru>, Heiko August <post@auge8472.de>, Travis Odom <travis.a.odom@gmail.com>, Vadimtro <vadimtro@yahoo.com>, Benjamin Auder <benjamin.auder@gmail.com>
     Website: https://en.wikipedia.org/wiki/SQL
     Category: common
     */

    function sql(hljs) {
        var COMMENT_MODE = hljs.COMMENT('--', '$');
        return {
            name: 'SQL',
            case_insensitive: true,
            illegal: /[<>{}*]/,
            contains: [
                {
                    beginKeywords:
                        'begin end start commit rollback savepoint lock alter create drop rename call ' +
                        'delete do handler insert load replace select truncate update set show pragma grant ' +
                        'merge describe use explain help declare prepare execute deallocate release ' +
                        'unlock purge reset change stop analyze cache flush optimize repair kill ' +
                        'install uninstall checksum restore check backup revoke comment values with',
                    end: /;/, endsWithParent: true,
                    keywords: {
                        $pattern: /[\w\.]+/,
                        keyword:
                            'as abort abs absolute acc acce accep accept access accessed accessible account acos action activate add ' +
                            'addtime admin administer advanced advise aes_decrypt aes_encrypt after agent aggregate ali alia alias ' +
                            'all allocate allow alter always analyze ancillary and anti any anydata anydataset anyschema anytype apply ' +
                            'archive archived archivelog are as asc ascii asin assembly assertion associate asynchronous at atan ' +
                            'atn2 attr attri attrib attribu attribut attribute attributes audit authenticated authentication authid ' +
                            'authors auto autoallocate autodblink autoextend automatic availability avg backup badfile basicfile ' +
                            'before begin beginning benchmark between bfile bfile_base big bigfile bin binary_double binary_float ' +
                            'binlog bit_and bit_count bit_length bit_or bit_xor bitmap blob_base block blocksize body both bound ' +
                            'bucket buffer_cache buffer_pool build bulk by byte byteordermark bytes cache caching call calling cancel ' +
                            'capacity cascade cascaded case cast catalog category ceil ceiling chain change changed char_base ' +
                            'char_length character_length characters characterset charindex charset charsetform charsetid check ' +
                            'checksum checksum_agg child choose chr chunk class cleanup clear client clob clob_base clone close ' +
                            'cluster_id cluster_probability cluster_set clustering coalesce coercibility col collate collation ' +
                            'collect colu colum column column_value columns columns_updated comment commit compact compatibility ' +
                            'compiled complete composite_limit compound compress compute concat concat_ws concurrent confirm conn ' +
                            'connec connect connect_by_iscycle connect_by_isleaf connect_by_root connect_time connection ' +
                            'consider consistent constant constraint constraints constructor container content contents context ' +
                            'contributors controlfile conv convert convert_tz corr corr_k corr_s corresponding corruption cos cost ' +
                            'count count_big counted covar_pop covar_samp cpu_per_call cpu_per_session crc32 create creation ' +
                            'critical cross cube cume_dist curdate current current_date current_time current_timestamp current_user ' +
                            'cursor curtime customdatum cycle data database databases datafile datafiles datalength date_add ' +
                            'date_cache date_format date_sub dateadd datediff datefromparts datename datepart datetime2fromparts ' +
                            'day day_to_second dayname dayofmonth dayofweek dayofyear days db_role_change dbtimezone ddl deallocate ' +
                            'declare decode decompose decrement decrypt deduplicate def defa defau defaul default defaults ' +
                            'deferred defi defin define degrees delayed delegate delete delete_all delimited demand dense_rank ' +
                            'depth dequeue des_decrypt des_encrypt des_key_file desc descr descri describ describe descriptor ' +
                            'deterministic diagnostics difference dimension direct_load directory disable disable_all ' +
                            'disallow disassociate discardfile disconnect diskgroup distinct distinctrow distribute distributed div ' +
                            'do document domain dotnet double downgrade drop dumpfile duplicate duration each edition editionable ' +
                            'editions element ellipsis else elsif elt empty enable enable_all enclosed encode encoding encrypt ' +
                            'end end-exec endian enforced engine engines enqueue enterprise entityescaping eomonth error errors ' +
                            'escaped evalname evaluate event eventdata events except exception exceptions exchange exclude excluding ' +
                            'execu execut execute exempt exists exit exp expire explain explode export export_set extended extent external ' +
                            'external_1 external_2 externally extract failed failed_login_attempts failover failure far fast ' +
                            'feature_set feature_value fetch field fields file file_name_convert filesystem_like_logging final ' +
                            'finish first first_value fixed flash_cache flashback floor flush following follows for forall force foreign ' +
                            'form forma format found found_rows freelist freelists freepools fresh from from_base64 from_days ' +
                            'ftp full function general generated get get_format get_lock getdate getutcdate global global_name ' +
                            'globally go goto grant grants greatest group group_concat group_id grouping grouping_id groups ' +
                            'gtid_subtract guarantee guard handler hash hashkeys having hea head headi headin heading heap help hex ' +
                            'hierarchy high high_priority hosts hour hours http id ident_current ident_incr ident_seed identified ' +
                            'identity idle_time if ifnull ignore iif ilike ilm immediate import in include including increment ' +
                            'index indexes indexing indextype indicator indices inet6_aton inet6_ntoa inet_aton inet_ntoa infile ' +
                            'initial initialized initially initrans inmemory inner innodb input insert install instance instantiable ' +
                            'instr interface interleaved intersect into invalidate invisible is is_free_lock is_ipv4 is_ipv4_compat ' +
                            'is_not is_not_null is_used_lock isdate isnull isolation iterate java join json json_exists ' +
                            'keep keep_duplicates key keys kill language large last last_day last_insert_id last_value lateral lax lcase ' +
                            'lead leading least leaves left len lenght length less level levels library like like2 like4 likec limit ' +
                            'lines link list listagg little ln load load_file lob lobs local localtime localtimestamp locate ' +
                            'locator lock locked log log10 log2 logfile logfiles logging logical logical_reads_per_call ' +
                            'logoff logon logs long loop low low_priority lower lpad lrtrim ltrim main make_set makedate maketime ' +
                            'managed management manual map mapping mask master master_pos_wait match matched materialized max ' +
                            'maxextents maximize maxinstances maxlen maxlogfiles maxloghistory maxlogmembers maxsize maxtrans ' +
                            'md5 measures median medium member memcompress memory merge microsecond mid migration min minextents ' +
                            'minimum mining minus minute minutes minvalue missing mod mode model modification modify module monitoring month ' +
                            'months mount move movement multiset mutex name name_const names nan national native natural nav nchar ' +
                            'nclob nested never new newline next nextval no no_write_to_binlog noarchivelog noaudit nobadfile ' +
                            'nocheck nocompress nocopy nocycle nodelay nodiscardfile noentityescaping noguarantee nokeep nologfile ' +
                            'nomapping nomaxvalue nominimize nominvalue nomonitoring none noneditionable nonschema noorder ' +
                            'nopr nopro noprom nopromp noprompt norely noresetlogs noreverse normal norowdependencies noschemacheck ' +
                            'noswitch not nothing notice notnull notrim novalidate now nowait nth_value nullif nulls num numb numbe ' +
                            'nvarchar nvarchar2 object ocicoll ocidate ocidatetime ociduration ociinterval ociloblocator ocinumber ' +
                            'ociref ocirefcursor ocirowid ocistring ocitype oct octet_length of off offline offset oid oidindex old ' +
                            'on online only opaque open operations operator optimal optimize option optionally or oracle oracle_date ' +
                            'oradata ord ordaudio orddicom orddoc order ordimage ordinality ordvideo organization orlany orlvary ' +
                            'out outer outfile outline output over overflow overriding package pad parallel parallel_enable ' +
                            'parameters parent parse partial partition partitions pascal passing password password_grace_time ' +
                            'password_lock_time password_reuse_max password_reuse_time password_verify_function patch path patindex ' +
                            'pctincrease pctthreshold pctused pctversion percent percent_rank percentile_cont percentile_disc ' +
                            'performance period period_add period_diff permanent physical pi pipe pipelined pivot pluggable plugin ' +
                            'policy position post_transaction pow power pragma prebuilt precedes preceding precision prediction ' +
                            'prediction_cost prediction_details prediction_probability prediction_set prepare present preserve ' +
                            'prior priority private private_sga privileges procedural procedure procedure_analyze processlist ' +
                            'profiles project prompt protection public publishingservername purge quarter query quick quiesce quota ' +
                            'quotename radians raise rand range rank raw read reads readsize rebuild record records ' +
                            'recover recovery recursive recycle redo reduced ref reference referenced references referencing refresh ' +
                            'regexp_like register regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy ' +
                            'reject rekey relational relative relaylog release release_lock relies_on relocate rely rem remainder rename ' +
                            'repair repeat replace replicate replication required reset resetlogs resize resource respect restore ' +
                            'restricted result result_cache resumable resume retention return returning returns reuse reverse revoke ' +
                            'right rlike role roles rollback rolling rollup round row row_count rowdependencies rowid rownum rows ' +
                            'rtrim rules safe salt sample save savepoint sb1 sb2 sb4 scan schema schemacheck scn scope scroll ' +
                            'sdo_georaster sdo_topo_geometry search sec_to_time second seconds section securefile security seed segment select ' +
                            'self semi sequence sequential serializable server servererror session session_user sessions_per_user set ' +
                            'sets settings sha sha1 sha2 share shared shared_pool short show shrink shutdown si_averagecolor ' +
                            'si_colorhistogram si_featurelist si_positionalcolor si_stillimage si_texture siblings sid sign sin ' +
                            'size size_t sizes skip slave sleep smalldatetimefromparts smallfile snapshot some soname sort soundex ' +
                            'source space sparse spfile split sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows ' +
                            'sql_small_result sql_variant_property sqlcode sqldata sqlerror sqlname sqlstate sqrt square standalone ' +
                            'standby start starting startup statement static statistics stats_binomial_test stats_crosstab ' +
                            'stats_ks_test stats_mode stats_mw_test stats_one_way_anova stats_t_test_ stats_t_test_indep ' +
                            'stats_t_test_one stats_t_test_paired stats_wsr_test status std stddev stddev_pop stddev_samp stdev ' +
                            'stop storage store stored str str_to_date straight_join strcmp strict string struct stuff style subdate ' +
                            'subpartition subpartitions substitutable substr substring subtime subtring_index subtype success sum ' +
                            'suspend switch switchoffset switchover sync synchronous synonym sys sys_xmlagg sysasm sysaux sysdate ' +
                            'sysdatetimeoffset sysdba sysoper system system_user sysutcdatetime table tables tablespace tablesample tan tdo ' +
                            'template temporary terminated tertiary_weights test than then thread through tier ties time time_format ' +
                            'time_zone timediff timefromparts timeout timestamp timestampadd timestampdiff timezone_abbr ' +
                            'timezone_minute timezone_region to to_base64 to_date to_days to_seconds todatetimeoffset trace tracking ' +
                            'transaction transactional translate translation treat trigger trigger_nestlevel triggers trim truncate ' +
                            'try_cast try_convert try_parse type ub1 ub2 ub4 ucase unarchived unbounded uncompress ' +
                            'under undo unhex unicode uniform uninstall union unique unix_timestamp unknown unlimited unlock unnest unpivot ' +
                            'unrecoverable unsafe unsigned until untrusted unusable unused update updated upgrade upped upper upsert ' +
                            'url urowid usable usage use use_stored_outlines user user_data user_resources users using utc_date ' +
                            'utc_timestamp uuid uuid_short validate validate_password_strength validation valist value values var ' +
                            'var_samp varcharc vari varia variab variabl variable variables variance varp varraw varrawc varray ' +
                            'verify version versions view virtual visible void wait wallet warning warnings week weekday weekofyear ' +
                            'wellformed when whene whenev wheneve whenever where while whitespace window with within without work wrapped ' +
                            'xdb xml xmlagg xmlattributes xmlcast xmlcolattval xmlelement xmlexists xmlforest xmlindex xmlnamespaces ' +
                            'xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltype xor year year_to_month years yearweek',
                        literal:
                            'true false null unknown',
                        built_in:
                            'array bigint binary bit blob bool boolean char character date dec decimal float int int8 integer interval number ' +
                            'numeric real record serial serial8 smallint text time timestamp tinyint varchar varchar2 varying void'
                    },
                    contains: [
                        {
                            className: 'string',
                            begin: '\'', end: '\'',
                            contains: [{begin: '\'\''}]
                        },
                        {
                            className: 'string',
                            begin: '"', end: '"',
                            contains: [{begin: '""'}]
                        },
                        {
                            className: 'string',
                            begin: '`', end: '`'
                        },
                        hljs.C_NUMBER_MODE,
                        hljs.C_BLOCK_COMMENT_MODE,
                        COMMENT_MODE,
                        hljs.HASH_COMMENT_MODE
                    ]
                },
                hljs.C_BLOCK_COMMENT_MODE,
                COMMENT_MODE,
                hljs.HASH_COMMENT_MODE
            ]
        };
    }

    var sql_1 = sql;

    /*
    Language: C#
    Author: Jason Diamond <jason@diamond.name>
    Contributor: Nicolas LLOBERA <nllobera@gmail.com>, Pieter Vantorre <pietervantorre@gmail.com>, David Pine <david.pine@microsoft.com>
    Website: https://docs.microsoft.com/en-us/dotnet/csharp/
    Category: common
    */

    /** @type LanguageFn */
    function csharp(hljs) {
        var BUILT_IN_KEYWORDS = [
            'bool',
            'byte',
            'char',
            'decimal',
            'delegate',
            'double',
            'dynamic',
            'enum',
            'float',
            'int',
            'long',
            'nint',
            'nuint',
            'object',
            'sbyte',
            'short',
            'string',
            'ulong',
            'unit',
            'ushort'
        ];
        var FUNCTION_MODIFIERS = [
            'public',
            'private',
            'protected',
            'static',
            'internal',
            'protected',
            'abstract',
            'async',
            'extern',
            'override',
            'unsafe',
            'virtual',
            'new',
            'sealed',
            'partial'
        ];
        var LITERAL_KEYWORDS = [
            'default',
            'false',
            'null',
            'true'
        ];
        var NORMAL_KEYWORDS = [
            'abstract',
            'as',
            'base',
            'break',
            'case',
            'class',
            'const',
            'continue',
            'do',
            'else',
            'event',
            'explicit',
            'extern',
            'finally',
            'fixed',
            'for',
            'foreach',
            'goto',
            'if',
            'implicit',
            'in',
            'interface',
            'internal',
            'is',
            'lock',
            'namespace',
            'new',
            'operator',
            'out',
            'override',
            'params',
            'private',
            'protected',
            'public',
            'readonly',
            'record',
            'ref',
            'return',
            'sealed',
            'sizeof',
            'stackalloc',
            'static',
            'struct',
            'switch',
            'this',
            'throw',
            'try',
            'typeof',
            'unchecked',
            'unsafe',
            'using',
            'virtual',
            'void',
            'volatile',
            'while'
        ];
        var CONTEXTUAL_KEYWORDS = [
            'add',
            'alias',
            'and',
            'ascending',
            'async',
            'await',
            'by',
            'descending',
            'equals',
            'from',
            'get',
            'global',
            'group',
            'init',
            'into',
            'join',
            'let',
            'nameof',
            'not',
            'notnull',
            'on',
            'or',
            'orderby',
            'partial',
            'remove',
            'select',
            'set',
            'unmanaged',
            'value|0',
            'var',
            'when',
            'where',
            'with',
            'yield'
        ];

        var KEYWORDS = {
            keyword: NORMAL_KEYWORDS.concat(CONTEXTUAL_KEYWORDS).join(' '),
            built_in: BUILT_IN_KEYWORDS.join(' '),
            literal: LITERAL_KEYWORDS.join(' ')
        };
        var TITLE_MODE = hljs.inherit(hljs.TITLE_MODE, {begin: '[a-zA-Z](\\.?\\w)*'});
        var NUMBERS = {
            className: 'number',
            variants: [
                { begin: '\\b(0b[01\']+)' },
                { begin: '(-?)\\b([\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)(u|U|l|L|ul|UL|f|F|b|B)' },
                { begin: '(-?)(\\b0[xX][a-fA-F0-9\']+|(\\b[\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)([eE][-+]?[\\d\']+)?)' }
            ],
            relevance: 0
        };
        var VERBATIM_STRING = {
            className: 'string',
            begin: '@"', end: '"',
            contains: [{begin: '""'}]
        };
        var VERBATIM_STRING_NO_LF = hljs.inherit(VERBATIM_STRING, {illegal: /\n/});
        var SUBST = {
            className: 'subst',
            begin: /\{/, end: /\}/,
            keywords: KEYWORDS
        };
        var SUBST_NO_LF = hljs.inherit(SUBST, {illegal: /\n/});
        var INTERPOLATED_STRING = {
            className: 'string',
            begin: /\$"/, end: '"',
            illegal: /\n/,
            contains: [{begin: /\{\{/}, {begin: /\}\}/}, hljs.BACKSLASH_ESCAPE, SUBST_NO_LF]
        };
        var INTERPOLATED_VERBATIM_STRING = {
            className: 'string',
            begin: /\$@"/, end: '"',
            contains: [{begin: /\{\{/}, {begin: /\}\}/}, {begin: '""'}, SUBST]
        };
        var INTERPOLATED_VERBATIM_STRING_NO_LF = hljs.inherit(INTERPOLATED_VERBATIM_STRING, {
            illegal: /\n/,
            contains: [{begin: /\{\{/}, {begin: /\}\}/}, {begin: '""'}, SUBST_NO_LF]
        });
        SUBST.contains = [
            INTERPOLATED_VERBATIM_STRING,
            INTERPOLATED_STRING,
            VERBATIM_STRING,
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE,
            NUMBERS,
            hljs.C_BLOCK_COMMENT_MODE
        ];
        SUBST_NO_LF.contains = [
            INTERPOLATED_VERBATIM_STRING_NO_LF,
            INTERPOLATED_STRING,
            VERBATIM_STRING_NO_LF,
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE,
            NUMBERS,
            hljs.inherit(hljs.C_BLOCK_COMMENT_MODE, {illegal: /\n/})
        ];
        var STRING = {
            variants: [
                INTERPOLATED_VERBATIM_STRING,
                INTERPOLATED_STRING,
                VERBATIM_STRING,
                hljs.APOS_STRING_MODE,
                hljs.QUOTE_STRING_MODE
            ]
        };

        var GENERIC_MODIFIER = {
            begin: "<",
            end: ">",
            contains: [
                { beginKeywords: "in out"},
                TITLE_MODE
            ]
        };
        var TYPE_IDENT_RE = hljs.IDENT_RE + '(<' + hljs.IDENT_RE + '(\\s*,\\s*' + hljs.IDENT_RE + ')*>)?(\\[\\])?';
        var AT_IDENTIFIER = {
            // prevents expressions like `@class` from incorrect flagging
            // `class` as a keyword
            begin: "@" + hljs.IDENT_RE,
            relevance: 0
        };

        return {
            name: 'C#',
            aliases: ['cs', 'c#'],
            keywords: KEYWORDS,
            illegal: /::/,
            contains: [
                hljs.COMMENT(
                    '///',
                    '$',
                    {
                        returnBegin: true,
                        contains: [
                            {
                                className: 'doctag',
                                variants: [
                                    {
                                        begin: '///', relevance: 0
                                    },
                                    {
                                        begin: '<!--|-->'
                                    },
                                    {
                                        begin: '</?', end: '>'
                                    }
                                ]
                            }
                        ]
                    }
                ),
                hljs.C_LINE_COMMENT_MODE,
                hljs.C_BLOCK_COMMENT_MODE,
                {
                    className: 'meta',
                    begin: '#', end: '$',
                    keywords: {
                        'meta-keyword': 'if else elif endif define undef warning error line region endregion pragma checksum'
                    }
                },
                STRING,
                NUMBERS,
                {
                    beginKeywords: 'class interface',
                    relevance: 0,
                    end: /[{;=]/,
                    illegal: /[^\s:,]/,
                    contains: [
                        { beginKeywords: "where class" },
                        TITLE_MODE,
                        GENERIC_MODIFIER,
                        hljs.C_LINE_COMMENT_MODE,
                        hljs.C_BLOCK_COMMENT_MODE
                    ]
                },
                {
                    beginKeywords: 'namespace',
                    relevance: 0,
                    end: /[{;=]/,
                    illegal: /[^\s:]/,
                    contains: [
                        TITLE_MODE,
                        hljs.C_LINE_COMMENT_MODE,
                        hljs.C_BLOCK_COMMENT_MODE
                    ]
                },
                {
                    beginKeywords: 'record',
                    relevance: 0,
                    end: /[{;=]/,
                    illegal: /[^\s:]/,
                    contains: [
                        TITLE_MODE,
                        GENERIC_MODIFIER,
                        hljs.C_LINE_COMMENT_MODE,
                        hljs.C_BLOCK_COMMENT_MODE
                    ]
                },
                {
                    // [Attributes("")]
                    className: 'meta',
                    begin: '^\\s*\\[', excludeBegin: true, end: '\\]', excludeEnd: true,
                    contains: [
                        {className: 'meta-string', begin: /"/, end: /"/}
                    ]
                },
                {
                    // Expression keywords prevent 'keyword Name(...)' from being
                    // recognized as a function definition
                    beginKeywords: 'new return throw await else',
                    relevance: 0
                },
                {
                    className: 'function',
                    begin: '(' + TYPE_IDENT_RE + '\\s+)+' + hljs.IDENT_RE + '\\s*(<.+>)?\\s*\\(', returnBegin: true,
                    end: /\s*[{;=]/, excludeEnd: true,
                    keywords: KEYWORDS,
                    contains: [
                        // prevents these from being highlighted `title`
                        {
                            beginKeywords: FUNCTION_MODIFIERS.join(" "),
                            relevance: 0
                        },
                        {
                            begin: hljs.IDENT_RE + '\\s*(<.+>)?\\s*\\(', returnBegin: true,
                            contains: [
                                hljs.TITLE_MODE,
                                GENERIC_MODIFIER
                            ],
                            relevance: 0
                        },
                        {
                            className: 'params',
                            begin: /\(/, end: /\)/,
                            excludeBegin: true,
                            excludeEnd: true,
                            keywords: KEYWORDS,
                            relevance: 0,
                            contains: [
                                STRING,
                                NUMBERS,
                                hljs.C_BLOCK_COMMENT_MODE
                            ]
                        },
                        hljs.C_LINE_COMMENT_MODE,
                        hljs.C_BLOCK_COMMENT_MODE
                    ]
                },
                AT_IDENTIFIER
            ]
        };
    }

    var csharp_1 = csharp;

    /*
    Language: Java
    Author: Vsevolod Solovyov <vsevolod.solovyov@gmail.com>
    Category: common, enterprise
    Website: https://www.java.com/
    */

    function java(hljs) {
        var JAVA_IDENT_RE = '[\u00C0-\u02B8a-zA-Z_$][\u00C0-\u02B8a-zA-Z_$0-9]*';
        var GENERIC_IDENT_RE = JAVA_IDENT_RE + '(<' + JAVA_IDENT_RE + '(\\s*,\\s*' + JAVA_IDENT_RE + ')*>)?';
        var KEYWORDS = 'false synchronized int abstract float private char boolean var static null if const ' +
            'for true while long strictfp finally protected import native final void ' +
            'enum else break transient catch instanceof byte super volatile case assert short ' +
            'package default double public try this switch continue throws protected public private ' +
            'module requires exports do';

        var ANNOTATION = {
            className: 'meta',
            begin: '@' + JAVA_IDENT_RE,
            contains: [
                {
                    begin: /\(/,
                    end: /\)/,
                    contains: ["self"] // allow nested () inside our annotation
                },
            ]
        };

        // https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10
        var decimalDigits = '[0-9](_*[0-9])*';
        var frac = `\\.(${decimalDigits})`;
        var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';
        var NUMBER = {
            className: 'number',
            variants: [
                // DecimalFloatingPointLiteral
                // including ExponentPart
                { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))` +
                        `[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
                // excluding ExponentPart
                { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
                { begin: `(${frac})[fFdD]?\\b` },
                { begin: `\\b(${decimalDigits})[fFdD]\\b` },

                // HexadecimalFloatingPointLiteral
                { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))` +
                        `[pP][+-]?(${decimalDigits})[fFdD]?\\b` },

                // DecimalIntegerLiteral
                { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },

                // HexIntegerLiteral
                { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },

                // OctalIntegerLiteral
                { begin: '\\b0(_*[0-7])*[lL]?\\b' },

                // BinaryIntegerLiteral
                { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
            ],
            relevance: 0
        };

        return {
            name: 'Java',
            aliases: ['jsp'],
            keywords: KEYWORDS,
            illegal: /<\/|#/,
            contains: [
                hljs.COMMENT(
                    '/\\*\\*',
                    '\\*/',
                    {
                        relevance: 0,
                        contains: [
                            {
                                // eat up @'s in emails to prevent them to be recognized as doctags
                                begin: /\w+@/, relevance: 0
                            },
                            {
                                className: 'doctag',
                                begin: '@[A-Za-z]+'
                            }
                        ]
                    }
                ),
                // relevance boost
                {
                    begin: /import java\.[a-z]+\./,
                    keywords: "import",
                    relevance: 2
                },
                hljs.C_LINE_COMMENT_MODE,
                hljs.C_BLOCK_COMMENT_MODE,
                hljs.APOS_STRING_MODE,
                hljs.QUOTE_STRING_MODE,
                {
                    className: 'class',
                    beginKeywords: 'class interface enum', end: /[{;=]/, excludeEnd: true,
                    keywords: 'class interface enum',
                    illegal: /[:"\[\]]/,
                    contains: [
                        { beginKeywords: 'extends implements' },
                        hljs.UNDERSCORE_TITLE_MODE
                    ]
                },
                {
                    // Expression keywords prevent 'keyword Name(...)' from being
                    // recognized as a function definition
                    beginKeywords: 'new throw return else',
                    relevance: 0
                },
                {
                    className: 'class',
                    begin: 'record\\s+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
                    returnBegin: true,
                    excludeEnd: true,
                    end: /[{;=]/,
                    keywords: KEYWORDS,
                    contains: [
                        { beginKeywords: "record" },
                        {
                            begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
                            returnBegin: true,
                            relevance: 0,
                            contains: [hljs.UNDERSCORE_TITLE_MODE]
                        },
                        {
                            className: 'params',
                            begin: /\(/, end: /\)/,
                            keywords: KEYWORDS,
                            relevance: 0,
                            contains: [
                                hljs.C_BLOCK_COMMENT_MODE
                            ]
                        },
                        hljs.C_LINE_COMMENT_MODE,
                        hljs.C_BLOCK_COMMENT_MODE
                    ]
                },
                {
                    className: 'function',
                    begin: '(' + GENERIC_IDENT_RE + '\\s+)+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true, end: /[{;=]/,
                    excludeEnd: true,
                    keywords: KEYWORDS,
                    contains: [
                        {
                            begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true,
                            relevance: 0,
                            contains: [hljs.UNDERSCORE_TITLE_MODE]
                        },
                        {
                            className: 'params',
                            begin: /\(/, end: /\)/,
                            keywords: KEYWORDS,
                            relevance: 0,
                            contains: [
                                ANNOTATION,
                                hljs.APOS_STRING_MODE,
                                hljs.QUOTE_STRING_MODE,
                                NUMBER,
                                hljs.C_BLOCK_COMMENT_MODE
                            ]
                        },
                        hljs.C_LINE_COMMENT_MODE,
                        hljs.C_BLOCK_COMMENT_MODE
                    ]
                },
                NUMBER,
                ANNOTATION
            ]
        };
    }

    var java_1 = java;

    /*
     Language: Kotlin
     Description: Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native.
     Author: Sergey Mashkov <cy6erGn0m@gmail.com>
     Website: https://kotlinlang.org
     Category: common
     */

    function kotlin(hljs) {
        const KEYWORDS = {
            keyword:
                'abstract as val var vararg get set class object open private protected public noinline ' +
                'crossinline dynamic final enum if else do while for when throw try catch finally ' +
                'import package is in fun override companion reified inline lateinit init ' +
                'interface annotation data sealed internal infix operator out by constructor super ' +
                'tailrec where const inner suspend typealias external expect actual',
            built_in:
                'Byte Short Char Int Long Boolean Float Double Void Unit Nothing',
            literal:
                'true false null'
        };
        const KEYWORDS_WITH_LABEL = {
            className: 'keyword',
            begin: /\b(break|continue|return|this)\b/,
            starts: {
                contains: [
                    {
                        className: 'symbol',
                        begin: /@\w+/
                    }
                ]
            }
        };
        const LABEL = {
            className: 'symbol',
            begin: hljs.UNDERSCORE_IDENT_RE + '@'
        };

        // for string templates
        const SUBST = {
            className: 'subst',
            begin: /\$\{/,
            end: /\}/,
            contains: [ hljs.C_NUMBER_MODE ]
        };
        const VARIABLE = {
            className: 'variable',
            begin: '\\$' + hljs.UNDERSCORE_IDENT_RE
        };
        const STRING = {
            className: 'string',
            variants: [
                {
                    begin: '"""',
                    end: '"""(?=[^"])',
                    contains: [
                        VARIABLE,
                        SUBST
                    ]
                },
                // Can't use built-in modes easily, as we want to use STRING in the meta
                // context as 'meta-string' and there's no syntax to remove explicitly set
                // classNames in built-in modes.
                {
                    begin: '\'',
                    end: '\'',
                    illegal: /\n/,
                    contains: [ hljs.BACKSLASH_ESCAPE ]
                },
                {
                    begin: '"',
                    end: '"',
                    illegal: /\n/,
                    contains: [
                        hljs.BACKSLASH_ESCAPE,
                        VARIABLE,
                        SUBST
                    ]
                }
            ]
        };
        SUBST.contains.push(STRING);

        const ANNOTATION_USE_SITE = {
            className: 'meta',
            begin: '@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*' + hljs.UNDERSCORE_IDENT_RE + ')?'
        };
        const ANNOTATION = {
            className: 'meta',
            begin: '@' + hljs.UNDERSCORE_IDENT_RE,
            contains: [
                {
                    begin: /\(/,
                    end: /\)/,
                    contains: [
                        hljs.inherit(STRING, {
                            className: 'meta-string'
                        })
                    ]
                }
            ]
        };

        // https://kotlinlang.org/docs/reference/whatsnew11.html#underscores-in-numeric-literals
        // According to the doc above, the number mode of kotlin is the same as java 8,
        // so the code below is copied from java.js
        const KOTLIN_NUMBER_RE = '\\b' +
            '(' +
            '0[bB]([01]+[01_]+[01]+|[01]+)' + // 0b...
            '|' +
            '0[xX]([a-fA-F0-9]+[a-fA-F0-9_]+[a-fA-F0-9]+|[a-fA-F0-9]+)' + // 0x...
            '|' +
            '(' +
            '([\\d]+[\\d_]+[\\d]+|[\\d]+)(\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))?' +
            '|' +
            '\\.([\\d]+[\\d_]+[\\d]+|[\\d]+)' +
            ')' +
            '([eE][-+]?\\d+)?' + // octal, decimal, float
            ')' +
            '[lLfF]?';
        const KOTLIN_NUMBER_MODE = {
            className: 'number',
            begin: KOTLIN_NUMBER_RE,
            relevance: 0
        };
        const KOTLIN_NESTED_COMMENT = hljs.COMMENT(
            '/\\*', '\\*/',
            {
                contains: [ hljs.C_BLOCK_COMMENT_MODE ]
            }
        );
        const KOTLIN_PAREN_TYPE = {
            variants: [
                {
                    className: 'type',
                    begin: hljs.UNDERSCORE_IDENT_RE
                },
                {
                    begin: /\(/,
                    end: /\)/,
                    contains: [] // defined later
                }
            ]
        };
        const KOTLIN_PAREN_TYPE2 = KOTLIN_PAREN_TYPE;
        KOTLIN_PAREN_TYPE2.variants[1].contains = [ KOTLIN_PAREN_TYPE ];
        KOTLIN_PAREN_TYPE.variants[1].contains = [ KOTLIN_PAREN_TYPE2 ];

        return {
            name: 'Kotlin',
            aliases: [ 'kt' ],
            keywords: KEYWORDS,
            contains: [
                hljs.COMMENT(
                    '/\\*\\*',
                    '\\*/',
                    {
                        relevance: 0,
                        contains: [
                            {
                                className: 'doctag',
                                begin: '@[A-Za-z]+'
                            }
                        ]
                    }
                ),
                hljs.C_LINE_COMMENT_MODE,
                KOTLIN_NESTED_COMMENT,
                KEYWORDS_WITH_LABEL,
                LABEL,
                ANNOTATION_USE_SITE,
                ANNOTATION,
                {
                    className: 'function',
                    beginKeywords: 'fun',
                    end: '[(]|$',
                    returnBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS,
                    illegal: /fun\s+(<.*>)?[^\s\(]+(\s+[^\s\(]+)\s*=/,
                    relevance: 5,
                    contains: [
                        {
                            begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
                            returnBegin: true,
                            relevance: 0,
                            contains: [ hljs.UNDERSCORE_TITLE_MODE ]
                        },
                        {
                            className: 'type',
                            begin: /</,
                            end: />/,
                            keywords: 'reified',
                            relevance: 0
                        },
                        {
                            className: 'params',
                            begin: /\(/,
                            end: /\)/,
                            endsParent: true,
                            keywords: KEYWORDS,
                            relevance: 0,
                            contains: [
                                {
                                    begin: /:/,
                                    end: /[=,\/]/,
                                    endsWithParent: true,
                                    contains: [
                                        KOTLIN_PAREN_TYPE,
                                        hljs.C_LINE_COMMENT_MODE,
                                        KOTLIN_NESTED_COMMENT
                                    ],
                                    relevance: 0
                                },
                                hljs.C_LINE_COMMENT_MODE,
                                KOTLIN_NESTED_COMMENT,
                                ANNOTATION_USE_SITE,
                                ANNOTATION,
                                STRING,
                                hljs.C_NUMBER_MODE
                            ]
                        },
                        KOTLIN_NESTED_COMMENT
                    ]
                },
                {
                    className: 'class',
                    beginKeywords: 'class interface trait', // remove 'trait' when removed from KEYWORDS
                    end: /[:\{(]|$/,
                    excludeEnd: true,
                    illegal: 'extends implements',
                    contains: [
                        {
                            beginKeywords: 'public protected internal private constructor'
                        },
                        hljs.UNDERSCORE_TITLE_MODE,
                        {
                            className: 'type',
                            begin: /</,
                            end: />/,
                            excludeBegin: true,
                            excludeEnd: true,
                            relevance: 0
                        },
                        {
                            className: 'type',
                            begin: /[,:]\s*/,
                            end: /[<\(,]|$/,
                            excludeBegin: true,
                            returnEnd: true
                        },
                        ANNOTATION_USE_SITE,
                        ANNOTATION
                    ]
                },
                STRING,
                {
                    className: 'meta',
                    begin: "^#!/usr/bin/env",
                    end: '$',
                    illegal: '\n'
                },
                KOTLIN_NUMBER_MODE
            ]
        };
    }

    var kotlin_1 = kotlin;

    const IDENT_RE$1 = '[A-Za-z$_][0-9A-Za-z$_]*';
    const KEYWORDS = [
        "as", // for exports
        "in",
        "of",
        "if",
        "for",
        "while",
        "finally",
        "var",
        "new",
        "function",
        "do",
        "return",
        "void",
        "else",
        "break",
        "catch",
        "instanceof",
        "with",
        "throw",
        "case",
        "default",
        "try",
        "switch",
        "continue",
        "typeof",
        "delete",
        "let",
        "yield",
        "const",
        "class",
        // JS handles these with a special rule
        // "get",
        // "set",
        "debugger",
        "async",
        "await",
        "static",
        "import",
        "from",
        "export",
        "extends"
    ];
    const LITERALS = [
        "true",
        "false",
        "null",
        "undefined",
        "NaN",
        "Infinity"
    ];

    const TYPES = [
        "Intl",
        "DataView",
        "Number",
        "Math",
        "Date",
        "String",
        "RegExp",
        "Object",
        "Function",
        "Boolean",
        "Error",
        "Symbol",
        "Set",
        "Map",
        "WeakSet",
        "WeakMap",
        "Proxy",
        "Reflect",
        "JSON",
        "Promise",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Float32Array",
        "Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "ArrayBuffer"
    ];

    const ERROR_TYPES = [
        "EvalError",
        "InternalError",
        "RangeError",
        "ReferenceError",
        "SyntaxError",
        "TypeError",
        "URIError"
    ];

    const BUILT_IN_GLOBALS = [
        "setInterval",
        "setTimeout",
        "clearInterval",
        "clearTimeout",

        "require",
        "exports",

        "eval",
        "isFinite",
        "isNaN",
        "parseFloat",
        "parseInt",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "unescape"
    ];

    const BUILT_IN_VARIABLES = [
        "arguments",
        "this",
        "super",
        "console",
        "window",
        "document",
        "localStorage",
        "module",
        "global" // Node.js
    ];

    const BUILT_INS = [].concat(
        BUILT_IN_GLOBALS,
        BUILT_IN_VARIABLES,
        TYPES,
        ERROR_TYPES
    );

    /**
     * @param {string} value
     * @returns {RegExp}
     * */

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function source$1(re) {
        if (!re) return null;
        if (typeof re === "string") return re;

        return re.source;
    }

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function lookahead(re) {
        return concat$1('(?=', re, ')');
    }

    /**
     * @param {...(RegExp | string) } args
     * @returns {string}
     */
    function concat$1(...args) {
        const joined = args.map((x) => source$1(x)).join("");
        return joined;
    }

    /*
    Language: JavaScript
    Description: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.
    Category: common, scripting
    Website: https://developer.mozilla.org/en-US/docs/Web/JavaScript
    */

    /** @type LanguageFn */
    function javascript(hljs) {
        /**
         * Takes a string like "<Booger" and checks to see
         * if we can find a matching "</Booger" later in the
         * content.
         * @param {RegExpMatchArray} match
         * @param {{after:number}} param1
         */
        const hasClosingTag = (match, { after }) => {
            const tag = "</" + match[0].slice(1);
            const pos = match.input.indexOf(tag, after);
            return pos !== -1;
        };

        const IDENT_RE$1$1 = IDENT_RE$1;
        const FRAGMENT = {
            begin: '<>',
            end: '</>'
        };
        const XML_TAG = {
            begin: /<[A-Za-z0-9\\._:-]+/,
            end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
            /**
             * @param {RegExpMatchArray} match
             * @param {CallbackResponse} response
             */
            isTrulyOpeningTag: (match, response) => {
                const afterMatchIndex = match[0].length + match.index;
                const nextChar = match.input[afterMatchIndex];
                // nested type?
                // HTML should not include another raw `<` inside a tag
                // But a type might: `<Array<Array<number>>`, etc.
                if (nextChar === "<") {
                    response.ignoreMatch();
                    return;
                }
                // <something>
                // This is now either a tag or a type.
                if (nextChar === ">") {
                    // if we cannot find a matching closing tag, then we
                    // will ignore it
                    if (!hasClosingTag(match, { after: afterMatchIndex })) {
                        response.ignoreMatch();
                    }
                }
            }
        };
        const KEYWORDS$1 = {
            $pattern: IDENT_RE$1,
            keyword: KEYWORDS.join(" "),
            literal: LITERALS.join(" "),
            built_in: BUILT_INS.join(" ")
        };

        // https://tc39.es/ecma262/#sec-literals-numeric-literals
        const decimalDigits = '[0-9](_?[0-9])*';
        const frac = `\\.(${decimalDigits})`;
        // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral
        // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
        const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
        const NUMBER = {
            className: 'number',
            variants: [
                // DecimalLiteral
                { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))` +
                        `[eE][+-]?(${decimalDigits})\\b` },
                { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },

                // DecimalBigIntegerLiteral
                { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },

                // NonDecimalIntegerLiteral
                { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
                { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
                { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },

                // LegacyOctalIntegerLiteral (does not include underscore separators)
                // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
                { begin: "\\b0[0-7]+n?\\b" },
            ],
            relevance: 0
        };

        const SUBST = {
            className: 'subst',
            begin: '\\$\\{',
            end: '\\}',
            keywords: KEYWORDS$1,
            contains: [] // defined later
        };
        const HTML_TEMPLATE = {
            begin: 'html`',
            end: '',
            starts: {
                end: '`',
                returnEnd: false,
                contains: [
                    hljs.BACKSLASH_ESCAPE,
                    SUBST
                ],
                subLanguage: 'xml'
            }
        };
        const CSS_TEMPLATE = {
            begin: 'css`',
            end: '',
            starts: {
                end: '`',
                returnEnd: false,
                contains: [
                    hljs.BACKSLASH_ESCAPE,
                    SUBST
                ],
                subLanguage: 'css'
            }
        };
        const TEMPLATE_STRING = {
            className: 'string',
            begin: '`',
            end: '`',
            contains: [
                hljs.BACKSLASH_ESCAPE,
                SUBST
            ]
        };
        const JSDOC_COMMENT = hljs.COMMENT(
            '/\\*\\*',
            '\\*/',
            {
                relevance: 0,
                contains: [
                    {
                        className: 'doctag',
                        begin: '@[A-Za-z]+',
                        contains: [
                            {
                                className: 'type',
                                begin: '\\{',
                                end: '\\}',
                                relevance: 0
                            },
                            {
                                className: 'variable',
                                begin: IDENT_RE$1$1 + '(?=\\s*(-)|$)',
                                endsParent: true,
                                relevance: 0
                            },
                            // eat spaces (not newlines) so we can find
                            // types or variables
                            {
                                begin: /(?=[^\n])\s/,
                                relevance: 0
                            }
                        ]
                    }
                ]
            }
        );
        const COMMENT = {
            className: "comment",
            variants: [
                JSDOC_COMMENT,
                hljs.C_BLOCK_COMMENT_MODE,
                hljs.C_LINE_COMMENT_MODE
            ]
        };
        const SUBST_INTERNALS = [
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE,
            HTML_TEMPLATE,
            CSS_TEMPLATE,
            TEMPLATE_STRING,
            NUMBER,
            hljs.REGEXP_MODE
        ];
        SUBST.contains = SUBST_INTERNALS
            .concat({
                // we need to pair up {} inside our subst to prevent
                // it from ending too early by matching another }
                begin: /\{/,
                end: /\}/,
                keywords: KEYWORDS$1,
                contains: [
                    "self"
                ].concat(SUBST_INTERNALS)
            });
        const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
        const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
            // eat recursive parens in sub expressions
            {
                begin: /\(/,
                end: /\)/,
                keywords: KEYWORDS$1,
                contains: ["self"].concat(SUBST_AND_COMMENTS)
            }
        ]);
        const PARAMS = {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS$1,
            contains: PARAMS_CONTAINS
        };

        return {
            name: 'Javascript',
            aliases: ['js', 'jsx', 'mjs', 'cjs'],
            keywords: KEYWORDS$1,
            // this will be extended by TypeScript
            exports: { PARAMS_CONTAINS },
            illegal: /#(?![$_A-z])/,
            contains: [
                hljs.SHEBANG({
                    label: "shebang",
                    binary: "node",
                    relevance: 5
                }),
                {
                    label: "use_strict",
                    className: 'meta',
                    relevance: 10,
                    begin: /^\s*['"]use (strict|asm)['"]/
                },
                hljs.APOS_STRING_MODE,
                hljs.QUOTE_STRING_MODE,
                HTML_TEMPLATE,
                CSS_TEMPLATE,
                TEMPLATE_STRING,
                COMMENT,
                NUMBER,
                { // object attr container
                    begin: concat$1(/[{,\n]\s*/,
                        // we need to look ahead to make sure that we actually have an
                        // attribute coming up so we don't steal a comma from a potential
                        // "value" container
                        //
                        // NOTE: this might not work how you think.  We don't actually always
                        // enter this mode and stay.  Instead it might merely match `,
                        // <comments up next>` and then immediately end after the , because it
                        // fails to find any actual attrs. But this still does the job because
                        // it prevents the value contain rule from grabbing this instead and
                        // prevening this rule from firing when we actually DO have keys.
                        lookahead(concat$1(
                            // we also need to allow for multiple possible comments inbetween
                            // the first key:value pairing
                            /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
                            IDENT_RE$1$1 + '\\s*:'))),
                    relevance: 0,
                    contains: [
                        {
                            className: 'attr',
                            begin: IDENT_RE$1$1 + lookahead('\\s*:'),
                            relevance: 0
                        }
                    ]
                },
                { // "value" container
                    begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
                    keywords: 'return throw case',
                    contains: [
                        COMMENT,
                        hljs.REGEXP_MODE,
                        {
                            className: 'function',
                            // we have to count the parens to make sure we actually have the
                            // correct bounding ( ) before the =>.  There could be any number of
                            // sub-expressions inside also surrounded by parens.
                            begin: '(\\(' +
                                '[^()]*(\\(' +
                                '[^()]*(\\(' +
                                '[^()]*' +
                                '\\))*[^()]*' +
                                '\\))*[^()]*' +
                                '\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>',
                            returnBegin: true,
                            end: '\\s*=>',
                            contains: [
                                {
                                    className: 'params',
                                    variants: [
                                        {
                                            begin: hljs.UNDERSCORE_IDENT_RE,
                                            relevance: 0
                                        },
                                        {
                                            className: null,
                                            begin: /\(\s*\)/,
                                            skip: true
                                        },
                                        {
                                            begin: /\(/,
                                            end: /\)/,
                                            excludeBegin: true,
                                            excludeEnd: true,
                                            keywords: KEYWORDS$1,
                                            contains: PARAMS_CONTAINS
                                        }
                                    ]
                                }
                            ]
                        },
                        { // could be a comma delimited list of params to a function call
                            begin: /,/, relevance: 0
                        },
                        {
                            className: '',
                            begin: /\s/,
                            end: /\s*/,
                            skip: true
                        },
                        { // JSX
                            variants: [
                                { begin: FRAGMENT.begin, end: FRAGMENT.end },
                                {
                                    begin: XML_TAG.begin,
                                    // we carefully check the opening tag to see if it truly
                                    // is a tag and not a false positive
                                    'on:begin': XML_TAG.isTrulyOpeningTag,
                                    end: XML_TAG.end
                                }
                            ],
                            subLanguage: 'xml',
                            contains: [
                                {
                                    begin: XML_TAG.begin,
                                    end: XML_TAG.end,
                                    skip: true,
                                    contains: ['self']
                                }
                            ]
                        }
                    ],
                    relevance: 0
                },
                {
                    className: 'function',
                    beginKeywords: 'function',
                    end: /[{;]/,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: [
                        'self',
                        hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
                        PARAMS
                    ],
                    illegal: /%/
                },
                {
                    // prevent this from getting swallowed up by function
                    // since they appear "function like"
                    beginKeywords: "while if switch catch for"
                },
                {
                    className: 'function',
                    // we have to count the parens to make sure we actually have the correct
                    // bounding ( ).  There could be any number of sub-expressions inside
                    // also surrounded by parens.
                    begin: hljs.UNDERSCORE_IDENT_RE +
                        '\\(' + // first parens
                        '[^()]*(\\(' +
                        '[^()]*(\\(' +
                        '[^()]*' +
                        '\\))*[^()]*' +
                        '\\))*[^()]*' +
                        '\\)\\s*\\{', // end parens
                    returnBegin:true,
                    contains: [
                        PARAMS,
                        hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
                    ]
                },
                // hack: prevents detection of keywords in some circumstances
                // .keyword()
                // $keyword = x
                {
                    variants: [
                        { begin: '\\.' + IDENT_RE$1$1 },
                        { begin: '\\$' + IDENT_RE$1$1 }
                    ],
                    relevance: 0
                },
                { // ES6 class
                    className: 'class',
                    beginKeywords: 'class',
                    end: /[{;=]/,
                    excludeEnd: true,
                    illegal: /[:"[\]]/,
                    contains: [
                        { beginKeywords: 'extends' },
                        hljs.UNDERSCORE_TITLE_MODE
                    ]
                },
                {
                    begin: /\b(?=constructor)/,
                    end: /[{;]/,
                    excludeEnd: true,
                    contains: [
                        hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
                        'self',
                        PARAMS
                    ]
                },
                {
                    begin: '(get|set)\\s+(?=' + IDENT_RE$1$1 + '\\()',
                    end: /\{/,
                    keywords: "get set",
                    contains: [
                        hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
                        { begin: /\(\)/ }, // eat to avoid empty params
                        PARAMS
                    ]
                },
                {
                    begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
                }
            ]
        };
    }

    /*
    Language: TypeScript
    Author: Panu Horsmalahti <panu.horsmalahti@iki.fi>
    Contributors: Ike Ku <dempfi@yahoo.com>
    Description: TypeScript is a strict superset of JavaScript
    Website: https://www.typescriptlang.org
    Category: common, scripting
    */

    /** @type LanguageFn */
    function typescript(hljs) {
        const IDENT_RE$1$1 = IDENT_RE$1;
        const NAMESPACE = {
            beginKeywords: 'namespace', end: /\{/, excludeEnd: true
        };
        const INTERFACE = {
            beginKeywords: 'interface', end: /\{/, excludeEnd: true,
            keywords: 'interface extends'
        };
        const USE_STRICT = {
            className: 'meta',
            relevance: 10,
            begin: /^\s*['"]use strict['"]/
        };
        const TYPES = [
            "any",
            "void",
            "number",
            "boolean",
            "string",
            "object",
            "never",
            "enum"
        ];
        const TS_SPECIFIC_KEYWORDS = [
            "type",
            "namespace",
            "typedef",
            "interface",
            "public",
            "private",
            "protected",
            "implements",
            "declare",
            "abstract",
            "readonly"
        ];
        const KEYWORDS$1 = {
            $pattern: IDENT_RE$1,
            keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS).join(" "),
            literal: LITERALS.join(" "),
            built_in: BUILT_INS.concat(TYPES).join(" ")
        };
        const DECORATOR = {
            className: 'meta',
            begin: '@' + IDENT_RE$1$1,
        };

        const swapMode = (mode, label, replacement) => {
            const indx = mode.contains.findIndex(m => m.label === label);
            if (indx === -1) { throw new Error("can not find mode to replace"); }
            mode.contains.splice(indx, 1, replacement);
        };

        const tsLanguage = javascript(hljs);

        // this should update anywhere keywords is used since
        // it will be the same actual JS object
        Object.assign(tsLanguage.keywords, KEYWORDS$1);

        tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
        tsLanguage.contains = tsLanguage.contains.concat([
            DECORATOR,
            NAMESPACE,
            INTERFACE,
        ]);

        // TS gets a simpler shebang rule than JS
        swapMode(tsLanguage, "shebang", hljs.SHEBANG());
        // JS use strict rule purposely excludes `asm` which makes no sense
        swapMode(tsLanguage, "use_strict", USE_STRICT);

        const functionDeclaration = tsLanguage.contains.find(m => m.className === "function");
        functionDeclaration.relevance = 0; // () => {} is more typical in TypeScript

        Object.assign(tsLanguage, {
            name: 'TypeScript',
            aliases: ['ts']
        });

        return tsLanguage;
    }

    var typescript_1 = typescript;

    /*
    Language: Scala
    Category: functional
    Author: Jan Berkel <jan.berkel@gmail.com>
    Contributors: Erik Osheim <d_m@plastic-idolatry.com>
    Website: https://www.scala-lang.org
    */

    function scala(hljs) {
        const ANNOTATION = {
            className: 'meta',
            begin: '@[A-Za-z]+'
        };

        // used in strings for escaping/interpolation/substitution
        const SUBST = {
            className: 'subst',
            variants: [
                {
                    begin: '\\$[A-Za-z0-9_]+'
                },
                {
                    begin: /\$\{/,
                    end: /\}/
                }
            ]
        };

        const STRING = {
            className: 'string',
            variants: [
                {
                    begin: '"',
                    end: '"',
                    illegal: '\\n',
                    contains: [ hljs.BACKSLASH_ESCAPE ]
                },
                {
                    begin: '"""',
                    end: '"""',
                    relevance: 10
                },
                {
                    begin: '[a-z]+"',
                    end: '"',
                    illegal: '\\n',
                    contains: [ hljs.BACKSLASH_ESCAPE,
                        SUBST ]
                },
                {
                    className: 'string',
                    begin: '[a-z]+"""',
                    end: '"""',
                    contains: [ SUBST ],
                    relevance: 10
                }
            ]

        };

        const SYMBOL = {
            className: 'symbol',
            begin: '\'\\w[\\w\\d_]*(?!\')'
        };

        const TYPE = {
            className: 'type',
            begin: '\\b[A-Z][A-Za-z0-9_]*',
            relevance: 0
        };

        const NAME = {
            className: 'title',
            begin: /[^0-9\n\t "'(),.`{}\[\]:;][^\n\t "'(),.`{}\[\]:;]+|[^0-9\n\t "'(),.`{}\[\]:;=]/,
            relevance: 0
        };

        const CLASS = {
            className: 'class',
            beginKeywords: 'class object trait type',
            end: /[:={\[\n;]/,
            excludeEnd: true,
            contains: [
                hljs.C_LINE_COMMENT_MODE,
                hljs.C_BLOCK_COMMENT_MODE,
                {
                    beginKeywords: 'extends with',
                    relevance: 10
                },
                {
                    begin: /\[/,
                    end: /\]/,
                    excludeBegin: true,
                    excludeEnd: true,
                    relevance: 0,
                    contains: [ TYPE ]
                },
                {
                    className: 'params',
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    relevance: 0,
                    contains: [ TYPE ]
                },
                NAME
            ]
        };

        const METHOD = {
            className: 'function',
            beginKeywords: 'def',
            end: /[:={\[(\n;]/,
            excludeEnd: true,
            contains: [ NAME ]
        };

        return {
            name: 'Scala',
            keywords: {
                literal: 'true false null',
                keyword: 'type yield lazy override def with val var sealed abstract private trait object if forSome for while throw finally protected extends import final return else break new catch super class case package default try this match continue throws implicit'
            },
            contains: [
                hljs.C_LINE_COMMENT_MODE,
                hljs.C_BLOCK_COMMENT_MODE,
                STRING,
                SYMBOL,
                TYPE,
                METHOD,
                CLASS,
                hljs.C_NUMBER_MODE,
                ANNOTATION
            ]
        };
    }

    var scala_1 = scala;

    /**
     * Highlight.js GraphQL syntax highlighting definition
     *
     * @see https://github.com/isagalaev/highlight.js
     *
     * @package: highlightjs-graphql
     * @author:  David Peek <mail@dpeek.com>
     */

    function hljsDefineGraphQL(hljs) {
        return {
            aliases: ["gql"],
            keywords: {
                keyword:
                    "query mutation subscription|10 input schema implements type interface union scalar fragment|10 enum on ...",
                literal: "ID ID! String Float Int Boolean",
                variable: "true false null"
            },
            contains: [
                hljs.HASH_COMMENT_MODE,
                hljs.QUOTE_STRING_MODE,
                hljs.NUMBER_MODE,
                {
                    className: "literal",
                    begin: "[^\\w][A-Z][a-z]",
                    end: "\\W",
                    excludeEnd: true
                },
                {
                    className: "literal",
                    begin: ":\\s\\[",
                    end: "[\\]!]{1,3}",
                    excludeBegin: true,
                    excludeEnd: true
                },
                {
                    className: "type",
                    begin: "[^\\w](?!ID)[A-Z][A-Z]",
                    end: "\\W",
                    excludeEnd: true
                },
                {
                    className: "name",
                    begin: "\\$",
                    end: "\\W",
                    excludeEnd: true
                },
                {
                    className: "meta",
                    begin: "@",
                    end: "\\W",
                    excludeEnd: true
                }
            ],
            illegal: /([;<']|BEGIN)/
        };
    }

    var graphql = function(hljs) {
        hljs.registerLanguage("graphql", hljsDefineGraphQL);
    };

    var definer = hljsDefineGraphQL;
    graphql.definer = definer;

    // import "highlight.js/styles/monokai-sublime.css";
    core.registerLanguage("sql", sql_1);
    core.registerLanguage("csharp", csharp_1);
    core.registerLanguage("java", java_1);
    core.registerLanguage("kotlin", kotlin_1);
    core.registerLanguage("typescript", typescript_1);
    core.registerLanguage("scala", scala_1);
    graphql(core);

    let SQL = class SQL extends EditorElement {
        constructor() {
            super(...arguments);
            this.contextmenu = false;
            this.contextmenuX = 0;
            this.contextmenuY = 0;
            this.menus = [];
            this.onContextmenuEnd = (event) => {
                this.contextmenu = false;
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus } = this.context;
            this.subscriptionList.push(eventBus.on(Bus.ERD.contextmenuEnd).subscribe(this.onContextmenuEnd), store.observe(store.canvasState, (name) => {
                if (name === "database") {
                    this.requestUpdate();
                }
            }));
        }
        render() {
            const sql = createDDL$6(this.context.store);
            const sqlHTML = core.highlight("sql", sql).value;
            return html `
      <div
        class="vuerd-sql vuerd-scrollbar hljs"
        contenteditable="true"
        spellcheck="false"
        @mousedown=${this.onMousedown}
        @contextmenu=${this.onContextmenu}
      >
        ${unsafeHTML(sqlHTML)}
      </div>
      ${this.contextmenu
                ? html `
            <vuerd-contextmenu
              .menus=${this.menus}
              .x=${this.contextmenuX}
              .y=${this.contextmenuY}
            ></vuerd-contextmenu>
          `
                : ""}
    `;
        }
        onContextmenu(event) {
            event.preventDefault();
            const { store } = this.context;
            this.contextmenuX = event.x;
            this.contextmenuY = event.y;
            this.menus = createDatabaseMenus(store);
            this.contextmenu = true;
        }
        onMousedown(event) {
            const el = event.target;
            if (!el.closest(".vuerd-contextmenu")) {
                this.contextmenu = false;
            }
        }
    };
    __decorate([
        property({ type: Boolean })
    ], SQL.prototype, "contextmenu", void 0);
    SQL = __decorate([
        customElement("vuerd-sql")
    ], SQL);

    /**
     * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
     */
    /**
     * Lower case as a function.
     */
    function lowerCase(str) {
        return str.toLowerCase();
    }

    // Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
    var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    // Remove all non-word characters.
    var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
    /**
     * Normalize the string into something other libraries can manipulate easier.
     */
    function noCase(input, options) {
        if (options === void 0) { options = {}; }
        var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
        var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
        var start = 0;
        var end = result.length;
        // Trim the delimiter from around the output string.
        while (result.charAt(start) === "\0")
            start++;
        while (result.charAt(end - 1) === "\0")
            end--;
        // Transform each token independently.
        return result
            .slice(start, end)
            .split("\0")
            .map(transform)
            .join(delimiter);
    }
    /**
     * Replace `re` in the input string with the replacement value.
     */
    function replace(input, re, value) {
        if (re instanceof RegExp)
            return input.replace(re, value);
        return re.reduce(function (input, re) { return input.replace(re, value); }, input);
    }

    function pascalCaseTransform(input, index) {
        var firstChar = input.charAt(0);
        var lowerChars = input.substr(1).toLowerCase();
        if (index > 0 && firstChar >= "0" && firstChar <= "9") {
            return "_" + firstChar + lowerChars;
        }
        return "" + firstChar.toUpperCase() + lowerChars;
    }
    function pascalCase(input, options) {
        if (options === void 0) { options = {}; }
        return noCase(input, __assign({ delimiter: "", transform: pascalCaseTransform }, options));
    }

    function camelCaseTransform(input, index) {
        if (index === 0)
            return input.toLowerCase();
        return pascalCaseTransform(input, index);
    }
    function camelCase(input, options) {
        if (options === void 0) { options = {}; }
        return pascalCase(input, __assign({ transform: camelCaseTransform }, options));
    }

    function dotCase(input, options) {
        if (options === void 0) { options = {}; }
        return noCase(input, __assign({ delimiter: "." }, options));
    }

    function snakeCase(input, options) {
        if (options === void 0) { options = {}; }
        return dotCase(input, __assign({ delimiter: "_" }, options));
    }

    function getPrimitiveType(dataType, database) {
        const dataTypeHints = getDataTypeHints(database);
        for (const dataTypeHint of dataTypeHints) {
            if (dataType
                .toLocaleLowerCase()
                .indexOf(dataTypeHint.name.toLocaleLowerCase()) === 0) {
                return dataTypeHint.primitiveType;
            }
        }
        return "string";
    }
    function getDataTypeHints(database) {
        for (const data of databaseHints) {
            if (data.database === database) {
                return data.dataTypeHints;
            }
        }
        return [];
    }
    function getNameCase(name, nameCase) {
        let changeName = name;
        switch (nameCase) {
            case "camelCase":
                changeName = camelCase(name);
                break;
            case "pascalCase":
                changeName = pascalCase(name);
                break;
            case "snakeCase":
                changeName = snakeCase(name);
                break;
        }
        return changeName;
    }

    const convertTypeMap = {
        int: "Int",
        long: "Int",
        float: "Float",
        double: "Float",
        decimal: "Float",
        boolean: "Boolean",
        string: "String",
        lob: "String",
        date: "String",
        dateTime: "String",
        time: "String",
    };
    function createCode(store) {
        const stringBuffer = [""];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        const relationships = store.relationshipState.relationships;
        tables.forEach((table) => {
            formatTable$6(table, stringBuffer, database, relationships, tables, tableCase, columnCase);
            stringBuffer.push("");
        });
        return stringBuffer.join("\n");
    }
    function formatTable$6(table, buffer, database, relationships, tables, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== "") {
            buffer.push(`# ${table.comment}`);
        }
        buffer.push(`type ${tableName} {`);
        table.columns.forEach((column) => {
            formatColumn$6(column, buffer, database, columnCase);
        });
        formatRelation$5(table, buffer, relationships, tables, tableCase, columnCase);
        buffer.push(`}`);
    }
    function formatColumn$6(column, buffer, database, columnCase) {
        if (!column.ui.fk) {
            const columnName = getNameCase(column.name, columnCase);
            if (column.comment.trim() !== "") {
                buffer.push(`  # ${column.comment}`);
            }
            const idType = column.option.primaryKey || column.ui.fk;
            if (idType) {
                buffer.push(`  ${columnName}: ID${column.option.notNull ? "!" : ""}`);
            }
            else {
                const primitiveType = getPrimitiveType(column.dataType, database);
                buffer.push(`  ${columnName}: ${convertTypeMap[primitiveType]}${column.option.notNull ? "!" : ""}`);
            }
        }
    }
    function formatRelation$5(table, buffer, relationships, tables, tableCase, columnCase) {
        relationships
            .filter((relationship) => relationship.end.tableId === table.id)
            .forEach((relationship) => {
                const startTable = getData(tables, relationship.start.tableId);
                if (startTable) {
                    const typeName = getNameCase(startTable.name, tableCase);
                    const fieldName = getNameCase(startTable.name, columnCase);
                    if (startTable.comment.trim() !== "") {
                        buffer.push(`  # ${startTable.comment}`);
                    }
                    buffer.push(`  ${fieldName}: ${typeName}`);
                }
            });
        relationships
            .filter((relationship) => relationship.start.tableId === table.id)
            .forEach((relationship) => {
                const endTable = getData(tables, relationship.end.tableId);
                if (endTable) {
                    const typeName = getNameCase(endTable.name, tableCase);
                    const fieldName = getNameCase(endTable.name, columnCase);
                    if (endTable.comment.trim() !== "") {
                        buffer.push(`  # ${endTable.comment}`);
                    }
                    if (oneRelationshipTypes.some((value) => value === relationship.relationshipType)) {
                        buffer.push(`  ${fieldName}: ${typeName}`);
                    }
                    else if (nRelationshipTypes.some((value) => value === relationship.relationshipType)) {
                        buffer.push(`  ${getNameCase(`${fieldName}List`, columnCase)}: [${typeName}!]!`);
                    }
                }
            });
    }

    const convertTypeMap$1 = {
        int: "int",
        long: "long",
        float: "float",
        double: "double",
        decimal: "decimal",
        boolean: "bool",
        string: "string",
        lob: "string",
        date: "DateTime",
        dateTime: "DateTime",
        time: "TimeSpan",
    };
    function createCode$1(store) {
        const stringBuffer = [""];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach((table) => {
            formatTable$7(table, stringBuffer, database, tableCase, columnCase);
            stringBuffer.push("");
        });
        return stringBuffer.join("\n");
    }
    function formatTable$7(table, buffer, database, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== "") {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`public class ${tableName} {`);
        table.columns.forEach((column) => {
            formatColumn$7(column, buffer, database, columnCase);
        });
        buffer.push(`}`);
    }
    function formatColumn$7(column, buffer, database, columnCase) {
        const columnName = getNameCase(column.name, columnCase);
        const primitiveType = getPrimitiveType(column.dataType, database);
        if (column.comment.trim() !== "") {
            buffer.push(`  // ${column.comment}`);
        }
        buffer.push(`  public ${convertTypeMap$1[primitiveType]} ${columnName.charAt(0).toLocaleUpperCase() + columnName.slice(1)} { get; set; }`);
    }

    const convertTypeMap$2 = {
        int: "Integer",
        long: "Long",
        float: "Float",
        double: "Double",
        decimal: "BigDecimal",
        boolean: "Boolean",
        string: "String",
        lob: "String",
        date: "LocalDate",
        dateTime: "LocalDateTime",
        time: "LocalTime",
    };
    function createCode$2(store) {
        const stringBuffer = [""];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach((table) => {
            formatTable$8(table, stringBuffer, database, tableCase, columnCase);
            stringBuffer.push("");
        });
        return stringBuffer.join("\n");
    }
    function formatTable$8(table, buffer, database, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== "") {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`@Data`);
        buffer.push(`public class ${tableName} {`);
        table.columns.forEach((column) => {
            formatColumn$8(column, buffer, database, columnCase);
        });
        buffer.push(`}`);
    }
    function formatColumn$8(column, buffer, database, columnCase) {
        const columnName = getNameCase(column.name, columnCase);
        const primitiveType = getPrimitiveType(column.dataType, database);
        if (column.comment.trim() !== "") {
            buffer.push(`  // ${column.comment}`);
        }
        buffer.push(`  private ${convertTypeMap$2[primitiveType]} ${columnName};`);
    }

    const convertTypeMap$3 = {
        int: "Int",
        long: "Long",
        float: "Float",
        double: "Double",
        decimal: "BigDecimal",
        boolean: "Boolean",
        string: "String",
        lob: "String",
        date: "LocalDate",
        dateTime: "LocalDateTime",
        time: "LocalTime",
    };
    function createCode$3(store) {
        const stringBuffer = [""];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach((table) => {
            formatTable$9(table, stringBuffer, database, tableCase, columnCase);
            stringBuffer.push("");
        });
        return stringBuffer.join("\n");
    }
    function formatTable$9(table, buffer, database, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== "") {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`class ${tableName} {`);
        table.columns.forEach((column) => {
            formatColumn$9(column, buffer, database, columnCase);
        });
        buffer.push(`}`);
    }
    function formatColumn$9(column, buffer, database, columnCase) {
        const columnName = getNameCase(column.name, columnCase);
        const primitiveType = getPrimitiveType(column.dataType, database);
        if (column.comment.trim() !== "") {
            buffer.push(`  // ${column.comment}`);
        }
        if (column.option.notNull &&
            primitiveType !== "date" &&
            primitiveType !== "dateTime" &&
            primitiveType !== "time") {
            buffer.push(`  var ${columnName}: ${convertTypeMap$3[primitiveType]} = ${getDefault(primitiveType)}`);
        }
        else {
            buffer.push(`  var ${columnName}: ${convertTypeMap$3[primitiveType]}? = null`);
        }
    }
    function getDefault(primitiveType) {
        switch (primitiveType) {
            case "int":
            case "long":
                return 0;
            case "float":
                return "0.0f";
            case "double":
                return "0.0";
            case "boolean":
                return false;
            case "string":
            case "lob":
                return '""';
            case "decimal":
                return "BigDecimal.ZERO";
            case "date":
            case "dateTime":
            case "time":
                return null;
        }
    }

    const convertTypeMap$4 = {
        int: "number",
        long: "number",
        float: "number",
        double: "number",
        decimal: "number",
        boolean: "boolean",
        string: "string",
        lob: "string",
        date: "string",
        dateTime: "string",
        time: "string",
    };
    function createCode$4(store) {
        const stringBuffer = [""];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach((table) => {
            formatTable$a(table, stringBuffer, database, tableCase, columnCase);
            stringBuffer.push("");
        });
        return stringBuffer.join("\n");
    }
    function formatTable$a(table, buffer, database, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== "") {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`export interface ${tableName} {`);
        table.columns.forEach((column) => {
            formatColumn$a(column, buffer, database, columnCase);
        });
        buffer.push(`}`);
    }
    function formatColumn$a(column, buffer, database, columnCase) {
        const columnName = getNameCase(column.name, columnCase);
        const primitiveType = getPrimitiveType(column.dataType, database);
        if (column.comment.trim() !== "") {
            buffer.push(`  // ${column.comment}`);
        }
        buffer.push(`  ${columnName}: ${convertTypeMap$4[primitiveType]}${column.option.notNull ? "" : " | null"};`);
    }

    const convertTypeMap$5 = {
        int: "Integer",
        long: "Long",
        float: "Float",
        double: "Double",
        decimal: "BigDecimal",
        boolean: "Boolean",
        string: "String",
        lob: "String",
        date: "LocalDate",
        dateTime: "LocalDateTime",
        time: "LocalTime",
    };
    function createCode$5(store) {
        const stringBuffer = [""];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        const relationships = store.relationshipState.relationships;
        tables.forEach((table) => {
            formatTable$b(table, stringBuffer, database, relationships, tables, tableCase, columnCase);
            stringBuffer.push("");
        });
        return stringBuffer.join("\n");
    }
    function formatTable$b(table, buffer, database, relationships, tables, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        const pkColumns = primaryKeyColumns(table.columns);
        if (pkColumns.length > 1) {
            buffer.push(`@Data`);
            buffer.push(`public class ${getNameCase(`${table.name}Id`, tableCase)} implements Serializable {`);
            const pfkTables = [];
            pkColumns.forEach((column) => {
                if (column.ui.pfk) {
                    relationships
                        .filter((relationship) => relationship.end.columnIds.some((columnId) => columnId === column.id))
                        .map((relationship) => getData(tables, relationship.start.tableId))
                        .filter((table) => table !== null).forEach((table) => {
                        if (!pfkTables.some((pfkTable) => pfkTable.id === table.id)) {
                            pfkTables.push(table);
                        }
                    });
                }
                else {
                    const columnName = getNameCase(column.name, columnCase);
                    const primitiveType = getPrimitiveType(column.dataType, database);
                    buffer.push(`  private ${convertTypeMap$5[primitiveType]} ${columnName};`);
                }
            });
            pfkTables.forEach((table) => {
                buffer.push(`  private ${getNameCase(table.name, tableCase)} ${getNameCase(table.name, columnCase)};`);
            });
            buffer.push(`}`);
        }
        if (table.comment.trim() !== "") {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`@Data`);
        buffer.push(`@Entity`);
        if (pkColumns.length > 1) {
            buffer.push(`@IdClass(${getNameCase(`${table.name}Id`, tableCase)}.class)`);
        }
        // if (unique(table.columns)) {
        //   const uqColumns = uniqueColumns(table.columns).map(column => {
        //     return { name: getNameCase(column.name, Case.snakeCase) };
        //   });
        //   buffer.push(`@Table(uniqueConstraints = {`);
        //   buffer.push(`  @UniqueConstraint(`);
        //   buffer.push(`    columnNames={${formatNames(uqColumns, '"')}}`);
        //   buffer.push(`  )`);
        //   buffer.push(`})`);
        // }
        buffer.push(`public class ${tableName} {`);
        table.columns.forEach((column) => {
            formatColumn$b(column, buffer, database, columnCase);
        });
        formatRelation$6(table, buffer, relationships, tables, tableCase, columnCase);
        buffer.push(`}`);
    }
    function formatColumn$b(column, buffer, database, columnCase) {
        if (!column.ui.fk && !column.ui.pfk) {
            const columnName = getNameCase(column.name, columnCase);
            const primitiveType = getPrimitiveType(column.dataType, database);
            if (column.comment.trim() !== "") {
                buffer.push(`  // ${column.comment}`);
            }
            if (column.option.primaryKey) {
                buffer.push(`  @Id`);
                if (column.option.autoIncrement) {
                    buffer.push(`  @GeneratedValue`);
                }
            }
            else if (column.option.notNull) {
                buffer.push(`  @Column(nullable = false)`);
            }
            if (primitiveType === "lob") {
                buffer.push(`  @Lob`);
            }
            buffer.push(`  private ${convertTypeMap$5[primitiveType]} ${columnName};`);
        }
    }
    function formatRelation$6(table, buffer, relationships, tables, tableCase, columnCase) {
        relationships
            .filter((relationship) => relationship.end.tableId === table.id)
            .forEach((relationship) => {
                const startTable = getData(tables, relationship.start.tableId);
                const endColumns = relationship.end.columnIds
                    .map((columnId) => getData(table.columns, columnId))
                    .filter((column) => column !== null);
                if (startTable && endColumns.length !== 0) {
                    const typeName = getNameCase(startTable.name, tableCase);
                    const fieldName = getNameCase(startTable.name, columnCase);
                    if (startTable.comment.trim() !== "") {
                        buffer.push(`  // ${startTable.comment}`);
                    }
                    if (primaryKey(endColumns)) {
                        buffer.push(`  @Id`);
                    }
                    if (oneRelationshipTypes.some((value) => value === relationship.relationshipType)) {
                        buffer.push(`  @OneToOne`);
                    }
                    else if (nRelationshipTypes.some((value) => value === relationship.relationshipType)) {
                        buffer.push(`  @ManyToOne`);
                    }
                    if (endColumns.length > 1) {
                        buffer.push(`  @JoinColumns(value = {`);
                        endColumns.forEach((column, index) => {
                            buffer.push(`    @JoinColumn(name = "${getNameCase(column.name, "snakeCase")}")${endColumns.length - 1 > index ? "," : ""}`);
                        });
                        buffer.push(`  })`);
                    }
                    else {
                        buffer.push(`  @JoinColumn(name = "${getNameCase(endColumns[0].name, "snakeCase")}")`);
                    }
                    buffer.push(`  private ${typeName} ${fieldName};`);
                }
            });
        relationships
            .filter((relationship) => relationship.start.tableId === table.id)
            .forEach((relationship) => {
                const endTable = getData(tables, relationship.end.tableId);
                if (endTable) {
                    const typeName = getNameCase(endTable.name, tableCase);
                    const fieldName = getNameCase(endTable.name, columnCase);
                    if (endTable.comment.trim() !== "") {
                        buffer.push(`  // ${endTable.comment}`);
                    }
                    if (oneRelationshipTypes.some((value) => value === relationship.relationshipType)) {
                        buffer.push(`  @OneToOne(mappedBy = "${getNameCase(table.name, columnCase)}")`);
                        buffer.push(`  private ${typeName} ${fieldName};`);
                    }
                    else if (nRelationshipTypes.some((value) => value === relationship.relationshipType)) {
                        buffer.push(`  @OneToMany(mappedBy = "${getNameCase(table.name, columnCase)}")`);
                        buffer.push(`  private List<${typeName}> ${getNameCase(`${fieldName}List`, columnCase)} = new ArrayList<>();`);
                    }
                }
            });
    }

    const convertTypeMap$6 = {
        int: "Int",
        long: "Long",
        float: "Float",
        double: "Double",
        decimal: "BigDecimal",
        boolean: "Boolean",
        string: "String",
        lob: "String",
        date: "LocalDate",
        dateTime: "LocalDateTime",
        time: "LocalTime",
    };
    function createCode$6(store) {
        const stringBuffer = [""];
        const { database, tableCase, columnCase } = store.canvasState;
        const tables = orderByNameASC(store.tableState.tables);
        tables.forEach((table) => {
            formatTable$c(table, stringBuffer, database, tableCase, columnCase);
            stringBuffer.push("");
        });
        return stringBuffer.join("\n");
    }
    function formatTable$c(table, buffer, database, tableCase, columnCase) {
        const tableName = getNameCase(table.name, tableCase);
        if (table.comment.trim() !== "") {
            buffer.push(`// ${table.comment}`);
        }
        buffer.push(`@Data`);
        buffer.push(`case class ${tableName}(`);
        table.columns.forEach((column, idx, array) => {
            var notLastElem = true;
            if (idx === array.length - 1) {
                notLastElem = false;
            }
            formatColumn$c(column, buffer, database, columnCase, notLastElem);
        });
        buffer.push(`)`);
    }
    function formatColumn$c(column, buffer, database, columnCase, addComma) {
        const columnName = getNameCase(column.name, columnCase);
        const primitiveType = getPrimitiveType(column.dataType, database);
        if (column.comment.trim() !== "") {
            buffer.push(` // ${column.comment}`);
        }
        buffer.push(` ${columnName}: ${convertTypeMap$6[primitiveType]}${addComma ? "," : ""}`);
    }

    function createGeneratorCode(store) {
        const { language } = store.canvasState;
        switch (language) {
            case "GraphQL":
                return createCode(store);
            case "C#":
                return createCode$1(store);
            case "Java":
                return createCode$2(store);
            case "Kotlin":
                return createCode$3(store);
            case "TypeScript":
                return createCode$4(store);
            case "JPA":
                return createCode$5(store);
            case "Scala":
                return createCode$6(store);
        }
        return "";
    }
    function createGeneratorCodeTable(store, table) {
        const stringBuffer = [""];
        const { language, database, tableCase, columnCase } = store.canvasState;
        const { tables } = store.tableState;
        const { relationships } = store.relationshipState;
        switch (language) {
            case "GraphQL":
                formatTable$6(table, stringBuffer, database, relationships, tables, tableCase, columnCase);
                stringBuffer.push("");
                break;
            case "C#":
                formatTable$7(table, stringBuffer, database, tableCase, columnCase);
                stringBuffer.push("");
                break;
            case "Java":
                formatTable$8(table, stringBuffer, database, tableCase, columnCase);
                stringBuffer.push("");
                break;
            case "Kotlin":
                formatTable$9(table, stringBuffer, database, tableCase, columnCase);
                stringBuffer.push("");
                break;
            case "TypeScript":
                formatTable$a(table, stringBuffer, database, tableCase, columnCase);
                stringBuffer.push("");
                break;
            case "JPA":
                formatTable$b(table, stringBuffer, database, relationships, tables, tableCase, columnCase);
                stringBuffer.push("");
                break;
            case "Scala":
                formatTable$c(table, stringBuffer, database, tableCase, columnCase);
                stringBuffer.push("");
                break;
        }
        return stringBuffer.join("\n");
    }

    const LanguageMap = {
        GraphQL: "graphql",
        "C#": "csharp",
        Java: "java",
        Kotlin: "kotlin",
        TypeScript: "typescript",
        JPA: "java",
        Scala: "scala",
    };
    let GeneratorCode = class GeneratorCode extends EditorElement {
        constructor() {
            super(...arguments);
            this.contextmenu = false;
            this.contextmenuX = 0;
            this.contextmenuY = 0;
            this.menus = [];
            this.onContextmenuEnd = (event) => {
                this.contextmenu = false;
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus } = this.context;
            this.subscriptionList.push(eventBus.on(Bus.ERD.contextmenuEnd).subscribe(this.onContextmenuEnd), store.observe(store.canvasState, (name) => {
                switch (name) {
                    case "language":
                    case "tableCase":
                    case "columnCase":
                        this.requestUpdate();
                        break;
                }
            }));
        }
        render() {
            const { language } = this.context.store.canvasState;
            const code = createGeneratorCode(this.context.store);
            const codeHTML = core.highlight(LanguageMap[language], code).value;
            return html `
      <div
        class="vuerd-generator-code vuerd-scrollbar hljs"
        contenteditable="true"
        spellcheck="false"
        @mousedown=${this.onMousedown}
        @contextmenu=${this.onContextmenu}
      >
        ${unsafeHTML(codeHTML)}
      </div>
      ${this.contextmenu
                ? html `
            <vuerd-contextmenu
              .menus=${this.menus}
              .x=${this.contextmenuX}
              .y=${this.contextmenuY}
            ></vuerd-contextmenu>
          `
                : ""}
    `;
        }
        onContextmenu(event) {
            event.preventDefault();
            const { store } = this.context;
            this.contextmenuX = event.x;
            this.contextmenuY = event.y;
            this.menus = createContextmenuGeneratorCode(store);
            this.contextmenu = true;
        }
        onMousedown(event) {
            const el = event.target;
            if (!el.closest(".vuerd-contextmenu")) {
                this.contextmenu = false;
            }
        }
    };
    __decorate([
        property({ type: Boolean })
    ], GeneratorCode.prototype, "contextmenu", void 0);
    GeneratorCode = __decorate([
        customElement("vuerd-generator-code")
    ], GeneratorCode);

    const MAX_WIDTH = 800;
    let Help$1 = class Help extends EditorElement {
        constructor() {
            super(...arguments);
            this.width = defaultWidth;
            this.animation = true;
            this.animationRight = defaultWidth;
            this.animationFrame = new AnimationFrame(200);
            this.onClose = () => {
                this.animation = true;
                this.animationFrame
                    .play({ right: this.animationRight }, { right: -1 * this.drawerWidth })
                    .update((value) => {
                        this.animationRight = value.right;
                    })
                    .complete(() => {
                        this.dispatchEvent(new CustomEvent("close"));
                    })
                    .start();
            };
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-help")) {
                    this.onClose();
                }
            };
        }
        get drawerWidth() {
            let width = this.width / 2;
            if (width > MAX_WIDTH) {
                width = MAX_WIDTH;
            }
            return width;
        }
        get right() {
            return this.animation ? this.animationRight : 0;
        }
        get helpDescribe() {
            const { keymap } = this.context;
            const describeList = [];
            describeList.push({
                name: "ERD ",
                keymap: `, ${keymapOptionToStringJoin(keymap.edit)}`,
            }, {
                name: "Grid ",
                keymap: ", ",
            }, {
                name: " ",
                keymap: keymapOptionToStringJoin(keymap.stop),
            }, {
                name: " - , ",
                keymap: keymapOptionToStringJoin(keymap.find),
            }, {
                name: "ERD  ",
                keymap: keymapOptionToStringJoin(keymap.undo),
            }, {
                name: "ERD  ",
                keymap: keymapOptionToStringJoin(keymap.redo),
            }, {
                name: " - , ",
                keymap: `Ctrl + , , Ctrl + , Cmd + , Cmd + , ${keymapOptionToStringJoin(keymap.selectAllTable)}`,
            }, {
                name: " - , ",
                keymap: `, Ctrl + , Cmd + , Shift + , Shift + (, ), ${keymapOptionToStringJoin(keymap.selectAllColumn)}`,
            }, {
                name: " - , , , ",
                keymap: ", Ctrl + , Cmd + ",
            }, {
                name: " ",
                keymap: keymapOptionToStringJoin(keymap.copyColumn),
            }, {
                name: " ",
                keymap: keymapOptionToStringJoin(keymap.pasteColumn),
            }, {
                name: " - ERD, , , SQL,  ",
                keymap: "",
            }, {
                name: " ",
                keymap: keymapOptionToStringJoin(keymap.tableProperties),
            }, {
                name: " ",
                keymap: keymapOptionToStringJoin(keymap.addTable),
            }, {
                name: " ",
                keymap: keymapOptionToStringJoin(keymap.addMemo),
            }, {
                name: " - , ",
                keymap: keymapOptionToStringJoin(keymap.addColumn),
            }, {
                name: " - , ",
                keymap: keymapOptionToStringJoin(keymap.removeTable),
            }, {
                name: " - , ",
                keymap: keymapOptionToStringJoin(keymap.removeColumn),
            }, {
                name: "  - , ",
                keymap: "(), ",
            }, {
                name: "  - , ",
                keymap: "(, )",
            }, {
                name: "  ",
                keymap: keymapOptionToStringJoin(keymap.primaryKey),
            }, {
                name: "  -   , ",
                keymap: ", ",
            }, {
                name: "  -   , ",
                keymap: "(, , , )",
            }, {
                name: " -  (Zero One N)",
                keymap: keymapOptionToStringJoin(keymap.relationshipZeroOneN),
            }, {
                name: " -    (Zero One)",
                keymap: keymapOptionToStringJoin(keymap.relationshipZeroOne),
            }, {
                name: " -  (Zero N)",
                keymap: keymapOptionToStringJoin(keymap.relationshipZeroN),
            }, {
                name: " - (One Only)",
                keymap: keymapOptionToStringJoin(keymap.relationshipOneOnly),
            }, {
                name: " -   (One N)",
                keymap: keymapOptionToStringJoin(keymap.relationshipOneN),
            }, {
                name: " - (One)",
                keymap: keymapOptionToStringJoin(keymap.relationshipOne),
            }, {
                name: " - (N)",
                keymap: keymapOptionToStringJoin(keymap.relationshipN),
            });
            return describeList;
        }
        connectedCallback() {
            super.connectedCallback();
            const { eventBus } = this.context;
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.subscriptionList.push(fromEvent(editor, "mousedown").subscribe(this.onMousedown), eventBus.on(Bus.Help.close).subscribe(this.onClose));
            this.animationRight = -1 * this.drawerWidth;
        }
        firstUpdated() {
            this.animationFrame
                .play({ right: -1 * this.drawerWidth }, { right: 0 })
                .update((value) => {
                    this.animationRight = value.right;
                })
                .complete(() => {
                    this.animation = false;
                })
                .start();
        }
        render() {
            const { keymap } = this.context;
            const keymapStop = keymapOptionToString(keymap.stop[0]);
            return html `
      <div
        class="vuerd-help"
        style=${styleMap({
                width: `${this.drawerWidth}px`,
                right: `${this.right}px`,
            })}
      >
        <div class="vuerd-help-header">
          <h3> </h3>
          <vuerd-icon
            class="vuerd-button"
            title=${keymapStop}
            icon="times"
            size="16"
            @click=${this.onClose}
          ></vuerd-icon>
        </div>
        <div class="vuerd-help-body vuerd-scrollbar">
          <table>
            <thead>
              <th></th>
              <th></th>
            </thead>
            <tbody>
              ${this.helpDescribe.map((describe) => html `
                  <tr>
                    <td>${describe.name}</td>
                    <td>${describe.keymap}</td>
                  </tr>
                `)}
            </tbody>
          </table>
        </div>
      </div>
    `;
        }
    };
    __decorate([
        property({ type: Number })
    ], Help$1.prototype, "width", void 0);
    __decorate([
        property({ type: Boolean })
    ], Help$1.prototype, "animation", void 0);
    __decorate([
        property({ type: Number })
    ], Help$1.prototype, "animationRight", void 0);
    Help$1 = __decorate([
        customElement("vuerd-help")
    ], Help$1);

    const MAX_WIDTH$1 = 800;
    let ImportErrorDDL$1 = class ImportErrorDDL extends EditorElement {
        constructor() {
            super(...arguments);
            this.width = defaultWidth;
            this.animation = true;
            this.animationRight = defaultWidth;
            this.message = "";
            this.animationFrame = new AnimationFrame(200);
            this.onClose = () => {
                this.animation = true;
                this.animationFrame
                    .play({ right: this.animationRight }, { right: -1 * this.drawerWidth })
                    .update((value) => {
                        this.animationRight = value.right;
                    })
                    .complete(() => {
                        this.dispatchEvent(new CustomEvent("close"));
                    })
                    .start();
            };
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-import-error-ddl")) {
                    this.onClose();
                }
            };
        }
        get drawerWidth() {
            let width = this.width / 2;
            if (width > MAX_WIDTH$1) {
                width = MAX_WIDTH$1;
            }
            return width;
        }
        get right() {
            return this.animation ? this.animationRight : 0;
        }
        connectedCallback() {
            super.connectedCallback();
            const { eventBus } = this.context;
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.subscriptionList.push(fromEvent(editor, "mousedown").subscribe(this.onMousedown), eventBus.on(Bus.ImportErrorDDL.close).subscribe(this.onClose));
            this.animationRight = -1 * this.drawerWidth;
        }
        firstUpdated() {
            this.animationFrame
                .play({ right: -1 * this.drawerWidth }, { right: 0 })
                .update((value) => {
                    this.animationRight = value.right;
                })
                .complete(() => {
                    this.animation = false;
                })
                .start();
        }
        render() {
            const { keymap } = this.context;
            const keymapStop = keymapOptionToString(keymap.stop[0]);
            return html `
      <div
        class="vuerd-import-error-ddl"
        style=${styleMap({
                width: `${this.drawerWidth}px`,
                right: `${this.right}px`,
            })}
      >
        <div class="vuerd-import-error-ddl-header">
          <h3>Import SQL DDL Error</h3>
          <vuerd-icon
            class="vuerd-button"
            title=${keymapStop}
            icon="times"
            size="16"
            @click=${this.onClose}
          ></vuerd-icon>
        </div>
        <div class="vuerd-import-error-ddl-body vuerd-scrollbar">
          ${this.message}
        </div>
        <div class="vuerd-import-error-ddl-footer">
          <a
            href="https://github.com/dineug/sql-ddl-parser/blob/master/src/SQL_DDL_Test_Case.md"
            target="_blank"
          >
            Import SQL DDL support syntax
          </a>
        </div>
      </div>
    `;
        }
    };
    __decorate([
        property({ type: Number })
    ], ImportErrorDDL$1.prototype, "width", void 0);
    __decorate([
        property({ type: Boolean })
    ], ImportErrorDDL$1.prototype, "animation", void 0);
    __decorate([
        property({ type: Number })
    ], ImportErrorDDL$1.prototype, "animationRight", void 0);
    __decorate([
        property({ type: String })
    ], ImportErrorDDL$1.prototype, "message", void 0);
    ImportErrorDDL$1 = __decorate([
        customElement("vuerd-import-error-ddl")
    ], ImportErrorDDL$1);

    const MAX_WIDTH$2 = 800;
    let Setting$1 = class Setting extends EditorElement {
        constructor() {
            super(...arguments);
            this.width = defaultWidth;
            this.animation = true;
            this.animationRight = defaultWidth;
            this.currentColumnType = null;
            this.animationFrame = new AnimationFrame(200);
            this.flipAnimation = new FlipAnimation(this.renderRoot, ".vuerd-column-order", "vuerd-column-order-move");
            this.draggable$ = new Subject();
            this.subDraggable = [];
            this.onClose = () => {
                this.animation = true;
                this.animationFrame
                    .play({ right: this.animationRight }, { right: -1 * this.drawerWidth })
                    .update((value) => {
                        this.animationRight = value.right;
                    })
                    .complete(() => {
                        this.dispatchEvent(new CustomEvent("close"));
                    })
                    .start();
            };
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-setting")) {
                    this.onClose();
                }
            };
            this.onDragoverGroupColumnOrder = (targetColumnType) => {
                const { store } = this.context;
                if (this.currentColumnType && this.currentColumnType !== targetColumnType) {
                    this.flipAnimation.snapshot();
                    store.dispatch(moveColumnOrder(this.currentColumnType, targetColumnType));
                }
            };
            this.onDragoverColumnOrder = (event) => {
                const el = event.target;
                const target = el.closest(".vuerd-column-order");
                if (target) {
                    const columnType = el.dataset.id;
                    this.draggable$.next(columnType);
                }
            };
        }
        get drawerWidth() {
            let width = this.width / 2;
            if (width > MAX_WIDTH$2) {
                width = MAX_WIDTH$2;
            }
            return width;
        }
        get right() {
            return this.animation ? this.animationRight : 0;
        }
        connectedCallback() {
            super.connectedCallback();
            const { eventBus, store } = this.context;
            const { setting } = store.canvasState;
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.subscriptionList.push(this.draggable$
                .pipe(debounceTime(50))
                .subscribe(this.onDragoverGroupColumnOrder), fromEvent(editor, "mousedown").subscribe(this.onMousedown), eventBus.on(Bus.Setting.close).subscribe(this.onClose), store.observe(setting.columnOrder, () => this.requestUpdate()), store.observe(setting, (name) => {
                if (name === "relationshipDataTypeSync") {
                    this.requestUpdate();
                }
            }));
            this.animationRight = -1 * this.drawerWidth;
        }
        firstUpdated() {
            this.animationFrame
                .play({ right: -1 * this.drawerWidth }, { right: 0 })
                .update((value) => {
                    this.animationRight = value.right;
                })
                .complete(() => {
                    this.animation = false;
                })
                .start();
        }
        updated(changedProperties) {
            this.flipAnimation.play();
        }
        disconnectedCallback() {
            this.subDraggable.forEach((sub) => sub.unsubscribe);
            super.disconnectedCallback();
        }
        render() {
            const { keymap } = this.context;
            const keymapStop = keymapOptionToString(keymap.stop[0]);
            const { setting } = this.context.store.canvasState;
            return html `
      <div
        class="vuerd-setting"
        style=${styleMap({
                width: `${this.drawerWidth}px`,
                right: `${this.right}px`,
            })}
      >
        <div class="vuerd-setting-header">
          <h3></h3>
          <vuerd-icon
            class="vuerd-button"
            title=${keymapStop}
            icon="times"
            size="16"
            @click=${this.onClose}
          ></vuerd-icon>
        </div>
        <div class="vuerd-setting-body vuerd-scrollbar">
          <table>
            <colgroup>
              <col width="190px" />
            </colgroup>
            <tbody>
              <tr>
                <td>
                    
                </td>
                <td>
                  <label class="vuerd-switch">
                    <input
                      type="checkbox"
                      ?checked=${setting.relationshipDataTypeSync}
                      @change=${this.onChangeRelationshipDataTypeSync}
                    />
                    <span class="slider round"></span>
                  </label>
                </td>
              </tr>
              <tr>
                <td>ColumnType Order</td>
                <td>
                  ${repeat$1(setting.columnOrder, (columnType) => columnType, (columnType) => html `
                        <div
                          class=${classMap({
                "vuerd-column-order": true,
                draggable: this.currentColumnType === columnType,
            })}
                          data-id=${columnType}
                          draggable="true"
                          @dragstart=${this.onDragstartColumnOrder}
                          @dragend=${this.onDragendColumnOrder}
                        >
                          ${columnType}
                        </div>
                      `)}
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    `;
        }
        onChangeRelationshipDataTypeSync(event) {
            const { store } = this.context;
            const input = event.target;
            store.dispatch(changeRelationshipDataTypeSync(input.checked));
        }
        onDragstartColumnOrder(event) {
            const el = event.target;
            const nodeList = this.renderRoot.querySelectorAll(".vuerd-column-order");
            nodeList.forEach((node) => {
                node.classList.add("none-hover");
                this.subDraggable.push(fromEvent(node, "dragover")
                    .pipe(throttleTime(300))
                    .subscribe(this.onDragoverColumnOrder));
            });
            this.currentColumnType = el.dataset.id;
        }
        onDragendColumnOrder() {
            this.currentColumnType = null;
            this.subDraggable.forEach((sub) => sub.unsubscribe);
            this.subDraggable = [];
            this.renderRoot
                .querySelectorAll(".vuerd-column-order")
                .forEach((node) => node.classList.remove("none-hover"));
        }
    };
    __decorate([
        property({ type: Number })
    ], Setting$1.prototype, "width", void 0);
    __decorate([
        property({ type: Boolean })
    ], Setting$1.prototype, "animation", void 0);
    __decorate([
        property({ type: Number })
    ], Setting$1.prototype, "animationRight", void 0);
    __decorate([
        property({ type: String })
    ], Setting$1.prototype, "currentColumnType", void 0);
    Setting$1 = __decorate([
        customElement("vuerd-setting")
    ], Setting$1);

    let TabIndexes = class TabIndexes extends EditorElement {
        constructor() {
            super(...arguments);
            this.subIndexes = [];
        }
        get indexes() {
            const { indexes } = this.context.store.tableState;
            return indexes.filter((index) => index.tableId === this.table.id);
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            const { indexes } = store.tableState;
            this.subscriptionList.push(store.observe(indexes, () => {
                this.unsubscribeIndex();
                this.subscribeIndex();
                this.requestUpdate();
            }));
            this.subscribeIndex();
        }
        disconnectedCallback() {
            this.unsubscribeIndex();
            super.disconnectedCallback();
        }
        render() {
            return html `
      <div class="vuerd-tab-indexes">
        <div>
          <vuerd-icon
            class="vuerd-button"
            title="New Index"
            icon="plus"
            size="12"
            @click=${this.onAddIndex}
          ></vuerd-icon>
        </div>
        ${repeat$1(this.indexes, (index) => index.id, (index) => html `
            <div class="vuerd-index">
              <vuerd-icon
                class="vuerd-button"
                title="remove index"
                icon="times"
                size="9"
                @click=${() => this.onRemoveIndex(index)}
              ></vuerd-icon>
              <div
                class=${classMap({
                "vuerd-index-unique": true,
                checked: index.unique,
            })}
                style="width: 22px;"
                title="Unique"
                @click=${() => this.onChangeIndexUnique(index)}
              >
                UQ
              </div>
              <input
                type="text"
                placeholder="index name"
                spellcheck="false"
                .value=${index.name}
                @input=${(event) => this.onInput(event, index)}
              />
              <vuerd-index-add-column
                .table=${this.table}
                .indexId=${index.id}
              ></vuerd-index-add-column>
              <vuerd-index-column
                .table=${this.table}
                .indexId=${index.id}
              ></vuerd-index-column>
            </div>
          `)}
      </div>
    `;
        }
        onAddIndex() {
            const { store } = this.context;
            store.dispatch(addIndex(this.table.id));
        }
        onRemoveIndex(index) {
            const { store } = this.context;
            store.dispatch(removeIndex([index.id]));
        }
        onChangeIndexUnique(index) {
            const { store } = this.context;
            store.dispatch(changeIndexUnique(index.id, !index.unique));
        }
        onInput(event, index) {
            const { store } = this.context;
            const input = event.target;
            store.dispatch(changeIndexName(index.id, input.value));
        }
        subscribeIndex() {
            const { store } = this.context;
            const { indexes } = this.context.store.tableState;
            indexes.forEach((index) => {
                this.subIndexes.push(store.observe(index, (name) => {
                    if (name === "unique") {
                        this.requestUpdate();
                    }
                }));
            });
        }
        unsubscribeIndex() {
            this.subIndexes.forEach((sub) => sub.unsubscribe());
            this.subIndexes = [];
        }
    };
    TabIndexes = __decorate([
        customElement("vuerd-tab-indexes")
    ], TabIndexes);

    let IndexAddColumn = class IndexAddColumn extends EditorElement {
        constructor() {
            super(...arguments);
            this.value = "";
            this.hints = [];
            this.startFilter = true;
            this.flipAnimation = new FlipAnimation(this.renderRoot, ".vuerd-index-add-column-hint", "vuerd-index-add-column-hint-move");
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-index-add-column")) {
                    this.hints = [];
                }
            };
        }
        get activeIndex() {
            let index = null;
            for (let i = 0; i < this.hints.length; i++) {
                if (this.hints[i].active) {
                    index = i;
                    break;
                }
            }
            return index;
        }
        connectedCallback() {
            super.connectedCallback();
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.hintFilter();
            this.subscriptionList.push(fromEvent(editor, "mousedown").subscribe(this.onMousedown));
        }
        updated(changedProperties) {
            changedProperties.forEach((oldValue, propName) => {
                switch (propName) {
                    case "value":
                        this.flipAnimation.snapshot();
                        this.hintFilter();
                        break;
                    case "hints":
                        this.flipAnimation.play();
                        break;
                }
            });
        }
        render() {
            return html `
      <div class="vuerd-index-add-column">
        <input
          style="width: 80px;"
          type="text"
          placeholder="add column"
          spellcheck="false"
          @keydown=${this.onKeydown}
          @input=${this.onInput}
          @focus=${this.onFocus}
        />
        <ul class="vuerd-index-add-column-list">
          ${repeat$1(this.hints, (hint) => hint.name, (hint) => {
                return html `
                <li
                  class=${classMap({
                    "vuerd-index-add-column-hint": true,
                    active: hint.active,
                })}
                  @click=${() => this.onSelectHint(hint)}
                >
                  ${unsafeHTML(hint.html)}
                </li>
              `;
            })}
        </ul>
      </div>
    `;
        }
        onFocus() {
            this.hintFilter();
        }
        onInput(event) {
            const input = event.target;
            this.value = input.value;
            this.onStartFilter();
        }
        onKeydown(event) {
            switch (event.key) {
                case "ArrowUp":
                    this.onArrowUp(event);
                    break;
                case "ArrowDown":
                    this.onArrowDown(event);
                    break;
                case "ArrowLeft":
                    this.onArrowLeft(event);
                    break;
                case "Enter":
                case "ArrowRight":
                    this.onArrowRight(event);
                    break;
            }
        }
        onArrowUp(event) {
            if (this.hints.length !== 0) {
                event.preventDefault();
            }
            const index = this.activeIndex;
            if (index !== null && index !== 0) {
                this.hints[index].active = false;
                this.hints[index - 1].active = true;
                this.requestUpdate();
            }
            else if (this.hints.length !== 0) {
                if (index === 0) {
                    this.hints[index].active = false;
                }
                this.hints[this.hints.length - 1].active = true;
                this.requestUpdate();
            }
        }
        onArrowDown(event) {
            if (this.hints.length !== 0) {
                event.preventDefault();
            }
            const index = this.activeIndex;
            if (index !== null && index !== this.hints.length - 1) {
                this.hints[index].active = false;
                this.hints[index + 1].active = true;
                this.requestUpdate();
            }
            else if (this.hints.length !== 0) {
                if (index === this.hints.length - 1) {
                    this.hints[index].active = false;
                }
                this.hints[0].active = true;
                this.requestUpdate();
            }
        }
        onArrowLeft(event) {
            this.activeEnd();
            this.requestUpdate();
        }
        onArrowRight(event) {
            const { store } = this.context;
            const { indexes } = store.tableState;
            const columns = this.table.columns;
            const index = this.activeIndex;
            if (index !== null) {
                event.preventDefault();
                this.startFilter = false;
                const indexModel = getData(indexes, this.indexId);
                const targetColumn = getData(columns, this.hints[index].id);
                if (targetColumn &&
                    indexModel &&
                    !indexModel.columns.some((column) => column.id === targetColumn.id)) {
                    store.dispatch(addIndexColumn(this.indexId, targetColumn.id));
                }
            }
        }
        onStartFilter() {
            this.startFilter = true;
        }
        onSelectHint(hint) {
            const { store } = this.context;
            const { indexes } = store.tableState;
            const columns = this.table.columns;
            this.startFilter = false;
            this.activeEnd();
            const input = this.renderRoot.querySelector("input");
            if (input) {
                const len = input.value.length;
                input.selectionStart = len;
                input.selectionEnd = len;
                input.focus();
            }
            const indexModel = getData(indexes, this.indexId);
            const targetColumn = getData(columns, hint.id);
            if (targetColumn &&
                indexModel &&
                !indexModel.columns.some((column) => column.id === targetColumn.id)) {
                store.dispatch(addIndexColumn(this.indexId, targetColumn.id));
            }
        }
        hintFilter() {
            const columns = this.table.columns;
            if (this.startFilter) {
                if (this.value.trim().length < 1) {
                    this.hints = [];
                }
                else {
                    this.hints = columns
                        .filter((column) => column.name.toLowerCase().indexOf(this.value.toLowerCase()) !== -1)
                        .map((column) => {
                            return {
                                id: column.id,
                                name: column.name,
                                html: markToHTML("vuerd-mark", column.name, this.value),
                                active: false,
                            };
                        });
                }
            }
        }
        activeEnd() {
            this.hints.forEach((hint) => (hint.active = false));
        }
    };
    __decorate([
        property({ type: String })
    ], IndexAddColumn.prototype, "value", void 0);
    __decorate([
        property({ type: Array })
    ], IndexAddColumn.prototype, "hints", void 0);
    IndexAddColumn = __decorate([
        customElement("vuerd-index-add-column")
    ], IndexAddColumn);

    let IndexColumn = class IndexColumn extends EditorElement {
        constructor() {
            super(...arguments);
            this.currentColumnId = "";
            this.flipAnimation = new FlipAnimation(this.renderRoot, ".vuerd-index-column", "vuerd-index-column-move");
            this.draggable$ = new Subject();
            this.subDraggable = [];
            this.subColumns = [];
            this.onDragoverGroup = (columnId) => {
                const { store } = this.context;
                if (this.currentColumnId !== columnId) {
                    this.flipAnimation.snapshot();
                    store.dispatch(moveIndexColumn(this.indexId, this.currentColumnId, columnId));
                }
            };
            this.onDragover = (event) => {
                const el = event.target;
                const target = el.closest(".vuerd-index-column");
                if (target) {
                    const id = target.dataset.id;
                    this.draggable$.next(id);
                }
            };
        }
        get index() {
            const { indexes } = this.context.store.tableState;
            const index = getData(indexes, this.indexId);
            return {
                id: index.id,
                columns: index.columns
                    .map((column) => {
                        const data = getData(this.table.columns, column.id);
                        if (data) {
                            const newData = cloneDeep(data);
                            newData.orderType = column.orderType;
                            return newData;
                        }
                        return null;
                    })
                    .filter((column) => column !== null),
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { store } = this.context;
            const { indexes } = store.tableState;
            const index = getData(indexes, this.indexId);
            if (index) {
                this.subscriptionList.push(store.observe(index.columns, () => {
                    this.unsubscribeColumn();
                    this.subscribeColumn();
                    this.requestUpdate();
                }));
                this.subscribeColumn();
            }
            this.subscriptionList.push(this.draggable$.pipe(debounceTime(50)).subscribe(this.onDragoverGroup));
        }
        updated(changedProperties) {
            this.flipAnimation.play();
        }
        disconnectedCallback() {
            this.subDraggable.forEach((sub) => sub.unsubscribe);
            this.unsubscribeColumn();
            super.disconnectedCallback();
        }
        render() {
            return html `
      ${repeat$1(this.index.columns, (column) => column.id, (column) => html `
          <div
            class=${classMap({
                "vuerd-index-column": true,
                draggable: this.currentColumnId === column.id,
            })}
            data-id=${column.id}
            draggable="true"
            @dragstart=${this.onDragstart}
            @dragend=${this.onDragend}
          >
            <div class="vuerd-index-column-name">
              ${column.name}
            </div>
            <div
              class="vuerd-index-column-order"
              @click=${() => this.onChangeColumnOrderType(column)}
            >
              ${column.orderType}
            </div>
            <vuerd-icon
              class="vuerd-button"
              title="remove column"
              icon="times"
              size="9"
              @click=${() => this.onRemoveColumn(column)}
            ></vuerd-icon>
          </div>
        `)}
    `;
        }
        onDragstart(event) {
            const nodeList = this.renderRoot.querySelectorAll(".vuerd-index-column");
            const hoverNodeList = this.renderRoot.querySelectorAll(".vuerd-index-column-name");
            hoverNodeList.forEach((node) => node.classList.add("none-hover"));
            nodeList.forEach((node) => {
                this.subDraggable.push(fromEvent(node, "dragover")
                    .pipe(throttleTime(300))
                    .subscribe(this.onDragover));
            });
            const el = event.target;
            const id = el.dataset.id;
            this.currentColumnId = id;
        }
        onDragend() {
            this.currentColumnId = "";
            this.subDraggable.forEach((sub) => sub.unsubscribe());
            this.subDraggable = [];
            this.renderRoot
                .querySelectorAll(".vuerd-index-column-name")
                .forEach((node) => node.classList.remove("none-hover"));
        }
        onRemoveColumn(column) {
            const { store } = this.context;
            store.dispatch(removeIndexColumn(this.indexId, column.id));
        }
        onChangeColumnOrderType(column) {
            const { store } = this.context;
            let value = "ASC";
            if (column.orderType === "ASC") {
                value = "DESC";
            }
            store.dispatch(changeIndexColumnOrderType(this.indexId, column.id, value));
        }
        subscribeColumn() {
            const { store } = this.context;
            const { indexes } = this.context.store.tableState;
            const index = getData(indexes, this.indexId);
            index.columns.forEach((column) => {
                this.subColumns.push(store.observe(column, () => this.requestUpdate()));
            });
        }
        unsubscribeColumn() {
            this.subColumns.forEach((sub) => sub.unsubscribe());
            this.subColumns = [];
        }
    };
    __decorate([
        property({ type: String })
    ], IndexColumn.prototype, "currentColumnId", void 0);
    IndexColumn = __decorate([
        customElement("vuerd-index-column")
    ], IndexColumn);

    let TabSQL = class TabSQL extends EditorElement {
        constructor() {
            super(...arguments);
            this.contextmenu = false;
            this.contextmenuX = 0;
            this.contextmenuY = 0;
            this.menus = [];
            this.onContextmenuEnd = (event) => {
                this.contextmenu = false;
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus } = this.context;
            this.subscriptionList.push(eventBus.on(Bus.ERD.contextmenuEnd).subscribe(this.onContextmenuEnd), store.observe(store.canvasState, (name) => {
                if (name === "database") {
                    this.requestUpdate();
                }
            }));
        }
        render() {
            const sql = createDDLTable(this.context.store, this.table);
            const sqlHTML = core.highlight("sql", sql).value;
            return html `
      <div
        class="vuerd-tab-sql vuerd-scrollbar hljs"
        contenteditable="true"
        spellcheck="false"
        @mousedown=${this.onMousedown}
        @contextmenu=${this.onContextmenu}
      >
        ${unsafeHTML(sqlHTML)}
      </div>
      ${this.contextmenu
                ? html `
            <vuerd-contextmenu
              .menus=${this.menus}
              .x=${this.contextmenuX}
              .y=${this.contextmenuY}
            ></vuerd-contextmenu>
          `
                : ""}
    `;
        }
        onContextmenu(event) {
            event.preventDefault();
            const { store } = this.context;
            this.contextmenuX = event.x;
            this.contextmenuY = event.y;
            this.menus = createDatabaseMenus(store);
            this.contextmenu = true;
        }
        onMousedown(event) {
            const el = event.target;
            if (!el.closest(".vuerd-contextmenu")) {
                this.contextmenu = false;
            }
        }
    };
    __decorate([
        property({ type: Boolean })
    ], TabSQL.prototype, "contextmenu", void 0);
    TabSQL = __decorate([
        customElement("vuerd-tab-sql")
    ], TabSQL);

    const LanguageMap$1 = {
        GraphQL: "graphql",
        "C#": "csharp",
        Java: "java",
        Kotlin: "kotlin",
        TypeScript: "typescript",
        JPA: "java",
        Scala: "scala",
    };
    let TabGeneratorCode = class TabGeneratorCode extends EditorElement {
        constructor() {
            super(...arguments);
            this.contextmenu = false;
            this.contextmenuX = 0;
            this.contextmenuY = 0;
            this.menus = [];
            this.onContextmenuEnd = (event) => {
                this.contextmenu = false;
            };
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus } = this.context;
            this.subscriptionList.push(eventBus.on(Bus.ERD.contextmenuEnd).subscribe(this.onContextmenuEnd), store.observe(store.canvasState, (name) => {
                switch (name) {
                    case "language":
                    case "tableCase":
                    case "columnCase":
                        this.requestUpdate();
                        break;
                }
            }));
        }
        render() {
            const { language } = this.context.store.canvasState;
            const code = createGeneratorCodeTable(this.context.store, this.table);
            const codeHTML = core.highlight(LanguageMap$1[language], code).value;
            return html `
      <div
        class="vuerd-tab-generator-code vuerd-scrollbar hljs"
        contenteditable="true"
        spellcheck="false"
        @mousedown=${this.onMousedown}
        @contextmenu=${this.onContextmenu}
      >
        ${unsafeHTML(codeHTML)}
      </div>
      ${this.contextmenu
                ? html `
            <vuerd-contextmenu
              .menus=${this.menus}
              .x=${this.contextmenuX}
              .y=${this.contextmenuY}
            ></vuerd-contextmenu>
          `
                : ""}
    `;
        }
        onContextmenu(event) {
            event.preventDefault();
            const { store } = this.context;
            this.contextmenuX = event.x;
            this.contextmenuY = event.y;
            this.menus = createContextmenuGeneratorCode(store);
            this.contextmenu = true;
        }
        onMousedown(event) {
            const el = event.target;
            if (!el.closest(".vuerd-contextmenu")) {
                this.contextmenu = false;
            }
        }
    };
    __decorate([
        property({ type: Boolean })
    ], TabGeneratorCode.prototype, "contextmenu", void 0);
    TabGeneratorCode = __decorate([
        customElement("vuerd-tab-generator-code")
    ], TabGeneratorCode);

    const MAX_WIDTH$3 = 800;
    let TableProperties$1 = class TableProperties extends EditorElement {
        constructor() {
            super(...arguments);
            this.width = defaultWidth;
            this.animation = true;
            this.animationRight = defaultWidth;
            this.tableId = "";
            this.tab = "indexes";
            this.tabs = [
                {
                    name: "Indexes",
                    type: "indexes",
                },
                {
                    name: "SQL DDL",
                    type: "SQL",
                },
                {
                    name: "Generator Code",
                    type: "GeneratorCode",
                },
            ];
            this.table = null;
            this.animationFrame = new AnimationFrame(200);
            this.onClose = () => {
                const { store } = this.context;
                this.animation = true;
                this.animationFrame
                    .play({ right: this.animationRight }, { right: -1 * this.drawerWidth })
                    .update((value) => {
                        this.animationRight = value.right;
                    })
                    .complete(() => {
                        store.dispatch(selectTable(store, false, this.tableId));
                        this.dispatchEvent(new CustomEvent("close"));
                    })
                    .start();
            };
            this.onCloseOnly = () => {
                this.animation = true;
                this.animationFrame
                    .play({ right: this.animationRight }, { right: -1 * this.drawerWidth })
                    .update((value) => {
                        this.animationRight = value.right;
                    })
                    .complete(() => {
                        this.dispatchEvent(new CustomEvent("close"));
                    })
                    .start();
            };
            this.onMousedown = (event) => {
                const el = event.target;
                if (!el.closest(".vuerd-table-properties")) {
                    this.onClose();
                }
            };
        }
        get drawerWidth() {
            let width = this.width / 2;
            if (width > MAX_WIDTH$3) {
                width = MAX_WIDTH$3;
            }
            return width;
        }
        get right() {
            return this.animation ? this.animationRight : 0;
        }
        connectedCallback() {
            super.connectedCallback();
            const { eventBus, store } = this.context;
            const root = this.getRootNode();
            const editor = root.querySelector(".vuerd-editor");
            this.subscriptionList.push(fromEvent(editor, "mousedown").subscribe(this.onMousedown), eventBus.on(Bus.TableProperties.close).subscribe(this.onClose), eventBus.on(Bus.TableProperties.closeOnly).subscribe(this.onCloseOnly));
            this.animationRight = -1 * this.drawerWidth;
            this.table = getData(store.tableState.tables, this.tableId);
            store.dispatch(selectEndTable(), selectEndMemo());
        }
        firstUpdated() {
            this.animationFrame
                .play({ right: -1 * this.drawerWidth }, { right: 0 })
                .update((value) => {
                    this.animationRight = value.right;
                })
                .complete(() => {
                    this.animation = false;
                })
                .start();
        }
        render() {
            var _a;
            const { keymap } = this.context;
            const keymapStop = keymapOptionToString(keymap.stop[0]);
            return html `
      <div
        class="vuerd-table-properties"
        style=${styleMap({
                width: `${this.drawerWidth}px`,
                right: `${this.right}px`,
            })}
      >
        <div class="vuerd-table-properties-header">
          <h3>  "${(_a = this.table) === null || _a === void 0 ? void 0 : _a.name}"</h3>
          <vuerd-icon
            class="vuerd-button"
            title=${keymapStop}
            icon="times"
            size="16"
            @click=${this.onClose}
          ></vuerd-icon>
        </div>
        <div class="vuerd-table-properties-body vuerd-scrollbar">
          <ul class="vuerd-table-properties-tab">
            ${this.tabs.map((tab) => html `
                  <li
                    class=${classMap({
                active: tab.type === this.tab,
            })}
                    @click=${() => this.onChangeTab(tab.type)}
                  >
                    ${tab.name}
                  </li>
                `)}
          </ul>
          ${this.table
                ? html `
                <div>
                  ${this.tab === "indexes"
                    ? html `
                        <vuerd-tab-indexes
                          .table=${this.table}
                        ></vuerd-tab-indexes>
                      `
                    : this.tab === "SQL"
                        ? html `
                        <vuerd-tab-sql .table=${this.table}></vuerd-tab-sql>
                      `
                        : this.tab === "GeneratorCode"
                            ? html `
                        <vuerd-tab-generator-code
                          .table=${this.table}
                        ></vuerd-tab-generator-code>
                      `
                            : ""}
                </div>
              `
                : ""}
        </div>
      </div>
    `;
        }
        onChangeTab(tab) {
            this.tab = tab;
        }
    };
    __decorate([
        property({ type: Number })
    ], TableProperties$1.prototype, "width", void 0);
    __decorate([
        property({ type: Boolean })
    ], TableProperties$1.prototype, "animation", void 0);
    __decorate([
        property({ type: Number })
    ], TableProperties$1.prototype, "animationRight", void 0);
    __decorate([
        property({ type: String })
    ], TableProperties$1.prototype, "tableId", void 0);
    __decorate([
        property({ type: String })
    ], TableProperties$1.prototype, "tab", void 0);
    TableProperties$1 = __decorate([
        customElement("vuerd-table-properties")
    ], TableProperties$1);

    let Editor$1 = class Editor extends RxElement {
        constructor() {
            super();
            this.width = defaultWidth;
            this.height = defaultHeight;
            this.automaticLayout = false;
            this.help = false;
            this.importErrorDDL = false;
            this.importErrorDDLMessage = "";
            this.setting = false;
            this.tableProperties = false;
            this.tablePropertiesId = "";
            this.subShare = null;
            this.resizeObserver = null;
            this.onImportErrorDDL = (event) => {
                this.importErrorDDLMessage = event.detail.message;
                this.importErrorDDL = true;
                this.requestUpdate();
            };
            this.onTableProperties = (event) => {
                this.tablePropertiesId = event.detail.tableId;
                this.tableProperties = true;
                this.requestUpdate();
            };
            this.onFocus = (event) => {
                const { helper } = this.context;
                const el = event.target;
                if (el.localName !== "input" &&
                    el.localName !== "textarea" &&
                    !el.closest(".vuerd-grid") &&
                    !el.closest(".vuerd-sql") &&
                    !el.closest(".vuerd-generator-code") &&
                    !el.closest(".vuerd-tab-sql") &&
                    !el.closest(".vuerd-tab-generator-code") &&
                    !el.closest(".tui-grid-layer-selection")) {
                    setTimeout(() => {
                        helper.focus();
                    }, 0);
                }
            };
            this.context = createEditorContext();
            // @ts-ignore
            if (ResizeObserver) {
                // @ts-ignore
                this.resizeObserver = new ResizeObserver((entries) => {
                    entries.forEach((entry) => {
                        const { width, height } = entry.contentRect;
                        this.width = width;
                        this.height = height;
                    });
                });
            }
        }
        static get styles() {
            return Layout;
        }
        get value() {
            const { store } = this.context;
            return createJsonStringify(store);
        }
        set value(json) {
            const { store } = this.context;
            if (typeof json === "string" && json.trim() !== "") {
                store.dispatch(loadJson(json));
            }
            else {
                store.dispatch(clear());
            }
        }
        connectedCallback() {
            super.connectedCallback();
            const { store, eventBus, helper } = this.context;
            this.subscriptionList.push(store.change$.subscribe(() => this.dispatchEvent(new CustomEvent("change"))), store.observe(store.canvasState, (name) => {
                if (name === "canvasType") {
                    this.requestUpdate();
                }
            }), store.observe(store.editorState, (name) => {
                const { editTable, editFilter, findActive, filterActive, } = store.editorState;
                if ((name === "editTable" && editTable === null) ||
                    (name === "editFilter" && editFilter === null && filterActive) ||
                    (name === "findActive" && !findActive)) {
                    helper.focus();
                }
            }), eventBus.on(Bus.Editor.importErrorDDL).subscribe(this.onImportErrorDDL), eventBus.on(Bus.Editor.tableProperties).subscribe(this.onTableProperties));
        }
        firstUpdated() {
            const { store, keymap, eventBus, helper } = this.context;
            const editor = this.renderRoot.querySelector(".vuerd-editor");
            const span = this.renderRoot.querySelector(".vuerd-text-width");
            const input = this.renderRoot.querySelector(".vuerd-editor-focus");
            helper.setSpan(span);
            helper.setInput(input);
            helper.focus();
            if (this.automaticLayout) {
                if (this.resizeObserver === null) {
                    Logger.warn("not supported ResizeObserver");
                }
                else {
                    this.resizeObserver.observe(editor);
                }
            }
            this.subscriptionList.push(fromEvent(editor, "keydown")
                .pipe(groupBy((event) => event.code === "Enter"), mergeMap((group$) => group$.key
                    ? group$.pipe(filter((event) => event.key !== "Process"), throttleTime(100))
                    : group$))
                .subscribe((event) => {
                    helper.keydown$.next(event);
                    if (keymapMatch(event, keymap.stop)) {
                        eventBus.emit(Bus.Help.close);
                        eventBus.emit(Bus.ImportErrorDDL.close);
                        eventBus.emit(Bus.Filter.close);
                        eventBus.emit(Bus.Find.close);
                        eventBus.emit(Bus.Setting.close);
                        eventBus.emit(Bus.TableProperties.close);
                    }
                }), merge(fromEvent(editor, "mousedown"), fromEvent(editor, "touchstart")).subscribe(this.onFocus));
        }
        updated(changedProperties) {
            changedProperties.forEach((oldValue, propName) => {
                if (propName === "automaticLayout") {
                    const editor = this.renderRoot.querySelector(".vuerd-editor");
                    if (this.resizeObserver === null) {
                        Logger.warn("not supported ResizeObserver");
                    }
                    else if (this.automaticLayout && editor) {
                        this.resizeObserver.observe(editor);
                    }
                    else if (editor) {
                        this.resizeObserver.unobserve(editor);
                    }
                }
            });
        }
        disconnectedCallback() {
            var _a;
            const { store, windowEventObservable, helper } = this.context;
            [store, windowEventObservable, helper].forEach((obj) => obj.destroy());
            (_a = this.subShare) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this.resizeObserver.disconnect();
            super.disconnectedCallback();
        }
        render() {
            const { canvasType } = this.context.store.canvasState;
            const { theme } = this.context;
            return html `
      <style type="text/css">
        @import url("https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap");
        :host {
          --vuerd-font-family: "Noto Sans", sans-serif;
          --vuerd-color-canvas: ${theme.canvas};
          --vuerd-color-table: ${theme.table};
          --vuerd-color-table-active: ${theme.tableActive};
          --vuerd-color-focus: ${theme.focus};
          --vuerd-color-key-pk: ${theme.keyPK};
          --vuerd-color-key-fk: ${theme.keyFK};
          --vuerd-color-key-pfk: ${theme.keyPFK};
          --vuerd-color-font: ${theme.font};
          --vuerd-color-font-active: ${theme.fontActive};
          --vuerd-color-font-placeholder: ${theme.fontPlaceholder};
          --vuerd-color-contextmenu: ${theme.contextmenu};
          --vuerd-color-contextmenu-active: ${theme.contextmenuActive};
          --vuerd-color-edit: ${theme.edit};
          --vuerd-color-column-select: ${theme.columnSelect};
          --vuerd-color-column-active: ${theme.columnActive};
          --vuerd-color-minimap-shadow: ${theme.minimapShadow};
          --vuerd-color-scrollbar-thumb: ${theme.scrollBarThumb};
          --vuerd-color-scrollbar-thumb-active: ${theme.scrollBarThumbActive};
          --vuerd-color-menubar: ${theme.menubar};
          --vuerd-color-visualization: ${theme.visualization};
        }
      </style>
      <div
        class="vuerd-editor"
        style=${styleMap({
                width: this.automaticLayout ? `100%` : `${this.width}px`,
                height: this.automaticLayout ? `100%` : `${this.height}px`,
            })}
      >
        <vuerd-menubar
          @help-start=${this.onHelp}
          @setting-start=${this.onSetting}
        ></vuerd-menubar>
        ${cache(canvasType === "ERD"
                ? html `
                <vuerd-erd
                  .width=${this.width}
                  .height=${this.height}
                ></vuerd-erd>
              `
                : "")}
        ${canvasType === "Grid"
                ? html `<vuerd-grid .height=${this.height}></vuerd-grid>`
                : canvasType === "Visualization"
                    ? html `
              <vuerd-visualization .width=${this.width}></vuerd-visualization>
            `
                    : canvasType === "SQL"
                        ? html `<vuerd-sql></vuerd-sql>`
                        : canvasType === "GeneratorCode"
                            ? html `<vuerd-generator-code></vuerd-generator-code>`
                            : ""}
        <span class="vuerd-text-width"></span>
        <input class="vuerd-editor-focus" type="text" />
        ${this.help
                ? html `<vuerd-help
              .width=${this.width}
              @close=${this.onHelpEnd}
            ></vuerd-help>`
                : ""}
        ${this.importErrorDDL
                ? html `
              <vuerd-import-error-ddl
                .width=${this.width}
                .message=${this.importErrorDDLMessage}
                @close=${this.onImportErrorDDLEnd}
              ></vuerd-import-error-ddl>
            `
                : ""}
        ${this.setting
                ? html `
              <vuerd-setting
                .width=${this.width}
                @close=${this.onSettingEnd}
              ></vuerd-setting>
            `
                : ""}
        ${this.tableProperties
                ? html `
              <vuerd-table-properties
                .width=${this.width}
                .tableId=${this.tablePropertiesId}
                @close=${this.onTablePropertiesEnd}
              ></vuerd-table-properties>
            `
                : ""}
      </div>
    `;
        }
        onHelp() {
            this.help = true;
            this.requestUpdate();
        }
        onHelpEnd() {
            this.help = false;
            this.requestUpdate();
        }
        onImportErrorDDLEnd() {
            this.importErrorDDL = false;
            this.importErrorDDLMessage = "";
            this.requestUpdate();
        }
        onSetting() {
            this.setting = true;
            this.requestUpdate();
        }
        onSettingEnd() {
            this.setting = false;
            this.requestUpdate();
        }
        onTablePropertiesEnd() {
            this.tableProperties = false;
            this.tablePropertiesId = "";
            this.requestUpdate();
        }
        focus() {
            const { helper } = this.context;
            helper.focus();
        }
        blur() {
            const { helper } = this.context;
            helper.blur();
        }
        initLoadJson(json) {
            if (typeof json === "string" && json.trim() !== "") {
                const { store } = this.context;
                store.dispatch(initLoadJson(json));
            }
        }
        loadSQLDDL(sql) {
            if (typeof sql === "string" && sql.trim() !== "") {
                const { store, helper } = this.context;
                const statements = DDLParser(sql);
                const json = createJson(statements, helper, store.canvasState.database);
                store.dispatch(loadJson(json), sortTable());
            }
        }
        clear() {
            const { store } = this.context;
            store.dispatch(clear());
        }
        setTheme(theme) {
            const editorTheme = this.context.theme;
            if (isObject$1(theme)) {
                Object.keys(theme).forEach((key) => {
                    const k = key;
                    if (editorTheme[k] !== undefined && typeof theme[k] === "string") {
                        editorTheme[k] = theme[k];
                    }
                });
            }
            this.requestUpdate();
        }
        setKeymap(keymap) {
            const editorKeymap = this.context.keymap;
            if (isObject$1(keymap)) {
                Object.keys(keymap).forEach((key) => {
                    const k = key;
                    if (editorKeymap[k] !== undefined && Array.isArray(keymap[k])) {
                        editorKeymap[k] = keymap[k];
                    }
                });
            }
        }
        setUser(user) {
            const { store } = this.context;
            if (isObject$1(user) && user.name) {
                store.user.name = user.name;
            }
        }
        sharePull(effect) {
            var _a;
            if (typeof effect === "function") {
                const { store } = this.context;
                (_a = this.subShare) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                this.subShare = null;
                this.subShare = store.share$.subscribe(effect);
                store.editorState.undoManager = false;
            }
        }
        sharePush(commands) {
            if (Array.isArray(commands)) {
                const { store } = this.context;
                store.dispatch(...commands);
                store.editorState.undoManager = false;
            }
        }
        getSQLDDL(database) {
            const { store } = this.context;
            if (database && databaseList.includes(database)) {
                return createDDL$6(store, database);
            }
            return createDDL$6(store);
        }
    };
    __decorate([
        property({ type: Number, reflect: true })
    ], Editor$1.prototype, "width", void 0);
    __decorate([
        property({ type: Number, reflect: true })
    ], Editor$1.prototype, "height", void 0);
    __decorate([
        property({ type: Boolean, reflect: true, attribute: "automatic-layout" })
    ], Editor$1.prototype, "automaticLayout", void 0);
    Editor$1 = __decorate([
        customElement("vuerd-editor")
    ], Editor$1);
    let EditorAlias = class EditorAlias extends Editor$1 {
    };
    EditorAlias = __decorate([
        customElement("erd-editor")
    ], EditorAlias);

    exports.setExportFileCallback = setExportFileCallback;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

}({}));
